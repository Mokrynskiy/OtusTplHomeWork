
   Б. Керниган, Д. Ритчи
   Язык программирования Си
   Издание 3-е, исправленное
   Предисловие
   С момента публикации в 1978 г. книги "Язык программирования Си" в мире компьютеров произошла революция. Большие машины стали еще больше, а возможности персональных ЭВМ теперь сопоставимы с возможностями больших машин десятилетней давности. Язык Си за это время также изменился, хотя и не очень сильно; что же касается сферы применения Си, то она далеко вышла за рамки его начального назначения как инструментального языка операционной системы UNIX.
   Рост популярности Си, накапливающиеся с годами изменения, создание компиляторов коллективами разработчиков, ранее не причастных к проектированию языка, - все это послужило стимулом к более точному и отвечающему времени определению языка по сравнению с первым изданием книги. В 1983 г. Американский институт национальных стандартов (American National Standards Institute - ANSI) учредил комитет, перед которым была поставлена цель выработать "однозначное и машинно-независимое определение языка Си", полностью сохранив при этом его стилистику. Результатом работы этого комитета и явился стандарт ANSI языка Си.
   Стандарт формализует средства языка, которые в первом издании были только намечены, но не описаны, такие, например, как присваивание структурам и перечисления. Он вводит новый вид описания функций, позволяющий проводить повсеместную проверку согласованности вызовов функций с их определением; специфицирует стандартную библиотеку с широким набором функций ввода-вывода, управления памятью, манипуляций со строками символов и другими функциями; уточняет семантику, бывшую в первоначальном определении неясной, и явно выделяет то, что остается машинно-зависимым.
   Во втором издании книги "Язык программирования Си" представлена версия Си, принятая в качестве стандарта ANSI. Мы решили описать язык заново, отметив при этом те места, в которых он претерпел изменения. В большинство параграфов это не привнесло существенных перемен, самые заметные различия касаются новой формы описания и определения функции. Следует отметить, что современные компиляторы уже обеспечили поддержку значительной части стандарта.
   Мы попытались сохранить краткость первого издания. Си - небольшой язык, и чтобы его описать большой книги не требуется. В новом издании улучшено описание наиболее важных средств, таких как указатели, которые занимают центральное место в программировании на Си; доработаны старые примеры, а в некоторые главы добавлены новые. Так, для усиления трактовки сложных объявлений в качестве примеров включены программы перевода объявлений в их словесные описания и обратно. Как и раньше, все примеры были протестированы прямо по текстам, написанным в воспринимаемой машиной форме.
   Приложение A - это справочное руководство, но отнюдь не стандарт. В нем мы попытались уложить самое существенное на минимуме страниц. По замыслу это приложение должно легко читаться программистом-пользователем: для разработчиков же компилятора определением языка должен служить сам стандарт. В приложении B приведены возможности стандартной библиотеки. Оно также представляет собой справочник для прикладных программистов, но не для разработчиков компиляторов. Приложение C содержит краткий перечень отличий представленной версии языка Си от его начальной версии.
   В предисловии к первому изданию мы говорили о том, что "чем больше работаешь с Си, тем он становится удобнее". Это впечатление осталось и после десяти лет работы с ним. Мы надеемся, что данная книга поможет вам изучить Си и успешно его использовать.
   Мы в большом долгу перед друзьями, которые помогали нам в выпуске второго издания книги. Джон Бентли, Дуг Гунн, Дуг Макилрой, Питер Нельсон и Роб Пайк сделали четкиезамечания почти по каждой странице первого варианта рукописи. Мы благодарны Алу Ахо, Деннису Аллиссону, Джою Кемпбеллу, Г. Р. Эмлину, Карен Фортганг, Аллену Голубу, Эндрю Хьюму, Дэйву Кристолу, Джону Линдерману, Дэйву Проссеру, Гину Спаффорду и Крису Ван Уику за внимательное прочтение книги. Мы получили полезные советы от Билла Чезвика, Марка Кернигана, Эндрю Коэнига, Робина Лейка, Тома Лондона, Джима Ридза, Кловиза Тондо и Питера Вайнбергера. Дейв Проссер ответил на многочисленные вопросы,касающиеся деталей стандарта ANSI. Мы широко пользовались транслятором с Си++ Бьерна Страуструпа для локальной проверки наших программ, а Дейв Кристол предоставил нам ANSI Си-компилятор для окончательной их проверки. Рич Дрешлер очень помог в наборе книги. Мы искренне благодарим всех.
   Брайан В. Керниган, Деннис М. Ритчи
   Предисловие к первому изданию
   Си - это универсальный язык программирования с компактным способом записи выражений, современными механизмами управления структурами данных и богатым набором операторов. Си не является ни языком "очень высокого уровня", ни "большим" языком, не рассчитан он и на какую-то конкретную область применения. Однако благодаря широким возможностям и универсальности для решения многих задач он удобнее и эффективнее, чем предположительно более мощные языки.
   Первоначально Си был создан Деннисом Ритчи как инструмент написания операционной системы UNIX для машины PDP-11 и реализован в рамках этой операционной системы. И операционная система, и Си- компилятор, и, по существу, все прикладные программы системы UNIX (включая и те, которые использовались для подготовки текста этой книги -Имеется в виду оригинал этой книги на английском языке. - Примеч. пер.)написаны на Си. Фирменные Си-компиляторы существуют и на нескольких машинах других типов, среди которых 1ВМ/370, Honeywell 6000 и Interdata 8/32. Си не привязан к конкретной аппаратуре или системе, однако на нем легко писать программы, которые без каких-либо изменений переносятся на другие машины, где осуществляется его поддержка.
   Цель нашей книги - помочь читателю научиться программировать на Си. Издание включает введение- учебник, позволяющий новичкам начать программировать как можно скорее, а также главы, посвященные основным свойствам языка, и справочное руководство. В ее основу положены изучение, написание и проработка примеров, а не простое перечисление правил. Почти все наши примеры - это законченные реальные программы, а не разобщенные фрагменты. Все они были оттестированы на машине точно в том виде, как приводятся в книге. Помимо демонстрации эффективного использования языка, там, где это было возможно, мы стремились проиллюстрировать полезные алгоритмы и принципыхорошего стиля написания программ и их разумного проектирования.
   Эта книга не является вводным курсом по программированию. Предполагается, что читатель знаком с такими основными понятиями, как "переменная", "присваивание", "цикл","функция". Тем не менее и новичок сможет изучить язык, хотя для него будет очень полезным общение с более знающими специалистами.
   Наш опыт показал, что Си - удобный, выразительный и гибкий язык, пригодный для программирования широкого класса задач. Его легко выучить, и чем больше работаешь с Си, тем он становится удобнее. Мы надеемся, что эта книга поможет вам хорошо его освоить.
   Вдумчивая критика и предложения многих друзей и коллег помогали нам написать книгу. В частности, Майк Бианки, Джим Блу, Стью Фелдман, Дуг Макилрой, Билл Рум, Боб Розин и Ларри Рослер со вниманием прочли все многочисленные варианты этой книги. Мы в долгу у Ала Ахо, Стива Бьерна, Дана Дворака, Чака Хейли, Мариои Харрис, Рика Холта, Стива Джонсона, Джона Машея, Боба Митца, Ральфа Мухи, Питера Нельсона, Эллиота Пинсона, Билла Плейджера, Джерри Спивака, Кена Томпсона и Питера Вайнбергера за полезные советы, полученные от них на различных стадиях подготовки рукописи, а также у Майка Леска и Джо Оссанны за помощь при подготовке ее к изданию.
   Брайан В. Керниган, Деннис М. Ритчи
   Введение
   Си - универсальный язык программирования. Он тесно связан с системой UNIX, так как был разработан в этой системе, которая как и большинство программ, работающих в ней,написаны на Си. Однако язык не привязан жестко к какой-то одной операционной системе или машине. Хотя он и назван "языком системного программирования", поскольку удобен для написания компиляторов и операционных систем, оказалось, что на нем столь же хорошо писать большие программы другого профиля.
   Многие важные идеи Си взяты из языка BCPL, автором которого является Мартин Ричардс. Влияние BCPL на Си было косвенным - через язык B, разработанный Кеном Томпсоном в 1970 г. для первой системы UNIX, реализованной на PDP-7.
   BCPLи B - "бестиповые" языки. В отличие от них Си обеспечивает разнообразие типов данных. Базовыми типами являются символы, а также целые и числа с плавающей точкой различных размеров. Кроме того, имеется возможность получать целую иерархию производных типов данных из указателей, массивов, структур и объединений. Выражения формируются из операторов и операндов. Любое выражение, включая присваивание и вызов функции, может быть инструкцией. Указатели обеспечивают машинно-независимую адреснуюарифметику.
   В Си имеются основные управляющие конструкции, используемые в хорошо структурированных программах: составная инструкция ({…}), ветвление по условию (if-else),выбор одной альтернативы из многих (switch),циклы с проверкой наверху (while,for)и с проверкой внизу (do),а также средство прерывания цикла (break).
   В качестве результата функции могут возвращать значения базовых типов, структур, объединений и указателей. Любая функция допускает рекурсивное обращение к себе. Как правило, локальные переменные функции - "автоматические", т. е. они создаются заново при каждом обращении к ней. Определения функций нельзя вкладывать друг в друга, но объявления переменных разрешается строить в блочно-структурной манере. Функции программы на Си могут храниться в отдельных исходных файлах и компилироватьсянезависимо. Переменные по отношению к функции могут быть внутренними и внешними. Последние могут быть доступными в пределах одного исходного файла или всей программы.
   На этапе препроцессирования выполняется макроподстановка в текст программы, включение других исходных файлов и условная компиляция.
   Си - язык сравнительно "низкого уровня". Однако это вовсе не умаляет его достоинств, просто Си имеет дело с теми же объектами, что и большинство компьютеров, т. е. с символами, числами и адресами. С ними можно оперировать при помощи арифметических и логических операций, выполняемых реальными машинами.
   В Си нет прямых операций над составными объектами, такими как строки символов, множества, списки и массивы. В нем нет операций, которые бы манипулировали с целыми массивами или строками символов, хотя структуры разрешается копировать целиком как единые объекты. В языке нет каких-либо средств распределения памяти, помимо возможности определения статических переменных и стекового механизма при выделении места для локальных переменных внутри функций. Нет в нем "кучи" и "сборщика мусора". Наконец, в самом Си нет средств ввода-вывода, инструкций READ (читать) и WRITE (писать) и каких-либо методов доступа к файлам. Все это - механизмы высокого уровня, которые в Си обеспечиваются исключительно с помощью явно вызываемых функций. Большинство реализованных Си-систем содержат в себе разумный стандартный набор этих функций.
   В продолжение сказанного следует отметить, что Си предоставляет средства лишь последовательного управления ходом вычислений: механизм ветвления по условиям, циклы, составные инструкции, подпрограммы и не содержит средств мультипрограммирования, параллельных процессов, синхронизации и организации сопрограмм.
   Отсутствие некоторых из перечисленных средств может показаться серьезным недостатком ("выходит, чтобы сравнить две строки символов, нужно обращаться к функции?"). Однако компактность языка имеет реальные выгоды. Поскольку Си относительно мал, то и описание его кратко, и овладеть им можно быстро. Программист может реально рассчитывать на то, что он будет знать, понимать и на практике регулярно пользоваться всеми возможностями языка.
   В течение многих лет единственным определением языка Си было первое издание книги "Язык программирования Си". В 1983 г. Институтом американских национальных стандартов (ANSI) учреждается комитет для выработки современного исчерпывающего определения языка Си. Результатом его работы явился стандарт для Си ("ANSI-C"), выпущенный в 1988 г.Большинство положений этого стандарта уже учтено в современных компиляторах.
   Стандарт базируется на первоначальном справочном руководстве. По сравнению с последним язык изменился относительно мало. Одной из целей стандарта было обеспечить, чтобы в большинстве случаев существующие программы оставались правильными или вызывали предупреждающие сообщения компиляторов об изменении поведения.
   Для большинства программистов самое важное изменение - это новый синтаксис объявления и определения функций. Объявление функции может теперь включать и описание ее аргументов. В соответствии с этим изменился и синтаксис определения функции. Дополнительная информация значительно облегчает компилятору выявление ошибок, связанных с несогласованностью аргументов; по нашему мнению, это очень полезное добавление к языку.
   Следует также отметить ряд небольших изменений. В языке узаконены присваивание структур и перечисления, которые уже некоторое время широко используются. Вычисления с плавающей точкой теперь допускаются и с одинарной точностью. Уточнены свойства арифметики, особенно для беззнаковых типов. Усовершенствован препроцессор. Большинство программистов эти изменения затронут очень слабо.
   Второй значительный вклад стандарта - это определение библиотеки, поставляемой вместе с Си- компилятором, в которой специфицируются функции доступа к возможностям операционной системы (например чтения-записи файлов), форматного ввода-вывода, динамического выделения памяти, манипуляций со строками символов и т. д. Набор стандартных заголовочных файлов обеспечивает единообразный доступ к объявлениям функций и типов данных. Гарантируется, что программы, использующие эту библиотеку привзаимодействии с операционной системой, будут работать также и на других машинах. Большинство программ, составляющих библиотеку, созданы по образу и подобию "стандартной библиотеки ввода-вывода" системы UNIX. Эта библиотека описана в первом издании книги и широко используется в других системах. И здесь программисты не заметят существенных различий. Так как типы данных и управляющих структур языка Си поддерживаются командами большинства существующих машин, исполнительная система (run-time library), обеспечивающая независимый запуск и выполнение программ, очень мала. Обращения к библиотечным функциям пишет сам программист (не компилятор), поэтому при желании их можно легко заменить на другие. Почти все программы, написанные на Си, если они не касаются каких-либо скрытых в операционной системе деталей, переносимы на другие машины.
   Си соответствует аппаратным возможностям многих машин, однако он не привязан к архитектуре какой- либо конкретной машины. Проявляя некоторую дисциплину, можно легко писать переносимые программы, т. е. программы, которые без каких-либо изменений могут работать на разных машинах. Стандарт предоставляет возможность для явного описания переносимости с помощью набора констант, отражающих характеристики машины, на которой программа будет работать.
   Си не является "строго типизированным" языком, но в процессе его развития контроль за типами был усилен. В первой версии Си хоть не одобрялся, но разрешался бесконтрольный обмен указателей и целых, что вызывало большие нарекания, но это уже давным-давно запрещено. Согласно стандарту теперь требуется явное объявление или явноеуказание преобразования, что уже и реализовано в хороших компиляторах. Новый вид объявления функций - еще один шаг в этом направлении. Компилятор теперь предупреждает о большей части ошибок в типах и автоматически не выполняет преобразования данных несовместимых типов. Однако основной философией Си остается то, что программисты сами знают, что делают; язык лишь требует явного указания об их намерениях.
   Си, как и любой другой язык программирования, не свободен от недостатков. Уровень старшинства некоторых операторов не является общепринятым, некоторые синтаксические конструкции могли бы быть лучше. Тем не менее, как оказалось, Си - чрезвычайно эффективный и выразительный язык, пригодный для широкого класса задач.
   Книга имеет следующую структуру. Глава 1 представляет собой обзор основных средств языка Си. Ее назначение - побудить читателя по возможности быстрее приступить к программированию, так как мы убеждены, что единственный способ изучить новый язык - это писать на нем программы. Эта часть книги предполагает наличие знаний по основным элементам программирования. Никаких пояснений того, что такое компьютер, компиляция или что означает выражение вида n=n+1 не дается. Хотя мы и пытались там, где это возможно, показать полезные приемы программирования, эта книга не призвана быть справочником ни по работе со структурами данных, ни по алгоритмам: когда оказывалось необходимым выбрать, на что сделать ударение, мы предпочитали сконцентрировать внимание на языке.
   В главах 2-6 различные средства языка обсуждаются более подробно и несколько более формально, чем в главе 1; при этом по-прежнему упор делается на примеры, являющиеся законченными программами, а не изолированными фрагментами. Глава 2 знакомит с базовыми типами данных, с операторами и выражениями. В главе 3 рассматриваются средства управления последовательностью вычислений:if-else,switch,while,forи т.д. В главе 4 речь идет о функциях и структуре программы (внешних переменных, правилах видимости, делении программы на несколько исходных файлов и т. д.), а также о препроцессоре. В главе 5 обсуждаются указатели и адресная арифметика. Глава 6 посвящена структурам и объединениям.
   В главе 7 описана стандартная библиотека, обеспечивающая общий интерфейс с операционной системой. Эта библиотека узаконена в качестве стандарта ANSI, иначе говоря, она должна быть представлена на всех машинах, где существует Си, благодаря чему программы, использующие ввод-вывод и другие возможности операционной системы, без каких-либо изменений можно переносить с одной машины на другую.
   Глава 8 содержит описание интерфейса между программами на Си и операционной системой UNIX, в частности описание ввода-вывода, файловой системы и распределения памяти. Хотя некоторые параграфы этой главы отражают специфику системы UNIX, программисты, пользующиеся другими системами, все же найдут в них много полезных сведений, включая определенный взгляд на то, как реализуется одна из версий стандартной библиотеки, и некоторые предложения по переносимости программ.
   Приложение A является справочником по языку. Строгое определение синтаксиса и семантики языка Си содержится в официальном документе стандарта ANSI. Последний, однако, более всего подходит разработчикам компилятора. Наш справочник определяет язык более сжато, не прибегая к педантично юридическому стилю, которым пользуется стандарт. Приложение B - сводка по содержимому стандартной библиотеки и предназначена скорее пользователям, чем реализаторам. В приложении C приводится краткий перечень отличий от первой версии языка. В сомнительных случаях, однако, окончательным судьей по языку остается стандарт и компилятор, которым вы пользуетесь.
   Глава 1. Обзор языка
   Начнем с быстрого ознакомления с языком Си. Наша цель - показать на реальных программах существенные элементы языка, не вдаваясь в мелкие детали, формальные правила и исключения из них. Поэтому мы не стремимся к полноте и даже точности (заботясь, однако, о корректности примеров). Нам бы хотелось как можно скорее подвести вас к моменту, когда вы сможете писать полезные программы. Чтобы сделать это, мы должны сконцентрировать внимание на основах: переменных и константах, арифметике, управлении последовательностью вычислений, функциях и простейшем вводе-выводе. В настоящей главе мы умышленно не затрагиваем тех средств языка, которые важны при написании больших программ: указателей, структур, большой части богатого набора операторов, некоторых управляющих инструкций и стандартной библиотеки.
   Такой подход имеет свои недостатки. Наиболее существенный из них состоит в том, что отдельное характерное свойство языка не описывается полностью в одном месте, и подобная лаконичность при обучении может привести к неправильному восприятию некоторых положений. В силу ограниченного характера подачи материала в примерах не используется вся мощь языка, и потому они не столь кратки и элегантны, как могли бы быть. Мы попытались по возможности смягчить эти эффекты, но считаем необходимым предупредить о них. Другой недостаток заключается в том, что в последующих главах какие-то моменты нам придется повторить. Мы надеемся, что польза от повторений превысит вызываемое ими раздражение.
   В любом случае опытный программист должен суметь экстраполировать материал данной главы на свои программистские нужды. Новичкам же рекомендуем дополнить ее чтение написанием собственных маленьких программ. И те и другие наши читатели могут рассматривать эту главу как "каркас", на который далее, начиная с главы 2, будут "навешиваться" элементы языка.
   1.1Начнем, пожалуй
   Единственный способ выучить новый язык программирования - это писать на нем программы. При изучении любого языка первой, как правило, предлагают написать приблизительно следующую программу:
   Напечатать слова Hello, world
   Вот первое препятствие, и чтобы его преодолеть, вы должны суметь где-то создать текст программы, успешно его скомпилировать, загрузить, запустить на выполнение и разобраться, куда будет отправлен результат. Как только вы овладеете этим, все остальное окажется относительно просто. Си-программа, печатающая "Hello, world", выглядит так:
   #include‹stdio.h›
   main()
   {
    printf("Hello, world\n");
   }
   Как запустить эту программу, зависит от системы, которую вы используете. Так, в операционной системе UNIX необходимо сформировать исходную программу в файле с именем, заканчивающимся символами ".c", например в файле hello.c, который затем компилируется с помощью команды
   cc hello.c
   Если вы все сделали правильно - не пропустили где-либо знака и не допустили орфографических ошибок, то компиляция пройдет "молча" и вы получите файл, готовый к исполнению и названный a.out. Если вы теперь запустите этот файл на выполнение командой
   a.out
   программа напечатает
   Hello, world
   В других системах правила запуска программы на выполнение могут быть иными; чтобы узнать о них, поговорите со специалистами.
   Теперь поясним некоторые моменты, касающиеся самой программы. Программа на Си, каких бы размеров она ни была, состоит изфункций и переменных.Функции содержатинструкции,описывающие вычисления, которые необходимо выполнить, а переменные хранят значения, используемые в процессе этих вычислений. Функции в Си похожи на подпрограммы и функции Фортрана или на процедуры и функции Паскаля. Приведенная программа - это функция с именемmain.Обычно вы вольны придумывать любые имена для своих функций, но "main" - особое имя: любая программа начинает свои вычисления с первой инструкции функцииmain.
   Обычноmainдля выполнения своей работы пользуется услугами других функций; одни из них пишутся самим программистом, а другие берутся готовыми из имеющихся в его распоряжении библиотек. Первая строка программы:
   #include‹stdio.h›
   сообщает компилятору, что он должен включить информацию о стандартной библиотеке ввода-вывода. Эта строка встречается в начале многих исходных файлов Си-программ. Стандартная библиотека описана в главе 7 и приложении В.
   Один из способов передачи данных между функциями состоит в том, что функция при обращении к другой функции передает ей список значений, называемыхаргументами.Этот список берется в скобки и помещается после имени функции. В нашем примереmainопределена как функция, которая не ждет никаких аргументов, что отмечено пустым списком ().
   Первая программа на Си:#include‹stdio.h›Включение информации о стандартной библиотеке.main()Определение функции с именемmain,не получающей никаких аргументов.{Инструкцииmainзаключаются о фигурные скобки.printf("Hello, world\n");Функцияmainвызывает библиотечную функциюprintfдля печати заданной последовательности символов; \n - символ новой строки.}Инструкции функции заключаются в фигурные скобки {}. Функцияmainсодержит только одну инструкцию printf("Hello, world\n");
   Функция вызывается по имени, после которого, в скобках, указывается список аргументов. Таким образом, приведенная выше строка - это вызов функцииprintfс аргументом "Hello, world\n". Функцияprintf -это библиотечная функция, которая в данном случае напечатает последовательность символов, заключенную в двойные кавычки.
   Последовательность символов в двойных кавычках, такая как "Hello, world\n", называетсястрокой символов,илистроковой константой.Пока что в качестве аргументов дляprintfи других функций мы будем использовать только строки символов.
   В Си комбинация\nвнутри строки символов обозначает символновой строкии при печати вызывает переход к левому краю следующей строки. Если вы удалите \n (стоит поэкспериментировать), то обнаружите, что, закончив печать, машина не переходит на новую строку. Символ новой строки в текстовый аргумент printf следует включать явным образом. Если вы попробуете выполнить, например,
   printf("Hello, world
   ");
   компилятор выдаст сообщение об ошибке.
   Символ новой строки никогда не вставляется автоматически, так что одну строку можно напечатать по шагам с помощью нескольких обращений кprintf.Нашу первую программу можно написать и так:
   #include‹stdio.h›

   main()
   {
    printf("Hello, ");
    printf("world");
    printf('\n');
   }
   В результате ее выполнения будет напечатана та же строка, что и раньше.
   Заметим, что\nобозначает только один символ. Такие особые комбинации символов, начинающиеся с обратной наклонной черты, как\n,и называемые эскейп-последовательностями, широко применяются для обозначения трудно представимых или невидимых символов. Среди прочих в Си имеются символы\t,\b,\",\\,обозначающие соответственно табуляцию, возврат на один символ назад ("забой" последнего символа), двойную кавычку, саму наклонную черту. Полный список таких символов представлен в параграфе 2.3.
   Упражнение 1.1.Выполните программу, печатающую "Hello, world", в вашей системе. Поэкспериментируйте, удаляя некоторые части программы, и посмотрите, какие сообщения об ошибках вы получите.
   Упражнение 1.2.Выясните, что произойдет, если в строковую константу аргументаprintfвставить \c, где c - символ, не входящий в представленный выше список.
   1.2Переменные и арифметические выражения
   Приведенная ниже программа выполняет вычисления по формуле °С = (5/9)(°F-32) и печатает таблицу соответствия температур по Фаренгейту температурам по Цельсию:
   0   –17
   20  –6
   40  4
   60  15
   80  26
   100 37
   120 48
   140 60
   160 71
   180 82
   200 93
   220 104
   240 115
   260 126
   280 137
   300 148
   Как и предыдущая, эта программа состоит из определения одной-единственной функцииmain.Она длиннее программы, печатающей "здравствуй, мир", но по сути не сложнее. На ней мы продемонстрируем несколько новых возможностей, включая комментарий, объявления, переменные, арифметические выражения, циклы и форматный вывод.
   #include‹stdio.h›
   /*печать таблицы температур по Фаренгейту
   и Цельсию для fahr = 0, 20,…, 300 */
   main()
   {
    int fahr, celsius;
    int lower, upper, step;
    lower = 0; /* нижняя граница таблицы температур */
    upper = 300; /* верхняя граница */
    step = 20; /* шаг */
    fahr = lower;
    while (fahr ‹= upper) {
     celsius = 5 * (fahr-32) / 9;
     printf("%d\t%d\n", fahr, celsius);
     fahr = fahr + step;
    }
   }
   Две строки:
   /*печать таблицы температур по Фаренгейту
   и Цельсию для fahr = 0, 20,… 300 */
   являютсякомментарием,который в данном случае кратко объясняет, что делает программа. Все символы, помещенные между /* и */, игнорируются компилятором, и этим можно свободно пользоваться, чтобы сделать программу более понятной. Комментарий можно располагать в любом месте, где могут стоять символы пробела, табуляции или символ новой строки.
   В Си любая переменная должна быть объявлена раньше, чем она будет использована; обычно все переменные объявляются в начале функции перед первой исполняемой инструкцией. Вобъявленииописываются свойства переменных. Оно состоит из названия типа и списка переменных, например:
   int fahr, celsius;
   int lower, upper, step;
   Типintозначает, что значения перечисленных переменных есть целые, в отличие от него типfloatуказывает на значения с плавающей точкой, т. е. на числа, которые могут иметь дробную часть. Диапазоны значений обоих типов зависят от используемой машины.
   Числа типаintбывают как 16-разрядные (лежат в диапазоне от -32768 до 32767), так и 32-разрядные. Числа типаfloatобычно представляются 32-разрядными словами, имеющими по крайней мере 6 десятичных значащих цифр (лежат приблизительно в диапазоне от 10-38до 10+38.
   Помимоintиfloatв Си имеется еще несколько базовых типов для данных, это:
   char -символ-единичный байт;
   short -короткое целое;
   long -длинное целое;
   double -с плавающей точкой с двойной точностью.
   Размеры объектов указанных типов также зависят от машины. Из базовых типов можно создавать:массивы, структурыиобъединения, указателина объекты базовых типов и функции, возвращающие значения этих типов в качестве результата. Обо всем этом мы расскажем позже.
   Вычисления в программе преобразования температур начинаются синструкций присваивания.
   lower = 0;
   upper = 300;
   step = 20;
   fahr = lower;
   которые устанавливают указанные в них переменные в начальные значения. Любая инструкция заканчивается точкой с запятой.
   Все строки таблицы вычисляются одним и тем же способом, поэтому мы воспользуемся циклом, повторяющим это вычисление для каждой строки. Необходимые действия выполнит циклwhile:
   while(fahr‹= upper) {
    …
   }
   Он работает следующим образом. Проверяется условие в скобках. Если оно истинно (значениеfahrменьше или равно значениюupper),то выполняется тело цикла (три инструкции, заключенные в фигурные скобки). Затем опять проверяется условие, и если оно истинно, то тело цикла выполняется снова. Когда условие становится ложным (fahrпревысилоupper),цикл завершается, и вычисления продолжаются с инструкции, следующей за циклом. Поскольку никаких инструкций за циклом нет, программа завершает работу.
   Телом циклаwhileможет быть одна или несколько инструкций, заключенных в фигурные скобки, как в программе преобразования температур, или одна-единственная инструкция без скобок, как в цикле
   (while i‹ j)
    i = 2 * i;
   И в том и в другом случае инструкции, находящиеся под управлениемwhile,мы будем записывать со сдвигом, равным одной позиции табуляции, которая в программе указывается четырьмя пробелами; благодаря этому будут ясно видны инструкции, расположенные внутри цикла. Отступы подчеркивают логическую структуру программы. Си-компилятор не обращает внимания на внешнее оформление программы, но наличие в нужных местах отступов и пробелов существенно влияет на то, насколько легко она будет восприниматься человеком при просмотре. Чтобы лучше была видна логическая структура выражения, мы рекомендуем на каждой строке писать только по одной инструкции и с обеих сторон от операторов ставить пробелы. Положение скобок не так важно, хотя существуют различные точки зрения на этот счет. Мы остановились на одном из нескольких распространенных стилей их применения. Выберите тот, который больше всего вам нравится, и строго ему следуйте.
   Большая часть вычислений выполняется в теле цикла. Температура по Фаренгейту переводится в температуру по Цельсию и присваивается переменнойcelsiusпосредством инструкции
   celsius = 5 * (fahr-32) / 9;
   Причина, по которой мы сначала умножаем на 5 и затем делим на 9, а не сразу умножаем на 5/9, связана с тем, что в Си, как и во многих других языках, деление целых сопровождаетсяотбрасыванием,т. е. потерей дробной части. Так как 5 и 9 - целые, отбрасывание в 5/9 дало бы нуль, и на месте температур по Цельсию были бы напечатаны нули.
   Этот пример прибавил нам еще немного знаний о том, как работает функцияprintf.Функцияprintf -это универсальная функция форматного ввода-вывода, которая будет подробно описана в главе 7. Ее первый аргумент - строка символов, в которой каждый символ % соответствует одному из последующих аргументов (второму, третьему, …), а информация, расположенная за символом %, указывает на вид, в котором выводится каждый из этих аргументов. Например, %d специфицирует выдачу аргумента в виде целого десятичного числа, и инструкция
   printf("%d\t%d\n", fahr, celsius);
   печатает целоеfahr,выполняет табуляцию (\t) и печатает целоеcelsius.
   В функцииprintfкаждому спецификатору первого аргумента (конструкции, начинающейся с%)соответствует второй аргумент, третий аргумент и т. д. Спецификаторы и соответствующие им аргументы должны быть согласованы по количеству и типам: в противном случае напечатано будет не то, что нужно.
   Кстати,printfне является частью языка Си, и вообще в языке нет никаких специальных конструкций, определяющих ввод-вывод. Функцияprintf -лишь полезная функция стандартной библиотеки, которая обычно доступна для Си-программ. Поведение функцииprintf,однако, оговорено стандартом ANSI, и ее свойства должны быть одинаковыми во всех Си-системах, удовлетворяющих требованиям стандарта.
   Желая сконцентрировать ваше внимание на самом Си, мы не будем много говорить о вводе-выводе до главы 7. В частности, мы отложим разговор о форматном вводе. Если вам потребуется ввести числа, советуем прочитать в параграфе 7.4 то, что касается функцииscanf.Эта функция отличается отprintfлишь тем, что она вводит данные, а не выводит.
   Существуют еще две проблемы, связанные с программой преобразования температур. Одна из них (более простая) состоит в том, что выводимый результат выглядит несколько неряшливо, поскольку числа не выровнены по правой позиции колонок. Это легко исправить, добавив в каждый из спецификаторов формата %d указание о ширине поля; при этом программа будет печатать числа, прижимая их к правому краю указанных полей. Например, мы можем написать
   printf("%3d%6d\n", fahr, celsius);
   чтобы в каждой строке первое число печатать в поле из трех позиций, а второе - из шести. В результате будет напечатано:
     0   -17
    20    -6
    40     4
    60    15
    80    26
   100    37
   Вторая, более серьезная проблема связана с тем, что мы пользуемся целочисленной арифметикой и поэтому не совсем точно вычисляем температуры по шкале Цельсия. Например, 0°F на самом деле (с точностью до десятой) равно -17.8°С, а не -17. Чтобы получить более точные значения температур, нам надо пользоваться не целочисленной арифметикой, а арифметикой с плавающей точкой. Это потребует некоторых изменений в программе.
   #include‹stdio.h›
   /*печать таблицы температур по Фаренгейту и Цельсию для
   fahr = 0, 20,…, 300; вариант с плавающей точкой */
   main()
   {
    float fahr, celsius;
    int lower, upper, step;
    lower = 0; /* нижняя граница таблицы температур */
    upper = 300; /* верхняя граница */
    step = 20; /* шаг */
    fahr = lower;
    while (fahr ‹= upper) {
     celsius = (5.0/9.0) * (fahr-32.0);
     printf("%3.0f %6.1f\n", fahr, celsius);
     fahr = fahr + step;
    }
   }
   Программа мало изменилась. Она отличается от предыдущей лишь тем, чтоfahrиcelsiusобъявлены какfloat,а формула преобразования написана в более естественном виде. В предыдущем варианте нельзя было писать 5/9, так как целочисленное деление в результате обрезания дало бы нуль. Десятичная точка в константе указывает на то, что последняя рассматривается как число с плавающей точкой, и 5.0/9.0, таким образом, есть частное от деления двух значений с плавающей точкой, которое не предполагает отбрасывания дробной части. В том случае, когда арифметическая операция имеет целые операнды, она выполняется по правилам целочисленной арифметики. Если же один операнд с плавающей точкой, а другой - целый, то перед тем, как операция будет выполнена, последний будет преобразован в число с плавающей точкой. Если бы мы написалиfahr-32то 32 автоматически было бы преобразовано в число с плавающей точкой. Тем не менее при записи констант с плавающей точкой мы всегда используем десятичную точку, причем даже в тех случаях, когда константы на самом деле имеют целые значения. Это делается для того, чтобы обратить внимание читающего программу на их природу.
   Более подробно правила, определяющие, в каких случаях целые переводятся в числа с плавающей точкой, рассматриваются в главе 2. А сейчас заметим, что присваивание
   fahr=lower;
   и проверка
   while(fahr‹= upper)
   работают естественным образом, т. е. перед выполнением операции значениеintприводится кfloat.
   Спецификация%3.0fвprintfопределяет печать числа с плавающей точкой (в данном случае числаfahr)в поле шириной не более трех позиций без десятичной точки и дробной части. Спецификация%6.1fописывает печать другого числа (celsius)в поле из шести позиций с одной цифрой после десятичной точки. Напечатано будет следующее:
     0  -17.8
    20   -6.7
    40    4.4
   Ширину и точность можно не задавать;%6fозначает, что число будет занимать не более шести позиций;%.2f -число имеет две цифры после десятичной точки, но ширина не ограничена;%fпросто указывает на печать числа с плавающей точкой.
   %d -печать десятичного целого.
   %6d -печать десятичного целого в поле из шести позиций.
   %f -печать числа с плавающей точкой.
   %6f -печать числа с плавающей точкой в поле из шести позиций.
   %.2f -печать числа с плавающей точкой с двумя цифрами после десятичной точки.
   %6.2f -печать числа с плавающей точкой и двумя цифрами после десятичной точки в поле из шести позиций.
   Кроме того,printfдопускает следующие спецификаторы:%oдля восьмеричного числа;%xдля шестнадцатеричного числа;%cдля символа;%sдля строки символов и%%для самого %.
   Упражнение 1.3.Усовершенствуйте программу преобразования температур таким образом, чтобы над таблицей она печатала заголовок.
   Упражнение 1.4.Напишите программу, которая будет печатать таблицу соответствия температур по Цельсию температурам по Фаренгейту.
   1.3Инструкция for
   Существует много разных способов для написания одной и той же программы. Видоизменим нашу программу преобразования температур:
   #include‹stdio.h›
   /*печать таблицы температур по Фаренгейту и Цельсию */
   main()
   {
    int fahr;
    for (fahr = 0; fahr ‹= 300; fahr = fahr + 20)
    printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
   }
   Эта программа печатает тот же результат, но выглядит она, несомненно, по-другому. Главное отличие заключается в отсутствии большинства переменных. Осталась толькопеременнаяfahr,которую мы объявили какint.Нижняя и верхняя границы и шаг присутствуют в виде констант в инструкцииfor -новой для нас конструкции, а выражение, вычисляющее температуру по Цельсию, теперь задано третьим аргументом функцииprintf,а не в отдельной инструкции присваивания.
   Последнее изменение является примером применения общего правила: в любом контексте, где возможно использовать значение переменной какого-то типа, можно использовать более сложное выражение того же типа. Так, на месте третьего аргумента функцииprintfсогласно спецификатору%6.1fдолжно быть значение с плавающей точкой, следовательно, здесь может быть любое выражение этого типа.
   Инструкцияforописывает цикл, который является обобщением циклаwhile.Если вы сравните его с ранее написаннымwhile,то вам станет ясно, как он работает. Внутри скобок имеются три выражения, разделяемые точкой с запятой. Первое выражение - инициализация
   fahr = 0
   выполняется один раз перед тем, как войти в цикл. Второе - проверка условия продолжения цикла
   fahr‹= 300
   Условие вычисляется, и если оно истинно, выполняется тело цикла (в нашем случае это одно обращение кprintf).Затем осуществляется приращение шага:
   fahr = fahr + 20
   и условие вычисляется снова. Цикл заканчивается, когда условие становится ложным. Как и в случае сwhile,телоfor-цикла может состоять из одной инструкции или из нескольких, заключенных в фигурные скобки. На месте этих трех выражений (инициализации, условия и приращения шага) могут стоять произвольные выражения.
   Выбор междуwhileиforопределяется соображениями ясности программы. Циклforболее удобен в тех случаях, когда инициализация и приращение шага логически связаны друг с другом общей переменной и выражаются единичными инструкциями, поскольку названный цикл компактнее циклаwhile,а его управляющие части сосредоточены в одном месте.
   Упражнение 1.5.Измените программу преобразования температур так, чтобы она печатала таблицу в обратном порядке, т. е. от 300 до 0.
   1.4Именованные константы
   Прежде чем мы закончим рассмотрение программы преобразования температур, выскажем еще одно соображение. Очень плохо, когда по программе рассеяны "загадочные числа", такие как 300, 20. Тот, кто будет читать программу, не найдет в них и намека на то, что они собой представляют. Кроме того, их трудно заменить на другие каким-то систематическим способом. Одна из возможностей справиться с такими числами - дать им осмысленные имена. Строка#defineопределяетсимвольное имя,илиименованную константу,для заданной строки символов:
   #defineимя подставляемый-текст
   С этого момента при любом появленииимени (если только оно встречается не в тексте, заключенном в кавычки, и не является частью определения другого имени) оно будет заменяться на соответствующий емуподставляемый-текст.Имяимеет тот же вид, что и переменная: последовательность букв и цифр, начинающаяся с буквы.Подставляемый-текстможет быть любой последовательностью символов, среди которых могут встречаться не только цифры.
   #include‹stdio.h›

   #define LOWER 0 /*нижняя граница таблицы */
   #define UPPER 300 /*верхняя граница */
   #define STEP 20 /*размер шага */

   /*печать таблицы температур по Фаренгейту и Цельсию */
   main()
   {
    int fahr;
    for (fahr = LOWER; fahr ‹= UPPER; fahr = fahr + STEP)
    printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));
   }
   ВеличиныLOWER, UPPERиSTEP -именованные константы, а не переменные, поэтому для них нет объявлений. По общепринятому соглашению имена именованных констант набираются заглавными буквами, чтобы они отличались от обычных переменных, набираемых строчными. Заметим, что в конце#define-строки точка с запятой не ставится.
   1.5Ввод-вывод символов
   Теперь мы намерены рассмотреть семейство программ по обработке текстов. Вы обнаружите, что многие существующие программы являются просто расширенными версиями обсуждаемых здесь прототипов.
   Стандартная библиотека поддерживает очень простую модель ввода-вывода. Текстовый ввод-вывод вне зависимости от того, откуда он исходит или куда направляется, имеет дело с потоком символов.Текстовый поток -это последовательность символов, разбитая на строки, каждая из которых содержит нуль или более символов и завершается символом новой строки. Обязанность следить за тем, чтобы любой поток ввода-вывода отвечал этой модели, возложена на библиотеку: программист, пользуясь библиотекой, не должен заботиться о том, в каком виде строки представляются вне программы.
   Стандартная библиотека включает несколько функций для чтения и записи одного символа. Простейшие из них -getcharиputchar.За одно обращение кgetcharсчитываетсяследующий символ вводаиз текстового потока, и этот символ выдается в качестве результата. Так, после выполнения
   c = getchar();
   переменнаяcсодержит очередной символ ввода. Обычно символы поступают с клавиатуры. Ввод из файлов рассматривается в главе 7.
   Обращение кputcharприводит к печати одного символа. Так,
   putchar(c);
   напечатает содержимое целой переменнойcв виде символа (обычно на экране). Вызовыputcharиprintfмогут произвольным образом перемежаться. Вывод будет формироваться в том же порядке, что и обращения к этим функциям.
   1.5.1Копирование файла
   При наличии функцийgetcharиputchar,ничего больше не зная о вводе-выводе, можно написать удивительно много полезных программ. Простейший пример - это программа, копирующая по одному символу с входного потока в выходной поток:
   чтение символа
   while (символ не является признаком конца файла)
   вывод только что прочитанного символа
   чтение символа
   Оформляя ее в виде программы ни Си, получим
   #include‹stdio.h›

   /*копирование ввода на вывод, 1-я версия */
   main()
   {
    int c;
    c = getchar();
    while (c != EOF) {
     putchar(c);
     c = getchar();
    }
   }
   Оператор отношения!=означает "не равно".
   Каждый символ, вводимый с клавиатуры или появляющийся на экране, как и любой другой символ внутри машины, кодируется комбинацией битов. Типcharспециально предназначен для хранения символьных данных, однако для этого также годится и любой целый тип. Мы пользуемся типомintи делаем это по одной важной причине, которая требует разъяснений.
   Существует проблема: как отличить конец ввода от обычных читаемых данных. Решение заключается в том, чтобы функцияgetcharпо исчерпании входного потока выдавала в качестве результата такое значение, которое нельзя было бы спутать ни с одним реальным символом. Это значение естьEOF (аббревиатура отend of file -конец файла). Мы должны объявить переменнуюcтакого типа, чтобы его "хватило" для представления всех возможных результатов, выдаваемых функциейgetchar.Нам не подходит типchar,так какcдолжна быть достаточно "емкой", чтобы помимо любого значения типаcharбыть в состоянии хранить иEOF.Вот почему мы используемint,а неchar.
   EOF -целая константа, определенная в‹stdio.h›.Какое значение имеет эта константа - неважно, лишь бы оно отличалось от любого из возможных значений типаchar.Использование именованной константы с унифицированным именем гарантирует, что программа не будет зависеть от конкретного числового значения, которое, возможно, в других Си-системах будет иным.
   Программу копирования можно написать более сжато. В Си любое присваивание, например
   c = getchar()
   трактуется как выражение со значением, равным значению левой части после присваивания. Это значит, что присваивание может встречаться внутри более сложного выражения. Если присваивание переменнойcрасположить в проверке условия циклаwhile,то программу копирования можно будет записать в следующем виде:
   #include‹stdio.h›
   /*копирование ввода на вывод; 2-я версия */
   main()
   {
    int c;

    while ((с = getchar()) != EOF)
     putchar(c);
   }
   Циклwhile,пересылая вcполученное отgetcharзначение, сразу же проверяет: не является ли оно "концом файла". Если это не так, выполняется тело циклаwhileи печатается символ. По окончании ввода завершается работа циклаwhile,а тем самым иmain.
   В данной версии ввод "централизован". - в программе имеется только одно обращение кgetchar.В результате она более компактна и легче воспринимается при чтении. Вам часто придется сталкиваться с такой формой записи, где присваивание делается вместе с проверкой. (Чрезмерное увлечение ею, однако, может запутать программу, поэтому мы постараемся пользоваться указанной формой разумно.)
   Скобки внутри условия, вокруг присваивания, необходимы.Приоритет !=выше, чем приоритет =, из чего следует, что при отсутствии скобок проверка!= будет выполняться до операции присваивания =. Таким образом, запись
   c = getchar() != EOF
   эквивалентна записи
   c = (getchar() != EOF)
   А это совсем не то, что нам нужно: переменнойcбудет присваиваться 0 или 1 в зависимости от того, встретит или не встретитgetcharпризнак конца файла. (Более подробно об этом см. в главе 2.)
   Упражнение 1.6.Убедитесь в том, что выражениеgetchar()!= EOFполучает значение 0 или 1.
   Упражнение 1.7.Напишите программу, печатающую значениеEOF.
   1.5.2Подсчет символов
   Следующая программа занимается подсчетом символов; она имеет много сходных черт с программой копирования.
   #include‹stdio.h›

   /*подсчет вводимых символов; 1-я версия */
   main()
   {
    long nc;
    nc = 0;

    while (getchar() != EOF)
     ++nc;
    printf("%ld\n", nc);
   }
   Инструкция
   ++nc;
   представляет новый оператор++,который означаетувеличить на единицу.Вместо этого можно было бы написатьnc=nc+1,но++ncнамного короче, а часто и эффективнее. Существует аналогичный оператор--,означающийуменьшить на единицу.Операторы++и--могут быть как префиксными (++nc),так и постфиксными (nc++).Как будет показано в главе 2, эти две формы в выражениях имеют разные значения, но и++nc,иnc++добавляют кncединицу. В данном случае мы остановились на префиксной записи.
   Программа подсчета символов накапливает сумму в переменной типаlong.Целые типаlongимеют не менее 32 битов. Хотя на некоторых машинах типыintиlongимеют одинаковый размер, существуют, однако, машины, в которыхintзанимает 16 бит с максимально возможным значением 32767, а это - сравнительно маленькое число, и счетчик типаintможет переполниться. Спецификация%ldвprintfуказывает, что соответствующий аргумент имеет типlong.
   Возможно охватить еще больший диапазон значений, если использовать типdouble (т. е.floatс двойной точностью). Применим также инструкциюforвместоwhile,чтобы продемонстрировать другой способ написания цикла.
   #include‹stdio.h›

   /*подсчет вводимых символов; 2-й версия */
   main()
   {
    double nc;
    for (nc = 0; getchar() != EOF; ++nc)
     ;
    printf("%.0f\n", nc);
   }
   Вprintfспецификатор%fприменяется как дляfloat,так и дляdouble;спецификатор%.0fозначает печать без десятичной точки и дробной части (последняя в нашем случае отсутствует).
   Тело указанногоfor-цикла пусто, поскольку кроме проверок и приращений счетчика делать ничего не нужно. Но правила грамматики Си требуют, чтобыfor-цикл имел тело. Выполнение этого требования обеспечивает изолированная точка с запятой, называемаяпустой инструкцией.Мы поставили точку с запятой на отдельной строке для большей наглядности.
   Наконец, заметим, что если ввод не содержит ни одного символа, то при первом же обращении кgetcharусловие вwhileилиforне будет выполнено и программа выдаст нуль, что и будет правильным результатом. Это важно. Одно из привлекательных свойств цикловwhileиforсостоит в том, что условие проверяется до того, как выполняется тело цикла. Если ничего делать не надо, то ничего делаться и не будет, пусть даже тело цикла не выполнится ни разу. Программа должна вести себя корректно и при нулевом количестве вводимых символов. Само устройство цикловwhileиforдает дополнительную уверенность в правильном поведении программы в случае граничных условий.
   1.5.3Подсчет строк
   Следующая программа подсчитывает строки. Как упоминалось выше, стандартная библиотека обеспечивает такую модель ввода-вывода, при которой входной текстовый поток состоит из последовательности строк, каждая из которых заканчивается символом новой строки. Следовательно, подсчет строк сводится к подсчету числа символов новой строки.
   #include‹stdio.h›
   /*подсчет строк входного потока */
   main()
   {
    int c, nl;
    nl = 0;
    while ((с = getchar()) != EOF)
     if (c == '\n')
      ++nl;
    printf("%d\n", nl);
   }
   Тело цикла теперь образует инструкцияif,под контролем которой находится увеличение счетчикаnlна единицу. Инструкция if проверяет условие в скобках и, если оно истинно, выполняет следующую за ним инструкцию (или группу инструкций, заключенную в фигурные скобки). Мы опять делаем отступы в тексте программы, чтобы показать, что чем управляется.
   Двойной знак равенства в языке Си обозначает оператор "равно" (он аналогичен оператору=в Паскале и.EQ.в Фортране). Удваивание знака=в операторе проверки на равенство сделано для того, чтобы отличить его от единичного=,используемого в Си для обозначения присваивания. Предупреждаем: начинающие программировать на Си иногда пишут=,а имеют в виду==.Как мы увидим в главе 2, в этом случае результатом будет обычно вполне допустимое по форме выражение, на которое компилятор не выдаст никаких предупреждающих сообщений (Современные компиляторы, как правило, выдают предупреждение о возможной ошибке. -Примеч. ред.).
   Символ, заключенный в одиночные кавычки, представляет собой целое значение, равное коду этого символа (в кодировке, принятой на данной машине). Это так называемаясимвольная константа.Существует и другой способ для написания маленьких целых значений. Например, 'A' есть символьная константа, в наборе символов ASCII ее значение равняется 65 - внутреннему представлению символаA.Конечно, 'A' в роли константы предпочтительнее, чем 65, поскольку смысл первой записи более очевиден, и она не зависит от конкретного способа кодировки символов.
   Эскейп-последовательности, используемые в строковых константах, допускаются также и в символьных константах. Так,'\n'обозначает код символа новой строки, который в ASCII равен 10. Следует обратить особое внимание на то, что'\n'обозначает один символ (код которого в выражении рассматривается как целое значение), в то время как"\n" -строковая константа, в которой чисто случайно указан один символ. Более подробно различие между символьными и строковыми константами разбирается в главе 2.
   Упражнение 1.8.Напишите программу для подсчета пробелов, табуляций и новых строк.
   Упражнение 1.9.Напишите программу, копирующую символы ввода в выходной поток и заменяющую стоящие подряд пробелы на один пробел.
   Упражнение 1.10.Напишите программу, копирующую вводимые символы в выходной поток с заменой символа табуляции на\t,символа забоя на\bи каждой обратной наклонной черты на\\.Это сделает видимыми все символы табуляции и забоя.
   1.5.4Подсчет слов
   Четвертая из нашей серии полезных программ подсчитывает строки, слова и символы, причем под словом здесь имеется в виду любая строка символов, не содержащая в себепробелов, табуляций и символов новой строки. Эта программа является упрощенной версией программыwcсистемы UNIX.
   #include‹stdio.h›

   #define IN 1 /*внутри слова */
   #define OUT 0 /*вне слова */

   /*подсчет строк, слов и символов */
   main()
   {
    int с, nl, nw, nc, state;
    state = OUT;
    nl = nw = nc = 0;
    while ((с = getchar()) != EOF) {
     ++nc;
     if (c == '\n')
      ++nl;
     if (c == ' ' || c == '\n' || c == '\t')
      state = OUT;
     else if (state == OUT) {
      state = IN;
      ++nw;
     }
    }
    printf("%d %d %d\n", nl, nw, nc);
   }
   Каждый раз, встречая первый символ слова, программа изменяет значение счетчика слов на 1. Переменнаяstateфиксирует текущее состояние - находимся мы внутри или вне слова. Вначале ей присваивается значение OUT, что соответствует состоянию "вне слова". Мы предпочитаем пользоваться именованными константами IN и OUT, а не собственно значениями 1 и 0, чтобы сделать программу более понятной. В такой маленькой программе этот прием мало что дает, но в большой программе увеличение ее ясности окупает незначительные дополнительные усилия, потраченные на то, чтобы писать программу в таком стиле с самого начала. Вы обнаружите, что большие изменения гораздо легче вносить в те программы, в которых магические числа встречаются только в виде именованных констант.
   Строка
   nl = nw = nc = 0;
   устанавливает все три переменные в нуль. Такая запись не является какой-то особой конструкцией и допустима потому, что присваивание есть выражение со своим собственным значением, а операции присваивания выполняются справа налево. Указанная строка эквивалентна
   nl = (nw = (nc = 0));
   Оператор||означаетИЛИ,так что строка
   if (c == ' ' || c == '\n' || c == '\t')
   читается как "если c есть пробел,или cесть новая строка,или cесть табуляция". (Напомним, что видимая эскейп-последовательность \t обозначает символ табуляции.) Существует также оператор&&,означающийИ.Его приоритет выше, чем приоритет||.Выражения, связанные операторами&&или ||, вычисляются слева направо; при этом гарантируется, что вычисления сразу прервутся, как только будет установлена истинность или ложность условия. Если c есть пробел, то дальше проверять, является значение c символом новой строки или же табуляции, не нужно. В этом частном случае данный способ вычислений не столь важен, но он имеет значение в более сложных ситуациях, которые мы вскоре рассмотрим.
   В примере также встречается словоelse,которое указывает на альтернативные действия, выполняемые в случае, когда условие, указанное вif,не является истинным. В общем виде условная инструкция записывается так:
   if (выражение)
    инструкция1
   else
    инструкция2
   В конструкцииif-elseвыполняется одна и только одна из двух инструкций. Есливыражениеистинно, то выполняетсяинструкция1,если нет, то -инструкция2.Каждая из этих двух инструкций представляет собой либо одну инструкцию, либо несколько, заключенных в фигурные скобки. В нашей программе послеelseстоит инструкцияif,управляющая двумя такими инструкциями.
   Упражнение 1.11.Как протестировать программу подсчета слов? Какой ввод вероятнее всего обнаружит ошибки, если они были допущены?
   Упражнение 1.12.Напишите программу, которая печатает содержимое своего ввода, помещая по одному слову на каждой строке.
   1.6Массивы
   А теперь напишем программу, подсчитывающую по отдельности каждую цифру, символы-разделители (пробелы, табуляции и новые-строки)и все другие символы. Это несколько искусственная программа, но она позволит нам в одном примере продемонстрировать еще несколько возможностей языка Си. Имеется двенадцать категорий вводимых символов. Удобно все десять счетчиков цифр хранить в массиве, а не в виде десяти отдельных переменных. Вот один из вариантов этой программы:
   #include‹stdio.h›

   /*подсчет цифр, символов-разделителей и прочих символов */
   main()
   {
    int с, i, nwhite, nother;
    int ndigit[10];

    nwhite = nother = 0;
    for (i = 0; i ‹ 10, ++i)
     ndigit[i]= 0;

    while ((c = getchar())!= EOF)
     if (c ›='0'&&с ‹= '9')
      ++ndigit[c - '0'];
     else if (c == ' ' || c == '\n' || c == '\t')
      ++nwhite;
     else
      ++nother;

    printf("цифры =");
    for (i = 0; i ‹ 10; ++i)
     printf("%d", ndigit[i]);
    printf(", символы-разделители =%d, прочие =%d\n", nwhite, nother);
   }
   В результате выполнения этой программы будет напечатан следующий результат:
   цифры = 9 3 0 0 0 0 0 0 0 1, символы-разделители = 123, прочие = 345
   Объявление
   int ndigit[10];
   объявляетndigitмассивом из 10 значений типаint.В Си элементы массива всегда нумеруются начиная с нуля, так что элементами этого массива будут ndigit[0], ndigit[1], …, ndigit[9], что учитывается вfor-циклах (при инициализации и печати массива).
   Индексом может быть любое целое выражение, образуемое целыми переменными (напримерi)и целыми константами.
   Приведенная программа опирается на определенные свойства кодировки цифр. Например, проверка
    if (c ›= '0'&& c‹= '9') …
   определяет, является ли находящийся вcсимвол цифрой. Если это так, то
   c -'0'
   есть числовое значение цифры. Сказанное справедливо только в том случае, если для ряда значений '0','1',…, '9' каждое следующее значение на 1 больше предыдущего. К счастью, это правило соблюдается во всех наборах символов.
   По определению, значения типаcharявляются просто малыми целыми, так что переменные и константы типаcharв арифметических выражениях идентичны значениям типаint.Это и естественно, и удобно; например, c-'0' есть целое выражение с возможными значениями от 0 до 9, которые соответствуют символам от '0' до '9', хранящимся в переменной c.Таким образом, значение данного выражения является правильным индексом для массива ndigit.
   Следующий фрагмент определяет, является символ цифрой, символом-разделителем или чем-нибудь иным.
   if (c›= '0'&& c‹= '9')
    ++n[c-'0'];
   else if (c ==' ' || c == '\n' || c == '\t')
    ++nwhite;
   else
    ++nother;
   Конструкция вида
   if (условие1)
    инструкция1
   else if (условие2)
    инструкция2
   :
   :
   else
    инструкцияn
   часто применяется для выбора одного из нескольких альтернативных путей, имеющихся в программе.Условиявычисляются по порядку в направлении сверху вниз до тех пор, пока одно из них не будет удовлетворено; в этом случае будет выполнена соответствующая емуинструкция,и работа всей конструкции завершится. (Любая из инструкций может быть группой инструкций в фигурных скобках.) Если ни одно из условий не удовлетворено, выполняетсяпоследняя инструкция, расположенная сразу заelse,если таковая имеется. Если жеelseи следующей за ней инструкции нет (как это было в программе подсчета слов), то никакие действия вообще не производятся. Между первымifи завершающимelseможет быть сколько угодно комбинаций вида
   else if (условие)
    инструкция
   Когда их несколько, программу разумно форматировать так, как мы здесь показали. Если же каждый следующийifсдвигать вправо относительно предыдущегоelse,то при длинном каскаде проверок текст окажется слишком близко прижатым к правому краю страницы.
   Инструкцияswitch,речь о которой пойдет в главе 3, обеспечивает другой способ изображения многопутевого ветвления на языке Си. Он более подходит, в частности, тогда, когда условием перехода служит совпадение значения некоторого выражения целочисленного типа с одной из констант, входящих в заданный набор. Вариант нашей программы, реализованной с помощьюswitch,приводится в параграфе 3.4.
   Упражнение 1.13.Напишите программу, печатающую гистограммы длин вводимых слов. Гистограмму легко рисовать горизонтальными полосами. Рисование вертикальными полосами - более трудная задача.
   Упражнение 1.14.Напишите программу, печатающую гистограммы частот встречаемости вводимых символов.
   1.7Функции
   Функции в Си играют ту же роль, что и подпрограммы и функции в Фортране или процедуры и функции в Паскале. Функция обеспечивает удобный способ отдельно оформить некоторое вычисление и пользоваться им далее, не заботясь о том, как оно реализовано. После того, как функции написаны, можно забыть,какони сделаны, достаточно знать лишь,чтоони умеют делать. Механизм использования функции в Си удобен, легок и эффективен. Нередко вы будете встречать короткие функции, вызываемые лишь единожды: они оформлены в виде функции с одной-единственной целью - получить более ясную программу.
   До сих пор мы пользовались готовыми функциями вроде main, getchar и putchar, теперь настала пора нам самим написать несколько функций. В Си нет оператора возведения в степень вроде ** в Фортране. Поэтому проиллюстрируем механизм определения функции на примере функцииpower(m, n),которая возводит целое m в целую положительную степень n. Так, power(2, 5) имеет значение 32. На самом деле для практического применения эта функция малопригодна, так как оперирует лишь малыми целыми степенями, однако она вполне может послужить иллюстрацией. (В стандартной библиотеке есть функцияpow(x, y),вычисляющая x в степени y.)
   Итак, мы имеем функцию power и главную функцию main, пользующуюся ее услугами, так что вся программа выглядит следующим образом:
   #include‹stdio.h›

   int power(int m, int n);

   /*тест функции power */
   main()
   {
    int i;
    for (i = 0; i ‹ 10; ++i)
     printf("%d %d %d\n", i, power(2,i), power(-3,i));
    return 0;
   }

   /*возводит base в n-ю степень, n ›= 0 */
   int power(int base, int n)
   {
    int i, p;

    p = 1;
    for (i = 1; i ‹= n; ++i)
     p = p * base;
    return p;
   }
   Определение любой функции имеет следующий вид:
   тип-результата имя-функции (список параметров, если он есть)
   {
    объявления
    инструкции
   }
   Определения функций могут располагаться в любом порядке в одном или в нескольких исходных файлах, но любая функция должна быть целиком расположена в каком-то одном. Если исходный текст программы распределен по нескольким файлам, то, чтобы ее скомпилировать и загрузить, вам придется сказать несколько больше, чем при использовании одного файла; но это уже относится к операционной системе, а не к языку. Пока мы предполагаем, что обе функции находятся в одном файле, так что будет достаточно тех знаний, которые вы уже получили относительно запуска программ на Си.
   В следующей строке из функции main к power обращаются дважды.
   printf("%d %d %d\n", i, power(2,i), power(-3,i));
   При каждом вызове функции power передаются два аргумента, и каждый раз главная программа main в ответ получает целое число, которое затем приводится к должному форматуи печатается. Внутри выражения power(2, i) представляет собой целое значение точно так же, как 2 или i. (Не все функции в качестве результата выдают целые значения; подробно об этом будет сказано в главе 4.)
   В первой строке определения power:
   int power(int base, int n);
   указываются типы параметров, имя функции и тип результата. Имена параметров локальны внутриpower,это значит, что они скрыты для любой другой функции, так что остальные подпрограммы могут свободно пользоваться теми же именами для своих целей. Последнее утверждение справедливо также для переменных i и p: i в power и i в main не имеют между собой ничего общего.
   Далеепараметроммы будем называть переменную из списка параметров, заключенного в круглые скобки и заданного в определении функции, ааргументом -значение, используемое при обращении к функции. Иногда в том же смысле мы будем употреблять терминыформальный аргументифактический аргумент.
   Значение, вычисляемое функцией power, возвращается в main с помощью инструкцииreturn.За словомreturnможет следовать любое выражение:
   returnвыражение;
   Функция не обязательно возвращает какое-нибудь значение. Инструкцияreturnбез выражения только передает управление в ту программу, которая ее вызвала, не передавая ей никакого результирующего значения. То же самое происходит, если в процессе вычислений мы выходим на конец функции, обозначенный в тексте последней закрывающей фигурной скобкой. Возможна ситуация, когда вызывающая функция игнорирует возвращаемый ей результат.
   Вы, вероятно, обратили внимание на инструкциюreturnв концеmain.Поскольку main есть функция, как и любая другая она может вернуть результирующее значение тому, кто ее вызвал, - фактически в ту среду, из которой была запущена программа. Обычно возвращается нулевое значение, что говорит о нормальном завершении выполнения. Ненулевое значение сигнализирует о необычном или ошибочном завершении. До сих пор ради простоты мы опускали return в main, но с этого момента будем задавать return как напоминание о том, что программы должны сообщать о состоянии своего завершения в операционную систему.
   Объявление
   int power(int m, int n);
   стоящее непосредственно передmain,сообщает, что функция power ожидает двух аргументов типаintи возвращает результат типаint.Это объявление, называемоепрототипом функции,должно быть согласовано с определением и всеми вызовамиpower.Если определение функции или вызов не соответствует своему прототипу, это ошибка.
   Имена параметров не требуют согласования. Фактически в прототипе они могут быть произвольными или вообще отсутствовать, т. е. прототип можно было бы записать и так:
   int power(int, int);
   Однако удачно подобранные имена поясняют программу, и мы будем часто этим пользоваться.
   Историческая справка. Самые большие отличия ANSI-Си от более ранних версий языка как раз и заключаются в способах объявления и определения функций. В первой версии Си функцию power требовалось задавать в следующем виде:
   /* power:возводит base в n-ю степень, n ›= 0 */
   /* (версия в старом стиле языка Си) */
   power(base, n)
   int base, n;
   {
    int i, р;
    p = 1;
    for (i = 1; i ‹= n; ++i)
     р = р * base;
    return р;
   }
   Здесь имена параметров перечислены в круглых скобках, а их типы заданы перед первой открывающей фигурной скобкой. В случае отсутствия указания о типе параметра, считается, что он имеет типint. (Тело функции не претерпело изменений.)
   Описание power в начале программы согласно первой версии Си должно было бы выглядеть следующим образом:
   int power();
   Нельзя было задавать список параметров, и поэтому компилятор не имел возможности проверить правильность обращений к power. Так как при отсутствии объявления power предполагалось, что функция возвращает значение типа int, то в данном случае объявление целиком можно было бы опустить.
   Новый синтаксис для прототипов функций облегчает компилятору обнаружение ошибок в количестве аргументов и их типах. Старый синтаксис объявления и определения функции все еще допускается стандартом ANSI, по крайней мере на переходный период, но если ваш компилятор поддерживает новый синтаксис, мы настоятельно рекомендуем пользоваться только им.
   Упражнение 1.15.Перепишите программу преобразования температур, выделив само преобразование в отдельную функцию.
   1.8Аргументы. Вызов по значению
   Одно свойство функций в Си, вероятно, будет в новинку для программистов, которые уже пользовались другими языками, в частности Фортраном. В Си все аргументы функции передаются "по значению". Это следует понимать так, что вызываемой функции посылаются значения ее аргументов во временных переменных, а не сами аргументы. Такой способ передачи аргументов несколько отличается от "вызова по ссылке" в Фортране и спецификации var при параметре в Паскале, которые позволяют подпрограмме иметь доступ к самим аргументам, а не к их локальным копиям.
   Главное отличие заключается в том, что в Си вызываемая функция не может непосредственно изменить переменную вызывающей функции: она может изменить только ее частную, временную копию.
   Однако вызов по значению следует отнести к достоинствам языка, а не к его недостаткам. Благодаря этому свойству обычно удается написать более компактную программу, содержащую меньшее число посторонних переменных, поскольку параметры можно рассматривать как должным образом инициализированные локальные переменные вызванной подпрограммы. В качестве примера приведем еще одну версию функции power, в которой как раз использовано это свойство.
   /* power:возводит base в n-ю степень; n ›= 0, версия 2 */
   int power(int base, int n)
   {
    int p;
    for (p = 1; n › 0; -n)
     p = p * base;
    return p;
   }
   Параметр n выступает здесь в роли временной переменной, в которой цикломforв убывающем порядке ведется счет числа шагов до тех пор, пока ее значение не станет нулем. При этом отпадает надобность в дополнительной переменной i для счетчика цикла. Что бы мы ни делали с n внутри power, это не окажет никакого влияния на сам аргумент, копия которого была передана функции power при ее вызове.
   При желании можно сделать так, чтобы функция смогла изменить переменную в вызывающей программе. Для этого последняя должна передать адрес подлежащей изменению переменной (указательна переменную), а в вызываемой функции следует объявить соответствующий параметр как указатель и организовать через него косвенный доступ к этой переменной. Все, что касается указателей, мы рассмотрим в главе 5.
   Механизм передачи массива в качестве аргумента несколько иной. Когда аргументом является имя массива, то функции передается значение, которое является адресом начала этого массива; никакие элементы массива не копируются. С помощью индексирования относительно полученного значения функция имеет доступ к любому элементу массива. Разговор об этом пойдет в следующем параграфе.
   1.9Символьные массивы
   Самый распространенный вид массива в Си - массив символов. Чтобы проиллюстрировать использование символьных массивов и работающих с ними функций, напишем программу, которая читает набор текстовых строк и печатает самую длинную из них. Ее схема достаточно проста:
   while (есть ли еще строка?)
    if (данная строка длиннее самой длинной из предыдущих)
     запомнить ее
     запомнить ее длину
   напечатать самую длинную строку
   Из схемы видно, что программа естественным образом распадается на части. Одна из них получает новую строку, другая проверяет ее, третья запоминает, а остальные управляют процессом вычислений.
   Поскольку процесс четко распадается на части, хорошо бы так и перевести его на Си. Поэтому сначала напишем отдельную функцию getline для получения очередной строки. Мы попытаемся сделать эту функцию полезной и для других применений. Как минимум getline должна сигнализировать о возможном конце файла, а еще лучше, если она будет выдавать длину строки - или нуль в случае исчерпания файла. Нуль годится для признака конца файла, поскольку не бывает строк нулевой длины, даже строка, содержащая только один символ новой строки, имеет длину 1.
   Когда мы обнаружили строку более длинную, чем самая длинная из всех предыдущих, то нам надо будет где-то ее запомнить. Здесь напрашивается вторая функция, copy, которая умеет копировать новую строку в надежное место.
   Наконец, нам необходима главная программа, которая бы управляла функциями getline и copy. Вот как выглядит наша программа в целом:
   #include‹stdio.h›
   #define MAXLINE 1000 /*максимальный размер вводимой строки */

   int getline(char line[], int MAXLINE);
   void copy(char to[], char from[]);

   /*печать самой длинной строки */
   main()
   {
    int len; /* длина текущей строки */
    int max; /* длина максимальной из просмотренных строк */
    char line[MAXLINE]; /* текущая строка */
    char longest[MAXLINE]; /* самая длинная строка */

    max = 0;
    while (len = getline(line, MAXLINE)) › 0)
     if (len › max) {
      max = len;
      copy(longest, line);
     }
    if (max › 0) /* была ли хоть одна строка? */
     printf("%s", longest);
    return 0;
   }

   /* getline:читает строку в s, возвращает длину */
   int getline(char s[], int lim)
   {
    int c, i;

    for (i = 0; i ‹ lim-1&& (c = getchar()) != EOF&&с != '\n'; ++i)
     s[i] = c;
    if (c == '\n') {
     s[i] = c;
     ++i;
    }
    s[i] = '\0';
    return i;
   }

   /* copy:копирует из 'from' в 'to'; to достаточно большой */
   void copy(char to[], char from[])
   {
    int i;

    i = 0;
    while ((to[i] = from[i]) != '\0')
     ++i;
   }
   Мы предполагаем, что функцииgetlineиcopy,описанные в начале программы, находятся в том же файле, что иmain.
   Функцииmainиgetlineвзаимодействуют между собой через пару аргументов и возвращаемое значение. Вgetlineаргументы определяются строкой
   int getline(char s[], int lim);
   Как мы видим, ее первый аргументsесть массив, а второй,lim,имеет типint.Задание размера массива в определении имеет целью резервирование памяти. В самойgetlineзадавать длину массиваsнет необходимости, так как его размер указан вmain.Чтобы вернуть значение вызывающей программе,getlineиспользуетreturnточно так же, как это делает функцияpower.В приведенной строке также сообщается, чтоgetlineвозвращает значение типаint,но так как при отсутствии указания о типе подразумеваетсяint,то передgetlineсловоintможно опустить.
   Одни функции возвращают результирующее значение, другие (такие какcopy)нужны только для того, чтобы произвести какие-то действия, не выдавая никакого значения. На месте типа результата вcopyстоитvoid.Это явное указание на то, что никакого значения данная функция не возвращает.
   Функцияgetlineв конец создаваемого ею массива помещает символ'\0' (null-символ, кодируемый нулевым байтом), чтобы пометить конец строки символов. То же соглашение относительно окончания нулем соблюдается и в случае строковой константы вроде
   "hello\n"
   В данном случае для него формируется массив из символов этой строки с '\0' в конце.
   hе l l o \n \0
   Спецификация%sв форматеprintfпредполагает, что соответствующий ей аргумент - строка символов, оформленная указанным выше образом. Функцияcopyв своей работе также опирается на тот факт, что читаемый ею аргумент заканчивается символом '\0', который она копирует наряду с остальными символами. (Всё сказанное предполагает, что '\0' не встречается внутри обычного текста.)
   Попутно стоит заметить, что при работе даже с такой маленькой программой мы сталкиваемся с некоторыми конструктивными трудностями. Например, что должна делатьmain,если встретится строка, превышающая допустимый размер? Функцияgetlineработает надежно: если массив полон, она прекращает пересылку, даже если символа новой строки не обнаружила. Получив отgetlineдлину строки и увидев, что она совпадает с MAXLINE, главная программа main могла бы "отловить" этот особый случай и справиться с ним. В интересах краткости описание этого случая мы здесь опускаем.
   Пользователиgetlineне могут заранее узнать, сколь длинными будут вводимые строки, поэтомуgetlineделает проверки на переполнение. А вот пользователям функцииcopyразмеры копируемых строк известны (или они могут их узнать), поэтому дополнительный контроль здесь не нужен.
   Упражнение 1.16.Перепишите main предыдущей программы так, чтобы она могла печатать самую длинную строку без каких-либо ограничений на ее размер.
   Упражнение 1.17.Напишите программу печати всех вводимых строк, содержащих более 80 символов.
   Упражнение 1.18.Напишите программу, которая будет в каждой вводимой строке заменять стоящие подряд символы пробелов и табуляций на один пробел и удалять пустые строки.
   Упражнение 1.19.Напишите функциюreverse(s),размещающую символы в строкеsв обратном порядке. Примените ее при написании программы, которая каждую вводимую строку располагает в обратном порядке.
   1.10Внешние переменные и область видимости
   Переменныеline,longestи прочие принадлежат только функцииmain,или, как говорят, локальны в ней. Поскольку они объявлены внутриmain,никакие другие функции прямо к ним обращаться не могут. То же верно и применительно к переменным других функций. Например,iвgetlineне имеет никакого отношения кiвcopy.Каждая локальная переменная функции возникает только в момент обращения к этой функции и исчезает после выхода из нее. Вот почему такие переменные, следуя терминологии других языков, называютавтоматическими. (В главе 4 обсуждается класс памятиstatic,который позволяет локальным переменным сохранять свои значения в промежутках между вызовами.)
   Так как автоматические переменные образуются и исчезают одновременно с входом в функцию и выходом из нее, они не сохраняют своих значений от вызова к вызову и должны устанавливаться заново при каждом новом обращении к функции. Если этого не делать, они будут содержать "мусор".
   В качестве альтернативы автоматическим переменным можно определитьвнешниепеременные, к которым разрешается обращаться по их именам из любой функции. (Этот механизм аналогичен области COMMON в Фортране и определениям переменных в самом внешнем блоке в Паскале.) Так как внешние переменные доступны повсеместно, их можно использовать вместо аргументов для связи между функциями по данным. Кроме того, поскольку внешние переменные существуют постоянно, а не возникают и исчезают на период выполнения функции, свои значения они сохраняют и после возврата из функций, их установивших.
   Внешняя переменная должна бытьопределена,причем только один раз, вне текста любой функции; в этом случае ей будет выделена память. Она должна бытьобъявленаво всех функциях, которые хотят ею пользоваться. Объявление содержит сведения о типе переменной. Объявление может быть явным, в виде инструкцииextern,или неявным, когда нужная информация получается из контекста. Чтобы конкретизировать сказанное, перепишем программу печати самой длинной строки с использованиемline,longestиmaxв качестве внешних переменных. Это потребует изменений в вызовах, объявлениях и телах всех трех функций.
   #include‹stdio.h›

   #define MAXLINE 1000 /*максимальный размер вводимой строки */

   int max; /*длина максимальной из просмотренных строк */
   char line[MAXLINE]; /*текущая строка */
   char longest[MAXLINE]; /*самая длинная строка */

   int getline(void);
   void copy(void);

   /*печать самой длинной строки: специализированная версия */
   main()
   {
    int len;
    extern int max;
    extern char longest[];
    max = 0;
    while ((len = getline()) › 0)
    if (len › max) {
     max = len;
     copy();
    }
    if (max › 0) /* была хотя бы одна строка */
     printf("%s", longest);
    return 0;
   }

   /* getline:специализированная версия */
   int getline(void)
   {
    int c, i;
    extern char line[];
    for (i = 0; i ‹ MAXLINE-1 && (c=getchar()) != EOF&& c!= '\n'; ++i)
     line[i] = c;
    if (c == '\n') {
     line[i]= c;
     ++i;
    }
    line[i] = '\0';
    return i;
   }

   /* copy:специализированная версия */
   void copy(void)
   {
    int i;
    extern char line[], longest[];

    i = 0;
    while ((longest[i] = line[i]) != '\0')
     ++i;
   }
   Внешние переменные дляmain, getlineиcopyопределяются в начале нашего примера, где им присваивается тип и выделяется память. Определения внешних переменных синтаксически ничем не отличаются от определения локальных переменных, но поскольку они расположены вне функций, эти переменные считаются внешними. Чтобы функция могла пользоваться внешней переменной, ей нужно прежде всего сообщить имя соответствующей переменной. Это можно сделать, например, задав объявлениеextern,которое по виду отличается от объявления внешней переменной только тем, что оно начинается с ключевого словаextern.
   В некоторых случаях объявлениеexternможно опустить. Если определение внешней переменной в исходном файле расположено выше функции, где она используется, то в объявленииexternнет необходимости. Таким образом, вmain, getlineиcopyобъявленияexternизбыточны. Обычно определения внешних переменных располагают в начале исходного файла, и все объявленияexternдля них опускают.
   Если же программа расположена в нескольких исходных файлах и внешняя переменная определена вфайле1,а используется вфайле2ифайлеЗ,то объявленияexternвфайле2ифайлеЗобязательны, поскольку необходимо указать, что во всех трех файлах функции обращаются к одной и той же внешней переменной. На практике обычно удобно собрать все объявления внешних переменных и функций в отдельный файл, называемыйзаголовочным (header-файлом), и помещать его с помощью#includeв начало каждого исходного файла. В именах header-файлов по общей договоренности используется суффикс.h.В этих файлах, в частности в‹stdio.h›,описываются также функции стандартной библиотеки. Более подробно о заголовочных файлах говорится в главе 4, а применительно к стандартной библиотеке - в главе 7 и приложении B.
   Так как специализированные версии getline и copy не имеют аргументов, на первый взгляд кажется, что логично их прототипы задать в виде getline() и copy(). Но из соображений совместимости со старыми Си-программами стандарт рассматривает пустой список как сигнал к тому, чтобы выключить все проверки на соответствие аргументов. Поэтому, когда нужно сохранить контроль и явно указать отсутствие аргументов, следует пользоваться словомvoid.Мы вернемся к этой проблеме в главе 4.
   Заметим, что по отношению к внешним переменным в этом параграфе мы очень аккуратно используем понятияопределениеиобъявление. "Определение" располагается в месте, где переменная создается и ей отводится память; "объявление" помещается там, где фиксируется природа переменной, но никакой памяти для нее не отводится.
   Следует отметить тенденцию все переменные делать внешними. Дело в том, что, как может показаться на первый взгляд, это приводит к упрощению связей - ведь списки аргументов становятся короче, а переменные доступны везде, где они нужны; однако они оказываются доступными и там, где не нужны. Так что чрезмерный упор на внешние переменные чреват большими опасностями - он приводит к созданию программ, в которых связи по данным не очевидны, поскольку переменные могут неожиданным и даже таинственным способом изменяться. Кроме того, такая программа с трудом поддается модификациям. Вторая версия программы поиска самой длинной строки хуже, чем первая, отчасти по этим причинам, а отчасти из-за нарушения общности двух полезных функций, вызванного тем, что в них вписаны имена конкретных переменных, с которыми они оперируют.
   Итак, мы рассмотрели то, что можно было бы назвать ядром Си. Описанных "кирпичиков" достаточно, чтобы создавать полезные программы значительных размеров, и было бы чудесно, если бы вы, прервав чтение, посвятили этому какое-то время. В следующих упражнениях мы предлагаем вам создать несколько более сложные программы, чем рассмотренные выше.
   Упражнение 1.20.Напишите программу detab, заменяющую символы табуляции во вводимом тексте нужным числом пробелов (до следующего "стопа" табуляции). Предполагается, что "стопы" табуляции расставлены на фиксированном расстоянии друг от друга, скажем, через n позиций. Как лучше задавать n - в виде значения переменной или в виде именованной константы?
   Упражнение 1.21.Напишите программу entab, заменяющую строки из пробелов минимальным числом табуляций и пробелов таким образом, чтобы вид напечатанного текста не изменился. Используйте те же "стопы" табуляции, что и в detab. В случае, когда для выхода на очередной "стоп" годится один пробел, что лучше - пробел или табуляция?
   Упражнение 1.22.Напишите программу, печатающую символы входного потока так, чтобы строки текста не выходили правее n-й позиции. Это значит, что каждая строка, длина которой превышает n, должна печататься с переносом на следующие строки. Место переноса следует " искать" после последнего символа, отличного от символа-разделителя, расположенного левее n-й позиции. Позаботьтесь о том, чтобы ваша программа вела себя разумно в случае очень длинных строк, а также когда до n-й позиции не встречается ни одного символа пробела или табуляции.
   Упражнение 1.23.Напишите программу, убирающую все комментарии из любой Си-программы. Не забудьте должным образом обработать строки символов и строковые константы. Комментарии в Си не могут быть вложены друг в друга.
   Упражнение 1.24.Напишите программу, проверяющую Си-программы на элементарные синтаксические ошибки вроде несбалансированности скобок всех видов. Не забудьте о кавычках (одиночных и двойных), эскейп-последовательностях (\…) и комментариях. (Это сложная программа, если писать ее для общего случая.)
   Глава 2. Типы, операторы и выражения
   Переменные и константы являются основными объектами данных, с которыми имеет дело программа. Переменные перечисляются в объявлениях, где устанавливаются их типы и, возможно, начальные значения. Операции определяют действия, которые совершаются с этими переменными. Выражения комбинируют переменные и константы для полученияновых значений. Тип объекта определяет множество значений, которые этот объект может принимать, и операций, которые над ними, могут выполняться. Названные "кирпичики" и будут предметом обсуждения в этой главе.
   Стандартом ANSI было утверждено значительное число небольших изменений и добавлений к основным типам и выражениям. Любой целочисленный тип теперь может быть со знаком,signed,и без знака,unsigned.Предусмотрен способ записи беззнаковых констант и шестнадцатеричных символьных констант. Операции с плавающей точкой допускаются теперь и с одинарной точностью. Введен типlong double,обеспечивающий повышенную точность. Строковые константы конкатенируются ("склеиваются") теперь во время компиляции. Частью языка стали перечисления (enum),формализующие для типа установку диапазона значений. Объекты для защиты их от каких-либо изменений разрешено помечать какconst.В связи с введением новых типов расширены правила автоматического преобразования из одного арифметического типа в другой.
   2.1Имена переменных
   Хотя мы ничего не говорили об этом в главе 1, но существуют некоторые ограничения на задание имен переменных и именованных констант.
   Имена составляются из букв и цифр; первым символом должна быть буква. Символ подчеркивания "_" считается буквой; его иногда удобно использовать, чтобы улучшить восприятие длинных имен переменных. Не начинайте имена переменных с подчеркивания, так как многие переменные библиотечных программ начинаются именно с этого знака. Большие (прописные) и малые (строчные) буквы различаются, так что x и X - это два разных имени. Обычно в программах на Си малыми буквами набирают переменные, а большими - именованные константы.
   Для внутренних имен значимыми являются первые 31 символ. Для имен функций и внешних переменных число значимых символов может быть меньше 31, так как эти имена обрабатываются ассемблерами и загрузчиками и языком не контролируются. Уникальность внешних имен гарантируется только в пределах 6 символов, набранных безразлично в каком регистре. Ключевые словаif,else,int,floatи т. д. зарезервированы, и их нельзя использовать в качестве имен переменных. Все они набираются на нижнем регистре (т. е. малыми буквами).
   Разумно давать переменным осмысленные имена в соответствии с их назначением, причем такие, чтобы их было трудно спутать друг с другом. Мы предпочитаем короткие имена для локальных переменных, особенно для счетчиков циклов, и более длинные для внешних переменных.
   2.2Типы и размеры данных
   В Си существует всего лишь несколько базовых типов:
   char -единичный байт, который может содержать один символ из допустимого символьного набора;
   int -целое, обычно отображающее естественное представление целых в машине;
   float -число с плавающей точкой одинарной точности;
   double -число с плавающей точкой двойной точности.
   Имеется также несколько квалификаторов, которые можно использовать вместе с указанными базовыми типами. Например, квалификаторыshort (короткий) иlong (длинный) применяются к целым:
   short int sh;
   long int counter;
   В таких объявлениях словоintможно опускать, что обычно и делается. Если только не возникает противоречий со здравым смыслом,short intиlong intдолжны быть разной длины, аintсоответствовать естественному размеру целых на данной машине. Чаще всего для представления целого, описанного с квалификаторомshort,отводится 16 бит, с квалификаторомlong - 32бита, а значению типаint -или 16, или 32 бита. Разработчики компилятора вправе сами выбирать подходящие размеры, сообразуясь с характеристиками своего компьютера и соблюдая следующие ограничения: значения типовshortиintпредставляются по крайней мере 16 битами; типаlong -по крайней мере 32 битами; размерshortне больше размераint,который в свою очередь не больше размераlong.
   Квалификаторыsigned (со знаком) илиunsigned (без знака) можно применять к типуcharи любому целочисленному типу. Значенияunsignedвсегда положительны или равны нулю и подчиняются законам арифметики по модулю 2n,где n - количество бит в представлении типа. Так, если значениюcharотводится 8 битов, тоunsigned charимеет значения в диапазоне от 0 до 255, asigned char -от -128 до 127 (в машине с двоичным дополнительным кодом). Являются ли значения типа простоcharзнаковыми или беззнаковыми, зависит от реализации, но в любом случае коды печатаемых символов положительны.
   Типlong doubleпредназначен для арифметики с плавающей точкой повышенной точности. Как и в случае целых, размеры объектов с плавающей точкой зависят от реализации;float,doubleиlong doubleмогут представляться одним размером, а могут - двумя или тремя разными размерами.
   Именованные константы для всех размеров вместе с другими характеристиками машины и компилятора содержатся в стандартных заголовочных файлах‹limits.h›и‹float.h› (см. приложение B).
   Упражнение 2.1.Напишите программу, которая будет выдавать диапазоны значений типовchar,short,intиlong,описанных какsignedи какunsigned,с помощью печати соответствующих значений из стандартных заголовочных файлов и путем прямого вычисления. Определите диапазоны чисел с плавающей точкой различных типов. Вычислить эти диапазоны сложнее.
   2.3Константы
   Целая константа, например 1234, имеет типint.Константа типаlongзавершается буквойlилиL,например 123456789L: слишком большое целое, которое невозможно представить какint,будет представлено какlong.Беззнаковые константы заканчиваются буквойuилиU,а окончаниеulилиULговорит о том, что тип константы -unsigned long.
   Константы с плавающей точкой имеют десятичную точку (123.4), или экспоненциальную часть (1е-2), или же и то и другое. Если у них нет окончания, считается, что они принадлежат к типуdouble.ОкончаниеfилиFуказывает на типfloat,аlилиL -на типlong double.
   Целое значение помимо десятичного может иметь восьмеричное или шестнадцатеричное представление. Если константа начинается с нуля, то она представлена в восьмеричном виде, если с 0x или с 0X, то - в шестнадцатеричном. Например, десятичное целое 31 можно записать как 037 или как 0X1F. Записи восьмеричной и шестнадцатеричной констант могут завершаться буквойL (для указания на типlong)иU (если нужно показать, что константа беззнаковая). Например, константа 0XFUL имеет значение 15 и типunsigned long.
   Символьная константаесть целое, записанное в виде символа, обрамленного одиночными кавычками, например 'x'. Значением символьной константы является числовой код символа из набора символов на данной машине. Например, символьная константа '0' в кодировке ASCII имеет значение 48, которое никакого отношения к числовому значению 0 не имеет. Когда мы пишем '0', а не какое-то значение (например 46), зависящее от способа кодировки, мы делаем программу независимой от частного значения кода, к тому же она и легче читается. Символьные константы могут участвовать в операциях над числами точно так же, как и любые другие целые, хотя чаще они используются для сравнения с другими символами.
   Некоторые символы в символьных и строковых константах записываются с помощью эскейп-последовательностей, например \n (символ новой строки); такие последовательности изображаются двумя символами, но обозначают один. Кроме того, произвольный восьмеричный код можно задать в виде
   '\ooo'
   где ооо - одна, две или три восьмеричные цифры (0:7) или
   '\xhh'
   где hh - одна, две или более шестнадцатеричные цифры (0…9, а…f, A…F). Таким образом, мы могли бы написать
   #define VTAB '013' /*вертикальная табуляция в ASCII */
   #define BELL '\007' /*звонок в ASCII */
   или в шестнадцатеричном виде:
   #define VTAB '\xb' /*вертикальная табуляций в ASCII */
   #define BELL '\x7' /*звонок в ASCII */
   Полный набор эскейп-последовательностей таков:
   \асигнал-звонок
   \bвозврат-на-шаг (забой)
   \fперевод-страницы
   \nновая-строка
   \rвозврат-каретки
   \tгоризонтальная-табуляция
   \vвертикальная-табуляция
   \\обратная наклонная черта
   \?знак вопроса
   \'одиночная кавычка
   \"двойная кавычка
   \oooвосьмеричный код
   \xhhшестнадцатеричный код
   Символьная константа '\0' - это символ с нулевым значением, так называемый символnull.Вместо просто 0 часто используют запись '\0', чтобы подчеркнуть символьную природу выражения, хотя и в том и другом случае запись обозначает нуль.
   Константные выражения - это выражения, оперирующие только с константами. Такие выражения вычисляются во время компиляции, а не во время выполнения, и поэтому их можно использовать в любом месте, где допустимы константы, как, например, в
   #define MAXLINE 1000
   char line[MAXLINE+1];
   или в
   #define LEAP 1 /* in leap years -в високосные годы */
   int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];
   Строковая константа,илистроковый литерал, -это нуль или более символов, заключенных в двойные кавычки, как, например,
   "Я строковая константа"
   или
   "" /*пустая строка */
   Кавычки не входят в строку, а служат только ее ограничителями. Так же, как и в символьные константы, в строки можно включать эскейп-последовательности; \", например, представляет собой двойную кавычку. Строковые константы можно конкатенировать ("склеивать") во время компиляции; например, запись двух строк
   "Здравствуй," " мир!"
   эквивалентна записи одной следующей строки:
   "Здравствуй, мир!"
   Указанное свойство позволяет разбивать длинные строки на части и располагать эти части на отдельных строчках.
   Фактически строковая константа - это массив символов. Во внутреннем представлении строки в конце обязательно присутствует нулевой символ '\0', поэтому памяти для строки требуется на один байт больше, чем число символов, расположенных между двойными кавычками. Это означает, что на длину задаваемой строки нет ограничения, но чтобы определить ее длину, требуется просмотреть всю строку. Функцияstrlen(s)вычисляет длину строки s без учета завершающего ее символа '\0'. Ниже приводится наша версия этой функции:
   /* strlen:возвращает длину строки s */
   int strlen(char s[])
   {
    int i;
    i = 0;
    while (s[i] != '\0')
     ++i;
    return i;
   }
   Функцияstrlenи некоторые другие, применяемые к строкам, описаны в стандартном заголовочном файле‹string.h›.
   Будьте внимательны и помните, что символьная константа и строка, содержащая один символ, не одно и то же: 'x' не то же самое, что "x". Запись 'x' обозначает целое значение, равное коду буквы x из стандартного символьного набора, а запись "x" - массив символов, который содержит один символ (букву x) и '\0'.
   В Си имеется еще один вид константы - константа перечисления. Перечисление - это список целых констант, как, например, в
   enum boolean {NO, YES};
   Первое имя в enum имеет значение 0, следующее - 1 и т.д. (если для значений констант не было явных спецификаций). Если не все значения специфицированы, то они продолжают прогрессию, начиная от последнего специфицированного значения, как в следующих двух примерах:
   enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t',
                           NEWLINE = '\n', VTAB = '\v', RETURN = '\r' };
   enum months { JAN = 1, FEB, MAR, APR, MAY, JUN,
                           JUL, AUG, SEP, OCT, NOV, DEC };
                           /* FEB есть 2, MAR есть 3 и т.д. */
   Имена в различных перечислениях должны отличаться друг от друга. Значения внутри одного перечисления могут совпадать.
   Средствоenumобеспечивает удобный способ присвоить константам имена, причем в отличие от#defineзначения констант при этом способе могут генерироваться автоматически. Хотя разрешается объявлять переменные типаenum,однако компилятор не обязан контролировать, входят ли присваиваемые этим переменным значения в их тип. Но сама возможность такой проверки часто делает enum лучше, чем #define. Кроме того, отладчик получает возможность печатать значения переменных типа enum в символьном виде.
   2.4Объявления
   Все переменные должны быть объявлены раньше, чем будут использоваться, при этом некоторые объявления могут быть получены неявно - из контекста. Объявление специфицирует тип и содержит список из одной или нескольких переменных этого типа, как, например, в
   int lower, upper, step;
   charс, line[1000];
   Переменные можно распределять по объявлениям произвольным образом, так что указанные выше списки можно записать и в следующем виде:
   int lower;
   int upper;
   int step;
   char c;
   char line[1000];
   Последняя форма записи занимает больше места, тем не менее она лучше, поскольку позволяет добавлять к каждому объявлению комментарий. Кроме того, она более удобна для последующих модификаций.
   В своем объявлении переменная может быть инициализирована, как, например:
   char esc = '\\';
   int i = 0;
   int limit = MAXLINE+1;
   float eps = 1.0e-5;
   Инициализация неавтоматической переменной осуществляется только один раз - перед тем, как программа начнет выполняться, при этом начальное значение должно быть константным выражением. Явно инициализируемая автоматическая переменная получает начальное значение каждый раз при входе в функцию или блок, ее начальным значением может быть любое выражение. Внешние и статические переменные по умолчанию получают нулевые значения. Автоматические переменные, явным образом не инициализированные, содержат неопределенные значения ("мусор").
   К любой переменной в объявлении может быть применен квалификаторconstдля указания того, что ее значение далее не будет изменяться.
   const doubleе = 2.71828182845905;
   const char msg[] = "предупреждение: ";
   Применительно к массиву квалификаторconstуказывает на то, что ни один из его элементов не будет меняться. Указаниеconstможно также применять к аргументу- массиву, чтобы сообщить, что функция не изменяет этот массив:
   int strlen(const char[]);
   Реакция на попытку изменить переменную, помеченную квалификаторомconstзависит от реализации компилятора.
   2.5Арифметические операторы
   Бинарными (т. е. с двумя операндами) арифметическими операторами являются+,-,*,/,а также оператор деления по модулю%.Деление целых сопровождается отбрасыванием дробной части, какой бы она ни была. Выражение
   x % y
   дает остаток от деления x на y и, следовательно, нуль, если x делится на y нацело. Например, год является високосным, если он делится на 4, но не делится на 100. Кроме того, год является високосным, если он делится на 400. Следовательно,
   if ((year % 4 == 0&& year % 100 !=0 || year % 400 == 0)
    printf("%d високосный год\n", year);
   else
    printf("%d невисокосный год\n", year);
   Оператор%к операндам типовfloatиdoubleне применяется. В какую сторону (в сторону увеличения или уменьшения числа) будет усечена дробная часть при выполнении/и каким будет знак результата операции%с отрицательными операндами, зависит от машины.
   Бинарные операторы+и-имеют одинаковый приоритет, который ниже приоритета операторов*,/и%,который в свою очередь ниже приоритета унарных операторов+и-.Арифметические операции одного приоритетного уровня выполняются слева направо.
   В конце этой главы (параграф 2.12) приводится таблица 2.1,в которой представлены приоритеты всех операторов и очередность их выполнения.
   2.6Операторы отношения и логические операторы
   Операторами отношения являются
   ›
   ›=
   ‹
   ‹=
   Все они имеют одинаковый приоритет. Сразу за ними идет приоритет операторов сравнения на равенство:
   == 
   !=
   Операторы отношения имеют более низкий приоритет, чем арифметические, поэтому выражение вроде i ‹ lim-1 будет выполняться так же, как i ‹ (lim-1), т.е. как мы и ожидаем.
   Более интересны логические операторы&&и||.Выражения, между которыми стоят операторы&&или ||, вычисляются слева направо. Вычисление прекращается, как только становится известна истинность или ложность результата. Многие Си-программы опираются на это свойство, как, например, цикл из функции getline, которую мы приводили в главе 1:
   for (i = 0; i‹ lim-1&& (с = getchar()) != EOF&&с != '\n'; ++i)
    s[i] = c;
   Прежде чем читать очередной символ, нужно проверить, есть ли для него место в массиве s, иначе говоря, сначала необходимо проверить соблюдение условия i ‹ lim-1. Если это условие не выполняется, мы не должны продолжать вычисление, в частности читать следующий символ. Так же было бы неправильным сравнивать c и EOF до обращения к getchar; следовательно, и вызов getchar, и присваивание должны выполняться перед указанной проверкой.
   Приоритет оператора&&выше, чем таковой оператора||,однако их приоритеты ниже, чем приоритет операторов отношения и равенства. Из сказанного следует, что выражение вида
   i‹ lim-1&& (с = getchar()) != '\n'&&с != EOF
   не нуждается в дополнительных скобках. Но, так как приоритет!=выше, чем приоритет присваивания, в
   (с = getchar()) != '\n'
   скобки необходимы, чтобы сначала выполнить присваивание, а затем сравнение с '\n'.
   По определению численным результатом вычисления выражения отношения или логического выражения является 1, если оно истинно, и 0, если оно ложно.
   Унарный оператор!преобразует ненулевой операнд в 0, а нуль в 1. Обычно оператор!используют в конструкциях вида
   if (!valid)
   что эквивалентно
   if (valid == 0)
   Трудно сказать, какая из форм записи лучше. Конструкция вида !valid хорошо читается ("если не правильно"), но в более сложных выражениях может оказаться, что ее не так-то легко понять.
   Упражнение 2.2.Напишите цикл, эквивалентный приведенному выше or-циклу, не пользуясь операторами&&и ||.
   2.7Преобразования типов
   Если операнды оператора принадлежат к разным типам, то они приводятся к некоторому общему типу. Приведение выполняется в соответствии с небольшим числом правил. Обычно автоматически производятся лишь те преобразования, которые без какой-либо потери информации превращают операнды с меньшим диапазоном значений в операнды с большим диапазоном, как, например, преобразование целого в число с плавающей точкой в выражении вроде f+i. Выражения, не имеющие смысла, например число с плавающей точкой в роли индекса, не допускаются. Выражения, в которых могла бы теряться информация (скажем, при присваивании длинных целых переменным более коротких типов или при присваивании значений с плавающей точкой целым переменным), могут повлечь за собой предупреждение, но они допустимы.
   Значения типаchar -это просто малые целые, и их можно свободно использовать в арифметических выражениях, что значительно облегчает всевозможные манипуляции с символами. В качестве примера приведем простенькую реализацию функции atoi, преобразующей последовательность цифр в ее числовой эквивалент.
   /* atoi:преобразование s в целое */
   int atoi(char s[])
   {
    int i, n;
    n = 0;
    for (i = 0; s[i] ›= '0'&& s[i]‹= '9'; ++i)
     n = 10 * n + (s[i] - '0');
    return n;
   }
   Как мы уже говорили в главе 1, выражение
   s[i] -'0'
   дает числовое значение символа, хранящегося в s[i], так как значения '0', '1' и пр. образуют непрерывную возрастающую последовательность.
   Другой пример приведенияcharкintсвязан с функцией lower, которая одиночный символ из набора ASCII, если он является заглавной буквой, превращает в строчную. Если же символ не является заглавной буквой,lower его не изменяет.
   /* lower:преобразование c в строчную, только для ASCII */
   int lower(int c)
   {
    if (c ›= 'A'&& c‹='Z')
    return c +'a'-'A';
   else
    return c;
   }
   В случае ASCII эта программа будет работать правильно, потому что между одноименными буквами верхнего и нижнего регистров - одинаковое расстояние (если их рассматривать как числовые значения). Кроме того, латинский алфавит - плотный, т. е. между буквами A и Z расположены только буквы. Для набора EBCDIC последнее условие не выполняется, и поэтому наша программа в этом случае будет преобразовывать не только буквы.
   Стандартный заголовочный файл‹ctype.h›,описанный в приложении B, определяет семейство функций, которые позволяют проверять и преобразовывать символы независимо от символьного набора. Например, функцияtolower(c) возвращает букву c в коде нижнего регистра, если она была в коде верхнего регистра, поэтому tolower - универсальная замена функции lower, рассмотренной выше. Аналогично проверку
   c›= '0'&& c‹= '9'
   можно заменить на isdigit(c)
   Далее мы будем пользоваться функциями из ‹ctype.h›.
   Существует одна тонкость, касающаяся преобразования символов в целые числа: язык не определяет, являются ли переменные типаcharзнаковыми или беззнаковыми. При преобразованииcharвintможет ли когда- нибудь получиться отрицательное целое? На машинах с разной архитектурой ответы могут отличаться. На некоторых машинах значение типаcharс единичным старшим битом будет превращено в отрицательное целое (посредством "распространения знака"). На других - преобразованиеcharвintосуществляется добавлением нулей слева, и, таким образом, получаемое значение всегда положительно.
   Гарантируется, что любой символ из стандартного набора печатаемых символов никогда не будет отрицательным числом, поэтому в выражениях такие символы всегда являются положительными операндами. Но произвольный восьмибитовый код в переменной типаcharна одних машинах может быть отрицательным числом, а на других - положительным. Для совместимости переменные типаchar,в которых хранятся несимвольные данные, следует специфицировать явно какsignedилиunsigned.
   Отношения вроде i › j и логические выражения, перемежаемые операторамиamp;&и||,определяют выражение-условие, которое имеет значение 1, если оно истинно, и 0, если ложно. Так, присваивание
   d = c›= '0'&& c‹= '9'
   установит d в значение 1, если c есть цифра, и 0 в противном случае. Однако функции, подобные isdigit, в качестве истины могут выдавать любое ненулевое значение. В местах проверок внутри if, while, for и пр. "истина" просто означает "не нуль".
   Неявные арифметические преобразования, как правило, осуществляются естественным образом. В общем случае, когда оператор вроде + или * с двумя операндами (бинарный оператор) имеет разнотипные операнды, прежде чем операция начнет выполняться, "низший" тип повышается до "высшего". Результат будет иметь высший тип. В параграфе 6 приложения A правила преобразования сформулированы точно. Если же в выражении нет беззнаковых операндов, можно удовлетвориться следующим набором неформальных правил:
   · Если какой-либо из операндов принадлежит типуlong double,то и другой приводится кlong double.
   · В противном случае, если какой-либо из операндов принадлежит типуdouble,то и другой приводится кdouble.
   · В противном случае, если какой-либо из операндов принадлежит типуfloat,то и другой приводится кfloat.
   · В противном случае операнды типовcharиshortприводятся кint.
   · И наконец, если один из операндов типаlong,то и другой приводится кlong.
   Заметим, что операнды типаfloatне приводятся автоматически к типуdouble;в этом данная версия языка отличается от первоначальной. Вообще говоря, математические функции, аналогичные собранным в библиотеке‹math.h›,базируются на вычислениях с двойной точностью. В основномfloatиспользуется для экономии памяти на больших массивах и не так часто - для ускорения счета на тех машинах, где арифметика с двойной точностью слишком дорога с точки зрения расхода времени и памяти.
   Правила преобразования усложняются с появлением операндов типаunsigned.Проблема в том, что сравнения знаковых и беззнаковых значений зависят от размеров целочисленных типов, которые на разных машинах могут отличаться. Предположим, что значение типаintзанимает 16 битов, а значение типаlong - 32бита. Тогда -1L ‹ 1U, поскольку 1U принадлежит типуunsigned intи повышается до типаsigned long.Но -1L ›1UL, так как -1L повышается до типаunsigned longи воспринимается как большое положительное число.
   Преобразования имеют место и при присвоениях: значение правой части присвоения приводится к типу левой части, который и является типом результата.
   Типcharпревращается вintпутем распространения знака или другим описанным выше способом.
   Типlong intпреобразуются вshort intили в значения типаcharпутем отбрасывания старших разрядов. Так, в
   int i;
   char c;
   i = c;
   c = i;
   значение c не изменится. Это справедливо независимо от того, распространяется знак при переводеcharвintили нет. Однако, если изменить очередность присваиваний, возможна потеря информации.
   Если x принадлежит типуfloat,а i - типуint,то и x=i, и i=z вызовут преобразования, причем переводfloatвintсопровождается отбрасыванием дробной части. Еслиdoubleпереводится воfloat,то значение либо округляется, либо обрезается; это зависит от реализации.
   Так как аргумент в вызове функции есть выражение, при передаче его функции также возможно преобразование типа. При отсутствии прототипа (функции аргументы тинаcharиshortпереводятся вint, afloat -вdouble.Вот почему мы объявляли аргументы типаintилиdoubleдаже тогда, когда в вызове функции использовали аргументы типаcharилиfloat.
   И наконец, для любого выражения можно явно ("насильно") указать преобразование его типа, используя унарный оператор, называемый приведением. Конструкция вида
   (имя-типа)выражение
   приводит выражение к указанному в скобках типу по перечисленным выше правилам. Смысл операции приведения можно представить себе так: выражение как бы присваивается некоторой переменной указанного типа, и эта переменная используется вместо всей конструкции. Например, библиотечная функция sqrt рассчитана на аргумент типаdoubleи выдает чепуху, если ей подсунуть что-нибудь другое (sqrt описана в). Поэтому, если n имеет целочисленный тип, мы можем написать
   sqrt((double) n)
   и перед тем, как значение n будет передано функции, оно будет переведено вdouble.Заметим, что операция приведения всего лишь вырабатывает значение n указанного типа, но саму переменную n не затрагивает. Приоритет оператора приведения столь же высок, как и любого унарного оператора, что зафиксировано в таблице, помещенной в конце этой главы.
   В том случае, когда аргументы описаны в прототипе функции, как тому и следует быть, при вызове функции нужное преобразование выполняется автоматически. Так, при наличии прототипа функции sqrt:
   double sqrt(double);
   перед обращением к sqrt в присваивании
   root2 = sqrt(2);
   целое 2 будет переведено в значениеdouble 2.0автоматически без явного указания операции приведения.
   Операцию приведения проиллюстрируем на переносимой версии генератора псевдослучайных чисел и функции, инициализирующей "семя". И генератор, и функция входят в стандартную библиотеку.
   unsigned long int next = 1;
   /* rand:возвращает псевдослучайное целое 0…32767 */
   int rand(void)
   {
    next = next * 1103515245 + 12345;
    return (unsigned int)(next/65536) % 32768;
   }

   /* srand:устанавливает "семя" для rand() */
   void srand(unsigned int seed)
   {
    next = seed;
   }
   Упражнение 2.3.Напишите функцию htol(s), которая преобразует последовательность шестнадцатеричных цифр, начинающуюся с 0x или 0X, в соответствующее целое. Шестнадцатеричными цифрами являются символы 0…9, a…f, А…F.
   2.8Операторы инкремента и декремента
   В Си есть два необычных оператора, предназначенных для увеличения и уменьшения переменных. Оператор инкремента++добавляет 1 к своему операнду, а оператор декремента--вычитает 1. Мы уже неоднократно использовали ++ для наращивания значения переменных, как, например, в
   if (c == '\n')
    ++nl;
   Необычность операторов ++ и -- в том, что их можно использовать и как префиксные (помещая перед переменной: ++n), и как постфиксные (помещая после переменной: n++) операторы. В обоих случаях значение n увеличивается на 1, но выражение ++n увеличивает n до того, как его значение будет использовано, а n++ - после того. Предположим, что n содержит 5, тогда
   x = n++;
   установит x в значение 5, а
   x = ++n;
   установит x в значение 6. И в том и другом случае n станет равным 6. Операторы инкремента и декремента можно применять только к переменным. Выражения вроде (i+j)++ недопустимы.
   Если требуется только увеличить или уменьшить значение переменной (но не получить ее значение), как например
   if (c=='\n')
    nl++;
   то безразлично, какой оператор выбрать - префиксный или постфиксный. Но существуют ситуации, когда требуется оператор вполне определенного типа. Например, рассмотрим функцию squeeze(s, c), которая удаляет из строки s все символы, совпадающие с c:
   /* squeeze:удаляет все c из s*/
   void squeeze(char s[], intс)
   {
    int i, j;
    for (i = j =0; s[i] != '\0'; i++)
    if (s[i] != c)
     s[j++] = s[i];
    s[i] = '\0';
   }
   Каждый раз, когда встречается символ, отличный от c, он копируется в текущую j-ю позицию, и только после этого переменная j увеличивается на 1, подготавливаясь таким образом к приему следующего символа. Это в точности совпадает со следующими действиями:
   if (s[i] !=с)
   {
    s[j] = s[i];
    j++;
   }
   Другой пример - функция getline, которая нам известна по главе 1. Приведенную там запись
   if (c =='\n') {
    s[i] = c;
    ++i;
   }
   можно переписать более компактно:
   if (с == '\n')
    s[i++] = с;
   В качестве третьего примера рассмотрим стандартную функцию strcat(s,t), которая строку t помещает в конец строки s. Предполагается, что в s достаточно места, чтобы разместить там суммарную строку. Мы написали strcat так, что она не возвращает никакого результата. На самом деле библиотечная strcat возвращает указатель на результирующую строку.
   /* strcat:помещает t в конец s; s достаточно велика */
   void strcat (char s[], char t[])
   {
    int i, j;
    i = j = 0;
    while (s[i] != '\0') /* находим конец s */
     i++;
    while ((s[i++] = t[j++]) != '\0') /* копируем t */
    ;
   }
   При копировании очередного символа из t в s постфиксный оператор ++ применяется и к i, и к j, чтобы на каждом шаге цикла переменные i и j правильно отслеживали позиции перемещаемого символа.
   Упражнение 2.4.Напишите версию функции squeeze(s1,s2), которая удаляет из s1 все символы, встречающиеся в строке s2.
   Упражнение 2.5.Напишите функцию any(s1,s2), которая возвращает либо ту позицию в s1, где стоит первый символ, совпавший с любым из символов в s2, либо -1 (если ни один символ из s1 не совпадает с символами из s2). (Стандартная библиотечная функция strpbrk делает то же самое, но выдает не номер позиции символа, а указатель на символ.)
   2.9Побитовые операторы
   В Си имеются шесть операторов для манипулирования с битами. Их можно применять только к целочисленным операндам, т. е. к операндам типовchar,short,intи long, знаковым и беззнаковым.
   & - побитовое И
   | -побитовое ИЛИ
   ^ -побитовое исключающее ИЛИ.
   ‹‹ - сдвиг влево.
   ›› - сдвиг вправо.
   ~ -побитовое отрицание (унарный).
   Оператор & (побитовое И) часто используется для обнуления некоторой группы разрядов. Например
   n = n& 0177;
   обнуляет в n все разряды, кроме младших семи.
   Оператор| (побитовое ИЛИ) применяют для установки разрядов; так,
   x = x | SET_ON;
   устанавливает единицы в тех разрядах x, которым соответствуют единицы в SET_ON.
   Оператор^ (побитовое исключающее ИЛИ) в каждом разряде установит 1, если соответствующие разряды операндов имеют различные значения, и 0, когда они совпадают.
   Поразрядные операторы &и|следует отличать от логических операторов&&и||,которые при вычислении слева направо дают значение истинности. Например, если x равно 1, а y равно 2, то x& yдаст нуль, а x&& y -единицу.
   Операторы‹‹и››сдвигают влево или вправо свой левый операнд на число битовых позиций, задаваемое правым операндом, который должен быть неотрицательным. Так, x ‹‹ 2 сдвигает значение x влево на 2 позиции, заполняя освобождающиеся биты нулями, что эквивалентно умножению x на 4. Сдвиг вправо беззнаковой величины всегда сопровождается заполнением освобождающихся разрядов нулями. Сдвиг вправо знаковой величины на одних машинах происходит с распространением знака ("арифметический сдвиг"), на других - с заполнением освобождающихся разрядов нулями ("логический сдвиг").
   Унарный оператор ~ поразрядно "обращает" целое т. е. превращает каждый единичный бит в нулевой и наоборот. Например
   x = x& ~077
   обнуляет в x последние 6 разрядов. Заметим, что запись x& ~077не зависит от длины слова, и, следовательно, она лучше, чем x& 0177700,поскольку последняя подразумевает, что x занимает 16 битов. Не зависимая от машины форма записи ~077 не потребует дополнительных затрат при счете, так как ~077 - константное выражение, которое будет вычислено во время компиляции.
   Для иллюстрации некоторых побитовых операций рассмотрим функцию getbits(x, p, n), которая формирует поле в n битов, вырезанных из x, начиная с позиции p, прижимая его к правому краю. Предполагается, что 0-й бит - крайний правый бит, а n и p - осмысленные положительные числа. Например, getbits(x,4,3) вернет в качестве результата 4, 3 и 2-й биты значения x, прижимая их к правому краю. Вот эта функция:
   /* getbits:получает n бит, начиная с p-й позиции */
   unsigned getbits(unsigned x, int p, int n)
   {
    return (x ›› (p+1-n))& ~(~0‹‹ n);
   }
   Выражение x ›› (р+1-n) сдвигает нужное нам поле к правому краю. Константа ~0 состоит из одних единиц, и ее сдвиг влево на n бит (~0 ‹‹ n) приведет к тому, что правый край этой константы займут n нулевых разрядов. Еще одна операция побитовой инверсии ~ позволяет получить справа n единиц.
   Упражнение 2.6.Напишите функцию setbits(x, p, n, y), возвращающую значение x, в котором n битов, начиная с p-й позиции, заменены на n правых разрядов из y (остальные биты не изменяются).
   Упражнение 2.7.Напишите функцию invert(x, p, n), возвращающую значение x с инвертированными n битами, начиная с позиции p (остальные биты не изменяются).
   Упражнение 2.8.Напишите функцию rightrot (x, n), которая циклически сдвигает x вправо на n разрядов.
   2.10Операторы и выражения присваивания
   Выражение
   i = i + 2;
   в котором стоящая слева переменная повторяется и справа, можно написать в сжатом виде:
   i += 2;
   Оператор+=,как и=,называется оператором присваивания.
   Большинству бинарных операторов (аналогичных + и имеющих левый и правый операнды) соответствуют операторы присваиванияop=,где op - один из операторов
   +
   - 
   *
   /
   %
   ‹‹
   ››
   &
   ^
   |
   Есливыр1ивыр2 -выражения, то
   выр1 op=выр2
   Эквивалентно
   выр1 = (выр1) op (выр2)
   с той лишь разницей, что выр1вычисляется только один раз. Обратите внимание на скобки вокруг выр2:
   x *= y + 1
   эквивалентно
   x = x * (y + 1)
   но не
   x=x*y+1
   В качестве примера приведем функцию bitcount, подсчитывающую число единичных битов в своем аргументе целочисленного типа.
   /* bitcount:подсчет единиц в х */
   int bitcount(unsignedх)
   {
    int b;
    for (b = 0; х != 0; x ››= 1)
     if (x& 01)
      b++;
    return b;
   }
   Независимо от машины, на которой будет работать эта программа, объявление аргумента x как unsigned гарантирует, что при правом сдвиге освобождающиеся биты будут заполняться нулями, а не знаковым битом.
   Помимо краткости операторы присваивания обладают тем преимуществом, что они более соответствуют тому, как человек мыслит. Мы говорим "прибавить 2 к i" или "увеличить i на 2", а не "взять i, добавить 2 и затем вернуть результат в i", так что выражение i+=2 лучше, чем i=i+2. Кроме того, в сложных выражениях вроде
   yyval[yypv[p3+p4] + yypv[p1+p2]]+= 2
   благодаря оператору присваивания += запись становится более легкой для понимания, так как читателю при такой записи не потребуется старательно сравнивать два длинных выражения, совпадают ли они, или выяснять, почему они не совпадают. Следует иметь в виду и то, что подобные операторы присваивания могут помочь компилятору сгенерировать более эффективный код.
   Мы уже видели, что присваивание вырабатывает значение и может применяться внутри выражения: вот самый расхожий пример:
   while ((с = getchar()) != EOF)
   В выражениях встречаются и другие операторы присваивания (+=, -= и т. д.), хотя и реже. Типом и значением любого выражения присваивания являются тип и значение его левого операнда после завершения присваивания.
   Упражнение 2.9.Применительно к числам, в представлении которых использован дополнительный код, выражение x&= (x-1)уничтожает самую правую 1 в x. Объясните, почему. Используйте это наблюдение при написании более быстрого варианта функции bitcount.
   2.11Условные выражения
   Инструкции
   if (a› b)
    z = a;
   else
    z = b;
   пересылают в z большее из двух значений a и b. Условное выражение, написанное с помощью тернарного (т. е. имеющего три операнда) оператора "?: ", представляет собой другой способ записи этой и подобных ей конструкций. В выражении
   выр1?выр2:выр3
   первым вычисляется выражение выр1.Если его значение не нуль (истина), то вычисляется выражение выр2,и значение этого выражения становится значением всего условного выражения. В противном случае вычисляется выражение выр3и его значение становится значением условного выражения. Следует отметить, что из выражений выр2и выр3вычисляется только одно из них. Таким образом, чтобы установить в z большее из a и b, можно написать
   z = (a› b) ? a: b; /* z = max(a, b) */
   Следует заметить, что условное выражение и в самом деле является выражением, и его можно использовать в любом месте, где допускается выражение. Если выр2и выр3принадлежат разным типам, то тип результата определяется правилами преобразования, о которых шла речь в этой главе ранее. Например, если f имеет типfloat,а n - типint,то типом выражения
   (n› 0) ? f : n
   будетfloatвне зависимости от того, положительно значение n или нет.
   Заключать в скобки первое выражение в условном выражении не обязательно, так как приоритет?:очень низкий (более низкий приоритет имеет только присваивание), однако мы рекомендуем всегда это делать, поскольку благодаря обрамляющим скобкам условие в выражении лучше воспринимается.
   Условное выражение часто позволяет сократить программу. В качестве примера приведем цикл, обеспечивающий печать n элементов массива по 10 на каждой строке с одним пробелом между колонками; каждая строка цикла, включая последнюю, заканчивается символом новой строки:
   for (i = 0; i‹ n; i++)
    printf("%6d %c", a[i], (i%10 == 9 || i == n-1) ? '\n' : ' ');
   Символ новой строки посылается после каждого десятого и после n-го элемента. За всеми другими элементами следует пробел. Эта программа выглядит довольно замысловато, зато она более компактна, чем эквивалентная программа с использованием if-else. Вот еще один хороший пример:
   printf("Вы имеете %d элемент%s: \n", n, (n%10 == 1&& n%100 != 11)?
    " ": ((n%100 ‹ 10 || n%100 › 20)&& n%10›= 2&& n%10‹= 4) ?
    "a": "ов");
   Упражнение 2.10.Напишите функцию lower, которая переводит большие буквы в малые, используя условное выражение (а не конструкцию if-else).
   2.12Приоритет и очередность вычислений
   В таблице 2.1 показаны приоритеты и очередность вычислений всех операторов, включая и те, которые мы еще не рассматривали. Операторы, перечисленные на одной строке, имеют одинаковый приоритет: строки упорядочены по убыванию приоритетов; так, например, *, / и % имеют одинаковый приоритет, который выше, чем приоритет бинарных + и -. "Оператор" () относится к вызову функции. Операторы -› и . (точка) обеспечивают доступ к элементам структур; о них пойдет речь в главе 6, там же будет рассмотрен и оператор sizeof (размер объекта). Операторы * (косвенное обращение по указателю) и& (получение адреса объекта) обсуждаются в главе 5. Оператор "запятая" будет рассмотрен в главе 3.
   Таблица 2.1. Приоритеты и очередность вычислений операторовОператорыВыполняются() [] -› .слева направо! ~ ++ -- + - * & (type) sizeofсправа налево* / %слева направо+ -слева направо‹‹ ››слева направо‹ ‹= › ›=слева направо==  !=слева направо& слева направо^слева направо|слева направо&&слева направо||слева направо?:справа налево= += -= *= /= %=&= ^= |=‹‹= ››=справа налево,слева направо
   Примечание. Унарные операторы+,-,*и &имеют более высокий приоритет, чем те же бинарные операторы.
   Заметим, что приоритеты побитовых операторов&,^и|ниже, чем приоритет ==и!=,из-за чего в побитовых проверках, таких как
   if ((x& MASK) == 0)…
   чтобы получить правильный результат, приходится использовать скобки. Си подобно многим языкам не фиксирует очередность вычисления операндов оператора (за исключением&&,||,?:и,).Например, в инструкции вида
   x = f() + g();
   fможет быть вычислена раньше g или наоборот. Из этого следует, что если одна из функций изменяет значение переменной, от которой зависит другая функция, то помещаемый в x результат может зависеть от очередности вычислений. Чтобы обеспечить нужную последовательность вычислений, промежуточные результаты можно запоминать во временных переменных.
   Очередность вычисления аргументов функции также не определена, поэтому на разных компиляторах
   printf("%d %d\n", ++n, power(2, n)); /*НЕВЕРНО*/
   может давать несовпадающие результаты. Результат вызова функции зависит от того, когда компилятор сгенерирует команды увеличения n - до или после обращения к power. Чтобы обезопасить себя от возможного побочного эффекта, достаточно написать
   ++n;
   printf("%d %d\n", n, power(2, n));
   Обращения к функциям, вложенные присвоения, инкрементные и декрементные операторы дают "побочный эффект", проявляющийся в том, что при вычислении выражения значения некоторых переменных изменяются. В любом выражении с побочным эффектом может быть скрыта трудно просматриваемая зависимость результата выражения от очередности изменения значений переменных, входящих в выражение. В такой, например, типично неприятной ситуации
   a[i] = i++; /* I.B.: doubtful example */
   возникает вопрос: массив a индексируется старым или измененным значением i? Компиляторы могут по-разному генерировать программу, что проявится в интерпретации данной записи. Стандарт сознательно устроен так, что большинство подобных вопросов оставлено на усмотрение компиляторов, так как лучший порядок вычислений определяется архитектурой машины. Стандартом только гарантируется, что все побочные эффекты при вычислении аргументов проявятся перед входом в функцию. Правда, в примере с printf это нам не поможет.
   Мораль такова: писать программы, зависящие от очередности вычислений, - плохая практика, какой бы язык вы ни использовали. Естественно, надо знать, чего следует избегать, но если вы не знаете, как образуются побочные эффекты на разных машинах, то лучше и не рассчитывать выиграть на особенностях частной реализации.
   Глава 3. Управление
   Порядок, в котором выполняются вычисления, определяется инструкциями управления. Мы уже встречались с наиболее распространенными управляющими конструкциями такого рода в предыдущих примерах; здесь мы завершим их список и более точно определим рассмотренные ранее.
   3.1Инструкции и блоки
   Выражение, скажемx = 0,илиi++,илиprintf(:),становитсяинструкцией,если в конце его поставить точку с запятой, например:
   x = 0;
   i++;
   printf(…);
   В Си точка с запятой является заключающим символом инструкции, а не разделителем, как в языке Паскаль.
   Фигурные скобки{и}используются для объединения объявлений и инструкций всоставную инструкцию,илиблок,чтобы с точки зрения синтаксиса эта новая конструкция воспринималась как одна инструкция. Фигурные скобки, обрамляющие группу инструкций, образующих тело функции, - это один пример; второй пример - это скобки, объединяющие инструкции, помещенные послеif,else,whileилиfor. (Переменные могут быть объявлены внутрилюбогоблока, об этом разговор пойдет в главе 4.) После правой закрывающей фигурной скобки в конце блока точка с запятой не ставится.
   3.2Конструкция if-else
   Инструкцияif-elseиспользуется для принятия решения. Формально ее синтаксисом является:
   if (выражение)
    инструкция1
   else
    инструкция2
   причемelse-часть может и отсутствовать. Сначала вычисляется выражение, и, если оно истинно (т. е. отлично от нуля), выполняетсяинструкция1.Если выражение ложно (т. е. его значение равно нулю) и существуетelse-часть, то выполняетсяинструкция2.
   Так какifпросто проверяет числовое значение выражения, условие иногда можно записывать в сокращенном виде. Так, запись
   if (выражение)
   короче, чем
   if (выражение != 0)
   Иногда такие сокращения естественны и ясны, в других случаях, наоборот, затрудняют понимание программы.
   Отсутствиеelse-части в одной из вложенных друг в другаif-конструкций может привести к неоднозначному толкованию записи. Эту неоднозначность разрешают тем, чтоelseсвязывают с ближайшимif,у которого нет своегоelse.Например, в
   if (n› 0)
    if (а › b)
     z = a;
    else
     z = b;
   elseотносится к внутреннемуif,что мы и показали с помощью отступов. Если нам требуется иная интерпретация, необходимо должным образом расставить фигурные скобки:
   if (n› 0) {
    if (а › b)
     z = a;
   }
   else
    z = b;
   Ниже приводится пример ситуации, когда неоднозначность особенно опасна:
   if (n›= 0)
    for (i=0; i ‹ n; i++)
     if (s[i] › 0) {
      printf(":");
      return i;
     }
   else /*НЕВЕРНО */
    printf("ошибка - отрицательное n\n");
   С помощью отступов мы недвусмысленно показали, что нам нужно, однако компилятор не воспримет эту информацию и отнесетelseк внутреннемуif.Искать такого рода ошибки особенно тяжело. Здесь уместен следующий совет: вложенныеifобрамляйте фигурными скобками. Кстати, обратите внимание на точку с запятой после z = a в
   if (а › b)
    z = а;
   else
    z = b;
   Здесь она обязательна, поскольку по правилам грамматики заifдолжна следовать инструкция, а выражение-инструкция вроде z = a; всегда заканчивается точкой с запятой.
   3.3Конструкция else-if
   Конструкция
   if (выражение)
    инструкция
   else if (выражение)
    инструкция
   else if (выражение)
    инструкция
   else if (выражение)
    инструкция
   else
    инструкция
   встречается так часто, что о ней стоит поговорить особо. Приведенная последовательность инструкцийif -самый общий способ описания многоступенчатого принятия решения. Выражения вычисляются по порядку; как только встречаетсявыражениесо значением "истина", выполняется соответствующая емуинструкция,на этом последовательность проверок завершается. Здесь под словоминструкцияимеется в виду либо одна инструкция, либо группа инструкций в фигурных скобках.
   Последняяelse-часть срабатывает, если не выполняются все предыдущие условия. Иногда в последней части не требуется производить никаких действий, в этом случае фрагмент
   else
    инструкция
   можно опустить или использовать для фиксации ошибочной ("невозможной") ситуации.
   В качестве иллюстрации трехпутевого ветвления рассмотрим функцию бинарного поиска значения x в массиве v. Предполагается, что элементы v упорядочены по возрастанию. Функция выдает положение x в v (число в пределах от 0 до n-1), если x там встречается, и -1, если его нет.
   При бинарном поиске значение x сначала сравнивается с элементом, занимающим серединное положение в массиве v. Если x меньше, чем это значение, то областью поиска становится "верхняя" половина массива v, в противном случае - "нижняя". В любом случае следующий шаг - это сравнение с серединным элементом отобранной половины. Процесс "уполовинивания" диапазона продолжается до тех пор, пока либо не будет найдено значение, либо не станет пустым диапазон поиска. Запишем функцию бинарного поиска:
   /* binsearch:найти x в v[0] ‹= v[1] ‹=… ‹= v[n-1] */
   int binsearch(intх, int v[], int n)
   {
    int low, high, mid;

    low = 0;
    high = n-1;
    while (low ‹=high) {
     mid = (low + high) / 2;
     if (х ‹ v[mid])
      high = mid - 1;
     else if (х › v[mid])
      low = mid+1;
     else /* совпадение найдено */
      return mid;
    }
    return -1; /* совпадения нет */
   }
   Основное действие, выполняемое на каждой шаге поиска, - сравнение значения x (меньше, больше или равно) с элементом v[mid]; это сравнение естественно поручить конструкцииelse-if.
   Упражнение 3.1.В нашей программе бинарного поиска внутри цикла осуществляются две проверки, хотя могла быть только одна (при увеличении числа проверок вне цикла). Напишите программу, предусмотрев в ней одну проверку внутри цикла. Оцените разницу во времени выполнения.
   3.4Переключатель switch
   Инструкцияswitchиспользуется для выбора одного из многих путей. Она проверяет, совпадает ли значение выражения с одним из значений, входящих в некоторое множество целых констант, и выполняет соответствующую этому значению ветвь программы:
   switch (выражение) {
   caseконст-выр:инструкции
   caseконст-выр:инструкции
   default:инструкции
   }
   Каждая ветвьcaseпомечена одной или несколькими целочисленными константами или же константными выражениями. Вычисления начинаются с той ветвиcase,в которой константа совпадает со значением выражения. Константы всех ветвейcaseдолжны отличаться друг от друга. Если выяснилось, что ни одна из констант не подходит, то выполняется ветвь, помеченная словомdefault,если таковая имеется, в противном случае ничего не делается. Ветвиcaseиdefaultможно располагать в любом порядке.
   В главе 1 мы написали программу, подсчитывающую число вхождений в текст каждой цифры, символов-разделителей (пробелов, табуляций и новых строк) и всех остальных символов. В ней мы использовали последовательностьif…else if…else.Теперь приведем вариант этой программы с переключателемswitch:
   #include‹stdio.h›
   main() /*подсчет цифр, символов-разделителей и прочих символов */
   {
    int c, i, nwhite, nother, ndigit[10];
    nwhite = nother = 0;
    for (i = 0; i ‹ 10; i++)
     ndigit[i] = 0;
    while ((с = getchar()) != EOF) {
     switch (c) {
     case '0': case '1': case '2': case '3': case '4':
     case '5': case '6': case '7': case '8': case '9':
      ndigit[c - '0']++;
      break;
     case ' ':
     case '\n':
     case '\t':
      nwhite++;
      break;
     default:
      nother++;
      break;
     }
    }
    printf("цифр =");
    for(i = 0; i ‹ 10; i++)
     printf (" %d", ndigit[i]);
    printf(", символов-разделителей = %d, прочих = %d\n",
     nwhite, nother);
    return 0;
   }
   Инструкцияbreakвызывает немедленный выход из переключателяswitch.Поскольку выбор ветвиcaseреализуется как переход на метку, то после выполнения одной ветвиcase,если ничего не предпринять, программа провалится вниз на следующую ветвь. Инструкцииbreakиreturn -наиболее распространенные средства выхода из переключателя. Инструкцияbreakиспользуется также для принудительного выхода из цикловwhile,forиdo-while (мы еще поговорим об этом чуть позже).
   "Сквозное" выполнение ветвейcaseвызывает смешанные чувства. С одной стороны, это хорошо, поскольку позволяет несколько ветвейcaseобъединить в одну, как мы и поступили с цифрами в нашем примере. Но с другой - это означает, что в конце почти каждой ветви придется ставитьbreak,чтобы избежать перехода к следующей. Последовательный проход по ветвям - вещь ненадежная, это чревато ошибками, особенно при изменении программы. За исключением случая с несколькими метками для одного вычисления, старайтесь по возможности реже пользоваться сквозным проходом, но если уж вы его применяете, обязательно комментируйте эти особые места.
   Добрый вам совет: даже в конце последней ветви (послеdefaultв нашем примере) помещайте инструкциюbreak,хотя с точки зрения логики в ней нет никакой необходимости. Но эта маленькая предосторожность спасет вас, когда однажды вам потребуется добавить в конец еще одну ветвьcase.
   Упражнение 3.2.Напишите функцию escape (s,t), которая при копировании текста из t в s преобразует такие символы, какновая строкаитабуляцияв "видимые последовательности символов" (вроде \n и \t). Используйте инструкциюswitch.Напишите функцию, выполняющую обратное преобразование эскейп- последовательностей в настоящие символы.
   3.5Циклы while и for
   Мы уже встречались с цикламиwhileиfor.В цикле
   while (выражение)
    инструкция
   вычисляетсявыражение.Если его значение отлично от нуля, то выполняетсяинструкция,и вычисление выражения повторяется. Этот цикл продолжается до тех пор, пока выражение не станет равным нулю, после чего вычисления продолжатся с точки, расположенной сразу заинструкцией.
   Инструкцияfor
   for (выр1;выр2;выр3)
    инструкция
   эквивалентна конструкции
   выр1;
   while (выр2) {
    инструкция
    выр3;
   }
   если не считать отличий в поведении инструкцииcontinue,речь о которой пойдет в параграфе 3.7.
   С точки зрения грамматики три компоненты циклаforпредставляют собой произвольные выражения, но чащевыр1ивыр3 -это присваивания или вызовы функций, авыр2 -выражение отношения. Любое из этих трех выражений может отсутствовать, но точку с запятой опускать нельзя. При отсутствиивыр1,иливыр3считается, что их просто нет в конструкции цикла; при отсутствиивыр2,предполагается, что его значение как бы всегда истинно. Например,
   for (;;) {
    :
   }
   есть "бесконечный" цикл, выполнение которого, вероятно, прерывается каким-то другим способом, например с помощью инструкцийbreakили return. Какой цикл выбрать:whileилиfor -это дело вкуса. Так, в
   while ((c = getchar()) == ' ' || c == '\n' || c == '\t')
    ; /* обойти символы-разделители */
   нет ни инициализации, ни пересчета параметра, поэтому здесь больше подходитwhile.
   Там, где есть простая инициализация и пошаговое увеличение значения некоторой переменной, больше подходит циклfor,так как в этом цикле организующая его часть сосредоточена в начале записи. Например, начало цикла, обрабатывающего первые n элементов массива, имеет следующий вид:
   for (i = 0; i‹ n; i++)
    …
   Это похоже наDO-циклы в Фортране иfor-циклы в Паскале. Сходство, однако, не вполне точное, так как в Си индекс и его предельное значение могут изменяться внутри цикла, и значение индекса i после выхода изцикла всегда определено. Поскольку три компонента цикла могут быть произвольными выражениями, организацияfor-циклов не ограничивается только случаем арифметической прогрессии. Однако включать в заголовок цикла вычисления, не имеющие отношения к инициализации и инкрементированию, считается плохим стилем. Заголовок лучше оставить только для операций управления циклом.
   В качестве более внушительного примера приведем другую версию программыatoi,выполняющей преобразование строки в ее числовой эквивалент. Это более общая версия по сравнению с рассмотренной в главе 2, в том смысле, что она игнорирует левые символы-разделители (если они есть) и должным образом реагирует на знаки + и -, которые могут стоять перед цифрами. (В главе 4 будет рассмотрен вариантatof,который осуществляет подобное преобразование для чисел с плавающей точкой.)
   Структура программы отражает вид вводимой информации:
   игнорировать символы-разделители, если они есть
   получить знак, если он есть
   взять целую часть и преобразовать ее
   На каждом шаге выполняется определенная часть работы и четко фиксируется ее результат, который затем используется на следующем шаге. Обработка данных заканчивается на первом же символе, который не может быть частью числа.
   #include‹ctype.h›
   /* atoi:преобразование s в целое число; версия 2 */
   int atoi(char s[])
   {
    int i, n, sign;
    /* игнорировать символы-разделители */
    for (i = 0; isspace(s[i]); i++)
     ;
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-') /* пропуск знака */
     i++;
    for (n = 0; isdigit(s[i]); i++)
    n = 10 * n + (s[i] - '0');
    return sign * n;
   }
   Заметим, что в стандартной библиотеке имеется более совершенная функция преобразования строки в длинное целое (long int) - функцияstrtol (см. параграф 5 приложения B).
   Преимущества, которые дает централизация управления циклом, становятся еще более очевидными, когда несколько циклов вложены друг в друга. Проиллюстрируем их на примере сортировки массива целых чисел методом Шелла, предложенным им в 1959 г. Основная идея этого алгоритма в том, что на ранних стадиях сравниваются далеко отстоящие друг от друга, а не соседние элементы, как в обычных перестановочных сортировках. Это приводит к быстрому устранению массовой неупорядоченности, благодаря чему на более поздней стадии остается меньше работы. Интервал между сравниваемыми элементами постепенно уменьшается до единицы, и в этот момент сортировка сводится к обычным перестановкам соседних элементов. Программа shellsort имеет следующий вид:
   /* shellsort:сортируются v[0]… v[n-1] в возрастающем порядке */
   void shellsort (int v[], int n)
   {
    int gap, i, j, temp;
    for (gap = n/2; gap › 0; gap /= 2)
     for (i = gap; i ‹ n; i++)
      for (j = i - gap; j ›= 0&& v[j]› v[j+gap]; j -= gap) {
       temp = v[j];
       v[j] = v[j + gap];
       v[j + gap] = temp;
      }
   }
   Здесь использованы три вложенных друг в друга цикла. Внешний управляет интервалом gap между сравниваемыми элементами, сокращая его путем деления пополам от n/2 до нуля. Средний цикл перебирает элементы. Внутренний - сравнивает каждую пару элементов, отстоящих друг от друга на расстоянии gap, и переставляет элементы в неупорядоченных парах. Так как gap обязательно сведется к единице, все элементы в конечном счете будут упорядочены. Обратите внимание на то, что универсальность циклаforпозволяет сделать внешний цикл по форме похожим на другие, хотя он и не является арифметической прогрессией.
   Последний оператор Си - это "," (запятая), которую чаще всего используют в инструкцииfor.Пара выражений, разделенных запятой, вычисляется слева направо. Типом и значением результата являются тип и значение правого выражения, что позволяет в инструкцииforв каждой из трех компонент иметь по несколько выражений, например вести два индекса параллельно. Продемонстрируем это на примере функции reverse(s), которая "переворачивает" строку s, оставляя результат в той же строке s:
   #include‹string.h›
   /* reverse:переворачивает строку s (результат в s) */
   void reverse(char s[])
   {
    int с, i, j;
    for (i = 0, j = strlen(s)-1; i ‹ j; i++, j--) {
     с = s[i];
     s[i] = s[j];
     s[j] = c;
    }
   }
   Запятые, разделяющие аргументы функции, переменные в объявлениях и пр. не являются операторами-запятыми и не обеспечивают вычислений слева направо.
   Запятыми как операторами следует пользоваться умеренно. Более всего они уместны в конструкциях, которые тесно связаны друг с другом (как вfor-цикле программы reverse), а также в макросах, в которых многоступенчатые вычисления должны быть выражены одним выражением. Запятой-оператором в программе reverse можно было бы воспользоваться и при обмене символами в проверяемых парах элементов строки, мысля этот обмен как одну отдельную операцию:
   for (i = 0, j = strlen(s)-1; i‹ j; i++, j--)
    с = s[i], s[i] = s[j], s[j] = c;
   Упражнение 3.3.Напишите функцию expand(s1,s2), заменяющую сокращенную запись наподобие a-z в строке s1 эквивалентной полной записью аbс…хуz в s2. В s1 допускаются буквы (прописные и строчные) и цифры. Следует уметь справляться с такими случаями, как a-b-c, a-z0-9 и -a-b. Считайте знак - в начале или в конце s1 обычным символом минус.
   3.6Цикл do-while
   Как мы говорили в главе 1, в циклахwhileиforпроверка условия окончания цикла выполняется наверху. В Си имеется еще один вид цикла,do-while,в котором эта проверка в отличие отwhileиforделается внизу после каждого прохождения тела цикла, т. е. после того, как тело выполнится хотя бы один раз. Циклdo-whileимеет следующий синтаксис:
   do
    инструкция
   while (выражение);
   Сначала выполняетсяинструкция,затем вычисляетсявыражение.Если оно истинно, тоинструкциявыполняется снова и т. д. Когда выражение становится ложным, цикл заканчивает работу. Циклdo-whileэквивалентен циклуrepeat-untilв Паскале с той лишь разницей, что в первом случае указывается условие продолжения цикла, а во втором - условие его окончания.
   Опыт показывает, что циклdo-whileиспользуется гораздо реже, чемwhileиfor.Тем не менее потребность в нем время от времени возникает, как, например, в функцииitoa (обратной по отношению кatoi),преобразующей число в строку символов. Выполнить такое преобразование оказалось несколько более сложным делом, чем ожидалось, поскольку простые алгоритмы генерируют цифры в обратном порядке. Мы остановились на варианте, в котором сначала формируется обратная последовательность цифр, а затем она реверсируется.
   /* itoa:преобразование n в строку s */
   void itoa(int n, char s[])
   {
    int i, sign;
    if ((sign = n) ‹ 0) /* сохраняем знак */
     n =-n; /* делаем n положительным */
    i = 0;
    do {/* генерируем цифры в обратном порядке */
     s[i++] = n %10 + '0'; /* следующая цифра */
    } while ((n /= 10) › 0); /* исключить ее */
    if (sign ‹ 0)
     s[i++] = '-';
    s[i] = '\0';
    reverse(s);
   }
   Конструкцияdo-whileздесь необходима или по крайней мере удобна, поскольку в s посылается хотя бы один символ, даже если n равно нулю. В теле цикла одну инструкцию мы выделили фигурными скобками (хотя они и избыточны), чтобы неискушенный читатель не принял по ошибке словоwhileза начало циклаwhile.
   Упражнение 3.4.При условии, что для представления чисел используется дополнительный код, наша версияitoaне справляется с самым большим по модулю отрицательным числом, значение которого равняется -(2n-1),где n - размер слова. Объясните, чем это вызвано. Модифицируйте программу таким образом, чтобы она давала правильное значение указанного числа независимо от машины,на которой выполняется.
   Упражнение 3.5.Напишите функцию itob(n,s,b), которая переводит целое n в строку s, представляющую число по основанию b. В частности, itob(n, s, 16) помещает в s текст числа n в шестнадцатеричномвиде.
   Упражнение 3.6.Напишите версию itoa с дополнительным третьим аргументом, задающим минимальную ширину поля. При необходимости преобразованное число должно слева дополняться пробелами.
   3.7Инструкции break и continue
   Иногда бывает удобно выйти из цикла не по результату проверки, осуществляемой в начале или в конце цикла, а каким-то другим способом. Такую возможность для цикловfor,whileиdo-while,а также для переключателяswitchпредоставляет инструкцияbreak.Эта инструкция вызывает немедленный выход из самого внутреннего из объемлющих ее циклов или переключателей.
   Следующая функция,trim,удаляет из строки завершающие пробелы, табуляции, символы новой строки;breakиспользуется в ней для выхода из цикла по первому обнаруженному справа символу, отличному от названных.
   /* trim:удаляет завершающие пробелы, табуляции и новые строки */
   int trim(char s[])
   {
    int n;
    for (n = strlen(s)-1; n ›= 0, n--)
     if (s[n]!= ' '&& s[n]!= '\t'&& s[n]!= '\n')
      break;
    s[n+1] = '\0';
    return n;
   }
   С помощью функцииstrlenможно получить длину строки. Циклforпросматривает его в обратном порядке, начиная с конца, до тех пор, пока не встретится символ, отличный от пробела, табуляции и новой строки. Цикл прерывается, как только такой символ обнаружится или n станет отрицательным (т. е. вся строка будет просмотрена). Убедитесь, что функция ведет себя правильно и в случаях, когда строка пуста или состоит только из символов-разделителей.
   Инструкцияcontinueв чем-то похожа наbreak,но применяется гораздо реже. Она вынуждает ближайший объемлющий ее цикл (for,whileилиdo-while)начать следующий шаг итерации. Дляwhileиdo-whileэто означает немедленный переход к проверке условия, а дляfor -к приращению шага. Инструкциюcontinueможно применять только к циклам, но не кswitch.Внутри переключателяswitch,расположенного в цикле, она вызовет переход к следующей итерации этого цикла.
   Вот фрагмент программы, обрабатывающий только неотрицательные элементы массива a (отрицательные пропускаются).
   for (i = 0; i‹ n; i++) {
    if (a[i] ‹ 0) /* пропуск отрицательных элементов */
     continue;
    … /* обработка положительных элементов */
   }
   К инструкцииcontinueчасто прибегают тогда, когда оставшаяся часть цикла сложна, а замена условия в нем на противоположное и введение еще одного уровня приводят к слишком большому числу уровней вложенности.
   3.8Инструкция goto и метки
   В Си имеются порицаемая многими инструкцияgotoи метки для перехода на них. Строго говоря, в этой инструкции нет никакой необходимости, и на практике почти всегда легко без нее обойтись. До сих пор в нашей книге мы не использовалиgoto.
   Однако существуют случаи, в которыхgotoможет пригодиться. Наиболее типична ситуация, когда нужно прервать обработку в некоторой глубоко вложенной структуре и выйти сразу из двух или большего числа вложенных циклов. Инструкцияbreakздесь не поможет, так как она обеспечит выход только из самого внутреннего цикла. В качестве примера рассмотрим следующую конструкцию:
   for (…)
    for (…) {
     …
    if (disaster) /* если бедствие */
     goto error; /* уйти на ошибку */
   error: /*обработка ошибки */
    ликвидировать беспорядок
   Такая организация программы удобна, если подпрограмма обработки ошибочной ситуации не тривиальна и ошибка может встретиться в нескольких местах.
   Метка имеет вид обычного имени переменной, за которым следует двоеточие. На метку можно перейти с помощьюgotoиз любого места данной функции, т. е. метка видима на протяжении всей функции.
   В качестве еще одного примера рассмотрим такую задачу: определить, есть ли в массивах a и b совпадающие элементы. Один из возможных вариантов ее реализации имеет следующий вид:
   for (i = 0; i‹ n; i++)
    for (j = 0; j ‹ m; j++)
     if (a[i] == b[i])
      goto found;
   /*нет одинаковых элементов */
    …
   found:
   /*обнаружено совпадение: a[i] - b[i] */
   Программу нахождения совпадающих элементов можно написать и безgoto,правда, заплатив за это дополнительными проверками и еще одной переменной:
   found = 0;
   for (i = 0; i‹ n&& !found; i++)
    for (j = 0; j ‹ m&& !found; j++)
     if (a[i] == b[j])
      found = 1;
   if (found) /*обнаружено совпадение: a[i-1] - b[j-1] */
    …
   else
    /* нет одинаковых элементов */
    …
   За исключением редких случаев, подобных только что приведенным, программы с применениемgoto,как правило, труднее для понимания и сопровождения, чем программы, решающие те же задачи безgoto.Хотя мы и не догматики в данном вопросе, все же думается, что кgotoследует прибегать крайне редко, если использовать эту инструкцию вообще.
   Глава 4. Функции и структура программы
   Функции разбивают большие вычислительные задачи на более мелкие и позволяют воспользоваться тем, что уже сделано другими разработчиками, а не начинать создание программы каждый раз "с нуля". В выбранных должным образом функциях "упрятаны" несущественные для других частей программы детали их функционирования, что делает программу в целом более ясной и облегчает внесение в нее изменений.
   Язык проектировался так, чтобы функции были эффективными и простыми в использовании. Обычно программы на Си состоят из большого числа небольших функций, а не из немногих больших. Программу можно располагать в одном или нескольких исходных файлах. Эти файлы можно компилировать отдельно, а загружать вместе, в том числе и с ранее откомпилированными библиотечными функциями. Процесс загрузки здесь не рассматривается, поскольку он различен в разных системах.
   Объявление и определение функции - это та область, где стандартом ANSI в язык внесены самые существенные изменения. Как мы видели в главе 1, в описании функции теперь разрешено задавать типы аргументов. Синтаксис определения функции также изменен, так что теперь объявления и определения функций соответствуют друг другу. Это позволяет компилятору обнаруживать намного больше ошибок, чем раньше. Кроме того. если типы аргументов соответствующим образом объявлены, то необходимые преобразования аргументов выполняются автоматически.
   Стандарт вносит ясность в правила, определяющие области видимости имен; в частности, он требует, чтобы для каждого внешнего объекта было только одно определение. Внем обобщены средства инициализации: теперь можно инициализировать автоматические массивы и структуры. Улучшен также препроцессор Си. Он включает более широкий набор директив условной компиляции, предоставляет возможность из макроаргументов генерировать строки в кавычках, а кроме того. содержит более совершенный механизм управления процессом макрорасширения.
   4.1Основные сведения о функциях
   Начнем с того, что сконструируем программу, печатающую те строки вводимого текста, в которых содержится некоторый "образец", заданный в виде строки символов. (Эта программа представляет собой частный случай функции grep системы UNIX.) Рассмотрим пример: в результате поиска образца "ould" в строках текста
   Ah Love! could you and I with Fate conspire
   To grasp this sorry Scheme of Things entire,
   Would not we shatter it to bits - and then
   Re-mould it nearer to The Heart's Desire!
   мы получим
   Ah Love! could you and I with Fate conspire
   Would not we shatter it to bits - and then
   Re-mould it nearer to the Heart's Desire!
   Работа по поиску образца четко распадается на три этапа:
   while (существует еще строка)
   if (строка содержит образец)
   напечатать ее
   Хотя все три составляющие процесса поиска можно поместить в функциюmain,все же лучше сохранить приведенную структуру и каждую ее часть реализовать в виде отдельной функции. Легче иметь дело с тремя небольшими частями, чем с одной большой, поскольку, если несущественные особенности реализации скрыты в функциях, вероятность их нежелательного воздействия друг на друга минимальна. Кроме того, оформленные в виде функций соответствующие части могут оказаться полезными и в других программах.
   Конструкция "while (существует еще строка)"реализована вgetline (см. главу 1), а фразу "напечатать ее"можно записать с помощью готовой функцииprintf.Таким образом, нам остается перевести на Си только то, что определяет, входит ли заданный образец в строку.
   Чтобы решить эту задачу, мы напишем функциюstrindex(s,t),которая указывает место (индекс) в строкеs,где начинается строкаt,или -1, еслиsне содержитt.Так как в Си нумерация элементов в массивах начинается с нуля, отрицательное число -1 подходит в качестве признака неудачного поиска. Если далее нам потребуется более сложное отождествление по образцу, мы просто заменимstrindexна другую функцию, оставив при этом остальную часть программы без изменений. (Библиотечная функцияstrstrаналогична функцииstrindexи отличается от последней только тем, что возвращает не индекс, а указатель.)
   После такого проектирования программы ее "деталировка" оказывается очевидной. Мы имеем представление о программе в целом и знаем, как взаимодействуют ее части. В нашей программе образец для поиска задается строкой-литералом, что снижает ее универсальность. В главе 5 мы еще вернемся к проблеме инициализации символьных массивов и покажем, как образец сделать параметром, устанавливаемым при запуске программы. Здесь приведена несколько измененная версия функцииgetline,и было бы поучительно сравнить ее с версией, рассмотренной в главе 1.
   #include‹stdio.h›
   #define MAXLINE 1000 /*максимальный размер вводимой строки */

   int getline(char line[], int max);
   int strindex(char source[], char searchfor[]);

   char pattern[] ="ould"; /*образец для поиска */

   /*найти все строки, содержащие образец */

   main()
   {
    char line[MAXLINE];
    int found = 0;
    while (getline(line, MAXLINE) › 0)
     if (strindex(line, pattern) ›= 0) {
      printf ("%s", line);
      found++;
     }
    return found;
   }

   /* getline:читает строку в s, возвращает длину */
   int getline(char s[], int lim)
   {
    int c, i;
    i = 0;
    while (--lim › 0&& (c=getchar()) != EOF&&с != '\n') /* I.B.: misprint was here -lim instead of --lim */
     s[i++] = c;
    if (c == '\n')
     s[i++] = c;
    s[i] = '\0';
    return i;
   }

   /* strindex:вычисляет место t в s или выдает -1, если t нет в s */
   int strindex (char s[], char t[])
   {
    int i, j, k;
    for (i = 0; s[i] != '\0'; i++) {
     for (j = i, k = 0; t[k] !=  '\0'&& s[j] == t[k]; j++, k++)
      ;
     if (k › 0&& t[k] == '\0')
      return i;
    }
    return -1;
   }
   Определение любой функции имеет следующий вид:
   тип-результата имя-функции (объявления аргументов)
   {
    объявления и инструкции
   }
   Отдельные части определения могут отсутствовать, как, например, в определении "минимальной" функции
   dummy() {}
   которая ничего не вычисляет и ничего не возвращает. Такая ничего не делающая функция в процессе разработки программы бывает полезна в качестве "хранителя места". Если тип результата опущен, то предполагается, что функция возвращает значение типаint.
   Любая программа - это просто совокупность определений переменных и функций. Связи между функциями осуществляются через аргументы, возвращаемые значения и внешние переменные. В исходном файле функции могут располагаться в любом порядке; исходную программу можно разбивать на любое число файлов, но так, чтобы ни одна из функций не оказалась разрезанной.
   Инструкцияreturnреализует механизм возврата результата от вызываемой функции к вызывающей. За словомreturnможет следовать любое выражение:
   returnвыражение;
   Если потребуется,выражениебудет приведено к возвращаемому типу функции. Часто выражение заключают в скобки, но они не обязательны.
   Вызывающая функция вправе проигнорировать возвращаемое значение. Более того,выражениевreturnможет отсутствовать, и тогда вообще никакое значение не будет возвращено в вызывающую функцию. Управление возвращается в вызывающую функцию без результирующего значения также и в том случае, когда вычисления достигли "конца" (т. е. последней закрывающей фигурной скобки функции). Не запрещена (но должна вызывать настороженность) ситуация, когда в одной и той же функции одниreturnимеют при себе выражения, а другие - не имеют. Во всех случаях, когда функция "забыла" передать результат вreturn,она обязательно выдаст "мусор".
   Функцияmainв программе поиска по образцу возвращает в качестве результата количество найденных строк. Это число доступно той среде, из которой данная программа была вызвана.
   Механизмы компиляции и загрузки Си-программ, расположенных в нескольких исходных файлах, в разных системах могут различаться. В системе UNIX, например, эти работы выполняет упомянутая в главе 1 командаcc.Предположим, что три функции нашего последнего примера расположены в трех разных файлах:main.с,getline.cиstrindex.c.Тогда команда
   cc main.с getline.c strindex.c
   скомпилирует указанные файлы, поместив результат компиляции в файлы объектных модулейmain.o,getline.oиstrindex.o,и затем загрузит их в исполняемый файлa.out.Если обнаружилась ошибка, например в файлеmain.с,то его можно скомпилировать снова и результат загрузить ранее полученными объектными файлами, выполнив следующую команду:
   cc main.с getline.o strindex.o
   Командаccиспользует стандартные расширения файлов ".с" и ".о", чтобы отличать исходные файлы от объектных.
   Упражнение 4.1.Напишите функцию strindex(s, t), которая выдает позицию самого правого вхождения t в s или -1, если вхождения не обнаружено.
   4.2Функции, возвращающие нецелые значения
   В предыдущих примерах функции либо вообще не возвращали результирующих значений (void),либо возвращали значения типаint.А как быть, когда результат функции должен иметь другой тип? Многие вычислительные функции, как, например, sqrt, sin и cos, возвращают значения типа double; другие специальные функции могут выдавать значения еще каких-то типов. Чтобы проиллюстрировать, каким образом функция может возвратить нецелое значение, напишем функциюatof(s),которая переводит строку s в соответствующее число с плавающей точкой двойной точности. Функцияatofпредставляет собой расширение функцииatoi,две версии которой были рассмотрены в главах 2 и 3. Она имеет дело со знаком (которого может и не быть), с десятичной точкой, а также с целой и дробной частями, одна из которых может отсутствовать. Наша версия не является высококачественной программой преобразования вводимых чисел; такая программа потребовала бы заметно больше памяти. Функцияatofвходит в стандартную библиотеку программ: ее описание содержится в заголовочном файле‹stdlib.h›.
   Прежде всего отметим, что объявлять тип возвращаемого значения должна самаatof,так как этот тип не естьint.Указатель типа задается перед именем функции.
   #include‹ctype.h›
   /*atof:преобразование строки s в double */
   double atof (char s[])
   {
    double val, power;
    int i, sign;

    for (i = 0; isspace(s[i]); i++)
     ; /* игнорирование левых символов-разделителей */
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-')
     i++;
    for (val = 0.0; isdigit(s[i]); i++)
     val = 10.0 * val + (s[i] - '0');
    if (s[i] == '.')
     i++;
    for (power = 1.0; isdigit(s[i]); i++) {
     val = 10.0 * val + (s.[i] - '0');
     power *= 10.0;
    }
    return sign * val / power;
   }
   Кроме того, важно, чтобы вызывающая программа знала, чтоatofвозвращает нецелое значение. Один из способов обеспечить это - явно описатьatofв вызывающей программе. Подобное описание демонстрируется ниже в программе простенького калькулятора (достаточного для проверки баланса чековой книжки), которыйкаждую вводимую строку воспринимает как число, прибавляет его к текущей сумме и печатает ее новое значение.
   #include‹stdio.h›
   #define MAXLINE 100
   /*примитивный калькулятор */
   main()
   {
    double sum, atof (char[]);
    char line[MAXLINE];
    int getline (char line[], int max);

    sum = 0;
    while (getline(line, MAXLINE) › 0)
     printf ("\t%g\n", sum += atof(line));
    return 0;
   }
   В объявлении
   double sum, atof (char[]);
   говорится, чтоsum -переменная типаdouble, aatof -функция, которая принимает один аргумент типаchar[]и возвращает результат типаdouble.
   Объявление и определение функцииatofдолжны соответствовать друг другу. Если в одном исходном файле сама функцияatofи обращение к ней вmainимеют разные типы, то это несоответствие будет зафиксировано компилятором как ошибка. Но если функцияatofбыла скомпилирована отдельно (что более вероятно), то несоответствие типов не будет обнаружено, иatofвозвратит значение типаdouble,которое функцияmainвоспримет какint,что приведет к бессмысленному результату.
   Это последнее утверждение, вероятно, вызовет у вас удивление, поскольку ранее говорилось о необходимости соответствия объявлений и определений. Причина несоответствия, возможно, будет следствием того, что вообще отсутствует прототип функции, и функция неявно объявляется при первом своем появлении в выражении, как, например, в
   sum += atof(line);
   Если в выражении встретилось имя, нигде ранее не объявленное, за которым следует открывающая скобка, то такое имя по контексту считается именем функции, возвращающей результат типаint;при этом относительно ее аргументов ничего не предполагается. Если в объявлении функции аргументы не указаны, как в
   double atof();
   то и в этом случае считается, что ничего об аргументахatofне известно, и все проверки на соответствие ее параметров будут выключены. Предполагается, что такая специальная интерпретация пустого списка позволит новым компиляторам транслировать старые Си-программы. Но в новых программах пользоваться этим - не очень хорошая идея. Если у функции есть аргументы, опишите их, если их нет, используйте словоvoid.
   Располагая соответствующим образом описанной функциейatof,мы можем написать функциюatoi,преобразующую строку символов в целое значение, следующим образом:
   /* atoi:преобразование строки s в int с помощью atof */
   int atoi (char s[])
   {
    double atof (char s[]);
    return (int) atof (s);
   }
   Обратите внимание на вид объявления и инструкцииreturn.Значение выражения в
   returnвыражение;
   перед тем, как оно будет возвращено в качестве результата, приводится к типу функции. Следовательно, поскольку функцияatoiвозвращает значениеint,результат вычисленияatofтипаdoubleв инструкцииreturnавтоматически преобразуется в типint.При преобразовании возможна потеря информации, и некоторые компиляторы предупреждают об этом. Оператор приведения явно указывает на необходимость преобразования типа и подавляет любое предупреждающее сообщение.
   Упражнение 4.2.Дополните функциюatofтаким образом, чтобы она справлялась с числами вида
   123.45e-6
   в которых после мантиссы может стоять e (или E) с последующим порядком (быть может, со знаком).
   4.3Внешние переменные
   Программа на Си обычно оперирует с множеством внешних объектов: переменных и функций. Прилагательное "внешний" (external)противоположно прилагательному "внутренний", которое относится к аргументам и переменным, определяемым внутри функций. Внешние переменные определяются вне функций и потенциально доступны для многих функций. Сами функции всегда являются внешними объектами, поскольку в Си запрещено определять функции внутри других функций. По умолчанию одинаковые внешние имена, используемые в разных файлах, относятся к одному и тому же внешнему объекту (функции). (В стандарте это называетсяредактированием внешних связей (линкованием) (external linkage).)В этом смысле внешние переменные похожи на областиCOMMONв Фортране и на переменные самого внешнего блока в Паскале. Позже мы покажем, как внешние функции и переменные сделать видимыми только внутри одного исходного файла.
   Поскольку внешние переменные доступны всюду, их можно использовать в качестве связующих данных между функциями как альтернативу связей через аргументы и возвращаемые значения. Для любой функции внешняя переменная доступна по ее имени, если это имя было должным образом объявлено.
   Если число переменных, совместно используемых функциями, велико, связи между последними через внешние переменные могут оказаться более удобными и эффективными, чем длинные списки аргументов. Но, как отмечалось в главе 1, к этому заявлению следует относиться критически, поскольку такая практика ухудшает структуру программы иприводит к слишком большому числу связей между функциями по данным.
   Внешние переменные полезны, так как они имеют большую область действия и время жизни. Автоматические переменные существуют только внутри функции, они возникают в момент входа в функцию и исчезают при выходе из нее. Внешние переменные, напротив, существуют постоянно, так что их значения сохраняются и между обращениями к функциям. Таким образом, если двум функциям приходится пользоваться одними и теми же данными и ни одна из них не вызывает другую, то часто бывает удобно оформить эти общие данные в виде внешних переменных, а не передавать их в функцию и обратно через аргументы.
   В связи с приведенными рассуждениями разберем пример. Поставим себе задачу написать программу-калькулятор, понимающую операторы +, -, * и /. Такой калькулятор легче будет написать, если ориентироваться на польскую, а не инфиксную запись выражений. (Обратная польская запись применяется в некоторых карманных калькуляторах и в таких языках, как Forth и Postscript.) В обратной польской записи каждый оператор следует за своими операндами. Выражение в инфиксной записи, скажем
   (1 - 2) * (4 + 5)
   в польской записи представляется как
   1 2 - 4 5 + *
   Скобки не нужны, неоднозначности в вычислениях не бывает, поскольку известно, сколько операндов требуется для каждого оператора.
   Реализовать нашу программу весьма просто. Каждый операнд посылается в стек; если встречается оператор, то из стека берется соответствующее число операндов (в случае бинарных операторов два) и выполняется операция, после чего результат посылается в стек. В нашем примере числа 1 и 2 посылаются в стек, затем замещаются на их разность -1. Далее в стек посылаются числа 4 и 5, которые затем заменяются их суммой (9). Числа -1 и 9 заменяются в стеке их произведением (т. е. -9). Встретив символ новой строки, программа извлекает значение из стека и печатает его.
   Таким образом, программа состоит из цикла, обрабатывающего на каждом своем шаге очередной встречаемый оператор или операнд:
   while (следующий элемент не конец-файла)
    if (число)
     послать его в стек
    else if (оператор)
     взять из стека операнды
     выполнить операцию
     результат послать в стек
    else if (новая-строка)
     взять с вершины стека число и напечатать
    else
     ошибка
   Операции "послать в стек" и "взять из стека" сами по себе тривиальны, однако по мере добавления к ним механизмов обнаружения и нейтрализации ошибок становятся достаточно длинными. Поэтому их лучше оформить в виде отдельных функций, чем повторять соответствующий код по всей программе. И конечно необходимо иметь отдельную функцию для получения очередного оператора или операнда.
   Главный вопрос, который мы еще не рассмотрели, - это вопрос о том, где расположить стек и каким функциям разрешить к нему прямой доступ. Стек можно расположить в функцииmainи передавать сам стек и текущую позицию в нем в качестве аргументов функциямpush ("послать в стек") иpop ("взять из стека"). Но функцииmainнет дела до переменных, относящихся к стеку, - ей нужны только операции по помещению чисел в стек и извлечению их оттуда. Поэтому мы решили стек и связанную с ним информацию хранить во внешних переменных, доступных для функцийpushиpop,но не доступных дляmain.
   Переход от эскиза к программе достаточно легок. Если теперь программу представить как текст, расположенный в одном исходном файле, она будет иметь следующий вид:
   #include /*могут быть в любом количестве */
   #define /*могут быть в любом количестве */

   объявления функций для main

   main() {…}
   внешние переменные для push и pop

   void push (double f) {…}
   double pop (void) {…}

   int getop(char s[]) {…}

   подпрограммы, вызываемые функцией getop
   Позже мы обсудим, как текст этой программы можно разбить на два или большее число файлов.
   Функцияmain -это цикл, содержащий большой переключательswitch,передающий управление на ту или иную ветвь в зависимости от типа оператора или операнда. Здесь представлен более типичный случай применения переключателяswitchпо сравнению с рассмотренным в параграфе 3.4.
   #include‹stdio.h›
   #include‹stdlib.h› /* для atof() */

   #define MAXOP 100 /*макс. размер операнда или оператора */
   #define NUMBER '0' /*признак числа */

   int getop (char []);
   void push (double);
   double pop (void);

   /*калькулятор с обратной польской записью */
   main()
   {
    int type;
    double op2;
    char s[MAXOP];

    while ((type = getop (s)) != EOF) {
     switch (type) {
     case NUMBER:
      push (atof(s));
      break;
     case '+':
      push(pop() + pop());
      break;
     case '*':
      push(pop() * pop());
      break;
     case '-':
      op2 = pop();
      push(pop() - op2);
      break;
     case '/':
      pop2 = pop();
      if (op2 != 0.0)
       push(pop() / op2);
      else
       printf("ошибка: деление на нуль\n");
      break;
     case '\n':
      printf("\t%.8g\n", pop());
      break;
     default:
      printf("ошибка: неизвестная операция %s\n", s);
      break;
     }
    }
    return 0;
   }
   Так как операторы + и * коммутативны, порядок, в котором операнды берутся из стека, не важен, однако в случае операторов - и /, левый и правый операнды должны различаться. Так, в
   push(pop() - pop()); /*НЕПРАВИЛЬНО */
   очередность обращения кpopне определена. Чтобы гарантировать правильную очередность, необходимо первое значение из стека присвоить временной переменной, как это и сделано в main.
   #define MAXVAL 100 /*максимальная глубина стека */

   int sp = 0; /*следующая свободная позиция в стеке */
   double val[MAXVAL]; /*стек */

   /* push:положить значение f в стек */
   void push(double f)
   {
    if (sp ‹ MAXVAL)
     val[sp++] = f;
    else
    printf("ошибка: стек полон, %g не помещается\n", f);
   }

   /* pop:взять с вершины стека и выдать в качестве результата */
   double pop(void)
   {
    if (sp › 0)
     return val[--sp];
    else {
     printf ("ошибка: стек пуст\n");
     return 0.0;
    }
   }
   Переменная считается внешней, если она определена вне функции. Таким образом, стек и индекс стека, которые должны быть доступны и дляpush,и дляpop,определяются вне этих функций. Ноmainне использует ни стек, ни позицию в стеке, и поэтому их представление может быть скрыто отmain.
   Займемся реализациейgetop -функции, получающей следующий оператор или операнд. Нам предстоит решить довольно простую задачу. Более точно: требуется пропустить пробелы и табуляции; если следующий символ - не цифра и не десятичная точка, то нужно выдать его; в противном случае надо накопить строку цифр с десятичной точкой, если она есть, и выдать число NUMBER в качестве результата.
   #include‹ctype.h›

   int getch(void);
   void ungetch(int);

   /* getop:получает следующий оператор или операнд */
   int getop(char s[])
   {
    int i, с;
    while ((s[0] = с = getch()) == ' ' || с == '\t')
     ;
    s[1] = '\0;
    if (!isdigit(c)&&с!= '.')
     return c; /* не число */
    i = 0;
    if (isdigit(c)) /* накапливаем целую часть */
     while (isdigit(s[++i] - с = getch()))
      ;
    if (с == '.') /* накапливаем дробную часть */
     while (isdigit(s[++i] = с = getch()))
      ;
    s[i] = '\0';
    if (c != EOF)
     ungetch(c);
    return NUMBER;
   }
   Как работают функцииgetchиungetch?Во многих случаях программа не может "сообразить", прочла ли она все, что требуется, пока не прочтет лишнего. Так, накопление числа производится до тех пор, пока не встретится символ, отличный от цифры. Но это означает, что программа прочла на один символ больше, чем нужно, и последний символ нельзя включать в число.
   Эту проблему можно было бы решить при наличии обратной чтению операции "положить-назад", с помощью которой можно было бы вернуть ненужный символ. Тогда каждый раз, когда программа считает на один символ больше, чем требуется, эта операция возвращала бы его вводу, и остальная часть программы могла бы вести себя так, будто этот символ вовсе и не читался. К счастью, описанный механизм обратной посылки символа легко моделируется с помощью пары согласованных друг с другом функций, из которыхgetchпоставляет очередной символ из ввода, aungetchотправляет символ назад во входной поток, так что при следующем обращении кgetchмы вновь его получим.
   Нетрудно догадаться, как они работают вместе. Функцияungetchзапоминает посылаемый назад символ в некотором буфере, представляющем собой массив символов, доступный для обеих этих функций;getchчитает из буфера, если там что-то есть, или обращается кgetchar,если буфер пустой. Следует предусмотреть индекс, указывающий на положение текущего символа в буфере.
   Так как функцииgetchиungetchсовместно используют буфер и индекс, значения последних должны между вызовами сохраняться. Поэтому буфер и индекс должны быть внешними по отношению к этим программам, и мы можем записатьgetch,ungetchи общие для них переменные в следующем виде:
   #define BUFSIZE 100

   char buf[BUFSIZE]; /*буфер для ungetch */
   int bufp = 0; /*след. свободная позиция в буфере */

   int getch(void) /*взять (возможно возвращенный) символ */
   {
    return (bufp › 0) ? buf[--bufp]: getchar();
   }

   void ungetch(int c) /*вернуть символ на ввод */
   {
    if (bufp ›= BUFSIZE)
     printf("ungetch: слишком много символов\n");
    else
     buf[bufp++] = с;
   }
   Стандартная библиотека включает функциюungetc,обеспечивающую возврат одного символа (см. главу 7). Мы же, чтобы проиллюстрировать более общий подход, для запоминания возвращаемых символов использовали массив.
   Упражнение 4.3.Исходя из предложенной нами схемы, дополните программу- калькулятор таким образом, чтобы она "понимала" оператор получения остатка от деления (%) и отрицательные числа.
   Упражнение 4.4.Добавьте команды, с помощью которых можно было бы печатать верхний элемент стека (с сохранением его в стеке), дублировать его в стеке, менять местами два верхних элемента стека. Введите команду очистки стека.
   Упражнение 4.5.Предусмотрите возможность использования в программе библиотечных функций sin, ехр и pow. См. библиотеку ‹math.h› в приложении B (параграф 4).
   Упражнение 4.6.Введите команды для работы с переменными (легко обеспечить до 26 переменных, каждая из которых имеет имя, представленное одной буквой латинского алфавита). Добавьте переменную, предназначенную для хранения самого последнего из напечатанных значений.
   Упражнение 4.7.Напишите программу ungets(s), возвращающую строку s во входной поток. Должна ли ungets "знать" что-либо о переменных buf и bufp, или ей достаточно пользоваться только функцией ungetch?
   Упражнение 4.8.Предположим, что число символов, возвращаемых назад, не превышает 1. Модифицируйте с учетом этого факта функции getch и ungetch.
   Упражнение 4.9.В наших функциях не предусмотрена возможность возврата EOF. Подумайте, что надо сделать, чтобы можно было возвращать EOF, и скорректируйте соответственно программу.
   Упражнение 4.10.В основу программы калькулятора можно положить применение функции getline, которая читает целиком строку; при этом отпадает необходимость в getch и ungetch. Напишите программу, реализующую этот подход.
   4.4Области видимости
   Функции и внешние переменные, из которых состоит Си-программа, каждый раз компилировать все вместе нет никакой необходимости. Исходный текст можно хранить в нескольких файлах. Ранее скомпилированные программы можно загружать из библиотек. В связи с этим возникают следующие вопросы:
   • Как писать объявления, чтобы на протяжении компиляции используемые переменные были должным образом объявлены?
   • В каком порядке располагать объявления, чтобы во время загрузки все части программы оказались связаны нужным образом?
   • Как организовать объявления, чтобы они имели лишь одну копию?
   • Как инициализировать внешние переменные?
   Начнем с того, что разобьем программу-калькулятор на несколько файлов. Конечно, эта программа слишком мала, чтобы ее стоило разбивать на файлы, однако разбиение нашей программы позволит продемонстрировать проблемы, возникающие в больших программах.
   Областью видимостиимени считается часть программы, в которой это имя можно использовать. Для автоматических переменных, объявленных в начале функции, областью видимости является функция, в которой они объявлены. Локальные переменные разных функций, имеющие, однако, одинаковые имена, никак не связаны друг с другом. То же утверждение справедливо и в отношении параметров функции, которые фактически являются локальными переменными.
   Область действия внешней переменной или функции простирается от точки программы, где она объявлена, до конца файла, подлежащего компиляции. Например, еслиmain,sp,val,pushиpopопределены в одном файле в указанном порядке, т. е.
   main() {…}

   int sp = 0;
   double val[MAXVAL];

   void push(double f) {…}
   double pop(void) {…}
   то к переменнымspиvalможно адресоваться изpushиpopпросто по их именам; никаких дополнительных объявлений для этого не требуется. Заметим, что вmainэти имена не видимы так же, как и самиpushиpop.
   Однако, если на внешнюю переменную нужно сослаться до того, как она определена, или если она определена в другом файле, то ее объявление должно быть помечено словомextern.
   Важно отличатьобъявлениевнешней переменной от ееопределения.Объявление объявляет свойства переменной (прежде всего ее тип), а определение, кроме того, приводит к выделению для нее памяти. Если строки
   int sp;
   double val[MAXVAL];
   расположены вне всех функций, то ониопределяютвнешние переменныеspиval,т. e. отводят для них память, и, кроме того, служат объявлениями для остальной части исходного файла. А вот строки
   extern int sp;
   extern double val[];
   объявляютдля оставшейся части файла, чтоsp -переменная типаint,аval -массив типаdouble (размер которого определен где-то в другом месте); при этом ни переменная, ни массив не создаются, и память им не отводится.
   На всю совокупность файлов, из которых состоит исходная программа, для каждой внешней переменной должно быть одно-единственноеопределение;другие файлы, чтобы получить доступ к внешней переменной, должны иметь в себе объявлениеextern. (Впрочем, объявлениеexternможно поместить и в файл, в котором содержится определение.) В определениях массивов необходимо указывать их размеры, что в объявленияхexternне обязательно. Инициализировать внешнюю переменную можно только в определении. Хотя вряд ли стоит организовывать нашу программу таким образом, но мы определим push и pop в одном файле, а val и sp - в другом, где их и инициализируем. При этом для установления связей понадобятся такие определения и объявления:
   В файле 1:

   extern int sp;
   extern double val[];

   void push(double f) {…}
   double pop(void) {…}

   В файле2:

   int sp = 0;
   double val[MAXVAL];
   Поскольку объявленияexternнаходятся в началефайла1и вне определений функций, их действие распространяется на все функции, причем одного набора объявлений достаточно для всегофайла1.Та же организацияextern-объявлений необходима и в случае, когда программа состоит из одного файла, но определения sp и val расположены после их использования.
   4.5Заголовочные файлы
   Теперь представим себе, что компоненты программы-калькулятора имеют существенно большие размеры, и зададимся вопросом, как в этом случае распределить их по нескольким файлам. Программуmainпоместим в файл, который мы назовемmain.с;push,popи их переменные расположим во втором файле,stack.с; agetop -в третьем,getop.c.Наконец,getchиungetchразместим в четвертом файлеgetch.с;мы отделили их от остальных функций, поскольку в реальной программе они будут получены из заранее скомпилированной библиотеки.
   Существует еще один момент, о котором следует предупредить читателя, - определения и объявления совместно используются несколькими файлами. Мы бы хотели, насколько это возможно, централизовать эти объявления и определения так, чтобы для них существовала только одна копия. Тогда программу в процессе ее развития будет легче и исправлять, и поддерживать в нужном состоянии. Для этого общую информацию расположим в заголовочном файлеcalc.h,который будем по мере необходимости включать в другие файлы. (Строка #include описывается в параграфе 4.11) В результате получим программу, файловая структура которой показана ниже:
   main.с:
   #include‹stdio.h›
   #include‹stdlib.h›
   #include "calc.h"
   #define MAXOP 100
   main() {
    …
   }

   calc.h:
   #define NUMBER '0'
   void push(double);
   double pop(void);
   int getop(char[]);
   int getch(void);
   void ungetch(int);

   getop.c:
   #include‹stdio.h›
   #include‹ctype.h›
   #include "calc.h"
   getop (){
    …
   }

   getch.c:
   #include‹stdio.h›
   #define BUFSIZE 100
   char buf[BUFSIZE];
   intbufp = 0;
   int getch(void) {
    …
   }
   void ungetch(int) {
    …
   }

   stack.с:
   #include‹stdio.h›
   #include "calc.h"
   #define MAXVAL 100
   int sp = 0;
   double val[MAXVAL];
   void push(double) {
    …
   }
   double pop(void) {
    …
   }
   Неизбежен компромисс между стремлением, чтобы каждый файл владел только той информацией, которая ему необходима для работы, и тем, что на практике иметь дело с большим количеством заголовочных файлов довольно трудно. Для программ, не превышающих некоторого среднего размера, вероятно, лучше всего иметь один заголовочный файл, в котором собраны вместе все объекты, каждый из которых используется в двух различных файлах; так мы здесь и поступили. Для программ больших размеров потребуется более сложная организация с большим числом заголовочных файлов.
   4.6Статические переменные
   Переменныеspиvalв файлеstack.с,а такжеbufиbufpвgetch.снаходятся в личном пользовании функций этих файлов, и нет смысла открывать к ним доступ кому-либо еще. Указаниеstatic,примененное к внешней переменной или функции, ограничивает область видимости соответствующего объекта концом файла. Это способ скрыть имена. Так, переменныеbufиbufpдолжны быть внешними, поскольку их совместно используют функцииgetchиungetch,но их следует сделать невидимыми для "пользователей" функцийgetchиungetch.
   Статическая память специфицируется словомstatic,которое помещается перед обычным объявлением. Если рассматриваемые нами две функции и две переменные компилируются в одном файле, как в показанном ниже примере:
   static char buf[BUFSIZE]; /*буфер для ungetch */
   static int bufp = 0; /*след. свободная позиция в buf */

   int getch(void) {…}

   void ungetch(intс) {…}
   то никакая другая программа не будет иметь доступ ни кbuf,ни кbufp,и этими именами можно свободно пользоваться в других файлах для совсем иных целей. Точно так же, помещая указаниеstaticперед объявлениями переменныхspиval,с которыми работают толькоpushиpop,мы можем скрыть их от остальных функций.
   Указаниеstaticчаще всего используется для переменных, но с равным успехом его можно применять и к функциям. Обычно имена функций глобальны и видимы из любого места программы. Если же функция помечена словомstatic,то ее имя становится невидимым вне файла, в котором она определена.
   Объявлениеstaticможно использовать и для внутренних переменных. Как и автоматические переменные, внутренние статические переменные локальны в функциях, но в отличие от автоматических, они не возникают только на период работы функции, а существуют постоянно. Это значит, что внутренние статические переменные обеспечивают постоянное сохранение данных внутри функции.
   Упражнение 4.11.Модифицируйте функциюgetopтак, чтобы отпала необходимость в функцииungetch.Подсказка: используйте внутреннюю статическую переменную.
   4.7Регистровые переменные
   Объявлениеregisterсообщает компилятору, что данная переменная будет интенсивно использоваться. Идея состоит в том, чтобы переменные, объявленныеregister,разместить на регистрах машины, благодаря чему программа, возможно, станет более короткой и быстрой. Однако компилятор имеет право проигнорировать это указание. Объявлениеregisterвыглядит следующим образом:
   register intх;
   register charс;
   и т. д. Объявлениеregisterможет применяться только к автоматическим переменным и к формальным параметрам функции. Для последних это выглядит так:
   f(register unsigned m, register long n)
   {
    register int i;
    …
   }
   На практике существуют ограничения на регистровые переменные, что связано с возможностями аппаратуры. Располагаться в регистрах может лишь небольшое число переменных каждой функции, причем только определенных типов. Избыточные объявленияregisterни на что не влияют, так как игнорируются в отношении переменных, которым не хватило регистров или которые нельзя разместить на регистре. Кроме того, применительнок регистровой переменной независимо от того, выделен на самом деле для нее регистр или нет, не определено понятие адреса (см. главу 5). Конкретные ограничения на количество и типы регистровых переменных зависят от машины.
   4.8Блочная структура
   Поскольку функции в Си нельзя определять внутри других функций, он не является языком, допускающим блочную структуру программы в том смысле, как это допускается в Паскале и подобных ему языках. Но переменные внутри функций можно определять в блочно-структурной манере. Объявления переменных (вместе с инициализацией) разрешено помещать не только в начале функции, но и после любой левой фигурной скобки, открывающей составную инструкцию. Переменная, описанная таким способом, "затеняет" переменные с тем же именем, расположенные в объемлющих блоках, и существует вплоть до соответствующей правой фигурной скобки. Например, в
   if (n› 0) {
    int i; /* описание новой переменной i */
    for (i = 0; i ‹ n; i++)
     …
   }
   областью видимости переменнойiявляется ветвьif,выполняемая при n›0; и эта переменная никакого отношения к любымi,расположенным вне данного блока, не имеет. Автоматические переменные, объявленные и инициализируемые в блоке, инициализируются каждый раз при входе в блок. Переменныеstaticинициализируются только один раз при первом входе в блок.
   Автоматические переменные и формальные параметры также "затеняют" внешние переменные и функции с теми же именами. Например, в
   int x;
   int y;
   f(doubleх)
   {
    double y;
   }
   xвнутри функцииfрассматривается как параметр типаdouble,в то время как внеfэто внешняя переменная типаint.То же самое можно сказать и о переменнойy.
   С точки зрения стиля программирования, лучше не пользоваться одними и теми же именами для разных переменных, поскольку слишком велика возможность путаницы и появления ошибок.
   4.9Инициализация
   Мы уже много раз упоминали об инициализации, но всегда лишь по случаю, в ходе обсуждения других вопросов. В этом параграфе мы суммируем все правила, определяющие инициализацию памяти различных классов.
   При отсутствии явной инициализации для внешних и статических переменных гарантируется их обнуление; автоматические и регистровые переменные имеют неопределенные начальные значения ("мусор").
   Скалярные переменные можно инициализировать в их определениях, помещая после имени знак = и соответствующее выражение:
   intх = 1;
   char squote = '\'';
   long day = 1000L * 60L * 60L * 24L; /*день в миллисекундах */
   Для внешних и статических переменных инициализирующие выражения должны быть константными, при этом инициализация осуществляется только один раз до начала выполнения программы. Инициализация автоматических и регистровых переменных выполняется каждый раз при входе в функцию или блок. Для таких переменных инициализирующеевыражение - не обязательно константное. Это может быть любое выражение, использующее ранее определенные значения, включая даже и вызовы функции. Например, в программе бинарного поиска, описанной в параграфе 3.3, инициализацию можно записать так:
   int binsearch(intх, int v[], int n)
   {
    int low = 0;
    int high = n-1;
    int mid;
   }
   а не так:
   int low, high, mid;

   low = 0;
   high = n - 1;
   В сущности, инициализация автоматической переменной - это более короткая запись инструкции присваивания. Какая запись предпочтительнее - в большой степени дело вкуса. До сих пор мы пользовались главным образом явными присваиваниями, поскольку инициализация в объявлениях менее заметна и дальше отстоит от места использования переменной.
   Массив можно инициализировать в его определении с помощью заключенного в фигурные скобки списка инициализаторов, разделенных запятыми. Например, чтобы инициализировать массивdays,элементы которого суть количества дней в каждом месяце, можно написать:
   int days[] = {31, 28, 31, 30, 31, 30, 31. 31, 30, 31, 30, 31};
   Если размер массива не указан, то длину массива компилятор вычисляет по числу заданных инициализаторов; в нашем случае их количество равно 12.
   Если количество инициализаторов меньше числа, указанного в определении длины массива, то для внешних, статических и автоматических переменных оставшиеся элементы будут нулевыми. Задание слишком большого числа инициализаторов считается ошибкой. В языке нет возможности ни задавать повторения инициализатора, ни инициализировать средние элементы массива без задания всех предшествующих значений. Инициализация символьных массивов - особый случай: вместо конструкции с фигурными скобками и запятыми можно использовать строку символов. Например, возможна такая запись:
   char pattern[] = "ould";
   представляющая собой более короткий эквивалент записи
   char pattern[] = {'о', 'u', 'l', 'd', '\0'};
   В данном случае размер массива равен пяти (четыре обычных символа и завершающий символ '\0').
   4.10Рекурсия
   В Си допускается рекурсивное обращение к функциям, т. е. функция может обращаться сама к себе, прямо или косвенно. Рассмотрим печать числа в виде строки символов. Как мы упоминали ранее, цифры генерируются в обратном порядке - младшие цифры получаются раньше старших, а печататься они должны в правильной последовательности.
   Проблему можно решить двумя способами. Первый - запомнить цифры в некотором массиве в том порядке, как они получались, а затем напечатать их в обратном порядке; так это и было сделано в функцииitoa,рассмотренной в параграфе 3.6. Второй способ - воспользоваться рекурсией, при которойprintdсначала вызывает себя, чтобы напечатать все старшие цифры, и затем печатает последнюю младшую цифру. Эта программа, как и предыдущий ее вариант, при использовании самого большого по модулю отрицательного числа работает неправильно.
   #include‹stdio.h›

   /* printd:печатает n как целое десятичное число */
   void printd(int n)
   {
    if (n ‹ 0) {
     putchar('-');
     n = -n;
    }
    if (n / 10)
     printd(n / 10);
    putchar(n % 10 + '0');
   }
   Когда функция рекурсивно обращается сама к себе, каждое следующее обращение сопровождается получением ею нового полного набора автоматических переменных, независимых от предыдущих наборов. Так, в обращенииprintd(123)при первом вызове аргументn = 123,при втором -printdполучает аргумент 12, при третьем вызове - значение 1. Функцияprintdна третьем уровне вызова печатает 1 и возвращается на второй уровень, после чего печатает цифру 2 и возвращается на первый уровень. Здесь она печатает 3 и заканчивает работу.
   Следующий хороший пример рекурсии - это быстрая сортировка, предложенная Ч.А.Р. Хоаром в 1962 г. Для заданного массива выбирается один элемент, который разбивает остальные элементы на два подмножества - те, что меньше, и те, что не меньше него. Та же процедура рекурсивно применяется и к двум полученным подмножествам. Если в подмножестве менее двух элементов, то сортировать нечего, и рекурсия завершается.
   Наша версия быстрой сортировки, разумеется, не самая быстрая среди всех возможных, но зато одна из самых простых. В качестве делящего элемента мы используем серединный элемент.
   /* qsort:сортирует v[left]…v[right] по возрастанию */
   void qsort(int v[], int left, int right)
   {
    int i, last;
    void swap(int v[], int i, int j);

    if (left ›= right) /* ничего не делается, если */
     return; /* в массиве менее двух элементов */
    swap(v, left, (left + right)/2); /* делящий элемент */
    last = left; /* переносится в v[0] */
    for(i = left+1; i ‹= right; i++) /* деление на части */
     if (v[i] ‹ v[left])
      swap(v, ++last, i);
    swap(v, left, last); /* перезапоминаем делящий элемент */
    qsort(v, left, last-1);
    qsort(v, last+1, right);
   }
   В нашей программе операция перестановки оформлена в виде отдельной функции (swap),поскольку встречается вqsortтрижды.
   /* swap:поменять местами v[i] и v[j] */
   void swap(int v[], int i, int j)
   {
    int temp;
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
   }
   Стандартная библиотека имеет функциюqsort,позволяющую сортировать объекты любого типа.
   Рекурсивная программа не обеспечивает ни экономии памяти, поскольку требуется где-то поддерживать стек значений, подлежащих обработке, ни быстродействия; но по сравнению со своим нерекурсивным эквивалентом она часто короче, а часто намного легче для написания и понимания. Такого рода программы особенно удобны для обработки рекурсивно определяемых структур данных вроде деревьев; с хорошим примером на эту тему вы познакомитесь в параграфе 6.5.
   Упражнение 4.12.Примените идеи, которые мы использовали вprintd,для написания рекурсивной версии функцииitoa;иначе говоря, преобразуйте целое число в строку цифр с помощью рекурсивной программы.
   Упражнение 4.13.Напишите рекурсивную версию функцииreverse(s),переставляющую элементы строки в ту же строку в обратном порядке.
   4.11Препроцессор языка Си
   Некоторые возможности языка Си обеспечиваются препроцессором, который работает на первом шаге компиляции. Наиболее часто используются две возможности:#include,вставляющая содержимое некоторого файла во время компиляции, и#define,заменяющая одни текстовые последовательности на другие. В этом параграфе обсуждаются условная компиляция и макроподстановка с аргументами.
   4.11.1Включение файла
   Средство#includeпозволяет, в частности, легко манипулировать наборами#defineи объявлений. Любая строка вида
   #include "имя-файла"
   или
   #include‹имя-файла›
   заменяется содержимым файла с именемимя-файла.Еслиимя-файлазаключено в двойные кавычки, то, как правило, файл ищется среди исходных файлов программы; если такового не оказалось или имя-файла заключено в угловые скобки ‹ и ›, то поиск осуществляется по определенным в реализации правилам. Включаемый файл сам может содержать в себе строки#include.
   Часто исходные файлы начинаются с нескольких строк#include,ссылающихся на общие инструкции#defineи объявленияexternили прототипы нужных библиотечных функций из заголовочных файлов вроде‹stdio.h›. (Строго говоря, эти включения не обязательно являются файлами; технические детали того, как осуществляется доступ к заголовкам, зависят от конкретной реализации.)
   Средство#include -хороший способ собрать вместе объявления большой программы. Он гарантирует, что все исходные файлы будут пользоваться одними и теми же определениями и объявлениями переменных, благодаря чему предотвращаются особенно неприятные ошибки. Естественно, при внесении изменений во включаемый файл все зависимые от него файлы должны перекомпилироваться.
   4.11.2Макроподстановка
   Определение макроподстановки имеет вид:
   #defineимя замещающий-текст
   Макроподстановка используется для простейшей замены: во всех местах, где встречается лексемаимя,вместо нее будет помещензамещающий-текст.Имена в#defineзадаются по тем же правилам, что и имена обычных переменных. Замещающий текст может быть произвольным. Обычно замещающий текст завершает строку, в которой расположено слово#define,но в длинных определениях его можно продолжить на следующих строках, поставив в конце каждой продолжаемой строки обратную наклонную черту \. Область видимости имени, определенного в#define,простирается от данного определения до конца файла. В определении макроподстановки могут фигурировать более ранние#define-определения. Подстановка осуществляется только для тех имен, которые расположены вне текстов, заключенных в кавычки. Например, если YES определено с помощью#define,то никакой подстановки в printf("YES") или в YESMAN выполнено не будет.
   Любое имя можно определить с произвольным замещающим текстом. Например:
   #define forever for(;;) /*бесконечный цикл */
   определяет новое словоforeverдля бесконечного цикла.
   Макроподстановку можно определить с аргументами, вследствие чего замещающий текст будет варьироваться в зависимости от задаваемых параметров. Например, определимmaxследующим образом:
   #define max(A, B) ((A)› (B) ? (A) : (B))
   Хотя обращения кmaxвыглядят как обычные обращения к функции, они будут вызывать только текстовую замену. Каждый формальный параметр (в данном случае A и B) будет заменяться соответствующим ему аргументом. Так, строка
   x = max(p+q, r+s);
   будет заменена на строку
   x = ((p+q)› (r+s) ? (p+q) : (r+s));
   Поскольку аргументы допускают любой вид замены, указанное определениеmaxподходит для данных любого типа, так что не нужно писать разныеmaxдля данных разных типов, как это было бы в случае задания с помощью функций.
   Если вы внимательно проанализируете работуmax,то обнаружите некоторые подводные камни. Выражения вычисляются дважды, и если они вызывают побочный эффект (из-за инкрементных операций или функций ввода-вывода), это может привести к нежелательным последствиям. Например,
   max(i++, j++) /*НЕВЕРНО */
   вызовет увеличениеiиjдважды. Кроме того, следует позаботиться о скобках, чтобы обеспечить нужный порядок вычислений. Задумайтесь, что случится, если при определении
   #define square(x) x*x /*НЕВЕРНО */
   вызватьsquare (z+1).
   Тем не менее макросредства имеют свои достоинства. Практическим примером их использования является частое применениеgetcharиputcharиз ‹stdio.h›, реализованных с помощью макросов, чтобы из6ежать расходов времени от вызова функции на каждый обрабатываемый символ. Функции в ‹ctype.h› обычно также реализуются с помощью макросов. Действие#defineможно отменить с помощью#undef:
   #undef getchar
   int getchar(void) {…}
   Как правило, это делается, чтобы заменить макроопределение настоящей функцией с тем же именем.
   Имена формальных параметров не заменяются, если встречаются в заключенных в кавычки строках. Однако, если в замещающем тексте перед формальным параметром стоит знак#,этот параметр будет заменен на аргумент, заключенный в кавычки. Это может сочетаться с конкатенацией (склеиванием) строк, например, чтобы создать макрос отладочного вывода:
   #define dprint(expr) printf(#expr " = %g\n", expr)
   Обращение к
   dprint(x/y);
   развернется в
   printf("x/y" " = %g\n", x/y);
   а в результате конкатенации двух соседних строк получим
   printf("x/y=%g\n", x/y);
   Внутри фактического аргумента каждый знак " заменяется на \", а каждая \ на \\, так что результат подстановки приводит к правильной символьной константе.
   Оператор##позволяет в макрорасширениях конкатенировать аргументы. Если в замещающем тексте параметр соседствует с ##, то он заменяется соответствующим ему аргументом, а оператор ## и окружающие его символы-разделители выбрасываются. Например, в макроопределенииpasteконкатенируются два аргумента
   #define paste(front, back) front ## back
   так чтоpaste(name, 1)сгенерирует имяname1.
   Правила вложенных использований оператора ## не определены; другие подробности, относящиеся к ##, можно найти в приложении A.
   Упражнение 4.14.Определите swap(t,x,y) в виде макроса, который осуществляет обмен значениями указанного типа t между аргументами x и y. (Примените блочную структуру.)
   4.11.3Условная компиляция
   Самим ходом препроцессирования можно управлять с помощью условных инструкций. Они представляют собой средство для выборочного включения того или иного текста программы в зависимости от значения условия, вычисляемого вовремя компиляции.
   Вычисляется константное целое выражение, заданное в строке#if.Это выражение не должно содержать ни одного оператораsizeofили приведения к типу и ни однойenum-константы. Если оно имеет ненулевое значение, то будут включены все последующие строки вплоть до#endif,или#elif,или#else. (Инструкция препроцессора#elifпохожа на else if.) Выражениеdefined(имя)в#ifесть 1, еслиимябыло определено, и 0 в противном случае.
   Например, чтобы застраховаться от повторного включения заголовочного файлаhdr.h,его можно оформить следующим образом:
   #if !defined(HDR)
   #define HDR

   /*здесь содержимое hdr.h */

   #endif
   При первом включении файлаhdr.hбудет определено имяHDR,а при последующих включениях препроцессор обнаружит, что имяHDRуже определено, и перескочит сразу на#endif.Этот прием может оказаться полезным, когда нужно избежать многократного включения одного и того же файла. Если им пользоваться систематически, то в результате каждый заголовочный файл будет сам включать заголовочные файлы, от которых он зависит, освободив от этого занятия пользователя.
   Вот пример цепочки проверок имениSYSTEM,позволяющей выбрать нужный файл для включения:
   #if SYSTEM == SYSV
    #define HDR "sysv.h"
   #elif SYSTEM == BSD
    #define HDR "bsd.h"
   #elif SYSTEM == MSDOS
    #define HDR "msdos.h"
   #else
    #define HDR "default.h"
   #endif
   #include HDR
   Инструкции#ifdefи#ifndefспециально предназначены для проверки того, определено или нет заданное в них имя. И следовательно, первый пример, приведенный выше для иллюстрации#if,можно записать и в таком виде:
   #ifndef HDR
   #define HDR

   /*здесь содержимое hdr.h */

   #endif
   Глава 5. Указатели и массивы
   Указатель -это переменная, содержащая адрес переменной. Указатели широко применяются в Си - отчасти потому, что в некоторых случаях без них просто не обойтись, а отчасти потому, что программы с ними обычно короче и эффективнее. Указатели имассивытесно связаны друг с другом: в данной главе мы рассмотрим эту зависимость и покажем, как ею пользоваться. Наряду сgotoуказатели когда-то были объявлены лучшим средством для написания малопонятных программ. Так оно и есть, если ими пользоваться бездумно. Ведь очень легко получить указатель, указывающий на что-нибудь совсем нежелательное. При соблюдении же определенной дисциплины с помощью указателей можно достичь ясности и простоты. Мы попытаемся убедить вас в этом.
   Изменения, внесенные стандартом ANSI, связаны в основном с формулированием точных правил, как работать с указателями. Стандарт узаконил накопленный положительный опыт программистов и удачные нововведения разработчиков компиляторов. Кроме того, взаменchar*в качестве типа обобщенного указателя предлагается типvoid* (указатель на void).
   5.1Указатели и адреса
   Начнем с того, что рассмотрим упрощенную схему организации памяти. Память типичной машины подставляет собой массив последовательно пронумерованных или проадресованных ячеек, с которыми можно работать по отдельности или связными кусками. Применительно к любой машине верны следующие утверждения: один байт может хранить значение типаchar,двухбайтовые ячейки могут рассматриваться как целое типаshort,а четырехбайтовые - как целые типаlong.Указатель - это группа ячеек (как правило, две или четыре), в которых может храниться адрес. Так, если c имеет типchar,аp -указатель наc,то ситуация выглядит следующим образом: [Картинка: pic_1.png] 
   Унарный оператор &выдает адрес объекта, так что инструкция
   p =&c;
   присваивает переменнойpадрес ячейкиc (говорят, чтоpуказывает наc).Оператор &применяется только к объектам, расположенным в памяти: к переменным и элементам массивов. Его операндом не может быть ни выражение, ни константа, ни регистровая переменная.
   Унарный оператор*есть операторкосвенного доступа.Примененный к указателю он выдает объект, на который данный указатель указывает. Предположим, чтоxиyимеют типint,аip -укаэатель наint.Следующие несколько строк придуманы специально для того, чтобы показать, каким образом объявляются указатели и как используются операторы &и*.
   intх = 1, у = 2, z[10];
   int *ip; /* ip -указатель на int */

   ip =&x; /*теперь ip указывает на x */
   y = *ip; /* yтеперь равен 1 */
   *ip = 0; /* xтеперь равен 0 */
   ip =&z[0]; /* ipтеперь указывает на z[0] */
   Объявленияx,yиzнам уже знакомы. Объявление указателяip
   int *ip;
   мы стремились сделать мнемоничным - оно гласит: "выражение*ipимеет типint".Синтаксис объявления переменной "подстраивается" под синтаксис выражений, в которых эта переменная может встретиться. Указанный принцип применим и в объявлениях функций. Например, запись
   double *dp, atof (char *);
   означает, что выражения*dpиatof(s)имеют типdouble,а аргумент функцииatofесть указатель наchar.
   Вы, наверное, заметили, что указателю разрешено указывать только на объекты определенного типа. (Существует одно исключение: "указатель наvoid"может указывать на объекты любого типа, но к такому указателю нельзя применять оператор косвенного доступа. Мы вернемся к этому в параграфе 5.11.)
   Еслиipуказывает наxцелочисленного типа, то*ipможно использовать в любом месте, где допустимо применениеx;например,
   *ip = *ip + 10;
   увеличивает*ipна 10.
   Унарные операторы*и &имеют более высокий приоритет, чем арифметические операторы, так что присваивание
   y = *ip + 1;
   берет то, на что указываетip,и добавляет к нему 1, а результат присваивает переменнойy.Аналогично
   *ip += 1;
   увеличивает на единицу то, на что указываетip;те же действия выполняют
   ++*ip;
   и
   (*iр)++;
   В последней записи скобки необходимы, поскольку если их не будет, увеличится значение самого указателя, а не то, на что он указывает. Это обусловлено тем, что унарные операторы*и++имеют одинаковый приоритет и порядок выполнения - справа налево.
   И наконец, так как указатели сами являются переменными, в тексте они могут встречаться и без оператора косвенного доступа. Например, еслиiqесть другой указатель наint,то
   iq = ip;
   копирует содержимоеipвiq,чтобыipиiqуказывали на один и тот же объект.
   5.2Указатели и аргументы функций
   Поскольку в Си функции в качестве своих аргументов получают значения параметров, нет прямой возможности, находясь в вызванной функции, изменить переменную вызывающей функции. В программе сортировки нам понадобилась функцияswap,меняющая местами два неупорядоченных элемента. Однако недостаточно написать
   swap(a, b);
   где функцияswapопределена следующим образом:
   void swap(intх, int у) /* НЕВЕРНО */
   {
    int temp;
    temp = х;
    x = y;
    у = temp;
   }
   Посколькуswapполучает лишь копии переменныхaиb,она не может повлиять на переменныеaиbтой программы, которая к ней обратилась. Чтобы получить желаемый эффект, вызывающей программе надо передать указатели на те значения, которые должны быть изменены:
   swap(&a,&b);
   Так как оператор &получает адрес переменной,&aесть указатель наa.В самой же функцииswapпараметры должны быть объявлены как указатели, при этом доступ к значениям параметров будет осуществляться косвенно.
   void swap(int *px, int *py) /*перестановка *px и *py */
   {
    int temp;
    temp = *рх;
    *рх = *py;
    *ру = temp;
   }
   Графически это выглядит следующим образом: в вызывающей программе: [Картинка: fig5_2.jpg] 
   Аргументы-указатели позволяют функции осуществлять доступ к объектам вызвавшей ее программы и дают возможность изменить эти объекты. Рассмотрим, например, функциюgetint,которая осуществляет ввод в свободном формате одного целого числа и его перевод из текстового представления в значение типаint.Функцияgetintдолжна возвращать значение полученного числа или сигнализировать значением EOF о конце файла, если входной поток исчерпан. Эти значения должны возвращаться по разным каналам, так как нельзя рассчитывать на то, что полученное в результате перевода число никогда не совпадет с EOF.
   Одно из решений состоит в том, чтобыgetintвыдавала характеристику состояния файла (исчерпан или не исчерпан) в качестве результата, а значение самого числа помещала согласно указателю, переданному ей в виде аргумента. Похожая схема действует и в программеscanf,которую мы рассмотрим в параграфе 7.4. Показанный ниже цикл заполняет некоторый массив целыми числами, полученными с помощьюgetint.
   int n, array[SIZE], getint (int *);

   for (n = 0; n‹ SIZE&& getint (&array[n]) != EOF; n++)
    ;
   Результат каждого очередного обращения кgetintпосылается вarray[n],иnувеличивается на единицу. Заметим, и это существенно, что функцииgetintпередается адрес элементаarray[n].Если этого не сделать, уgetintне будет способа вернуть в вызывающую программу переведенное целое число.
   В предлагаемом нами варианте функцияgetintвозвращает EOF по концу файла; нуль, если следующие вводимые символы не представляют собою числа; и положительное значение, если введенные символы представляют собой число.
   #include‹ctype.h›

   int getch (void);
   void ungetch (int);

   /* getint:читает следующее целое из ввода в *pn */
   int getint(int *pn)
   {
   int c, sign;

   while (isspace(c = getch()))
    ; /* пропуск символов-разделителей */

    if (!isdigit(c)&& c != EOF&& c != '+ '&& c != '-') {
     ungetch (c); /* не число */
     return 0;
    }
    sign = (c == '-') ? -1 : 1;
    if (с == '+' || с == '-')
     с = getch();
    for (*pn = 0; isdigit(c); c = getch())
     *pn = 10 * *pn + (c -'0');
    *pn *= sign;
    if (c != EOF)
     ungetch(c);
    return c;
   }
   Везде вgetintпод*pnподразумевается обычная переменная типаint.Функцияungetchвместе сgetch (параграф 4.3) включена в программу, чтобы обеспечить возможность отослать назад лишний прочитанный символ.
   Упражнение 5.1.Функцияgetintнаписана так, что знаки - или +, за которыми не следует цифра, она понимает как "правильное" представление нуля. Скорректируйте программу таким образом, чтобы в подобных случаях она возвращала прочитанный знак назад во ввод.
   Упражнение 5.2.Напишите функциюgetfloat -аналогgetintдля чисел с плавающей точкой. Какой тип будет иметь результирующее значение, задаваемое функциейgetfloat?
   5.3Указатели и массивы
   В Си существует связь между указателями и массивами, и связь эта настолько тесная, что эти средства лучше рассматривать вместе. Любой доступ к элементу массива, осуществляемый операцией индексирования, может быть выполнен с помощью указателя. Вариант с указателями в общем случае работает быстрее, но разобраться в нем, особенно непосвященному, довольно трудно.
   Объявление
   int a[10];
   Определяет массивaразмера 10, т. е. блок из 10 последовательных объектов с именами a[0], a[1],…, a[9]. [Картинка: pic_3.jpg] 
   Записьa[i]отсылает нас кi-му элементу массива. Еслиpaесть указатель наint,т. е. объявлен как
   int *pa;
   то в результате присваивания
   pa =&a[0];
   paбудет указывать на нулевой элементa,иначе говоря,paбудет содержать адрес элементаa[0].
   Теперь присваивание
   x = *pa;
   будет копировать содержимоеa[0]вx.
   Еслиpaуказывает на некоторый элемент массива, тоpa+1по определению указывает на следующий элемент,pa+i -наi-й элемент послеpa, apa-i -наi-й элемент передpa.Таким образом, еслиpaуказывает наa[0],то
   *(pa+1)
   есть содержимоеa[1],a+i -адресa[i], a*(pa+i) -содержимоеa[i]. [Картинка: pic_4.jpg] 
   Сделанные замечания верны безотносительно к типу и размеру элементов массиваa.Смысл слов "добавить 1 к указателю", как и смысл любой арифметики с указателями, состоит в том, чтобыpa+1указывал на следующий объект, apa+i -наi-й послеpa.
   Между индексированием и арифметикой с указателями существует очень тесная связь. По определению значение переменной или выражения типа массив есть адрес нулевого элемента массива. После присваивания
   pa =&a[0];
   раиaимеют одно и то же значение. Поскольку имя массива является синонимом расположения его начального элемента, присваиваниеpa=&a[0]можно также записать в следующем виде:
   pa = a;
   Еще более удивительно (по крайней мере на первый взгляд) то, чтоa[i]можно записать как*(a+i).Вычисляяa[i],Си сразу преобразует его в*(a+i);указанные две формы записи эквивалентны. Из этого следует, что полученные в результате применения оператора &записи&a[i]иa+iтакже будут эквивалентными, т. е. и в том и в другом случае это адресi-го элемента послеa.С другой стороны, еслиpa -указатель, то его можно использовать с индексом, т. е. записьpa[i]эквивалентна записи*(pa+i).Короче говоря, элемент массива можно изображать как в виде указателя со смещением, так и в виде имени массива с индексом.
   Между именем массива и указателем, выступающим в роли имени массива, существует одно различие.Указатель - это переменная,поэтому можно написатьpa=aилиpa++.Ноимя массива не является переменной,и записи вродеa=paилиa++не допускаются.
   Если имя массива передается функции, то последняя получает в качестве аргумента адрес его начального элемента. Внутри вызываемой функции этот аргумент является локальной переменной, содержащей адрес. Мы можем воспользоваться отмеченным фактом и написать еще одну версию функцииstrlen,вычисляющей длину строки.
   /* strlen:возвращает длину строки */
   int strlen(char *s)
   {
    int n;
    for (n = 0; *s!= '\0'; s++)
     n++;
    return n;
   }
   Так как переменнаяs -указатель, к ней применима операция ++;s++не оказывает никакого влияния на строку символов функции, которая обратилась кstrlen.Просто увеличивается на 1 некоторая копия указателя, находящаяся в личном пользовании функцииstrlen.Это значит, что все вызовы, такие как:
   strlen("3дравствуй, мир"); /* строковая константа */
   strlen(array); /* char array[100]; */
   strlen(ptr); /* char *ptr; */
   правомерны.
   Формальные параметры
   char s[];
   и
   char *s;
   в определении функции эквивалентны. Мы отдаем предпочтение последнему варианту, поскольку он более явно сообщает, чтоsесть указатель. Если функции в качестве аргумента передается имя массива, то она может рассматривать его так, как ей удобно - либо как имя массива, либо как указатель, и поступать с ним соответственно. Она может даже использовать оба вида записи, если это покажется уместным и понятным.
   Функции можно передать часть массива, для этого аргумент должен указывать на начало подмассива. Например, еслиa -массив, то в записях
   f(&a[2])
   или
   f(a+2)
   функцииfпередается адрес подмассива, начинающегося с элементаa[2].Внутри функцииfописание параметров может выглядеть как
   f(int arr[]) {…}
   или
   f(int *arr) {…}
   Следовательно, дляfтот факт, что параметр указывает на часть массива, а не на весь массив, не имеет значения.
   Если есть уверенность, что элементы массива существуют, то возможно индексирование и в "обратную" сторону по отношению к нулевому элементу; выраженияp[-1],p[-2]и т.д. не противоречат синтаксису языка и обращаются к элементам, стоящим непосредственно передp[0].Разумеется, нельзя "выходить" за границы массива и тем самым обращаться к несуществующим объектам.
   5.4Адресная арифметика
   Еслиpесть указатель на некоторый элемент массива, тоp++увеличиваетpтак, чтобы он указывал на следующий элемент, аp+=iувеличивает его, чтобы он указывал наi-й элемент после того, на который указывал ранее. Эти и подобные конструкции - самые простые примеры арифметики над указателями, называемой также адресной арифметикой.
   Си последователен и единообразен в своем подходе к адресной арифметике. Это соединение в одном языке указателей, массивов и адресной арифметики - одна из сильных его сторон. Проиллюстрируем сказанное построением простого распределителя памяти, состоящего из двух программ. Первая,alloc(n),возвращает указательpнаnпоследовательно расположенных ячеек типаchar;программой, обращающейся кalloc,эти ячейки могут быть использованы для запоминания символов. Вторая,afree(p),освобождает память для, возможно, повторной ее утилизации. Простота алгоритма обусловлена предположением, что обращения кafreeделаются в обратном порядке по отношению к соответствующим обращениям кalloc.Таким образом, память, с которой работаютallocиafree,является стеком (списком, в основе которого лежит принцип "последним вошел, первым ушел"). В стандартной библиотеке имеются функцииmallocиfree,которые делают то же самое, только без упомянутых ограничений: в параграфе 8.7 мы покажем, как они выглядят.
   Функциюallocлегче всего реализовать, если условиться, что она будет выдавать куски некоторого большого массива типаchar,который мы назовемallocbuf.Этот массив отдадим в личное пользование функциямallocиafree.Так как они имеют дело с указателями, а не с индексами массива, то другим программам знать его имя не нужно. Кроме того, этот массив можно определить в том же исходном файле, что иallocиafree,объявив егоstatic,благодаря чему он станет невидимым вне этого файла. На практике такой массив может и вовсе не иметь имени, поскольку его можно запросить с помощьюmallocу операционной системы и получить указатель на некоторый безымянный блок памяти.
   Естественно, нам нужно знать, сколько элементов массиваallocbufуже занято. Мы введем указательallocp,который будет указывать на первый свободный элемент. Если запрашивается память дляnсимволов, тоallocвозвращает текущее значениеallocp (т. е. адрес начала свободного блока) и затем увеличивает его наn,чтобы указательallocpуказывал на следующую свободную область. Если же пространства нет, тоallocвыдает нуль. Функцияafree(p)просто устанавливаетallocpв значениеp,если оно не выходит за пределы массиваallocbuf.
   Перед вызовомallос: [Картинка: pic_5.jpg] 
   После вызоваalloc: [Картинка: pic_6.jpg] 
   #define ALLOCSIZE 10000 /*размер доступного пространства */

   static char allocbuf[ALLOCSIZE]; /*память для alloc */
   static char *allocp = allocbuf; /*указатель на своб. место */

   char *alloc(int n) /*возвращает указатель на n символов */
   {
    if (allocbuf + ALLOCSIZE - allocp ›= n) {
    allocp += n; /* пространство есть */
    return allocp - n; /* старое p */
   } else /*пространства нет */
    return 0;
   }

   void afree(char *p) /*освобождает память, на которую указывает p */
   {
    if (р ›= allocbuf&& p‹ allocbuf + ALLOCSIZE)
    allocp = p;
   }
   В общем случае указатель, как и любую другую переменную, можно инициализировать, но только такими осмысленными для него значениями, как нуль или выражение, приводящее к адресу ранее определенных данных соответствующего типа. Объявление
   static char *allocp = allocbuf;
   определяетallocpкак указатель наcharи инициализирует его адресом массиваallocbuf,поскольку перед началом работы программы массивallocbufпуст. Указанное объявление могло бы иметь и такой вид:
   static char *allocp =&allocbuf[0];
   поскольку имя массива и есть адрес его нулевого элемента. Проверка
   if (allocbuf + ALLOCSIZE - allocp›= n) {/* годится */
   контролирует, достаточно ли пространства, чтобы удовлетворить запрос наnсимволов. Если памяти достаточно, то новое значение дляallocpдолжно указывать не далее чем на следующую позицию за последним элементомallocbuf.При выполнении этого требованияallocвыдает указатель на начало выделенного блока символов (обратите внимание на объявление типа самой функции). Если требование не выполняется, функцияallocдолжна выдать какой-то сигнал о том, что памяти не хватает. Си гарантирует, что нуль никогда не будет правильным адресом для данных, поэтому мы будем использовать его в качестве признака аварийного события, в нашем случае нехватки памяти.
   Указатели и целые не являются взаимозаменяемыми объектами. Константа нуль - единственное исключение из этого правила: ее можно присвоить указателю, и указатель можно сравнить с нулевой константой. Чтобы показать, что нуль - это специальное значение для указателя, вместо цифры нуль, как правило, записываютNULL -константу, определенную в файле ‹stdio.h› (I.B.: вообще-то эта константа определена в ‹stddef.h› или ‹string.h›). С этого момента и мы будем ею пользоваться. Проверки
   if (allocbuf + ALLOCSIZE - allocp›= n) {/* годится */
   и
   if (p›= allocbuf&& p‹ allocbuf + ALLOCSIZE)
   демонстрируют несколько важных свойств арифметики с указателями. Во- первых, при соблюдении некоторых правил указатели можно сравнивать.
   Еслиpиqуказывают на элементы одного массива, то к ним можно применять операторы отношения==,!=,‹,›=и т. д. Например, отношение вида
   p‹ q
   истинно, еслиpуказывает на более ранний элемент массива, чемq.Любой указатель всегда можно сравнить на равенство и неравенство с нулем. А вот для указателей, не указывающих на элементы одного массива, результат арифметических операций или сравнений не определен. (Существует одно исключение: в арифметике с указателями можно использовать адрес несуществующего "следующего за массивом" элемента, т. е. адрес того "элемента", который станет последним, если в массив добавить еще один элемент.)
   Во-вторых, как вы уже, наверное, заметили, указатели и целые можно складывать и вычитать. Конструкция
   p + n
   означает адрес объекта, занимающегоn-е место после объекта, на который указываетp.Это справедливо безотносительно к типу объекта, на который указываетp;nавтоматически домножается на коэффициент, соответствующий размеру объекта. Информация о размере неявно присутствует в объявленииp.Если, к примеру,intзанимает четыре байта, то коэффициент умножения будет равен четырем.
   Допускается также вычитание указателей. Например, еслиpиqуказывают на элементы одного массива иp‹q,тоq-p+1есть число элементов отpдоqвключительно. Этим фактом можно воспользоваться при написании еще одной версииstrlen:
   /* strlen:возвращает длину строки s */
   int strlen(char *s)
   {
    char *p = s;
    while (*p != '\0')
     p++;
    return p - s;
   }
   В своем объявленииpинициализируется значениемs,т. е. вначалеpуказывает на первый символ строки. На каждом шаге циклаwhileпроверяется очередной символ; цикл продолжается до тех пор, пока не встретится '\0'. Каждое продвижение указателяpна следующий символ выполняется инструкциейp++,и разностьp-sдает число пройденных символов, т. е. длину строки. (Число символов в строке может быть слишком большим, чтобы хранить его в переменной типаint.Типptrdiff_t,достаточный для хранения разности (со знаком) двух указателей, определен в заголовочном файле‹stddef.h›.Однако, если быть очень осторожными, нам следовало бы для возвращаемого результата использовать типsize_t,в этом случае наша программа соответствовала бы стандартной библиотечной версии. Типsize_tесть тип беззнакового целого, возвращаемого операторомsizeof.
   Арифметика с указателями учитывает тип: если она имеет дело со значениямиfloat,занимающими больше памяти, чемchar,иp -указатель наfloat,тоp++продвинетpна следующее значениеfloat.Это значит, что другую версиюalloc,которая имеет дело с элементами типаfloat,а неchar,можно получить простой заменой вallocиafreeвсехcharнаfloat.Все операции с указателями будут автоматически откорректированы в соответствии с размером объектов, на которые указывают указатели.
   Можно производить следующие операции с указателями: присваивание значения указателя другому указателю того же типа, сложение и вычитание указателя и целого, вычитание и сравнение двух указателей, указывающих на элементы одного и того же массива, а также присваивание указателю нуля и сравнение указателя с нулем. Других операций с указателями производить не допускается. Нельзя складывать два указателя, перемножать их, делить, сдвигать, выделять разряды; указатель нельзя складывать со значением типаfloatилиdouble;указателю одного типа нельзя даже присвоить указатель другого типа, не выполнив предварительно операции приведения (исключение составляют лишь указатели типа void*).
   5.5Символьные указатели функции
   Строковая константа,написанная в виде
   "Я строка"
   есть массив символов. Во внутреннем представлении этот массив заканчивается нулевым символом '\0', по которому программа может найти конец строки. Число занятых ячеек памяти на одну больше, чем количество символов, помещенных между двойными кавычками.
   Чаще всего строковые константы используются в качестве аргументов функций, как, например, в
   printf("здравствуй, мир\n");
   Когда такая символьная строка появляется в программе, доступ к ней осуществляется через символьный указатель;printfполучает указатель на начало массива символов. Точнее, доступ к строковой константе осуществляется через указатель на ее первый элемент.
   Строковые константы нужны не только в качестве аргументов функций. Если, например, переменнуюpmessageобъявить как
   char *pmessage;
   то присваивание
   pmessage = "now is the time";
   поместит в нее указатель на символьный массив, при этом сама строка не копируется, копируется лишь указатель на нее. Операции для работы со строкой как с единым целым в Си не предусмотрены.
   Существует важное различие между следующими определениями:
   char amessage[] = "now is the time"; /*массив */
   char *pmessage = "now is the time"; /*указатель */
   amessage -это массив, имеющий такой объем, что в нем как раз помещается указанная последовательность символов и '\0'. Отдельные символы внутри массива могут изменяться, ноamessageвсегда указывает на одно и то же место памяти. В противоположность емуpmessageесть указатель, инициализированный так, чтобы указывать на строковую константу. А значение указателя можно изменить, и тогда последний будет указывать на что-либодругое. Кроме того, результат будет неопределен, если вы попытаетесь изменить содержимое константы. [Картинка: pic_7.jpg] 
   Дополнительные моменты, связанные с указателями и массивами, проиллюстрируем на несколько видоизмененных вариантах двух полезных программ, взятых нами из стандартной библиотеки. Первая из них, функцияstrcpy (s, t),копирует строкуtв строкуs.Хотелось бы написать прямоs = t,но такой оператор копирует указатель, а не символы. Чтобы копировать символы, нам нужно организовать цикл. Первый вариантstrcpy,с использованием массива, имеет следующий вид:
   /* strcpy:копирует t в s; вариант с индексируемым массивом*/
   void strcpy(char *s, char *t)
   {
    int i;
    i = 0;
    while ((s[i] = t[i]) != '\0')
     i++;
   }
   Для сравнения приведем версиюstrcpyс указателями:
   /* strcpy:копирует t в s: версия 1 (с указателями) */
   void strcpy(char *s, char *t)
   {
    while ((*s = *t) != '\0') {
     s++;
     t++;
    }
   }
   Поскольку передаются лишь копии значений аргументов,strcpyможет свободно пользоваться параметрамиsиtкак своими локальными переменными. Они должным образом инициализированы указателями, которые продвигаются каждый раз на следующий символ в каждом из массивов до тех пор, пока в копируемой строкеtне встретится '\0'.
   На практикеstrcpyтак не пишут. Опытный программист предпочтет более короткую запись:
   /* strcpy:копирует t в s; версия 2 (с указателями) */
   void strcpy(char *s, char *t)
   {
    while ((*s++ = *t++) != '\0')
     ;
   }
   Приращениеsиtздесь осуществляется в управляющей части цикла. Значением*t++является символ, на который указывает переменнаяtперед тем, как ее значение будет увеличено; постфиксный оператор ++ не изменяет указательt,пока не будет взят символ, на который он указывает. То же в отношенииs:сначала символ запомнится в позиции, на которую указывает старое значениеs,и лишь после этого значение переменнойsувеличится. Пересылаемый символ является одновременно и значением, которое сравнивается с '\0'. В итоге копируются все символы, включая и заключительный символ '\0'.
   Заметив, что сравнение с '\0' здесь лишнее (поскольку в Си ненулевое значение выражения в условии трактуется и как его истинность), мы можем сделать еще одно и последнее сокращение текста программы:
   /* strcpy:копирует t в s; версия 3 (с указателями) */
   void strcpy(char *s, char *t)
   {
    while (*s++ = *t++)
     ;
   }
   Хотя на первый взгляд то, что мы получили, выглядит загадочно, все же такая запись значительно удобнее, и следует освоить ее, поскольку в Си-программах вы будете с ней часто встречаться.
   Что касается функцииstrcpyиз стандартной библиотеки‹string.h›то она возвращает в качестве своего результата еще и указатель на новую копию строки.
   Вторая программа, которую мы здесь рассмотрим, этоstrcmp(s,t).Она сравнивает символы строкsиtи возвращает отрицательное, нулевое или положительное значение, если строкаsсоответственно лексикографически меньше, равна или больше, чем строкаt.Результат получается вычитанием первых несовпадающих символов изsиt.
   /* strcmp:выдает ‹ 0 при s ‹ t, 0 при s - t, › 0 при s › t */
   int strcmp(char *s, char *t)
   {
    int i;
    for (i = 0; s[i] == t[i]; i++)
     if (s[i] == '\0')
      return 0;
    return s[i] - t[i];
   }
   Та же программа с использованием указателей выглядит так:
   /* strcmp:выдает ‹ 0 при s ‹ t, 0 при s - t, › 0 при s › t */
   int strcmp(char *s, char *t)
   {
    for (; *s == *t; s++, t++)
     if (*s == '\0')
      return 0;
    return *s - *t;
   }
   Поскольку операторы++и-могут быть или префиксными, или постфиксными, встречаются (хотя и не так часто) другие их сочетания с оператором*.Например.
   *--p;
   уменьшитpпрежде, чем по этому указателю будет получен символ. Например, следующие два выражения:
   *p++ = val; /*поместить val в стек */
   val = *--p; /*взять из стека значение и поместить в val */
   являются стандартными для посылки в стек и взятия из стека (см. параграф 4.3.).
   Объявления функций, упомянутых в этом параграфе, а также ряда других стандартных функций, работающих со строками, содержатся в заголовочном файле‹string.h›.
   Упражнение 5.3.Используя указатели, напишите функциюstrcat,которую мы рассматривали в главе 2 (функцияstrcat(s,t)копирует строкуtв конец строкиs).
   Упражнение 5.4.Напишите функциюstrend(s,t),которая выдает 1, если строкаtрасположена в конце строкиs,и нуль в противном случае.
   Упражнение 5.5.Напишите варианты библиотечных функцийstrncpy,strncatиstrncmp,которые оперируют с первыми символами своих аргументов, число которых не превышаетn.Например,strncpy(t,s,n)копирует не болееnсимволовtвs.Полные описания этих функций содержатся в приложении B.
   Упражнение 5.6.Отберите подходящие программы из предыдущих глав и упражнений и перепишите их, используя вместо индексирования указатели. Подойдут, в частности, программыgetline (главы 1 и 4),atoi,itoaи их варианты (главы 2, 3 и 4),reverse (глава 3), а такжеstrindexиgetop (глава 4).
   5.6Массивы указателей, указатели на указатели
   Как и любые другие переменные, указатели можно группировать в массивы. Для иллюстрации этого напишем программу, сортирующую в алфавитном порядке текстовые строки; это будет упрощенный вариант программыsortсистемы UNIX.
   В главе 3 мы привели функцию сортировки по Шеллу, которая упорядочивает массив целых, а в главе 4 улучшили ее, повысив быстродействие. Те же алгоритмы используются издесь, однако, теперь они будут обрабатывать текстовые строки, которые могут иметь разную длину и сравнение или перемещение которых невозможно выполнить за одну операцию. Нам необходимо выбрать некоторое представление данных, которое бы позволило удобно и эффективно работать с текстовыми строками произвольной длины.
   Для этого воспользуемся массивом указателей на начала строк. Поскольку строки в памяти расположены вплотную друг к другу, к каждой отдельной строке доступ просто осуществлять через указатель на ее первый символ. Сами указатели можно организовать в виде массива. Одна из возможностей сравнить две строки - передать указатели на них функцииstrcmp.Чтобы поменять местами строки, достаточно будет поменять местами в массиве их указатели (а не сами строки). [Картинка: pic_8.jpg] 
   Здесь снимаются сразу две проблемы: одна - связанная со сложностью управления памятью, а вторая - с большими накладными расходами при перестановках самих строк. Процесс сортировки распадается на три этапа:
   чтение всех строк из ввода
   сортировка введенных строк
   печать их по порядку
   Как обычно, выделим функции, соответствующие естественному делению задачи, и напишем главную программуmain,управляющую этими функциями. Отложим на время реализацию этапа сортировки и сосредоточимся на структуре данных и вводе-выводе.
   Программа ввода должна прочитать и запомнить символы всех строк, а также построить массив указателей на строки. Она, кроме того, должна подсчитать число введенных строк - эта информация понадобится для сортировки и печати. Так как функция ввода может работать только с конечным числом строк, то, если их введено слишком много, она будет выдавать некоторое значение, которое никогда не совпадет с количеством строк, например -1.
   Программа вывода занимается только тем, что печатает строки, причем в том порядке, в котором расположены указатели на них в массиве.
   #include‹stdio.h›
   #include‹string.h›

   #define MAXLINES 5000 /*максимальное число строк */

   char *lineptr[MAXLINES]; /*указатели на строки */

   int readlines(char *lineptr[], int nlines);
   void writelines(char *lineptr[], int nlines);
   void qsort(char *lineptr[], int left, int right);

   /*сортировка строк */
   main()
   {
    int nlines; /* количество прочитанных строк */

    if ((nlines = readlines(lineptr, MAXLINES)) ›= 0) {
     qsort(lineptr, 0, nlines-1);
     writelines(lineptr, nlines);
     return 0;
    } else {
     printf("ошибка: слишком много строк\n");
     return 1;
    }
   }

   #define MAXLEN 1000 /*максимальная длина строки */
   int getline(char *, int);
   char *alloc(int);

   /* readlines:чтение строк */
   int readlines(char *lineptr[], int maxlines)
   {
    int len, nlines;
    char *p, line[MAXLEN];

    nlines = 0;
    while ((len = getline(line, MAXLEN)) › 0)
     if (nlines ›= maxlines || (p = alloc(len)) == NULL)
      return -1;
     else {
      line[len-1] = '\0'; /* убираем символ \n */
      strcpy(p, line);
      lineptr[nlines++] = p;
     }
    return nlines;
   }

   /* writelines:печать строк */
   void writelines(char *lineptr[], int nlines)
   {
    int i;
    for (i = 0; i ‹ nlines; i++)
     printf("%s\n", lineptr[i]);
   }
   Функцияgetlineвзята из параграфа 1.9. Основное новшество здесь - объявлениеlineptr:
   char *lineptr[MAXLINES];
   в котором сообщается, чтоlineptrесть массив из MAXLINES элементов, каждый из которых представляет собой указатель наchar.Иначе говоря,lineptr[i] -указатель на символ, а*lineptr[i] -символ, на который он указывает (первый символi-й строки текста).
   Так какlineptr -имя массива, его можно трактовать как указатель, т. е. так же, как мы это делали в предыдущих примерах, иwritelinesпереписать следующим образом:
   /* writelines:печать строк */
   void writelines(char *lineptr[], int nlines)
   {
    while (nlines-- › 0)
     printf("%s\n", *lineptr++);
   }
   Вначале*lineptrуказывает на первую строку: каждое приращение указателя приводит к тому, что*lineptrуказывает на следующую строку, и делается это до тех пор, покаnlinesне станет нулем.
   Теперь, когда мы разобрались с вводом и выводом, можно приступить к сортировке. Быструю сортировку, описанную в главе 4, надо несколько модифицировать: нужно изменить объявления, а операцию сравнения заменить обращением кstrcmp.Алгоритм остался тем же, и это дает нам определенную уверенность в его правильности.
   /* qsort:сортирует v[left]…v[right] по возрастанию */
   void qsort(char *v[], int left, int right)
   {
    int i, last;
    void swap(char *v[], int i, int j);

    if (left ›= right) /* ничего не делается, если в массиве */
     return; /* менее двух элементов */

    swap(v, left, (left+right)/2);
    last = left;
    for(i = left+1; i ‹= right; i++)
     if (strcmp(v[i], v[left]) ‹ 0)
      swap(v, ++last, i);
    swap(v, left, last);
    qsort(v, left, last-1);
    qsort(v, last+1, right);
   }
   Небольшие поправки требуются и в программе перестановки.
   /* swap:поменять местами v[i] и v[j] */
   void swap(char *v[], int i, int j)
   {
    char *temp;
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
   }
   Так как каждый элемент массиваv (т. е.lineptr)является указателем на символ,tempдолжен иметь тот же тип, что иv -тогда можно будет осуществлять пересылки междуtempи элементамиv.
   Упражнение 5.7.Напишите новую версиюreadlines,которая запоминала бы строки в массиве, определенном вmain,а не запрашивала память посредством программыalloc.Насколько быстрее эта программа?
   5.7Многомерные массивы
   В Си имеется возможность задавать прямоугольные многомерные массивы, правда, на практике по сравнению с массивами указателей они используются значительно реже. Вэтом параграфе мы продемонстрируем некоторые их свойства.
   Рассмотрим задачу перевода даты "день-месяц" в "день года" и обратно. Например, 1 марта - это 60-й день невисокосного или 61-й день високосного года. Определим две функции для этих преобразований: функцияday_of_yearбудет преобразовывать месяц и день в день года, amonth_day -день года в месяц и день. Поскольку последняя функция вычисляет два значения, аргументы месяц и день будут указателями. Так вызов
   month_day(1988, 60,&m,&d)
   присваивает переменнойmзначение 2, аd - 29 (29февраля).
   Нашим функциям нужна одна и та же информация, а именно таблица, содержащая числа дней каждого месяца. Так как для високосного и невисокосного годов эти таблицы будут различаться, проще иметь две отдельные строки в двумерном массиве, чем во время вычислений отслеживать особый случай с февралем. Массив и функции, выполняющие преобразования, имеют следующий вид:
   static char daytab[2][13] = {
    {0, 31, 28, 31. 30, 31, 30, 31, 31, 30, 31, 30, 31},
    {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
   }

   /* day_of_year:определяет день года по месяцу и дню */
   int day_of_year(int year, int month, int day)
   {
    int i, leap;
    leap = year % 4 == 0&& year % 100 !=0 || year % 400 == 0;
    for (i = 1; i ‹ month; i++)
    day += daytab[leap][i];
    return day;
   }

   /* month_day:определяет месяц и день по дню года */
   void month_day(int year, int yearday, int *pmonth, int *pday)
   {
    int i, leap;
    leap = year % 4 == 0&& year % 100 != 0 || year % 400 == 0;
    for (i = 1; yearday › daytab[leap][i]; i++)
    yearday -= daytab[leap][i];
    *pmonth = i;
    *pday = yearday;
   }
   Напоминаем, что арифметическое значение логического выражения (например выражения, с помощью которого вычислялосьleap)равно либо нулю (ложь), либо единице (истина), так что мы можем использовать его как индекс в массивеdaytab.
   Массивdaytabдолжен быть внешним по отношению к обеим функциямday_of_yearиmonth_day,так как он нужен и той и другой. Мы сделали его типаchar,чтобы проиллюстрировать законность применения типаcharдля малых целых без знака.
   Массивdaytab -это первый массив из числа двумерных, с которыми мы еще не имели дела. Строго говоря, в Си двумерный массив рассматривается как одномерный массив, каждый элемент которого - также массив. Поэтому индексирование изображается так:
   daytab[i][j] /* [строка] [столбец] */
   а не так:
   daytab[i,j] /*НЕВЕРНО */
   Особенность двумерного массива в Си заключается лишь в форме записи, в остальном его можно трактовать почти так же, как в других языках. Элементы запоминаются строками, следовательно, при переборе их в том порядке, как они расположены в памяти, чаще будет изменяться самый правый индекс.
   Массив инициализируется списком начальных значений, заключенным в фигурные скобки; каждая строка двумерного массива инициализируется соответствующим подсписком. Нулевой столбец добавлен в началоdaytabлишь для того, чтобы индексы, которыми мы будем пользоваться, совпадали с естественными номерами месяцев от 1 до 12. Экономить пару ячеек памяти здесь нет никакого смысла, а программа, в которой уже не надо корректировать индекс, выглядит более ясной.
   Если двумерный массив передается функции в качестве аргумента, то объявление соответствующего ему параметра должно содержать количество столбцов; количество строк в данном случае несущественно, поскольку, как и прежде, функции будет передан указатель на массив строк, каждая из которых есть массив из 13 значений типаint. Bнашем частном случае мы имеем указатель на объекты, являющиеся массивами из 13 значений типаint.Таким образом, если массивdaytabпередается некоторой функцииf,то эту функцию можно было бы определить следующим образом:
   f(int daytab[2][13]) {…}
   Вместо этого можно записать
   f(int daytab[][13]) {…}
   поскольку число строк здесь не имеет значения, или
   f(int (*daytab)[13]) {…}
   Последняя запись объявляет, что параметр есть указатель на массив из 13 значений типаint.Скобки здесь необходимы, так как квадратные скобки[]имеют более высокий приоритет, чем*.Без скобок объявление
   int *daytab[13]
   определяет массив из 13 указателей наchar.В более общем случае только первое измерение (соответствующее первому индексу) можно не задавать, все другие специфицировать необходимо. В параграфе 5.12 мы продолжим рассмотрение сложных объявлений.
   Упражнение 5.8.В функцияхday_of_yearиmonth_dayнет никаких проверок правильности вводимых дат. Устраните этот недостаток.
   5.8Инициализация массивов указателей
   Напишем функциюmonth_name(n),которая возвращает указатель на строку символов, содержащий названиеn-го месяца. Эта функция идеальна для демонстрации использования статического массива. Функцияmonth_nameимеет в своем личном распоряжении массив строк, на одну из которых она и возвращает указатель. Ниже покажем, как инициализируется этот массив имен.
   Синтаксис задания начальных значений аналогичен синтаксису предыдущих инициализаций:
   /* month_name:возвращает имя n-го месяца */
   char *month_name(int n)
   {
    static char *name[] = {
     "Неверный месяц",
     "Январь","Февраль","Март","Апрель","Май","Июнь",
     "Июль","Август","Сентябрь","Октябрь","Ноябрь","Декабрь"
    };
    return (n ‹ 1 || n › 12) ? name[0] : name[n];
   }
   Объявлениеnameмассивом указателей на символы такое же, как и объявлениеlineptrв программе сортировки. Инициализатором служит список строк, каждой из которых соответствует определенное место в массиве. Символыi-й строки где-то размещены, и указатель на них запоминается вname[i].Так как размер массиваnameне специфицирован, компилятор вычислит его по количеству заданных начальных значений.
   5.9Указатели против многомерных массивов
   Начинающие программировать на Си иногда не понимают, в чем разница между двумерным массивом и массивом указателей вродеnameиз приведенного примера. Для двух следующих определений:
   int a[10][20];
   int *b[10];
   записиa[3][4]иb[3][4]будут синтаксически правильным обращением к некоторому значению типаint.Однако толькоaявляется истинно двумерным массивом: для двухсот элементов типаintбудет выделена память, а вычисление смещения элементаa[строка][столбец]от начала массива будет вестись по формуле20 *строка + столбец,учитывающей его прямоугольную природу. Дляbже определено только 10 указателей, причем без инициализации. Инициализация должна задаваться явно -либо статически, либо в программе. Предположим, что каждый элементbуказывает на двадцатиэлементный массив, в результате где-то будут выделены пространство, в котором разместятся 200 значений типаint,и еще 10 ячеек для указателей. Важное преимущество массива указателей в том, что строки такого массива могут иметь разные длины. Таким образом, каждый элемент массиваbне обязательно указывает на двадцатиэлементный вектор; один может указывать на два элемента, другой - на пятьдесят, а некоторые и вовсе могут ни на что не указывать.
   Наши рассуждения здесь касались целых значений, однако чаще массивы указателей используются для работы со строками символов, различающимися по длине, как это было в функцииmonth_name.Сравните определение массива указателей и соответствующий ему рисунок:
   char *name[] = {"Неправильный месяц", "Янв", "Февр", "Март"}; [Картинка: pic_9.jpg] 
   с объявлением и рисунком для двумерного массива:
   char aname[][15] = {"Неправ. месяц", "Янв", "Февр", "Март"}; [Картинка: pic_10.jpg] 
   Упражнение 5.9.Перепишите программыday_of_yearиmonth_day,используя вместо индексов указатели.
   5.10Аргументы командной строки
   В операционной среде, обеспечивающей поддержку Си, имеется возможность передать аргументы или параметры запускаемой программе с помощью командной строки. В момент вызоваmainполучает два аргумента. В первом, обычно называемомargc (сокращение отargument count),стоит количество аргументов, задаваемых в командной строке. Второй,argv (отargument vector),является указателем на массив символьных строк, содержащих сами аргументы. Для работы с этими строками обычно используются указатели нескольких уровней.
   Простейший пример - программаecho ("эхо"), которая печатает аргументы своей командной строки в одной строчке, отделяя их друг от друга пробелами. Так, команда
   echoЗдравствуй, мир!
   Напечатает
   Здравствуй, мир!
   По соглашениюargv[0]есть имя вызываемой программы, так что значениеargcникогда не бывает меньше 1. Еслиargcравен 1, то в командной строке после имени программы никаких аргументов нет. В нашем примереargcравен 3, и соответственноargv[0],argv[1]иargv[2]суть строки"echo","Здравствуй,"и"мир!".Первый необязательный аргумент - этоargv[1],последний -argv[argc-1].Кроме того, стандарт требует, чтобыargv[argc]всегда был пустым указателем. [Картинка: pic_11.jpg] 
   Первая версия программыechoтрактуетargvкак массив символьных указателей.
   #include‹stdio.h›

   /*эхо аргументов командной строки: версия 1 */
   main(int argc, char *argv[])
   {
    int i;
    for (i = 1; i ‹ argc; i++)
     printf("%s%s", argv[i], (i ‹ argc-1) ? " " : ");
    printf("\n");
    return 0;
   }
   Так какargv -это указатель на массив указателей, мы можем работать с ним как с указателем, а не как с индексируемым массивом. Следующая программа основана на приращенииargv,он приращивается так, что его значение в каждый отдельный момент указывает на очередной указатель наchar;перебор указателей заканчивается, когда исчерпанargc.
   #include‹stdio.h›

   /*эхо аргументов командной строки; версия 2 */
   main(int argc, char *argv[])
   {
    while (--argc › 0)
     printf("%s%s", *++argv, (argc › 1) ? " " : ");
    print f("\n");
    return 0;
   }
   Аргументargv -указатель на начало массива строк аргументов. Использование в++argvпрефиксного оператора++приведет к тому, что первым будет напечатанargv[1],а неargv[0].Каждое очередное приращение указателя дает нам следующий аргумент, на который указывает*argv.В это же время значениеargcуменьшается на 1, и, когда оно станет нулем, все аргументы будут напечатаны. Инструкциюprintfможно было бы написать и так:
   printf((argc› 1)? "%s ": "%s", *++argv);
   Как видим, формат вprintfтоже может быть выражением.
   В качестве второго примера возьмем программу поиска образца, рассмотренную в параграфе 4.1, и несколько усовершенствуем ее. Если вы помните, образец для поиска мы "вмонтировали" глубоко в программу, а это, очевидно, не лучшее решение. Построим нашу программу по аналогии сgrepиз UNIXa, т. е. так, чтобы образец для поиска задавался первым аргументом в командной строке.
   #include‹stdio.h›
   #include‹string.h›
   #define MAXLINE 1000

   int getline(char *line, int max);
   /* find:печать строк с образцом, заданным 1-м аргументом */
   main(int argc, char *argv[])
   {
    char line[MAXLINE];
    int found = 0;

    if (argc != 2)
     printf("Используйте в find образец\n");
    else
     while (getline(line, MAXLINE) › 0)
      if (strstr(line, argv[1]) ›= NULL) {
       printf ("%s", line);
       found++;
      }
    return found;
   }
   Стандартная функцияstrstr(s,t)возвращает указатель на первую встретившуюся строкуtв строкеsили NULL, если таковой вsне встретилось. Функция объявлена в заголовочном файле ‹string.h›.
   Эту модель можно развивать и дальше, чтобы проиллюстрировать другие конструкции с указателями. Предположим, что мы вводим еще два необязательных аргумента. Один из них предписывает печатать все строки, кроме тех, в которых встречается образец; второй - перед каждой выводимой строкой печатать ее порядковый номер.
   По общему соглашению для Си-программ в системе UNIX знак минус перед аргументом вводит необязательный признак или параметр. Так, если-xслужит признаком слова "кроме", которое изменяет задание на противоположное, а-nуказывает на потребность в нумерации строк, то команда
   find -x -nобразец
   напечатает все строки, в которых не найден указанный образец, и, кроме того, перед каждой строкой укажет ее номер.
   Необязательные аргументы разрешается располагать в любом порядке, при этом лучше, чтобы остальная часть программы не зависела от числа представленных аргументов. Кроме того, пользователю было бы удобно, если бы он мог комбинировать необязательные аргументы, например так:
   find -nxобразец
   А теперь запишем нашу программу.
   #include‹stdio.h›
   #include‹string.h›
   #define MAXLINE 1000

   int getline(char *line, int max);

   /* find:печать строк образцами из 1-го аргумента */
   main(int argc, char *argv[])
   {
    char line[MAXLINE];
    long lineno = 0;
    int c, except = 0, number = 0, found = 0;

    while (--argc › 0&& (*++argv)[0] == '-')
     while (c = *++argv[0])
      switch (c) {
      case 'x':
       except = 1;
       break;
      case 'n':
       number = 1;
       break;
      default:
       printf("find: неверный параметр %c\n", c);
       argc = 0;
       found = -1;
       break;
      }
    if (argc != 1)
     printf("Используйте: find -x -n образец\n");
    else
     while (getline(line, MAXLINE) › 0) {
      lineno++;
      if ((strstr(line, *argv) != NULL) != except) {
       if (number)
        printf("%ld:", lineno);
       printf("%s", line);
       found++;
      }
     }
    return found;
   }
   Перед получением очередного аргументаargcуменьшается на 1, аargv "перемещается" на следующий аргумент. После завершения цикла при отсутствии ошибокargcсодержит количество еще не обработанных аргументов, aargvуказывает на первый из них. Таким образом,argcдолжен быть равен 1, a*argvуказывать на образец. Заметим, что*++argvявляется указателем на аргумент- строку, a(*++argv)[0] -его первым символом, на который можно сослаться и другим способом:
   **++argv;
   Поскольку оператор индексирования[]имеет более высокий приоритет, чем*и++,круглые скобки здесь обязательны, без них выражение трактовалось бы так же, как*++(argv[0]).Именно такое выражение мы применим во внутреннем цикле, где просматриваются символы конкретного аргумента. Во внутреннем цикле выражение*++argv[0]приращивает указательargv[0].
   Потребность в более сложных выражениях для указателей возникает не так уж часто. Но если такое случится, то разбивая процесс вычисления указателя на два или три шага, вы облегчите восприятие этого выражения.
   Упражнение 5.10.Напишите программуexpr,интерпретирующую обратную польскую запись выражения, задаваемого командной строкой, в которой каждый оператор и операнд представлены отдельным аргументом. Например,
   expr 2 3 4 + *
   вычисляется так же, как выражение 2*(3+4).
   Упражнение 5.11.Усовершенствуйте программыentabиdetab (см. упражнения 1.20 и 1.21) таким образом, чтобы через аргументы можно было задавать список "стопов" табуляции.
   Упражнение 5.12.Расширьте возможностиentabиdetabтаким образом, чтобы при обращении вида
   entab -m +n
   "стопы" табуляции начинались сm-й позиции и выполнялись через каждыеnпозиций. Разработайте удобный для пользователя вариант поведения программы по умолчанию (когда нет никаких аргументов).
   Упражнение 5.13.Напишите программуtail,печатающуюnпоследних введенных строк. По умолчанию значениеnравно 10, но при желанииnможно задать с помощью аргумента. Обращение вида
   tail -n
   печатаетnпоследних строк. Программа должна вести себя осмысленно при любых входных данных и любом значенииn.Напишите программу так, чтобы наилучшим образом использовать память; запоминание строк организуйте, как в программе сортировки, описанной в параграфе 5.6, а не на основе двумерного массива с фиксированным размером строки.
   5.11Указатели на функции
   В Си сама функция не является переменной, но можно определить указатель на функцию и работать с ним, как с обычной переменной: присваивать, размещать в массиве, передавать в качестве параметра функции, возвращать как результат из функции и т. д. Для иллюстрации этих возможностей воспользуемся программой сортировки, которая уже встречалась в настоящей главе. Изменим ее так, чтобы при задании необязательного аргумента -n вводимые строки упорядочивались по их числовому значению, а не в лексикографическом порядке.
   Сортировка, как правило, распадается на три части: на сравнение, определяющее упорядоченность пары объектов; перестановку, меняющую местами пару объектов, и сортирующий алгоритм, который осуществляет сравнения и перестановки до тех пор, пока все объекты не будут упорядочены. Алгоритм сортировки не зависит от операций сравнения и перестановки, так что передавая ему в качестве параметров различные функции сравнения и перестановки, его можно настроить на различные критерии сортировки.
   Лексикографическое сравнение двух строк выполняется функциейstrcmp (мы уже использовали эту функцию в ранее рассмотренной программе сортировки); нам также потребуется программаnumcmp,сравнивающая две строки как числовые значения и возвращающая результат сравнения в том же виде, в каком его выдаетstrcmp.Эти функции объявляются передmain,а указатель на одну из них передается функцииqsort.Чтобы сосредоточиться на главном, мы упростили себе задачу, отказавшись от анализа возможных ошибок при задании аргументов.
   #include‹stdio.h›
   #include‹string.h›

   #define MAXLINES 5000 /*максимальное число строк */
   char *lineptr[MAXLINES]; /*указатели на строки текста */

   int readlines(char *lineptr[], int nlines);
   void writelines(char *lineptr[], int nlines);
   void qsort(void *lineptr[], int left, int right,
   int (*comp)(void *, void *));
   int numcmp(char *, char *);

   /*сортировка строк */
   main(int argc, char *argv[])
   {
    int nlines; /* количество прочитанных строк */
    int numeric = 0; /* 1, если сорт. по числ. знач. */
    if (argc › 1&& strcmp(argv[1], "-n") == 0)
     numeric = 1;
    if ((nlines = readlines(lineptr, MAXLINES)) ›= 0) {
     qsort((void **) lineptr, 0, nlines-1,
      (int (*)(void*,void*))(numeric ? numcmp : strcmp));
     writelines(lineptr, nlines);
     return 0;
    } else {
     printf("Bведено слишком много строк\n");
     return 1;
    }
   }
   В обращениях к функциямqsort,strcmpиnumcmpих имена трактуются как адреса этих функций, поэтому оператор&перед ними не нужен, как он не был нужен и перед именем массива.
   Мы написалиqsortтак, чтобы она могла обрабатывать данные любого типа, а не только строки символов. Как видно из прототипа, функцияqsortв качестве своих аргументов ожидает массив указателей, два целых значения и функцию с двумя аргументами-указателями. В качестве аргументов-указателей заданы указатели обобщенного типаvoid *.Любой указатель можно привести к типуvoid *и обратно без потери информации, поэтому мы можем обратиться кqsort,предварительно преобразовав аргументы вvoid *.Внутри функции сравнения ее аргументы будут приведены к нужному ей типу. На самом деле эти преобразования никакого влияния на представления аргументов не оказывают, они лишь обеспечивают согласованность типов для компилятора.
   /* qsort:сортирует v[left]…v[right] по возрастанию */
   void qsort(void *v[], int left, int right, int (*comp)(void *, void *))
   {
    int i, last;
    void swap(void *v[], int, int);

    if (left ›= right) /* ничего не делается, если */
     return; /* в массиве менее двух элементов */
    swap(v, left, (left + right)/2);
    last = left;
    for (i = left+1; i ‹= right; i++)
     if ((*comp)(v[i], v[left]) ‹ 0)
      swap(v, ++last, i);
    swap(v, left, last);
    qsort(v, left, last-1, comp);
    qsort(v, last+1, right, comp);
   }
   Повнимательней приглядимся к объявлениям. Четвертый параметр функции qsort:
   int (*comp)(void *, void *)
   сообщает, чтоcomp -это указатель на функцию, которая имеет два аргумента- указателя и выдает результат типаint.Использованиеcompв строке
   if ((*comp)(v[i], v[left])‹ 0)
   согласуется с объявлением "comp -это указатель на функцию", и, следовательно,*comp -это функция, а
   (*comp)(v[i], v[left])
   - обращение к ней. Скобки здесь нужны, чтобы обеспечить правильную трактовку объявления; без них объявление
   int *comp(void *, void *) /*НЕВЕРНО */
   говорило бы, чтоcomp -это функция, возвращающая указатель наint,а это совсем не то, что требуется.
   Мы уже рассматривали функциюstrcmp,сравнивающую две строки. Ниже приведена функцияnumcmp,которая сравнивает две строки, рассматривая их как числа; предварительно они переводятся в числовые значения функциейatof.
   #include‹stdlib.h›

   /* numcmp:сравнивает s1 и s2 как числа */
   int numcmp(char *s1, char *s2)
   {
    double v1, v2;

    v1 = atof(s1);
    v2 = atof(s2);
    if (v1 ‹ v2)
     return -1;
    else if (v1 › v2)
     return 1;
    else
     return 0;
   }
   Функцияswap,меняющая местами два указателя, идентична той, что мы привели ранее в этой главе за исключением того, что объявления указателей заменены наvoid*.
   void swap(void *v[], int i, int j)
   {
    void *temp;
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
   }
   Программу сортировки можно дополнить и множеством других возможностей; реализовать некоторые из них предлагается в качестве упражнений.
   Упражнение 5.14.Модифицируйте программу сортировки, чтобы она реагировала на параметр-r,указывающий, что объекты нужно сортировать в обратном порядке, т. е. в порядке убывания. Обеспечьте, чтобы-rработал и вместе с-n.
   Упражнение 5.15.Введите в программу необязательный параметр-f,задание которого делало бы неразличимыми символы нижнего и верхнего регистров (например, a и A должны оказаться при сравнении равными).
   Упражнение 5.16.Предусмотрите в программе необязательный параметр-d,который заставит программу при сравнении учитывать только буквы, цифры и пробелы. Организуйте программу таким образом, чтобы этот параметр мог работать вместе с параметром-f.
   Упражнение 5.17.Реализуйте в программе возможность работы с полями: возможность сортировки по полям внутри строк. Для каждого поля предусмотрите свой набор параметров. Предметный указатель этой книги (Имеется в виду оригинал книги на английским языке. -Примеч. пер.)упорядочивался с параметрами:-dfдля терминов и-nдля номеров страниц.
   5.12Сложные объявления
   Иногда Си ругают за синтаксис объявлений, особенно тех, которые содержат в себе указатели на функции. Таким синтаксис получился в результате нашей попытки сделатьпохожими объявления объектов и их использование. В простых случаях этот синтаксис хорош, однако в сложных ситуациях он вызывает затруднения, поскольку объявленияперенасыщены скобками и их невозможно читать слева направо. Проблему иллюстрирует различие следующих двух объявлений:
   int *f(); /* f:функция, возвращающая ук-ль на int */
   int (*pf)(); /* pf:ук-ль на ф-цию, возвращающую int */
   Приоритет префиксного оператора*ниже, чем приоритет(),поэтому во втором случае скобки необходимы.
   Хотя на практике по-настоящему сложные объявления встречаются редко, все же важно знать, как их понимать, а если потребуется, и как их конструировать. Укажем хороший способ: объявления можно синтезировать, двигаясь небольшими шагами с помощьюtypedef,этот способ рассмотрен в параграфе 6.7. В настоящем параграфе на примере двух программ, осуществляющих преобразования правильных Си-объявлений в соответствующие им словесные описания и обратно, мы демонстрируем иной способ конструирования объявлений. Словесное описание читается слева направо.
   Первая программа,dcl, -более сложная. Она преобразует Си-объявления в словесные описания так, как показано в следующих примерах:
   char **argv
   argv:указ. на указ. на char
   int (*daytab)[13]
   daytab:указ. на массив[13] из int
   int (*daytab)[13]
   daytab:массив[13] из указ. на int
   void *comp()
   comp:функц. возвр. указ. на void
   void (*comp)()
   comp:указ. на функц. возвр. void
   char (*(*x())[])()
   x:функц. возвр. указ. на массив[] из указ. на функц. возвр. char
   char(*(*x[3])())[5]
   x:массив[3] из указ. на функц. возвр. указ. на массив[5] из char
   Функцияdclв своей работе использует грамматику, специфицирующую объявитель. Эта грамматика строго изложена в параграфе 8.5 приложения A, а в упрощенном виде записывается так:
   объявитель:              необязательные *собственно-объявитель
   собственно-объявитель:  имя
                            (объявитель)
                           собственно-объявитель()
                           собственно-объявитель [необязательныйразмер]
   Говоря простым языком,объявительестьсобственно-объявитель,перед которым может стоять * (т. е. одна или несколько звездочек), гдесобственно- объявительестьимя,илиобъявительв скобках, илисобственно-объявительс последующей парой скобок, илисобственно-объявительс последующей парой квадратных скобок, внутри которых может быть помещенразмер.
   Эту грамматику можно использовать для грамматического разбора объявлений. Рассмотрим, например, такой объявитель:
   (*pfa[])()
   Имяpfaбудет классифицировано какимяи, следовательно, каксобственно- объявитель.Затемpfa[]будет распознано каксобственно-объявитель,а*pfa[] -какобъявительи, следовательно,(*pfa[])естьсобственно-объявитель.Далее,(*pfa[])()естьсобственно-объявительи, таким образом,объявитель.Этот грамматический разбор можно проиллюстрировать деревом разбора, приведенным на следующей странице (гдесобственно-объявительобозначен более коротко, а именнособств.-объяв.).
   Сердцевиной программы обработки объявителя является пара функцийdclиdirdcl,осуществляющих грамматический разбор объявления согласно приведенной грамматике. Поскольку грамматика определена рекурсивно, эти функции обращаются друг к другу рекурсивно, по мере распознавания отдельных частей объявления. Метод, примененный в обсуждаемой программе для грамматического разбора, называется рекурсивным спуском. [Картинка: pic_12.jpg] 
   /* dcl:разбор объявителя */
   void dcl(void)
   {
    int ns;

    for (ns = 0, gettoken() == '*';) /* подсчет звездочек */
     ns++;

    dirdcl();
    while(ns- › 0)
    strcat(out, "указ. на");
   }

   /* dirdcl:разбор собственно объявителя */
   void dirdcl(void)
   {
    int type;

    if (tokentype == '(') {
     dcl();
     if (tokentype != ')')
      printf("oшибкa: пропущена)\n");
    } else if (tokentype == NAME) /* имя переменной */
     strcpy(name, token);
    else
     printf("ошибка: должно быть name или (dcl)\n");

    while((type = gettoken()) == PARENS || type == BRACKETS)
     if (type == PARENS)
      strcat(out, "функц. возвр.");
     else {
      strcat(out, " массив");
      strcat(out, token);
      strcat(out, " из");
     }
   }
   Приведенные программы служат только иллюстративным целям и не вполне надежны. Что касаетсяdcl,то ее возможности существенно ограничены. Она может работать только с простыми типами вродеcharиintи не справляется с типами аргументов в функциях и с квалификаторами вродеconst.Лишние пробелы для нее опасны. Она не предпринимает никаких мер по выходу из ошибочной ситуации, и поэтому неправильные описания также ей противопоказаны. Устранение этих недостатков мы оставляем для упражнений. Ниже приведены глобальные переменные и главная программаmain.
   #include‹stdio.h›
   #include‹string.h›
   #include‹ctype.h›

   #define MAXTOKEN 100

   enum {NAME, PARENS, BRACKETS};

   void dcl(void);
   void dirdcl(void);

   int gettoken(void);
   int tokentype; /*тип последней лексемы */
   char token[MAXTOKEN]; /*текст последней лексемы */
   char name[MAXTOKEN]; /*имя */
   char datatype[MAXTOKEN]; /*тип = char, int и т.д. */
   char out[1000]; /*выдаваемый текст */

   main() /*преобразование объявления в словесное описание */
   {
    while (gettoken() != EOF) {/* 1-я лексема в строке */
     strcpy(datatype, token); /* это тип данных */
     out[0] = '\0';
     dcl(); /* разбор остальной части строки */
     if (tokentype != '\n')
      printf("синтаксическая ошибка\n");
     printf("%s: %s %s\n", name, out, datatype);
    }
    return 0;
   }
   Функцияgettokenпропускает пробелы и табуляции и затем получает следующую лексему из ввода: "лексема" (token) -это имя, или пара круглых скобок, или пара квадратных скобок (быть может, с помещенным в них числом), или любой другой единичный символ.
   int gettoken(void) /*возвращает следующую лексему */
   {
    int с, getch(void);
    void ungetch(int);
    char *p = token;

    while ((c = getch()) == ' ' || с == '\t')
     ;
    if (c == '(') {
     if ((c = getch()) == ')' {
      strcpy(token, "()");
      return tokentype = PARENS;
     } else {
      ungetch(c);
      return tokentype = '(';
     }
    } else if (c == '[') {
     for (*p++ = c; (*p++ = getch()) != ']';)
      ;
     *p = '\0';
     return tokentype = BRACKETS;
    } else if (isalpha(c)) {
     for (*p++ = c; isalnum(c = getch());)
     *p++ = c;
     *p = '\0';
     ungetch(c);
     return tokentype = NAME;
    } else
    return tokentype = c;
   }
   Функцииgetchиungetchбыли рассмотрены в главе 4.
   Обратное преобразование реализуется легче, особенно если не придавать значения тому, что будут генерироваться лишние скобки. Программаundclпревращает фразу вроде "x есть функция, возвращающая указатель на массив указателей на функции, возвращающиеchar",которую мы будем представлять в виде
   х () * [] * () char
   в объявление
   char (*(*х())[])()
   Такой сокращенный входной синтаксис позволяет повторно пользоваться функциейgettoken.Функцияundclиспользует те же самые внешние переменные, что иdcl.
   /* undcl:преобразует словесное описание в объявление */
   main()
   {
    int type;
    char temp[MAXTOKEN];

    while (gettoken() != EOF) {
     strcpy(out, token);
     while ((type = gettoken()) != '\n')
      if (type == PARENS || type == BRACKETS)
       strcat(out, token);
      else if (type == '*') {
       sprintf(temp, "(*%s)", out);
       strcpy(out, temp);
      } else if (type == NAME) {
       sprintf(temp, "%s %s", token, out);
       strcpy(out, temp);
      } else
       printf("неверный элемент %s в фразе\n", token);
     printf("%s\n", out);
    }
    return 0;
   }
   Упражнение 5.18.Видоизменитеdclтаким образом, чтобы она обрабатывала ошибки во входной информации.
   Упражнение 5.19.Модифицируйтеundclтак, чтобы она не генерировала лишних скобок.
   Упражнение 5.20.Расширьте возможностиdcl,чтобыdclобрабатывала объявления с типами аргументов функции, квалификаторами вродеconstи т. п.
   Глава 6. Структуры
   Структура -это одна или несколько переменных (возможно, различных типов), которые для удобства работы с ними сгруппированы под одним именем. (В некоторых языках, в частности в Паскале, структуры называются записями.) Структуры помогают в организации сложных данных (особенно в больших программах), поскольку позволяют группу связанных между собой переменных трактовать не как множество отдельных элементов, а как единое целое.
   Традиционный пример структуры - строка платежной ведомости. Она содержит такие сведения о служащем, как его полное имя, адрес, номер карточки социального страхования, зарплата и т. д. Некоторые из этих характеристик сами могут быть структурами: например, полное имя состоит из нескольких компонент (фамилии, имени и отчества); аналогично адрес, и даже зарплата. Другой пример (более типичный для Си) - из области графики: точка есть пара координат, прямоугольник есть пара точек и т. д.
   Главные изменения, внесенные стандартом ANSI в отношении структур, - это введение для них операции присваивания. Структуры могут копироваться, над ними могут выполняться операции присваивания, их можно передавать функциям в качестве аргументов, а функции могут возвращать их в качестве результатов. В большинстве компиляторов уже давно реализованы эти возможности, но теперь они точно оговорены стандартом. Для автоматических структур и массивов теперь также допускается инициализация.
   6.1Основные сведения о структурах
   Сконструируем несколько графических структур. В качестве основного объекта выступает точка с координатамиxиyцелого типа. [Картинка: fig6_1.jpg] 
   Указанные две компоненты можно поместить в структуру, объявленную, например, следующим образом:
   struct point {int x; int y;};
   Объявление структуры начинается с ключевого словаstructи содержит список объявлений, заключенный в фигурные скобки. За словомstructможет следовать имя, называемоетегом структуры (от английского слова tag - ярлык, этикетка. - Примеч. пер.),pointв нашем случае. Тег дает название структуре данного вида и далее может служить кратким обозначением той части объявления, которая заключена в фигурные скобки.
   Перечисленные в структуре переменные называютсяэлементами (members -В некоторых изданиях, в том числе во 2-м издании на русским языке этой книги structure members переводится как члены структуры. - Примеч. ред). Имена элементов и тегов без каких-либо коллизий могут совпадать с именами обычных переменных (т. е. не элементов), так как они всегда различимы по контексту. Более того, одни и те же имена элементов могут встречаться в разных структурах, хотя, если следовать хорошему стилю программирования, лучше одинаковые имена давать только близким по смыслу объектам.
   Объявление структуры определяет тип. За правой фигурной скобкой, закрывающей список элементов, могут следовать переменные точно так же, как они могут быть указаныпосле названия любого базового типа. Таким образом, выражение
   struct {…} x, y, z;
   с точки зрения синтаксиса аналогично выражению
   intх, у, z;
   в том смысле, что и то и другое объявляетx,yиzпеременными указанного типа; и то и другое приведет к выделению памяти соответствующего размера.
   Объявление структуры, не содержащей списка переменных, не резервирует памяти; оно просто описывает шаблон, или образец структуры. Однако если структура имеет тег, то этим тегом далее можно пользоваться при определении структурных объектов. Например, с помощью заданного выше описания структурыpointстрока
   struct point pt;
   определяет структурную переменнуюptтипаstruct point.Структурную переменную при ее определении можно инициализировать, формируя список инициализаторов ее элементов в виде константных выражений:
   struct point maxpt = {320, 200};
   Инициализировать автоматические структуры можно также присваиванием или обращением к функции, возвращающей структуру соответствующего типа.
   Доступ к отдельному элементу структуры осуществляется посредством конструкции вида:
   имя-структуры.элемент
   Оператор доступа к элементу структуры.соединяет имя структуры и имя элемента. Чтобы напечатать, например, координаты точкиpt,годится следующее обращение кprintf:
   printf("%d, %d", pt.x, pt.y);
   Другой пример: чтобы вычислить расстояние от начала координат (0,0) доpt,можно написать
   double dist, sqrt(double); dist = sqrt((double)pt.x * pt.x + (double)pt.y * pt.y);
   Структуры могут быть вложены друг в друга. Одно из возможных представлений прямоугольника - это пара точек на углах одной из его диагоналей: [Картинка: fig6_2.jpg] 
   struct rect {struct point pt1; struct point pt2;};
   Структураrectсодержит две структурыpoint.Если мы объявимscreenкак
   struct rect screen;
   то
   screen.pt1.x
   обращается к координатеxточкиpt1изscreen.
   6.2Структуры и функции
   Единственно возможные операции над структурами - это их копирование, присваивание, взятие адреса с помощью&и осуществление доступа к ее элементам. Копирование и присваивание также включают в себя передачу функциям аргументов и возврат ими значений. Структуры нельзя сравнивать. Инициализировать структуру можно списком константных значений ее элементов; автоматическую структуру также можно инициализировать присваиванием.
   Чтобы лучше познакомиться со структурами, напишем несколько функций, манипулирующих точками и прямоугольниками. Возникает вопрос: а как передавать функциям названные объекты? Существует по крайней мере три подхода: передавать компоненты по отдельности, передавать всю структуру целиком и передавать указатель на структуру. Каждый подход имеет свои плюсы и минусы.
   Первая функция,makepoint,получает два целых значения и возвращает структуруpoint.
   /* makepoint:формирует точку по компонентам x и y */
   struct point makepoint(intх, int у) {
    struct point temp;
    temp.x = х;
    temp.у = у;
    return temp;
   }
   Заметим: никакого конфликта между именем аргумента и именем элемента структуры не возникает; более того, сходство подчеркивает родство обозначаемых им объектов.
   Теперь с помощьюmakepointможно выполнять динамическую инициализацию любой структуры или формировать структурные аргументы для той или иной функции:
   struct rect screen;
   struct point middle;
   struct point makepoint(int, int);

   screen.pt1 = makepoint(0, 0);
   screen.pt2 = makepoint(XMAX, YMAX);
   middle = makepoint((screen.pt1.x + screen.pt2.x)/2, (screen.pt1.y + screen.pt2.y)/2);
   Следующий шаг состоит в определении ряда функций, реализующих различные операции над точками. В качестве примера рассмотрим следующую функцию:
   /* addpoint:сложение двух точек */
   struct point addpoint(struct point p1, struct point p2)
   {
    p1.x += p2.x;
    p1.y += p2.y;
    return p1;
   }
   Здесь оба аргумента и возвращаемое значение - структуры. Мы увеличиваем компоненты прямо в р1 и не используем для этого временной переменной, чтобы подчеркнуть, что структурные параметры передаются по значению так же, как и любые другие.
   В качестве другого примера приведем функциюptinrect,которая проверяет: находится ли точка внутри прямоугольника, относительно которого мы принимаем соглашение, что в него входят его левая и нижняя стороны, но не входят верхняя и правая.
   /* ptinrect:возвращает 1, если p в r, и 0 в противном случае */
   int ptinrect(struct pointр, struct rect r) {
    return p.x&gt;= r.pt1.x&& p.x&lt; r.pt2.x && p.y&gt;= r.pt1.y&& p.y&lt; r.pt2.y;
   }
   Здесь предполагается, что прямоугольник представлен в стандартном виде, т.е. координаты точкиpt1меньше соответствующих координат точкиpt2.Следующая функция гарантирует получение прямоугольника в каноническом виде.
   #define min(a, b) ((a)&lt; (b) ? (a) : (b))
   #define max(a, b) ((a)&gt; (b) ? (a) : (b))

   /* canonrect:канонизация координат прямоугольника */
   struct rect canonrect(struct rect r)
   {
    struct rect temp;
    temp.pt1.x = min(r.pt1.x, r.pt2.x);
    temp.ptl.y = min(r.pt1.y, r.pt2.у);
    temp.pt2.x = max(r.pt1.x, r.pt2.x);
    temp.pt2.y = max(r.pt1.y, r.pt2.y);
    return temp;
   }
   Если функции передается большая структура, то, чем копировать ее целиком, эффективнее передать указатель на нее. Указатели на структуры ничем не отличаются от указателей на обычные переменные. Объявление
   struct point *pp;
   сообщает, чтоpp -это указатель на структуру типаstruct point.Еслиppуказывает на структуруpoint,то*pp -это сама структура, а(*pp).xи(*pp).y -ее элементы. Используя указательpp,мы могли бы написать
   struct point origin, *pp;
   pp =&origin;
   printf("origin: (%d,%d)\n", (*pp).x, (*pp).y);
   Скобки в(*pp).xнеобходимы, поскольку приоритет оператора.выше, чем приоритет*.Выражение*pp.xбудет проинтерпретировано как*(pp.x),что неверно, посколькуpp.xне является указателем.
   Указатели на структуры используются весьма часто, поэтому для доступа к ее элементам была придумана еще одна, более короткая форма записи. Еслиp -указатель на структуру, то
   р-›элемент-структуры
   есть ее отдельный элемент. (Оператор-›состоит из знака -, за которым сразу следует знак ›.) Поэтомуprintfможно переписать в виде
   printf("origin: (%d,%d)\n", pp-›х, pp-›y);
   Операторы. и -› выполняются слева направо. Таким образом, при наличии объявления
   struct rect r, *rp =&r;
   следующие четыре выражения будут эквивалентны:
   r.pt1.x rp-›pt1.x (r.pt1).x (rp-›pt1).x
   Операторы доступа к элементам структуры.и-›вместе с операторами вызова функции()и индексации массива[]занимают самое высокое положение в иерархии приоритетов и выполняются раньше любых других операторов. Например, если задано объявление
   struct {int len; char *str;} *p;
   то
   ++p-›len
   увеличит на 1 значение элемента структурыlen,а не указательp,поскольку в этом выражении как бы неявно присутствуют скобки:++(p-›len).Чтобы изменить порядок выполнения операций, нужны явные скобки. Так, в(++р)-›len,прежде чем взять значениеlen,программа прирастит указательp.В(р++)-›lenуказательpувеличится после того, как будет взято значениеlen (в последнем случае скобки не обязательны).
   По тем же правилам*p-›strобозначает содержимое объекта, на который указываетstr;*p-›str++прирастит указательstrпосле получения значения объекта, на который он указывал (как и в выражении*s++),(*p-›str)++увеличит значение объекта, на который указываетstr;*p++-›strувеличитpпосле получения того, на что указываетstr.
   6.3Массивы структур
   Рассмотрим программу, определяющую число вхождений каждого ключевого слова в текст Си-программы. Нам нужно уметь хранить ключевые слова в виде массива строк и счетчики ключевых слов в виде массива целых. Один из возможных вариантов - это иметь два параллельных массива:
   char *keyword[NKEYS];
   int keycount[NKEYS];
   Однако именно тот факт, что они параллельны, подсказывает нам другую организацию хранения - через массив структур. Каждое ключевое слово можно описать парой характеристик
   char *word;
   int count;
   Такие пары составляют массив. Объявление
   struct key {
    char *word;
    int count;
   } keytab[NKEYS];
   объявляет структуру типаkeyи определяет массивkeytab,каждый элемент которого является структурой этого типа и которому где-то будет выделена память. Это же можно записать и по-другому:
   struct key {
    char *word;
    int count;
   };
   struct key keytab[NKEYS];
   Так какkeytabсодержит постоянный набор имен, его легче всего сделать внешним массивом и инициализировать один раз в момент определения. Инициализация структур аналогична ранее демонстрировавшимся инициализациям - за определением следует список инициализаторов, заключенный в фигурные скобки:
   struct key {
    char *word;
    int count;
   } keytab[] = {
    "auto", 0,
    "break", 0,
    "case", 0,
    "char", 0,
    "const", 0,
    "continue", 0,
    "default", 0,
    /*…*/
    "unsigned", 0,
    "void", 0,
    "volatile", 0,
    "while", 0
   };
   Инициализаторы задаются парами, чтобы соответствовать конфигурации структуры. Строго говоря, пару инициализаторов для каждой отдельной структуры следовало бы заключить в фигурные скобки, как, например, в
   {"auto", 0},
   {"break", 0},
   {"case", 0},
   …
   Однако когда инициализаторы - простые константы или строки символов и все они имеются в наличии, во внутренних скобках нет необходимости. Число элементов массиваkeytabбудет вычислено по количеству инициализаторов, поскольку они представлены полностью, а внутри квадратных скобок "[]" ничего не задано.
   Программа подсчета ключевых слов начинается с определенияkeytab.Программаmainчитает ввод, многократно обращаясь к функцииgetwordи получая на каждом ее вызове очередное слово. Каждое слово ищется вkeytab.Для этого используется функция бинарного поиска, которую мы написали в главе 3. Список ключевых слов должен быть упорядочен в алфавитном порядке.
   #include&lt;stdio.h&gt;
   #include&lt;ctype.h&gt;
   #include&lt;string.h&gt;

   #define MAXWORD 100

   int getword(char *, int);
   int binsearch(char *, struct key *, int);

   /*подсчет ключевых слов Си */
   main()
   {
    int n;
    char word[MAXWORD];

    while(getword(word, MAXWORD) != EOF)
     if (isalpha(word[0]))
      if ((n = binsearch(word, keytab, NKEYS))&gt;= 0)
       keytab[n].count++;
    for (n = 0; n&lt; NKEYS; n++)
     if (keytab[n].count&gt; 0)
      printf("%4d %s\n", keytab[n].count, keytab[n].word);
    return 0;
   }

   /* binsearch:найти слово в tab[0]...tab[n-1] */
   int binsearch(char *word, struct key tab[], int n)
   {
    int cond;
    int low, high, mid;

    low = 0;
    high = n-1;
    while (low&lt;= high) {
     mid = (low + high)/2;
     if ((cond = strcmp(word, tab[mid].word))&lt; 0)
      high = mid - 1;
     else if (cond&gt; 0)
      low = mid + 1;
     else
      return mid;
    }
    return -1;
   }
   Чуть позже мы рассмотрим функциюgetword,а сейчас нам достаточно знать, что при каждом ее вызове получается очередное слово, которое запоминается в массиве, заданном первым аргументом.
   NKEYS -количество ключевых слов вkeytab.Хотя мы могли бы подсчитать число таких слов вручную, гораздо легче и безопасней сделать это с помощью машины, особенно если список ключевых слов может быть изменен. Одно из возможных решений - поместить в конец списка инициализаторов пустой указатель (NULL) и затем перебирать в цикле элементыkeytab,пока не встретится концевой элемент.
   Но возможно и более простое решение. Поскольку размер массива полностью определен во время компиляции и равен произведению количества элементов массива на размер его отдельного элемента, число элементов массива можно вычислить по формуле
   размер keytab /размер struct key
   В Си имеется унарный операторsizeof,который работает во время компиляции. Его можно применять для вычисления размера любого объекта. Выражения
   sizeofобъект
   и
   sizeof (имя типа)
   выдают целые значения, равные размеру указанного объекта или типа в байтах. (Строго говоря,sizeofвыдает беззнаковое целое, тип которогоsize_tопределена заголовочном файле‹stddef.h›.)Что касается объекта, то это может быть переменная, массив или структура. В качестве имени типа может выступать имя базового типа (int,double…) или имя производного типа, например структуры или указателя.
   В нашем случае, чтобы вычислить количество ключевых слов, размер массива надо поделить на размер одного элемента. Указанное вычисление используется в инструкции#defineдля установки значения NKEYS:
   #define NKEYS (sizeof keytab / sizeof(struct key))
   Этот же результат можно получить другим способом - поделить размер массива на размер какого-то его конкретного элемента:
   #define NKEYS (sizeof keytab / sizeof keytab[0])
   Преимущество такого рода записей в том, что их не надо коppектировать при изменении типа.
   Поскольку препроцессор не обращает внимания на имена типов, операторsizeofнельзя применять в#if.Но в#defineвыражение препроцессором не вычисляется, так что предложенная нами запись допустима.
   Теперь поговорим о функцииgetword.Мы написалиgetwordв несколько более общем виде, чем требуется для нашей программы, но она от этого не стала заметно сложнее. Функцияgetwordберет из входного потока следующее "слово". Под словом понимается цепочка букв-цифр, начинающаяся с буквы, или отдельный символ, отличный от символа-разделителя. В случае конца файла функция возвращает EOF, в остальных случаях ее значением является код первого символа слова или сам символ, если это не буква.
   /* getword:принимает следующее слово или символ из ввода */
   int getword (char *word, int lim) {
    int c, getch(void);
    void ungetch(int);
    char *w = word;

    while (isspace(c = getch()))
     ;
    if (c != EOF)
     *w++ = c;
    if (!isalpha(c)) {
     *w = '\0';
     return c;
    }
    for (; --lim › 0; w++)
     if (!isalnum(*w = getch())) {
      ungetch(*w);
      break;
     }
    *w = '\0';
    return word[0];
   }
   Функцияgetwordобращается кgetchиungetch,которые мы написали в главе 4. По завершении набора букв-цифр оказывается, чтоgetwordвзяла лишний символ. Обращение кungetchпозволяет вернуть его назад во входной поток. Вgetwordиспользуются такжеisspace -для пропуска символов-разделителей,isalpha -для идентификации букв иisalnum -для распознавания букв-цифр. Все они описаны в стандартном заголовочном файле‹ctype.h›.
   Упражнение 6.1. Haшa вepcияgetwordне обрабатывает должным образом знак подчеркивания, строковые константы, комментарии и управляющие строки препроцессора. Напишите более совершенный вариант программы.
   6.4Указатели на структуры
   Для иллюстрации некоторых моментов, касающихся указателей на структуры и массивов структур, перепишем программу подсчета ключевых слов, пользуясь для получения элементов массива вместо индексов указателями.
   Внешнее объявление массиваkeytabостается без изменения, amainиbinsearchнужно модифицировать.
   #include&lt;stdio.h&gt;
   #include&lt;ctype.h&gt;
   #include&lt;string.h&gt;
   #define MAXWORD 100

   int getword(char *, int);
   struct key *binsearch(char *, struct key *, int);

   /*подсчет ключевых слов Си: версия с указателями */
   main()
   {
    char word[MAXWORD];
    struct key *p;
    while (getword(word, MAXWORD) != EOF)
     if (isalpha(word[0]))
      if ((p = binsearch(word, keytab, NKEYS)) != NULL)
       p-&gt;count++;
      for (p = keytab; p&lt; keytab + NKEYS; p++)
       if (p-&gt;count&gt; 0)
        printf("%4d %s\n", p-&gt;count, p-&gt;word);
    return 0;
   }

   /* binsearch:найти слово word в tab[0]...tab[n-1] */
   struct key *binsearch(char *word, struct key *tab, int n)
   {
    int cond;
    struct key *low =&tab[0];
    struct key *high =&tab[n];
    struct key *mid;
    while (low&lt; high) {
     mid = low + (high - low) / 2;
     if ((cond = strcmp(word, mid-&gt;word))&lt; 0)
      high = mid;
     else if (cond&gt; 0)
      low = mid + 1;
     else
      return mid;
    }
    return NULL;
   }
   Некоторые детали этой программы требуют пояснений. Во-первых, описание функцииbinsearchдолжно отражать тот факт, что она возвращает указатель наstruct key,а не целое, это объявлено как в прототипе функции, так и в функцииbinsearch.Еслиbinsearchнаходит слово, то она выдает указатель на него, в противном случае она возвращает NULL. Во-вторых, к элементамkeytabдоступ в нашей программе осуществляется через указатели. Это потребовало значительных изменений вbinsearch.Инициализаторами дляlowиhighтеперь служат указатели на начало и на место сразу после конца массива. Вычисление положения среднего элемента с помощью формулы
   mid = (low + high) / 2 /*НЕВЕРНО */
   не годится, поскольку указатели нельзя складывать. Однако к ним можно применить операцию вычитания, и так какhigh-lowесть число элементов, присваивание
   mid = low + (high-low) / 2
   превратитmidв указатель на элемент, лежащий посередине междуlowиhigh.
   Самое важное при переходе на новый вариант программы - сделать так, чтобы не генерировались неправильные указатели и не было попыток обратиться за пределы массива. Проблема в том, что и&tab[-1],и&tab[n]находятся вне границ массива. Первый адрес определенно неверен, нельзя также осуществить доступ и по второму адресу. По правилам языка, однако, гарантируется, что адрес ячейки памяти, следующей сразу за концом массива (т. е.&tab[n]),в арифметике с указателями воспринимается правильно.
   В главной программеmainмы написали
   for (р = keytab; р&lt; keytab + NKEYS;р++)
   Еслиp -это указатель на структуру, то при выполнении операций сручитывается размер структуры. Поэтомур++увеличит р на такую величину, чтобы выйти на следующий структурный элемент массива, а проверка условия вовремя остановит цикл.
   Не следует, однако, полагать, что размер структуры равен сумме размеров ее элементов. Вследствие выравнивания объектов разной длины в структуре могут появляться безымянные "дыры". Например, если переменная типаcharзанимает один байт, аint -четыре байта, то для структуры
   struct { 
    char с; 
    int i;
   };
   может потребоваться восемь байтов, а не пять. Операторsizeofвозвращает правильное значение.
   Наконец, несколько слов относительно формата программы. Если функция возвращает значение сложного типа, как, например, в нашем случае она возвращает указатель на структуру:
   struct key *binsearch(char *word, struct key *tab, int n)
   то "высмотреть" имя функции оказывается совсем не просто. В подобных случаях иногда пишут так:
   struct key *
   binsearch(char *word, struct key *tab, int n)
   Какой форме отдать предпочтение - дело вкуса. Выберите ту, которая больше всего вам нравится, и придерживайтесь ее.
   6.5Структуры со ссылками на себя
   Предположим, что мы хотим решить более общую задачу - написать программу, подсчитывающую частоту встречаемости для любых слов входного потока. Так как список слов заранее не известен, мы не можем предварительно упорядочить его и применить бинарный поиск. Было бы неразумно пользоваться и линейным поиском каждого полученного слова, чтобы определять, встречалось оно ранее или нет - в этом случае программа работала бы слишком медленно. (Более точная оценка: время работы такой программы пропорционально квадрату количества слов.) Как можно организовать данные, чтобы эффективно справиться со списком произвольных слов?
   Один из способов - постоянно поддерживать упорядоченность уже полученных слов, помещая каждое новое слово в такое место, чтобы не нарушалась имеющаяся упорядоченность. Делать это передвижкой слов в линейном массиве не следует, - хотя бы потому, что указанная процедура тоже слишком долгая. Вместо этого мы воспользуемся структурой данных, называемой бинарным деревом.
   В дереве на каждое отдельное слово предусмотрен "узел", который содержит:
   -указатель на текст слова;
   -счетчик числа встречаемости;
   -указатель на левый сыновний узел;
   -указатель на правый сыновний узел.
   У каждого узла может быть один или два сына, или узел вообще может не иметь сыновей.
   Узлы в дереве располагаются так, что по отношению к любому узлу левое поддерево содержит только те слова, которые лексикографически меньше, чем слово данного узла,а правое - слова, которые больше него. Вот как выглядит дерево, построенное для фразы "now is the time for all good men to come to the aid of their party" ("настало время всем добрым людям помочь своей партии"), по завершении процесса, в котором для каждого нового слова в него добавлялся новый узел:  [Картинка: fig6_3.jpg] 
   Чтобы определить, помещено ли уже в дерево вновь поступившее слово, начинают с корня, сравнивая это слово со словом из корневого узла. Если они совпали, то ответ на вопрос - положительный. Если новое слово меньше слова из дерева, то поиск продолжается в левом поддереве, если больше, то - в правом. Если же в выбранном направлении поддерева не оказалось, то этого слова в дереве нет, а пустующая позиция, говорящая об отсутствии поддерева, как раз и есть то место, куда нужно "подвесить" узел с новым словом. Описанный процесс по сути рекурсивен, так как поиск в любом узле использует результат поиска в одном из своих сыновних узлов. В соответствии с этим для добавления узла и печати дерева здесь наиболее естественно применить рекурсивные функции.
   Вернемся к описанию узла, которое удобно представить в виде структуры с четырьмя компонентами:
   struct tnode { /*узел дерева */
    char *word; /* указатель на текст */
    int count; /* число вхождений */
    struct tnode *left; /* левый сын */
    struct tnode *right; /* правый сын */
   };
   Приведенное рекурсивное определение узла может показаться рискованным, но оно правильное. Структура не может включать саму себя, но ведь
   struct tnode *left;
   объявляетleftкак указатель наtnode,а не самtnode.
   Иногда возникает потребность во взаимоссылающихся структурах: двух структурах, ссылающихся друг на друга. Прием, позволяющий справиться с этой задачей, демонстрируется следующим фрагментом:
   struct t {
    ...
    struct s *p; /* р указывает на s */
   };
   struct s {
    ... struct t *q; /* q указывает на t */
   };
   Вся программа удивительно мала - правда, она использует вспомогательные программы вродеgetword,уже написанные нами. Главная программа читает слова с помощьюgetwordи вставляет их в дерево посредствомaddtree.
   #include&lt;stdio.h&gt;
   #include&lt;ctype.h&gt;
   #include&lt;string.h&gt;

   #define MAXWORD 100

   struct tnode *addtree(struct tnode *, char *);
   void treeprint(struct tnode *);
   int getword(char *, int);

   /*подсчет частоты встречаемости слов */
   main()
   {
    struct tnode *root;
    char word[MAXWORD];

    root = NULL;
    while (getword (word, MAXWORD) != EOF)
     if (isalpha(word[0])) root = addtree(root, word);
    treeprint(root);
    return 0;
   }
   Функцияaddtreeрекурсивна. Первое слово функцияmainпомещает на верхний уровень дерева (корень дерева). Каждое вновь поступившее слово сравнивается со словом узла и "погружается" или в левое, или в правое поддерево с помощью рекурсивного обращения кaddtree.Через некоторое время это слово обязательно либо совпадет с каким-нибудь из имеющихся в дереве слов (в этом случае к счетчику будет добавлена 1), либо программа встретит пустую позицию, что послужит сигналом для создания нового узла и добавления его к дереву. Создание нового узла сопровождается тем, чтоaddtreeвозвращает на него указатель, который вставляется в узел родителя.
   struct tnode *talloc(void);
   char *strdup(char *);

   /* addtree:добавляет узел со словом w в р или ниже него */
   struct tnode *addtree(struct tnode *p, char *w)
   {
    int cond;

    if (р == NULL) { /* слово встречается впервые */
     p = talloc(); /* создается новый узел */
     p-&gt;word = strdup(w);
     p-&gt;count = 1;
     p-&gt;left = p-&gt;right = NULL;
    } else if ((cond = strcmp(w, p-&gt;word)) == 0)
     p-&gt;count++; /*это слово уже встречалось */
    else if (cond&lt; 0) /*меньше корня левого поддерева */
     p-&gt;left = addtree(p-&gt;left, w);
    else /* больше корня правого поддерева */
     p-&gt;right = addtree(p-&gt;right, w);
    return p;
   }
   Память для нового узла запрашивается с помощью программыtalloc,которая возвращает указатель на свободное пространство, достаточное для хранения одного узла дерева, а копирование нового слова в отдельное место памяти осуществляется с помощьюstrdup. (Мы рассмотрим эти программы чуть позже.) В тот (и только в тот) момент, когда к дереву подвешивается новый узел, происходит инициализация счетчика и обнуление указателей на сыновей. Мы опустили (что неразумно) контроль ошибок, который должен выполняться при получении значений отstrdupиtalloc.
   Функцияtreeprintпечатает дерево в лексикографическом порядке: для каждого узла она печатает его левое поддерево (все слова, которые меньше слова данного узла), затем само слово и, наконец, правое поддерево (слова, которые больше слова данного узла).
   /* treeprint:упорядоченная печать дерева р */
   void treeprint(struct tnode *p)
   {
    if (p != NULL) {
     treeprint (p-›left);
     printf("%4d %s\n", p-›count, p-›word);
     treeprint(p-›right);
    }
   }
   Если вы не уверены, что досконально разобрались в том, как работает рекурсия, "проиграйте" действияtreeprintна дереве, приведенном выше. Практическое замечание: если дерево "несбалансировано" (что бывает, когда слова поступают не в случайном порядке), то время работы программы может сильно возрасти. Худший вариант, когда слова уже упорядочены; в этом случае затраты на вычисления будут такими же, как при линейном поиске. Существуют обобщения бинарного дерева, которые не страдают этим недостатком, но здесь мы их не описываем.
   Прежде чем завершить обсуждение этого примера, сделаем краткое отступление от темы и поговорим о механизме запроса памяти. Очевидно, хотелось бы иметь всего лишь одну функцию, выделяющую память, даже если эта память предназначается для разного рода объектов. Но если одна и та же функция обеспечивает память, скажем) и для указателей наchar,и для указателей наstruct tnode,то возникают два вопроса. Первый: как справиться с требованием большинства машин, в которых объекты определенного типа должны быть выровнены (например,intчасто должны размещаться, начиная с четных адресов)? И второе: как объявить функцию-распределитель памяти, которая вынуждена в качестве результата возвращать указатели разных типов?
   Вообще говоря, требования, касающиеся выравнивания, можно легко выполнить за счет некоторого перерасхода памяти. Однако для этого возвращаемый указатель должен быть таким, чтобы удовлетворялись любые ограничения, связанные с выравниванием. Функцияalloc,описанная в главе 5, не гарантирует нам любое конкретное выравнивание, поэтому мы будем пользоваться стандартной библиотечной функциейmalloc,которая это делает. В главе 8 мы покажем один из способов ее реализации.
   Вопрос об объявлении типа таких функций, какmalloc,является камнем преткновения в любом языке с жесткой проверкой типов. В Си вопрос решается естественным образом:mallocобъявляется как функция, которая возвращает указатель наvoid.Полученный указатель затем явно приводится к желаемому типу (Замечание о приведении типа величины, возвращаемой функциейmalloc,нужно переписать. Пример коpректен и работает, но совет является спорным в контексте стандартов ANSI/ISO 1988-1989 г. На самом деле это не обязательно (при условии что приведениеvoid*кALMOSTANYTYPE*выполняется автоматически) и возможно даже опасно, еслиmallocили ее заместитель не может быть объявлен как функция, возвращающаяvoid*.Явное приведение типа может скрыть случайную ошибку. В другие времена (до появления стандарта ANSI) приведение считалось обязательным, что также справедливо и для C++. - Примеч. авт.). Описанияmallocи связанных с ней функций находятся в стандартном заголовочном файле‹stdlib.h›.Таким образом, функциюtallocможно записать так:
   #include‹stdlib.h›

   /* talloc:создает tnode */
   struct tnode *talloc(void) {
    return (struct tnode *) malloc(sizeof(struct tnode));
   }
   Функцияstrdupпросто копирует строку, указанную в аргументе, в место, полученное с помощьюmalloc:
   char *strdup(char *s) /*делает дубликат s */
   {
    char *p;

    p = (char *) malloc(strlen(s)+1); /* +1 для '\0' */
    if (p != NULL)
     strcpy(p, s);
    return p;
   }
   Функцияmallocвозвращает NULL, если свободного пространства нет;strdupвозвращает это же значение, оставляя заботу о выходе из ошибочной ситуации вызывающей программе.
   Память, полученную с помощьюmalloc,можно освободить для повторного использования, обратившись к функцииfree (см. главы 7 и 8).
   Упражнение 6.2.Напишите программу, которая читает текст Си-программы и печатает в алфавитном порядке все группы имен переменных, в которых совпадают первые 6 символов, но последующие в чем-то различаются. Не обрабатывайте внутренности закавыченных строк и комментариев. Число 6 сделайте параметром, задаваемым в командной строке.
   Упражнение 6.3.Напишите программу печати таблицы "перекрестных ссылок", которая будет печатать все слова документа и указывать для каждого из них номера строк, где оно встретилось. Программа должна игнорировать "шумовые" слова, такие как "и", "или" и пр.
   Упражнение 6.4.Напишите программу, которая печатает весь набор различных слов, образующих входной поток, в порядке возрастания частоты их встречаемости. Перед каждым словом должно быть указано число вхождений.
   6.6Просмотр таблиц
   В этом параграфе, чтобы проиллюстрировать новые аспекты применения структур, мы напишем ядро пакета программ, осуществляющих вставку элементов в таблицы и их поиск внутри таблиц. Этот пакет - типичный набор программ, с помощью которых работают с таблицами имен в любом макропроцессоре или компиляторе. Рассмотрим, например, инструкцию#define.Когда встречается строка вида
   #define IN 1
   имя IN и замещающий его текст 1 должны запоминаться в таблице. Если затем имя IN встретится в инструкции, например в
   state = IN;
   это должно быть заменено на 1.
   Существуют две программы, манипулирующие с именами и замещающими их текстами. Этоinstall(s,t),которая записывает имяsи замещающий его текстtв таблицу, гдеsиt -строки, иlookup(s),осуществляющая поискsв таблице и возвращающая указатель на место, где имяsбыло найдено, или NULL, еслиsв таблице не оказалось.
   Алгоритм основан нахэш-поиске:поступающее имя свертывается в неотрицательное число (хэш-код), которое затем используется в качестве индекса в массиве указателей. Каждый элемент этого массива является указателем на начало связанного списка блоков, описывающих имена с данным хэш-кодом. Если элемент массива равен NULL, это значит, что имен с соответствующим хэш-кодом нет. [Картинка: fig6_4.jpg] 
   Блок в списке - это структура, содержащая указатели на имя, на замещающий текст и на следующий блок в списке; значение NULL в указателе на следующий блок означает конец списка.
   struct nlist {/*элемент таблицы */
    struct nlist *next; /* указатель на следующий элемент */
    char *name; /* определенное имя */
    char *defn; /* замещающий текст */
   };
   А вот как записывается определение массива указателей:
   #define HASHSIZE 101
   static struct nlist *hashtab[HASHSIZE]; /*таблица указателей */
   Функция хэширования, используемая вlookupиinstall,суммирует коды символов в строке и в качестве результата выдаст остаток от деления полученной суммы на размер массива указателей. Это не самая лучшая функция хэширования, но достаточно лаконичная и эффективная.
   /* hash:получает хэш-код для строки s */
   unsigned hash(char *s)
   {
    unsigned hashval;
    for (hashval = 0; *s != '\0'; s++)
     hashval = *s + 31 * hashval;
    return hashval % HASHSIZE;
   }
   Беззнаковая арифметика гарантирует, что хэш-код будет неотрицательным.
   Хэширование порождает стартовый индекс для массиваhashtab;если соответствующая строка в таблице есть, она может быть обнаружена только в списке блоков, на начало которого указывает элемент массиваhashtabс этим индексом. Поиск осуществляется с помощьюlookup.Еслиlookupнаходит элемент с заданной строкой, то возвращает указатель на нее, если не находит, то возвращает NULL.
   /* lookup:ищет s */
   struct nlist *lookup(char *s)
   {
    struct nlist *np;

    for (np = hashtab[hash(s)]; np != NULL; np = np-›next)
     if (strcmp(s, np-›name) == 0)
      return np; /* нашли */
    return NULL; /* не нашли */
   }
   Вfor-цикле функцииlookupдля просмотра списка используется стандартная конструкция
   for (ptr = head; ptr != NULL; ptr = ptr-›next)…
   Функцияinstallобращается кlookup,чтобы определить, имеется ли уже вставляемое имя. Если это так, то старое определение будет заменено новым. В противном случае будет образован новый элемент. Если запрос памяти для нового элемента не может быть удовлетворен, функцияinstallвыдает NULL.
   struct nlist *lookup(char *);
   char *strdup(char *);

   /* install:заносит имя и текст (name, defn) в таблицу */
   struct nlist *install(char *name, char *defn)
   {
    struct nlist *np;
    unsigned hashval;
    if ((np = lookup(name)) == NULL) {/* не найден */
     np = (struct nlist *) malloc(sizeof(*np));
     if (np == NULL || (np-›name = strdup(name)) == NULL)
      return NULL;
     hashval = hash(name);
     np-›next = hashtab[hashval];
     hashtab[hashval] = np;
    }
    else /* уже имеется */
     free((void *) np-›defn); /* освобождаем прежний defn */
    if ((np-›defn = strdup(defn)) == NULL)
     return NULL;
    return np;
   }
   Упражнение 6.5.Напишите функциюundef,удаляющую имя и определение из таблицы, организация которой поддерживается функциямиlookupиinstall.
   Упражнение 6.6.Реализуйте простую версию#define-npoцeccopa (без аргументов), которая использовала бы программы этого параграфа и годилась бы для Си-программ. Вам могут помочь программыgetchиungetch.
   6.7Средство typedef
   Язык Си предоставляет средство, называемоеtypedef,которое позволяет давать типам данных новые имена. Например, объявление
   typedef int Length;
   делает имяLengthсинонимомint.С этого момента типLengthможно применять в объявлениях, в операторе приведения и т. д. точно так же, как типint:
   Length len, maxlen;
   Length *lengths[];
   Аналогично объявление
   typedef char *String;
   делаетStringсинонимомchar *,т. e. указателем наchar,и правомерным будет, например, следующее его использование:
   Stringр, lineptr[MAXLINES], alloc(int);
   int strcmp(String, String);
   p = (String) malloc(100);
   Заметим, что объявляемый вtypedefтип стоит на месте имени переменной в обычном объявлении, а не сразу за словомtypedef.С точки зрения синтаксиса словоtypedefнапоминает класс памяти -extern,staticи т. д. Имена типов записаны с заглавных букв для того, чтобы они выделялись.
   Для демонстрации более сложных примеров примененияtypedefвоспользуемся этим средством при задании узлов деревьев, с которыми мы уже встречались в данной главе.
   typedef struct tnode *Treeptr;
   typedef struct tnode {/*узел дерева: */
    char *word; /* указатель на текст */
    int count; /* число вхождений */
    Treeptr left; /* левый сын */
    Treeptr right; /* правый сын */
   } Treenode;
   В результате создаются два новых названия типов:Treenode (структура) иTreeptr (указатель на структуру). Теперь программуtallocможно записать в следующем виде:
   Treeptr talloc(void) {
    return (Treeptr) malloc(sizeof(Treenode));
   }
   Следует подчеркнуть, что объявлениеtypedefне создает объявления нового типа, оно лишь сообщает новое имя уже существующему типу. Никакого нового смысла эти новые имена не несут, они объявляют переменные в точности с теми же свойствами, как если бы те были объявлены напрямую без переименования типа. Фактическиtypedefаналогичен#defineс тем лишь отличием, что при интерпретации компилятором он может справиться с такой текстовой подстановкой, которая не может быть обработана препроцессором. Например
   typedef int (*PFI)(char *, char *);
   создает типPFI - "указатель на функцию (двух аргументов типаchar *),возвращающуюint",который, например, в программе сортировки, описанной в главе 5, можно использовать в таком контексте:
   PFI strcmp, numcmp;
   Помимо просто эстетических соображений, для примененияtypedefсуществуют две важные причины. Первая - параметризация программы, связанная с проблемой переносимости. Если с помощьюtypedefобъявить типы данных, которые, возможно, являются машинно-зависимыми, то при переносе программы на другую машину потребуется внести изменения только в определенияtypedef.Одна из распространенных ситуаций - использованиеtypedef-имен для варьирования целыми величинами. Для каждой конкретной машины это предполагает соответствующие установкиshort,intилиlong,которые делаются аналогично установкам стандартных типов, напримерsize_tиptrdiff_t.
   Вторая причина, побуждающая к применениюtypedef,-желание сделать более ясным текст программы. Тип, названныйТreeptr (от английских слов tree - дерево и pointer - указатель), более понятен, чем тот же тип, записанный как указатель на некоторую сложную структуру.
   6.8Объединения
   Объединение -это переменная, которая может содержать (в разные моменты времени) объекты различных типов и размеров. Все требования относительно размеров и выравнивания выполняет компилятор. Объединения позволяют хранить разнородные данные в одной и той же области памяти без включения в программу машинно-зависимой информации. Эти средства аналогичны вариантным записям в Паскале.
   Примером использования объединений мог бы послужить сам компилятор, заведующий таблицей символов, если предположить, что константа может иметь типint,floatили являться указателем на символ и иметь типchar *.Значение каждой конкретной константы должно храниться в переменной соответствующего этой константе типа. Работать с таблицей символов всегда удобнее, если значения занимают одинаковую по объёму память и запоминаются в одном и том же месте независимо от своего типа. Цель введения в программу объединения - иметь переменную, которая бы на законных основаниях хранила в себе значения нескольких типов. Синтаксис объединений аналогичен синтаксису структур. Приведем пример объединения.
   union u_tag {
    int ival;
    float fval;
    char *sval;
   } u;
   Переменнаяuбудет достаточно большой, чтобы в ней поместилась любая переменная из указанных трех типов: точный ее размер зависит от реализации. Значение одного из этих трех типов может быть присвоено переменнойuи далее использовано в выражениях, если это правомерно, т. е. если тип взятого ею значения совпадает с типом последнего присвоенного ей значения. Выполнение этого требования в каждый текущий момент - целиком на совести программиста. В том случае, если нечто запомнено как значение одного типа, а извлекается как значение другого типа, результат зависит от реализации. Синтаксис доступа к элементам объединения следующий:
   имя-объединения.элемент
   или
   указатель-на-объединение-›элемент
   т. е. в точности такой, как в структурах. Если для хранения типа текущего значенияuиспользовать, скажем, переменнуюutype,то можно написать такой фрагмент программы:
   if (utype == INT)
    printf("%d\n", u.ival);
   else if (utype == FLOAT)
    printf("%f\n", u.fval);
   else if (utype == STRING)
    printf("%s\n", u.sval);
   else
    printf ("неверный тип %d в utype\n", utype);
   Объединения могут входить в структуры и массивы, и наоборот. Запись доступа к элементу объединения, находящегося в структуре (как и структуры, находящейся в объединении), такая же, как и для вложенных структур. Например, в массиве структур
   struct {
    char *name;
    int flags;
    int utype;
    union {
     int ival;
     float fval;
     char *sval;
    } u;
   } symtab[NSYM];
   кivalобращаются следующим образом:
   symtab[i].u.ival
   а к первому символу строкиsvalможно обратиться любым из следующих двух способов:
   *symtab[i].u.sval
   symtab[i].u.sval[0]
   Фактически объединение - это структура, все элементы которой имеют нулевое смещение относительно ее базового адреса и размер которой позволяет поместиться в ней самому большому ее элементу, а выравнивание этой структуры удовлетворяет всем типам объединения. Операции, применимые к структурам, годятся и для объединений, т. е. законны присваивание объединения и копирование его как единого целого, взятие адреса от объединения и доступ к отдельным его элементам.
   Инициализировать объединение можно только значением, имеющим тип его первого элемента; таким образом, упомянутую выше переменнуюuможно инициализировать лишь значением типаint.
   В главе 8 (на примере программы, заведующей выделением памяти) мы покажем, как, применяя объединение, можно добиться, чтобы расположение переменной было выровнено по соответствующей границе в памяти.
   6.9Битовые поля
   При дефиците памяти может возникнуть необходимость запаковать несколько объектов в одно слово машины. Одна из обычных ситуаций, встречающаяся в задачах обработки таблиц символов для компиляторов, - это объединение групп однобитовых флажков. Форматы некоторых данных могут от нас вообще не зависеть и диктоваться, например, интерфейсами с аппаратурой внешних устройств: здесь также возникает потребность адресоваться к частям слова.
   Вообразим себе фрагмент компилятора, который заведует таблицей символов. Каждый идентификатор программы имеет некоторую связанную с ним информацию: например, представляет ли он собой ключевое слово и, если это переменная, к какому классу принадлежит: внешняя и/или статическая и т. д. Самый компактный способ кодирования такой информации - расположить однобитовые флажки в одном слове типаcharилиint.
   Один из распространенных приемов работы с битами основан на определении набора "масок", соответствующих позициям этих битов, как, например, в
   #define KEYWORD 01 /*ключевое слово */
   #define EXTERNAL 02 /*внешний */
   #define STATIC 04 /*статический */
   или в
   enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };
   Числа должны быть степенями двойки. Тогда доступ к битам становится делом "побитовых операций", описанных в главе 2 (сдвиг, маскирование, взятие дополнения). Некоторые виды записи выражений встречаются довольно часто. Так,
   flags |= EXTERNAL | STATIC;
   устанавливает 1 в соответствующих битах переменнойflags,
   flags&= ~(EXTERNAL | STATIC);
   обнуляет их, a
   if ((flags& (EXTERNAL | STATIC)) == 0)…
   оценивает условие как истинное, если оба бита нулевые.
   Хотя научиться писать такого рода выражения не составляет труда, вместо побитовых логических операций можно пользоваться предоставляемым Си другим способом прямого определения и доступа к полям внутри слова. Битовое поле (или для краткости просто поле) - это некоторое множество битов, лежащих рядом внутри одной, зависящей от реализации единицы памяти, которую мы будем называть "словом". Синтаксис определения полей и доступа к ним базируется на синтаксисе структур. Например, строки#define,фигурировавшие выше при задании таблицы символов, можно заменить на определение трех полей:
   struct {
    unsigned int is_keyword: 1;
    unsigned int is_extern: 1;
    unsigned int is_static: 1;
   } flags;
   Эта запись определяет переменнуюflags,которая содержит три однобитовых поля. Число, следующее за двоеточием, задает ширину поля. Поля объявлены какunsigned int,чтобы они воспринимались как беззнаковые величины.
   На отдельные поля ссылаются так же, как и на элементы обычных структур:flags.is_keyword,flags.is_externи т.д. Поля "ведут себя" как малые целые и могут участвовать в арифметических выражениях точно так же, как и другие целые. Таким образом, предыдущие примеры можно написать более естественно:
   flags.is_extern = flags.is_static = 1;
   устанавливает 1 в соответствующие биты;
   flags.is_extern = flags.is_static = 0;
   их обнуляет, а
   if (flags.is_extern == 0&& flags.is_ststic == 0)…
   проверяет их.
   Почти все технические детали, касающиеся полей, в частности, возможность поля перейти границу слова, зависят от реализации. Поля могут не иметь имени; с помощью безымянного поля (задаваемого только двоеточием и шириной) организуется пропуск нужного количества разрядов. Особая ширина, равная нулю, используется, когда требуется выйти на границу следующего слова.
   На одних машинах поля размещаются слева направо, на других - справа налево. Это значит, что при всей полезности работы с ними, если формат данных, с которыми мы имеемдело, дан нам свыше, то необходимо самым тщательным образом исследовать порядок расположения полей; программы, зависящие от такого рода вещей, не переносимы. Поля можно определять только с типомint,а для того чтобы обеспечить переносимость, надо явно указыватьsignedилиunsigned.Они не могут быть массивами и не имеют адресов, и, следовательно, оператор &к ним не применим.
   Глава 7. Ввод и вывод
   Возможности для ввода и вывода не являются частью самого языка Си, поэтому мы подробно и не рассматривали их до сих пор. Между тем реальные программы взаимодействуют со своим окружением гораздо более сложным способом, чем те, которые были затронуты ранее. В этой главе мы опишем стандартную библиотеку, содержащую набор функций, обеспечивающих ввод-вывод, работу со строками, управление памятью, стандартные математические функции и разного рода сервисные Си-программы. Но особое внимание уделим вводу-выводу.
   Библиотечные функции ввода-вывода точно определяются стандартом ANSI, так что они совместимы на любых системах, где поддерживается Си. Программы, которые в своем взаимодействии с системным окружением не выходят за рамки возможностей стандартной библиотеки, можно без изменений переносить с одной машины на другую.
   Свойства библиотечных функций специфицированы в более чем дюжине заголовочных файлов; вам уже встречались некоторые из них, в том числе‹stdio.h›,‹string.h›и‹ctype.h›.Мы не рассматриваем здесь всю библиотеку, так как нас больше интересует написание Си-программ, чем использование библиотечных функций. Стандартная библиотека подробно описана в приложении B.
   7.1Стандартный ввод-вывод
   Как уже говорилось в главе 1, библиотечные функции реализуют простую модель текстового ввода-вывода. Текстовый поток состоит из последовательности строк; каждая строка заканчивается символом новой строки. Если система в чем-то не следует принятой модели, библиотека сделает так, чтобы казалось, что эта модель удовлетворяется полностью. Например, пара символов -возврат-кареткииперевод-строки -при вводе могла бы быть преобразована в один символ новой строки, а при выводе выполнялось бы обратное преобразование.
   Простейший механизм ввода - это чтение одного символа изстандартного ввода (обычно с клавиатуры) функциейgetchar:
   int getchar(void)
   В качестве результата каждого своего вызова функцияgetcharвозвращает следующий символ ввода или, если обнаружен конец файла,EOF.Именованная константа EOF (аббревиатура отend of file -конец файла) определена в‹stdio.h›.Обычно значениеEOFравно -1, но, чтобы не зависеть от конкретного значения этой константы, обращаться к ней следует по имени (EOF).
   Во многих системах клавиатуру можно заменить файлом, перенаправив ввод с помощью значка‹.Так, если программаprogиспользуетgetchar,то командная строка
   prog‹ infile
   предпишет программеprogчитать символы изinfile,а не с клавиатуры. Переключение ввода делается так, что сама программаprogне замечает подмены; в частности строка"‹ infile"не будет включена в аргументы командной строкиargv.Переключение ввода будет также незаметным, если ввод исходит от другой программы и передается конвейерным образом. В некоторых системах командная строка
   otherprog | prog
   приведет к тому, что запустится две программы,otherprogиprog,и стандартный выходotherprogпоступит на стандартный входprog.Функция
   int putchar(int)
   используется для вывода:putchar(c)отправляет символcвстандартный вывод,под которым по умолчанию подразумевается экран. Функцияputcharв качестве результата возвращает посланный символ или, в случае ошибки,EOF.То же и в отношении вывода: с помощью записи вида› имя-файлавывод можно перенаправить в файл. Например, еслиprogиспользует для вывода функциюputchar,то
   prog› outfile
   будет направлять стандартный вывод не на экран, а вoutfile.А командная строка
   prog | anotherprog
   соединит стандартный вывод программыprogсо стандартным вводом программыanotherprog.
   Вывод, осуществляемый функциейprintf,также отправляется в стандартный выходной поток. Вызовыputcharиprintfмогут как угодно чередоваться, при этом вывод будет формироваться в той последовательности, в которой происходили вызовы этих функций.
   Любой исходный Си-файл, использующий хотя бы одну функцию библиотеки ввода-вывода, должен содержать в себе строку
   #include‹stdio.h›
   причем она должна быть расположена до первого обращения к вводу-выводу. Если имя заголовочного файла заключено в угловые скобки ‹ и ›, это значит, что поиск заголовочного файла ведется в стандартном месте (например в системе UNIX это обычно директорий/usr/include).
   Многие программы читают только из одного входного потока и пишут только в один выходной поток. Для организации ввода-вывода таким программам вполне хватит функцийgetchar,putcharиprintf,а для начального обучения уж точно достаточно ознакомления с этими функциями. В частности, перечисленных функций достаточно, когда требуется вывод одной программы соединить с вводом следующей. В качестве примера рассмотрим программуlower,переводящую свой ввод на нижний регистр:
   #include‹stdio.h›
   #include‹ctype.h›

   main() /* lower:переводит ввод на нижний регистр */
   {
    int с;
    while ((с = getchar()) != EOF)
     putchar(tolower(c));
    return 0;
   }
   Функцияtolowerопределена в‹ctype.h›.Она переводит буквы верхнего регистра в буквы нижнего регистра, а остальные символы возвращает без изменений. Как мы уже упоминали, "функции" вродеgetcharиputcharиз библиотеки‹stdio.h›и функцияtolowerиз библиотеки‹ctype.h›часто реализуются в виде макросов, чтобы исключить накладные расходы от вызова функции на каждый отдельный символ. В параграфе 8.5 мы покажем, как это делается. Независимо от того, как на той или иной машине реализованы функции библиотеки‹ctype.h›,использующие их программы могут ничего не знать о кодировке символов.
   Упражнение 7.1.Напишите программу, осуществляющую перевод ввода с верхнего регистра на нижний или с нижнего на верхний в зависимости от имени, по которому она вызывается и текст которого находится вarg[0].
   7.2Форматный вывод (printf)
   Функцияprintfпереводит внутренние значения в текст.
   int printf(char *format, arg1, arg2,…)
   В предыдущих главах мы использовалиprintfнеформально. Здесь мы покажем наиболее типичные случаи применения этой функции: полное ее описание дано в приложении B.
   Функцияprintfпреобразует, форматирует и печатает свои аргументы в стандартном выводе под управлением формата. Возвращает она количество напечатанных символов.
   Форматная строка содержит два вида объектов: обычные символы, которые напрямую копируются в выходной поток, и спецификации преобразования, каждая из которых вызывает преобразование и печать очередного аргументаprintf.Любая спецификация преобразования начинается знаком%и заканчиваетсясимволом-спецификатором.Между%и символом-спецификатором могут быть расположены (в указанном ниже порядке) следующие элементы:
   • Знак минус, предписывающий выравнивать преобразованный аргумент по левому краю поля.
   • Число, специфицирующее минимальную ширину поля. Преобразованный аргумент будет занимать поле по крайней мере указанной ширины. При необходимости лишние позиции слева (или справа при левостороннем расположении) будут заполнены пробелами.
   • Точка, отделяющая ширину поля от величины, устанавливающей точность.
   • Число (точность), специфицирующее максимальное количество печатаемых символов в строке, или количество цифр после десятичной точки - для чисел с плавающей запятой, или минимальное количество цифр - для целого.
   • Буква h, если печатаемое целое должно рассматриваться как short, или l (латинская буква ell), если целое должно рассматриваться как long.
   Символы-спецификаторы перечислены в таблице 7.1. Если за%не помещен символ- спецификатор, поведение функцииprintfбудет не определено. Ширину и точность можно специфицировать с помощью*;значение ширины (или точности) в этом случае берется из следующего аргумента (который должен быть типаint).Например, чтобы напечатать не болееmaxсимволов из строкиs,годится следующая запись:
   printf("%.*s", max, s);
   Таблица 7.1 Основные преобразования printfСимволТип аргумента; вид печатиd,iint;десятичное целоеounsigned int;беззнаковое восьмеричное (octal)целое (без нуля слева)x,X unsigned int;беззнаковое шестнадцатеричное целое (без 0x или 0X слева), для 10…15 используются abcdef или ABCDEFuunsigned int;беззнаковое десятичное целоеcint;одиночный символschar *;печатает символы, расположенные до знака \0, или в количестве, заданном точностьюfdouble;[-]m.dddddd,где количество цифрdзадается точностью (по умолчанию равно 6)e,Edouble;[-]m.dddddde+xxили[-]m.ddddddE+xx,где количество цифрdзадается точностью (по умолчанию равно 6)g,Gdouble;использует%eили%E,если порядок меньше, чем -4, или больше или равен точности; в противном случае использует%f.Завершающие нули и завершающая десятичная точка не печатаютсяpvoid *;указатель (представление зависит от реализации)%Аргумент не преобразуется; печатается знак%
   Большая часть форматных преобразований была продемонстрирована в предыдущих главах. Исключение составляет задание точности для строк. Далее приводится переченьспецификаций и показывается их влияние на печать строки "hello, world", состоящей из 12 символов. Поле специально обрамлено двоеточиями, чтобы была видна его протяженность.
   :%s:        :hello, world:
   :%10s       :hello, world:
   :%.10s:     :hello, wor:
   :%-10s:     :hello, world:
   :%.15s:     :hello, world:
   :%-15s:     :hello, world     :
   :%15.10s:   :       hello, wor:
   :%-15.10s:  :hello, wor       :
   Предостережение: функцияprintfиспользует свой первый аргумент, чтобы определить, сколько еще ожидается аргументов и какого они будут типа. Вы не получите правильного результата, если аргументов будет не хватать или они будут принадлежать не тому типу. Вы должны также понимать разницу в следующих двух обращениях:
   printf(s); /*НЕВЕРНО, если в s есть % */
   printf("%s", s); /*ВЕРНО всегда */
   Функцияsprintfвыполняет те же преобразования, что иprintf,но вывод запоминает в строке
   int sprintf(char *string, char *format, arg1, arg2,…)
   Эта функция форматируетarg1,arg2и т. д. в соответствии с информацией, заданной аргументомformat,как мы описывали ранее, но результат помещает не в стандартный вывод, а вstring.Заметим, что строкаstringдолжна быть достаточно большой, чтобы в ней поместился результат.
   Упражнение 7.2.Напишите программу, которая будет печатать разумным способом любой ввод. Как минимум она должна уметь печатать неграфические символы в восьмеричном или шестнадцатеричном виде (в форме, принятой на вашей машине), обрывая длинные текстовые строки.
   7.3Списки аргументов переменной длины
   Этот параграф содержит реализацию минимальной версииprintf.Приводится она для того, чтобы показать, как надо писать функции со списками аргументов переменной длины, причем такие, которые были бы переносимы. Поскольку нас главным образом интересует обработка аргументов, функциюminprintfнапишем таким образом, что она в основном будет работать с задающей формат строкой и аргументами; что же касается форматных преобразований, то они будут осуществляться с помощью стандартногоprintf.
   Объявление стандартной функцииprintfвыглядит так:
   int printf(char *fmt,…)
   Многоточие в объявлении означает, что число и типы аргументов могут изменяться. Знак многоточие может стоять только в конце списка аргументов. Наша функцияminprintfобъявляется как
   void minprintf(char *fmt,…)
   поскольку она не будет выдавать число символов, как это делаетprintf.
   Вся сложность в том, каким образомminprintfбудет продвигаться вдоль списка аргументов, - ведь у этого списка нет даже имени. Стандартный заголовочный файл‹stdarg.h›содержит набор макроопределений, которые устанавливают, как шагать по списку аргументов. Наполнение этого заголовочного файла может изменяться от машины к машине, но представленный им интерфейс везде одинаков.
   Типva_listслужит для описания переменной, которая будет по очереди указывать на каждый из аргументов; вminprintfэта переменная имеет имяap (от "argument pointer" -указатель на аргумент). Макросva_startинициализирует переменнуюap)чтобы она указывала на первый безымянный аргумент. Кva_startнужно обратиться до первого использованияap.Среди аргументов по крайней мере один должен быть именованным: от последнего именованного аргумента этот макрос "отталкивается" при начальной установке.
   Макросva_argна каждом своем вызове выдает очередной аргумент, аapпередвигает на следующий: но имени типа он определяет тип возвращаемого значения и размер шага для выхода на следующий аргумент. Наконец, макросva_endделает очистку всего, что необходимо. Кva_endследует обратиться перед самым выходом из функции.
   Перечисленные средства образуют основу нашей упрощенной версииprinf.
   #include‹stdarg.h›

   /* minprintf:минимальный printf с переменным числом аргументов */
   void minprintf(char *fmt,…)
   {
    va_list ap; /* указывает на очередной безымянный аргумент */
    char *p, *sval;
    int ival;
    double dval;

    va_start(ap, fmt); /* устанавливает ap на 1-й безымянный аргумент */
    for (p=fmt; *p; p++) {
     if (*p !='%') {
      putchar(*p);
      continue;
     }
     switch (*++p) {
     case 'd':
      ival = va_arg(ap, int);
      printf ("%d", ival);
      break;
     case 'f':
      dval = va_arg(ap, double);
      printf("%f", dval);
      break;
     case 's':
       for (sval = va_arg(ap, char *); *sval; sval++)
        putchar(*sval);
       break;
     default:
      putchar(*p);
      break;
     }
    }
    va_end(ap); /* очистка, когда все сделано */
   }
   Упражнение 7.3.Дополнитеminprintfдругими возможностямиprintf.
   7.4Форматный ввод (scanf)
   Функцияscanf,обеспечивающая ввод, является аналогомprintf;она выполняет многие из упоминавшихся преобразований, но в противоположном направлении. Ее объявление имеет следующий вид:
   int scanf(char *format,…)
   Функцияscanfчитает символы из стандартного входного потока, интерпретирует их согласно спецификациям строкиformatи рассылает результаты в свои остальные аргументы. Аргументformatмы опишем позже; другие аргументы, каждый из которых должен быть указателем, определяют, где будут запоминаться должным образом преобразованные данные. Как и дляprintf,в этом параграфе дается сводка наиболее полезных, но отнюдь не всех возможностей данной функции.
   Функцияscanfпрекращает работу, когда оказывается, что исчерпался формат или вводимая величина не соответствует управляющей спецификации. В качестве результатаscanfвозвращает количество успешно введенных элементов данных. По исчерпании файла она выдаетEOF.Существенно то, что значение EOF не равно нулю, поскольку нульscanfвыдает, когда вводимый символ не соответствует первой спецификации форматной строки. Каждое очередное обращение кscanfпродолжает ввод символа, следующего сразу за последним обработанным.
   Существует также функцияsscanf,которая читает из строки (а не из стандартного ввода).
   int sscanf(char *string, char *format, arg1, arg2,…)
   Функцияsscanfпросматривает строкуstringсогласно форматуformatи рассылает полученные значения вarg1,arg2и т. д. Последние должны быть указателями.
   Формат обычно содержит спецификации, которые используются для управления преобразованиями ввода. В него могут входить следующие элементы:
   • Пробелы или табуляции, которые игнорируются.
   • Обычные символы (исключая %), которые, как ожидается, совпадут с очередными символами, отличными от символов-разделителей входного потока.
   • Спецификации преобразования, каждая из которых начинается со знака % и завершается символом-спецификатором типа преобразования. В промежутке между этими двумя символами в любой спецификации могут располагаться, причем в том порядке, как они здесь указаны: знак * (признак подавления присваивания); число, определяющее ширинуполя; буква h, l или L, указывающая на размер получаемого значения; и символ преобразования (o, d, x).
   Спецификация преобразования управляет преобразованием следующего вводимого поля. Обычно результат помещается в переменную, на которую указывает соответствующий аргумент. Однако если в спецификации преобразования присутствует*,то поле ввода пропускается и никакое присваивание не выполняется. Поле ввода определяется как строка без символов-разделителей; оно простирается до следующего символа-разделителя или же ограничено шириной поля, если она задана. Поскольку символ новой строки относится к символам-разделителям, тоsscanfпри чтении будет переходить с одной строки на другую. (Символами-разделителями являются символы пробела, табуляции, новой строки, возврата каретки, вертикальной табуляции и перевода страницы.)
   Символ-спецификатор указывает, каким образом следует интерпретировать очередное поле ввода. Соответствующий аргумент должен быть указателем, как того требует механизм передачи параметров по значению, принятый в Си. Символы-спецификаторы приведены в таблице 7.2.
   Перед символами-спецификаторамиd,l,o,uиxможет стоять букваh,указывающая на то, что соответствующий аргумент должен иметь типshort * (а неint *),илиl (латинская ell), указывающая на типlong *.Аналогично, перед символами-спецификаторамиe,fиgможет стоять букваl,указывающая, что тип аргумента -double * (а неfloat *).
   Таблица 7.2 Основные преобразования scanfСимволВводимые данные; тип аргументаdдесятичное целое:int *iцелое:int *.Целое может быть восьмеричным (с 0 слева) или шестнадцатеричным (с 0x или 0X слева)oвосьмеричное целое (с нулем слева или без него);int *uбеззнаковое десятичное целое;unsigned int *xшестнадцатеричное целое (с 0x или 0X слева или без них);int *cсимволы;char *.Следующие символы ввода (по умолчанию один) размещаются в указанном месте. Обычный пропуск символов- разделителей подавляется; чтобы прочесть очередной символ, отличный от символа-разделителя, используйте %1ssСтрока символов(без обрамляющих кавычек);char *,указывающая на массив символов, достаточный для строки и завершающего символа '\0', который будет добавленe,f,gчисло с плавающей точкой, возможно, со знаком; обязательно присутствие либо десятичной точки, либо экспоненциальной части, а возможно, и обеих вместе;float *%сам знак%,никакое присваивание не выполняется
   Чтобы построить первый пример, обратимся к программе калькулятора из главы 4, в которой организуем ввод с помощью функцииscanf:
   #include‹stdio.h›

   main() /*программа-калькулятор */ {
    double sum, v;

    sum = 0;
    while (scanf ("%lf",&v) == 1)
     printf("\t%.2f\n", sum += v);
    return 0;
   }
   Предположим, что нам нужно прочитать строки ввода, содержащие данные вида
   25дек 1988
   Обращение кscanfвыглядит следующим образом:
   int day, year; /*день, год */
   char monthname[20]; /*название месяца */

   scanf ("%d %s %d",&day, monthname,&year);
   Знак &передmonthnameне нужен, так как имя массива есть указатель.
   В строке формата могут присутствовать символы, не участвующие ни в одной из спецификаций; это значит, что эти символы должны появиться на вводе. Так, мы могли бы читать даты видаmm/dd/yyс помощью следующего обращения кscanf:
   int day, month, year; /*день, месяц, год */
   scanf("%d/%d/%d",&day,&month,&year);
   В своем формате функцияscanfигнорирует пробелы и табуляции. Кроме того, при поиске следующей порции ввода она пропускает во входном потоке все символы- разделители (пробелы, табуляции, новые строки и т.д.). Воспринимать входной поток, не имеющий фиксированного формата, часто оказывается удобнее, если вводить всю строку целиком и для каждого отдельного случая подбирать подходящий вариантsscanf.Предположим, например, что нам нужно читать строки с датами, записанными в любой из приведенных выше форм. Тогда мы могли бы написать:
   while (getline(line, sizeof(line))› 0) {
    if (sscanf(line, "%d %s %d",&day, monthname,&year) == 3)
     printf("вepно: %s\r", line); /* в виде 25 дек 1968 */
    else if (sscanf(line, "%d/%d/%d",&month,&day,&year) == 3)
     printf("вepно: %s\n", line); /* в виде mm/dd/yy */
    else
     printf("неверно: %s\n", line); /* неверная форма даты */
   }
   Обращения кscanfмогут перемежаться с вызовами других функций ввода. Любая функция ввода, вызванная послеscanf,продолжит чтение с первого еще непрочитанного символа.
   В завершение еще раз напомним, что аргументы функцийscanfиsscanfдолжны быть указателями.
   Одна из самых распространенных ошибок состоит в том, что вместо того, чтобы написать
   scanf ("%d",&n);
   пишут
   scanf("%d", n);
   Компилятор о подобной ошибке ничего не сообщает.
   Упражнение 7.4.Напишите свою версиюscanfпо аналогии сminprintfиз предыдущего параграфа.
   Упражнение 7.5.Перепишите основанную на постфиксной записи программу калькулятора из главы 4 таким образом, чтобы для ввода и преобразования чисел она использовалаscanfи/илиsscanf.
   7.5Доступ к файлам
   Во всех предыдущих примерах мы имели дело со стандартным вводом и стандартным выводом, которые для программы автоматически предопределены операционной системой конкретной машины.
   Следующий шаг - научиться писать программы, которые имели бы доступ к файлам, заранее не подсоединенным к программам. Одна из программ, в которой возникает такая необходимость, - это программаcat,объединяющая несколько именованных файлов и направляющая результат в стандартный вывод. Функцияcatчасто применяется для выдачи файлов на экран, а также как универсальный "коллектор" файловой информации для тех программ, которые не имеют возможности обратиться к файлу по имени. Например, команда
   cat x.c y.c
   направит в стандартный вывод содержимое файловx.cиy.c (и ничего более).
   Возникает вопрос: что надо сделать, чтобы именованные файлы можно было читать; иначе говоря, как связать внешние имена, придуманные пользователем, с инструкциями чтения данных?
   На этот счет имеются простые правила. Для того чтобы можно было читать из файла или писать в файл, он должен быть предварительно открыт с помощью библиотечной функцииfopen.Функцияfopenполучает внешнее имя типаx.cилиy.c,после чего осуществляет некоторые организационные действия и "переговоры" с операционной системой (технические детали которых здесь не рассматриваются) и возвращает указатель, используемый в дальнейшем для доступа к файлу.
   Этот указатель, называемыйуказателем файла,ссылается на структуру, содержащую информацию о файле (адрес буфера, положение текущего символа в буфере, открыт файл на чтение или на запись, были ли ошибки при работе с файлом и не встретился ли конец файла). Пользователю не нужно знать подробности, поскольку определения, полученные из ‹stdio.h›, включают описание такой структуры, называемойFILE.
   Единственное, что требуется для определения указателя файла, - это задать описания такого, например, вида:
   FILE *fp;
   FILE *fopen(char *name, char *mode);
   Это говорит, чтоfpесть указатель наFILE, afopenвозвращает указатель наFILE.Заметим, чтоFILE -это имя типа) наподобиеint,а не тег структуры. Оно определено с помощьюtypedef. (Детали того, как можно реализоватьfopenв системе UNIX, приводятся в параграфе 8.5.)
   Обращение кfopenв программе может выглядеть следующим образом:
   fp = fopen(name, mode);
   Первый аргумент - строка, содержащая имя файла. Второй аргумент несет информацию о режиме. Это тоже строка: в ней указывается, каким образом пользователь намерен применять файл. Возможны следующие режимы: чтение (read - "r"),запись (write - "w")и добавление (append - "a"),т. е. запись информации в конец уже существующего файла. В некоторых системах различаются текстовые и бинарные файлы; в случае последних в строку режима необходимодобавить букву "b" (binary -бинарный).
   Тот факт, что некий файл, которого раньше не было, открывается на запись или добавление, означает, что он создается (если такая процедура физически возможна). Открытие уже существующего файла на запись приводит к выбрасыванию его старого содержимого, в то время как при открытии файла на добавление его старое содержимое сохраняется. Попытка читать несуществующий файл является ошибкой. Могут иметь место и другие ошибки; например, ошибкой считается попытка чтения файла, который по статусу запрещено читать. При наличии любой ошибкиfopenвозвращает NULL. (Возможна более точная идентификация ошибки; детальная информация по этому поводу приводится в конце параграфа 1 приложения B.)
   Следующее, что нам необходимо знать, - это как читать из файла или писать в файл, коль скоро он открыт. Существует несколько способов сделать это, из которых самый простой состоит в том, чтобы воспользоваться функциямиgetcиputc.Функцияgetcвозвращает следующий символ из файла; ей необходимо сообщить указатель файла, чтобы она знала откуда брать символ.
   int getc(FILE *fp);
   Функцияgetcвозвращает следующий символ из потока, на который указывает*fp;в случае исчерпания файла или ошибки она возвращает EOF.
   Функцияputcпишет символcв файлfp
   int putc(intс, FILE *fp);
   и возвращает записанный символ или EOF в случае ошибки. Аналогичноgetcharиputchar,реализацияgetcиputcможет быть выполнена в виде макросов, а не функций.
   При запуске Си-программы операционная система всегда открывает три файла и обеспечивает три файловые ссылки на них. Этими файлами являются: стандартный ввод, стандартный вывод и стандартный файл ошибок; соответствующие им указатели называютсяstdin,stdoutиstderr;они описаны в ‹stdio.h›. Обычноstdinсоотнесен с клавиатурой, аstdoutиstderr -с экраном. Однакоstdinиstdoutможно связать с файлами или, используя конвейерный механизм, соединить напрямую с другими программами, как это описывалось в параграфе 7.1.
   С помощьюgetc,putc,stdinиstdoutфункцииgetcharиputcharтеперь можно определить следующим образом:
   #define getchar() getc(stdin)
   #define putchar(c) putc((c), stdout)
   Форматный ввод-вывод файлов можно построить на функцияхfscanfиfprintf.Они идентичныscanfиprintfс той лишь разницей, что первым их аргументом является указатель на файл, для которого осуществляется ввод-вывод, формат же указывается вторым аргументом.
   int fscanf(FILE *fp, char *format,…)
   int fprintf(FILE *fp, char *format,…)
   Вот теперь мы располагаем теми сведениями, которые достаточны для написания программыcat,предназначенной для конкатенации (последовательного соединения) файлов. Предлагаемая версия функцииcat,как оказалось, удобна для многих программ. Если в командной строке присутствуют аргументы, они рассматриваются как имена последовательно обрабатываемых файлов. Если аргументов нет, то обработке подвергается стандартный ввод.
   #include‹stdio.h›
   /* cat:конкатенация файлов, версия 1 */
   main(int argc, char *argv[])
   {
    FILE *fp;
    void filecopy(FILE *, FILE *);

    if (argc == 1) /* нет аргументов; копируется стандартный ввод */
     filecopy(stdin, stdout);
    else
     while (--argc › 0)
      if ((fp = fopen(*++argv, "r")) == NULL) {
       printf("cat: не могу открыть файл %s\n", *argv);
       return 1;
      } else {
       filecopy(fp, stdout);
       fclose(fp);
      }
    return 0;
   }

   /* filecopy:копирует файл ifp в файл ofp */
   void filecopy(FILE *ifp, FILE *ofp)
   {
    int c;

    while ((c = getc(ifp)) != EOF)
     putc(c, ofp);
   }
   Файловые указателиstdinиstdoutпредставляют собой объекты типаFILE*.Это константы, а не переменные, следовательно, им нельзя ничего присваивать.
   Функция
   int fclose(FILE *fp)
   - обратная по отношению кfopen;она разрывает связь между файловым указателем и внешним именем (которая раньше была установлена с помощьюfopen),освобождая тем самым этот указатель для других файлов. Так как в большинстве операционных систем количество одновременно открытых одной программой файлов ограничено, то файловые указатели, если они больше не нужны, лучше освобождать, как это и делается в программеcat.Есть еще одна причина применитьfcloseк файлу вывода, - это необходимость "опорожнить" буфер, в которомputcнакопила предназначенные для вывода данные. При нормальном завершении работы программы для каждого открытого файлаfcloseвызывается автоматически. (Вы можете закрытьstdinиstdout,если они вам не нужны. Воспользовавшись библиотечной функциейfreopen,их можно восстановить.)
   7.6Управление ошибками (stderr и exit)
   Обработку ошибок вcatнельзя признать идеальной. Беда в том, что если файл по какой-либо причине недоступен, сообщение об этом мы получим по окончании конкатенируемого вывода. Это нас устроило бы, если бы вывод отправлялся только на экран, a не в файл или по конвейеру другой программе. Чтобы лучше справиться с этой проблемой, программе помимо стандартного выводаstdoutпридается еще один выходной поток, называемыйstderr.Вывод вstderrобычно отправляется на экран, даже если выводstdoutперенаправлен в другое место. Перепишемcatтак, чтобы сообщения об ошибках отправлялись вstderr.
   #include‹stdio.h›
   /* cat:конкатенация файлов, версия 2 */
   main(int argc, char *argv[])
   {
    FILE *fp;
    void filecopy(FILE *, FILE *);
    char *prog = argv[0]; /* имя программы */
    if (argc == 1) /* нет аргументов, копируется станд. ввод */
     filecopy(stdin, stdout);
    else
     while (--argc › 0)
      if ((fp = fopen(*++argv, "r")) == NULL) {
       fprintf(stderr, "%s: не могу открыть файл %s\n", prog, *argv);
       exit(1);
      } else {
       filecopy(fp, stdout);
       fclose(fp);
      }
    if (ferror(stdout)) {
     fprintf(stderr, "%s: ошибка записи в stdout\n", prog);
     exit(2);
    }
    exit(0);
   }
   Программа сигнализирует об ошибках двумя способами. Первый - сообщение об ошибке с помощьюfprintfпосылается вstderrс тем, чтобы оно попало на экран, а не оказалось на конвейере или в другом файле вывода. Имя программы, хранящееся вargv[0],мы включили в сообщение, чтобы в случаях, когда данная программа работает совместно с другими, был ясен источник ошибки.
   Второй способ указать на ошибку - обратиться к библиотечной функцииexit,завершающей работу программы. Аргумент функцииexitдоступен некоторому процессу, вызвавшему данный процесс. А следовательно, успешное или ошибочное завершение программы можно проконтролировать с помощью некоей программы, которая рассматривает эту программу в качестве подчиненного процесса. По общей договоренности возврат нуля сигнализирует о том, что работа прошла нормально, в то время как ненулевые значения обычно говорят об ошибках. Чтобы опорожнить буфера, накопившие информацию для всех открытых файлов вывода, функцияexitвызываетfclose.
   Инструкцияreturnexpглавной программыmainэквивалентна обращению к функцииexit(exp).Последний вариант (с помощьюexit)имеет то преимущество, что он пригоден для выхода и из других функций, и, кроме того, словоexitлегко обнаружить с помощью программы контекстного поиска, похожей на ту, которую мы рассматривали в главе 5. Функцияferrorвыдает ненулевое значение, если в файлеfpбыла обнаружена ошибка.
   int ferror(FILE *fp)
   Хотя при выводе редко возникают ошибки, все же они встречаются (например, оказался переполненным диск); поэтому в программах широкого пользования они должны тщательно контролироваться.
   Функцияfeof(FILE *fp) aнaлoгичнa функцииferror; oнa вoзвpaщaeт нeнулевое значение, если встретился конец указанного в аргументе файла.
   int feof(FILE *fp);
   В наших небольших иллюстративных программах мы не заботились о выдаче статуса выхода, т. е. выдаче некоторого числа, характеризующего состояние программы в моментзавершения: работа закончилась нормально или прервана из-за ошибки? Если работа прервана в результате ошибки, то какой? Любая серьезная программа должна выдавать статус выхода.
   7.7Ввод-вывод строк
   В стандартной библиотеке имеется программа вводаfgets,аналогичная программеgetline,которой мы пользовались в предыдущих главах.
   char *fgets(char *line, int maxline, FILE *fp)
   Функцияfgetsчитает следующую строку ввода (включая и символ новой строки) из файлаfpв массив символовline,причем она может прочитать не болееMAXLINE-1символов. Переписанная строка дополняется символом '\0'. Обычноfgetsвозвращаетline,а по исчерпании файла или в случае ошибки - NULL. (Нашаgetlineвозвращала длину строки, которой мы потом пользовались, и нуль в случае конца файла.)
   Функция выводаfputsпишет строку (которая может и не заканчиваться символом новой строки) в файл.
   int fputs(char *line, FILE *fp)
   Эта функция возвращает EOF, если возникла ошибка, и неотрицательное значение в противном случае.
   Библиотечные функцииgetsиputsподобны функциямfgetsиfputs.Отличаются они тем, что оперируют только стандартными файламиstdinиstdout,и кроме того,getsвыбрасывает последний символ '\n', aputsего добавляет.
   Чтобы показать, что ничего особенного в функциях вродеfgetsиfputsнет, мы приводим их здесь в том виде, в каком они существуют в стандартной библиотеке на нашей системе.
   /* fgets:получает не более n символов из iop */
   char *fgets(char *s, int n, FILE *iop) {
    register int c;
    register char *cs;

    cs = s;
    while (--n › 0&& (с = getc(iop)) != EOF)
     if ((*cs++ = c) == '\n')
      break;
    *cs= '\0';
    return (c == EOF&& cs == s) ? NULL : s;
   }

   /* fputs:посылает строку s в файл iop */
   int fputs(char *s, FILE *iop)
   {
    int c;

    while (c = *s++)
     putc(c, iop);
    return ferror(iop) ? EOF : 0;
   }
   Стандарт определяет, что функцияferrorвозвращает в случае ошибки ненулевое значение;fputsв случае ошибки возвращает EOF, в противном случае - неотрицательное значение.
   С помощьюfgetsлегко реализовать нашу функциюgetline:
   /* getline:читает строку, возвращает ее длину */
   int getline(char *line, int max)
   {
    if (fgets(line, max, stdin) == NULL)
     return 0;
    else
     return strlen(line);
   }
   Упражнение 7.6.Напишите программу, сравнивающую два файла и печатающую первую строку, в которой они различаются.
   Упражнение 7.7.Модифицируйте программу поиска по образцу из главы 5 таким образом, чтобы она брала текст из множества именованных файлов, а если имен файлов в аргументах нет, то из стандартного ввода. Будет ли печататься имя файла, в котором найдена подходящая строка?
   Упражнение 7.8.Напишите программу, печатающую несколько файлов. Каждый файл должен начинаться с новой страницы, предваряться заголовком и иметь свою нумерацию страниц.
   7.8Другие библиотечные функции
   В стандартной библиотеке представлен широкий спектр различных функций. Настоящий параграф содержит краткий обзор наиболее полезных из них. Более подробно эти и другие функции описаны в приложении B.
   7.8.1Операции со строками
   Мы уже упоминали функцииstrlen,strcpy,strcatиstrcmp,описание которых даны в ‹string.h›. Далее, до конца пункта, предполагается, чтоsиtимеют типchar *,cиn -типint.
   strcat(s,t) -приписываетtв конецs.
   strncat(s,t,n) -приписываетnсимволов изtв конецs.
   strcmp(s,t) -возвращает отрицательное число, нуль или положительное число дляs‹t,s - tилиs›t,соответственно.
   strncmp(s,t,n) -делает то же, что иstrcmp,но количество сравниваемых символов не может превышатьn
   strcpy(s,t) -копируетtвs.
   strncpy(s,t,n) -копирует не болееnсимволов изtвs.
   strlen(s) -возвращает длинуs.
   strchr(s,c) -возвращает указатель на первое появление символаcвsили, еслиcнет вs, NULL.
   strrchr(s,c) -возвращает указатель на последнее появление символаcвsили, еслиcнет вs, NULL.
   7.8.2Анализ класса символов и преобразование символов
   Несколько функций из библиотеки ‹ctype.h› выполняют проверки и преобразование символов. Далее, до конца пункта, переменнаяc -это переменная типаint,которая может быть представлена значениемunsigned,charилиEOF.Все эти функции возвращают значения типаint.
   isalpha(c) -не нуль, еслиc -буква; 0 в противном случае.
   isupper(c) -не нуль, еслиc -буква верхнего регистра; 0 в противном случае.
   islower(c) -не нуль, еслиc -буква нижнего регистра; 0 в противном случае.
   isdigit(c) -не нуль, еслиc -цифра; 0 в противном случае.
   isalnum(c) -не нуль, если илиisalpha(c),илиisdigit(c)истинны; 0 в противном случае.
   isspace(c) -не нуль, еслиc -символ пробела, табуляции, новой строки, возврата каретки, перевода страницы, вертикальной табуляции.
   toupper(c) -возвращаетc,приведенную к верхнему регистру.
   tolower(c) -возвращаетc,приведенную к нижнему регистру.
   7.8.3Функция ungetc
   В стандартной библиотеке содержится более ограниченная версия функцииungetchпо сравнению с той, которую мы написали в главе 4. Называется онаungetc.Эта функция, имеющая прототип
   int ungetc(intс, FILE *fp)
   отправляет символcназад в файлfpи возвращаетc,а в случае ошибки EOF. Для каждого файла гарантирован возврат не более одного символа. Функциюungetcможно использовать совместно с любой из функций ввода вродеscanf,getc,getcharи т. д.
   7.8.4Исполнение команд операционной системы
   Функцияsystem(char *s)выполняет команду системы, содержащуюся в строкеs,и затем возвращается к выполнению текущей программы.
   Содержимоеs,строго говоря, зависит от конкретной операционной системы. Рассмотрим простой пример: в системе UNIX инструкция
   system("date");
   вызовет программуdate,которая направит дату и время в стандартный вывод. Функция возвращает зависящий от системы статус выполненной команды. В системе UNIX возвращаемый статус - это значение, переданное функциейexit.
   7.8.5Управление памятью
   Функцииmallocиcallocдинамически запрашивают блоки свободной памяти. Функцияmalloc
   void *malloc(size_t n)
   возвращает указатель наnбайт неинициализированной памяти или NULL, если запрос удовлетворить нельзя. Функцияcalloc
   void *calloc(size_t n, size_t size)
   возвращает указатель на область, достаточную для хранения массива изnобъектов указанного размера (size),или NULL, если запрос не удается удовлетворить. Выделенная память обнуляется.
   Указатель, возвращаемый функциямиmallocиcalloc,будет выдан с учетом выравнивания, выполненного согласно указанному типу объекта. Тем не менее к нему должна быть применена операция приведения к соответствующему типу (Как уже отмечалось (см. примеч. в параграфе 6.5), замечания о приведении типов значений, возвращаемых функциямиmallocилиcalloc, -неверно. -Примеч. авт.),как это сделано в следующем фрагменте программы:
   int *ip;
   ip = (int *) calloc(n, sizeof(int));
   Функцияfree(p)освобождает область памяти, на которую указываетp, -указатель, первоначально полученный с помощьюmallocилиcalloc.Никаких ограничений на порядок, в котором будет освобождаться память, нет, но считается ужасной ошибкой освобождение тех областей, которые не были получены с помощьюcallocилиmalloc.
   Нельзя также использовать те области памяти, которые уже освобождены. Следующий пример демонстрирует типичную ошибку в цикле, освобождающем элементы списка.
   for (p = head; p != NULL; p = p-›next) /* НЕВЕРНО */
    free(p);
   Правильным будет, если вы до освобождения сохраните то, что вам потребуется, как в следующем цикле:
   for (p = head; p != NULL; p = q) {
    q = p-›next;
    free(p);
   }
   В параграфе 8.7 мы рассмотрим реализацию программы управления памятью вродеmalloc,позволяющую освобождать выделенные блоки памяти в любой последовательности.
   7.8.6Математические функции
   В‹math.h›описано более двадцати математических функций. Здесь же приведены наиболее употребительные. Каждая из них имеет один или два аргумента типаdoubleи возвращает результат также типаdouble.
   sin(x) -синус x, x в радианах
   cos(x) -косинус x, x в радианах
   atan2(y,x) -арктангенс y/x, y и x в радианах
   exp(x) -экспоненциальная функция e в степени x
   log(x) -натуральный (по основанию e) логарифм x (x›0)
   log10(x) -обычный (по основанию 10) логарифм x (x›0)
   pow(x,y) - xв степени y
   sqrt(x) -корень квадратный x (x › 0)
   fabs(x) -абсолютное значение x
   7.8.7Генератор случайных чисел
   Функцияrand()вычисляет последовательность псевдослучайных целых в диапазоне от нуля до значения, заданного именованной константой RAND_MAX, которая определена в ‹stdlib.h›. Привести случайные числа к значениям с плавающей точкой, большим или равным 0 и меньшим 1, можно по формуле
   #define frand() ((double) rand() / (RAND_MAX+1.0))
   (Если в вашей библиотеке уже есть функция для получения случайных чисел с плавающей точкой, вполне возможно, что ее статистические характеристики лучше указанной.)
   Функцияsrand(unsigned)устанавливает семя дляrand.Реализацииrandиsrand,предлагаемые стандартом и, следовательно, переносимые на различные машины, рассмотрены в параграфе 2.7.
   Упражнение 7.9.Реализуя функции вродеisupper,можно экономить либо память, либо время. Напишите оба варианта функции.
   Глава 8. Интерфейс с системой UNIX
   Свои услуги операционная система UNIX предлагает в виде наборасистемных вызовов,которые фактически являются ее внутренними функциями и к которым можно обращаться из программ пользователя. В настоящей главе описано, как в Си-программах можно применять некоторые наиболее важные вызовы. Если вы работаете в системе UNIX, то эти сведения будут вам полезны непосредственно и позволят повысить эффективность работы или получить доступ к тем возможностям, которых нет в библиотеке. Даже если вы используете Си в другой операционной системе, изучение рассмотренных здесь примеров все равно приблизит вас к пониманию программирования на Си; аналогичные программы (отличающиеся лишь деталями) вы встретите практически в любой операционной системе. Так как библиотека Си-программ, утвержденная в качестве стандарта ANSI, в основном отражает возможности системы UNIX, предлагаемые программы помогут вам лучше понять и библиотеку.
   Глава состоит из трех основных частей, описывающих:ввод-вывод,файловую системуиорганизацию управления памятью.В первых двух частях предполагается некоторое знакомство читателя с внешними характеристиками системы UNIX. В главе 7 мы рассматривали единый для всех операционныхсистем интерфейс ввода-вывода. В любой конкретной системе программы стандартной библиотеки пишутся с использованием средств именно этой конкретной системы. В следующих нескольких параграфах мы опишем вызовы системы UNIX по вводу-выводу и покажем, как с их помощью можно реализовать некоторые разделы стандартной библиотеки.
   8.1Дескрипторы файлов
   В системе UNIX любые операции ввода-вывода выполняются посредством чтения и записи файлов, поскольку все внешние устройства, включая клавиатуру и экран, рассматриваются как объекты файловой системы. Это значит, что все связи между программой и внешними устройствами осуществляются в рамках единого однородного интерфейса.
   В самом общем случае, прежде чем читать или писать, вы должны проинформировать систему о действиях, которые вы намереваетесь выполнять в отношении файла; эта процедура называетсяоткрытиемфайла. Если вы собираетесь писать в файл, то, возможно, его потребуется создать заново или очистить от хранимой информации. Система проверяет ваши права на эти действия (файл существует? вы имеете к нему доступ?) и, если все в порядке, возвращает программе небольшое неотрицательное целое, называемоедескриптором файла.Всякий раз, когда осуществляется ввод-вывод, идентификация файла выполняется по его дескриптору, а не по имени. (Дескриптор файла аналогичен файловому указателю, используемому в стандартной библиотеке, или хэндлу (handle)в MS- DOS.) Вся информация об открытом файле хранится и обрабатывается операционной системой; программа пользователя обращается к файлу только через его дескриптор.
   Ввод с клавиатуры и вывод на экран применяются настолько часто, что для удобства работы с ними предусмотрены специальные соглашения. При запуске программы командный интерпретатор (shell)открывает три файла с дескрипторами 0, 1 и 2, которые называются соответственностандартным вводом,стандартным выводомистандартным файлом ошибок.Если программа читает из файла 0, а пишет в файлы 1 и 2 (здесь цифры - дескрипторы файлов), то она может осуществлять ввод и вывод, не заботясь об их открытии.
   Пользователь программы имеет возможность перенаправить ввод-вывод в файл или из файла с помощью значков ‹ и ›, как, например, в
   prog‹ infile › outfile
   В этом случае командный интерпретатор заменит стандартные установки дескрипторов 0 и 1 на именованные файлы. Обычно дескриптор файла 2 остается подсоединенным к экрану, чтобы на него шли сообщения об ошибках. Сказанное верно и для ввода-вывода, связанного в конвейер. Во всех случаях замену файла осуществляет командный интерпретатор, а не программа. Программа, если она ссылается на файл 0 (в случае ввода) и файлы 1 и 2 (в случае вывода), не знает, ни откуда приходит ее ввод, ни куда отправляется ее вывод.
   8.2Нижний уровень ввода-вывода (read и write)
   Ввод-вывод основан на системных вызовахreadиwrite,к которым Си-программа обращается с помощью функций с именамиreadиwrite.
   Для обеих первым аргументом являетсядескриптор файла.Во втором аргументе указывается массив символов вашей программы, куда посылаются или откуда берутся данные. Третий аргумент - это количество пересылаемых байтов.
   int n_read = read(int fd, char *buf, int n);
   int n_written = write(int fd, char *buf, int n);
   Обе функции возвращают число переданных байтов. При чтении количество прочитанных байтов может оказаться меньше числа, указанного в третьем аргументе. Нуль означает конец файла, а -1 сигнализирует о какой-то ошибке. При записи функция возвращает количество записанных байтов, и если это число не совпадает с требуемым, следует считать, что запись не произошла. За один вызов можно прочитать или записать любое число байтов. Обычно это число равно или 1, что означает посимвольную передачу "безбуферизации", или чему-нибудь вроде 1024 или 4096, соответствующих размеру физического блока внешнего устройства. Эффективнее обмениваться большим числом байтов, поскольку при этом требуется меньше системных вызовов. Используя полученные сведения, мы можем написать простую программу, копирующую свой ввод на свой вывод и эквивалентную программе копирования файла, описанной в главе 1. С помощью этой программы можно копировать откуда угодно и куда угодно, поскольку всегда существует возможность перенаправить ввод-вывод на любой файл или устройство.
   #include "syscalls.h"

   main() /*копирование ввода на вывод */
   {
    char buf[BUFSIZ];
    int n;

    while ((n = read(0, buf, BUFSIZ)) › 0)
     write(i, buf, n);
    return 0;
   }
   Прототипы функций, обеспечивающие системные вызовы, мы собрали в файлеsyscalls.h,что позволяет нам включать его в программы этой главы. Однако имя данного файла не зафиксировано стандартом.
   Параметр BUFSIZ также определен в ‹syscalls.h›: в каждой конкретной системе он имеет свое значение. Если размер файла не кратен BUFSIZ, то какая-то операция чтения вернет значение меньшее, чем BUFSIZ, а следующее обращение кreadдаст в качестве результата нуль.
   Полезно рассмотреть, как используютсяreadиwriteпри написании программ более высокого уровня - таких какgetchar,putcharи т. д. Вот, к примеру, версия программыgetchar,которая осуществляет небуферизованный ввод, читая по одному символу из стандартного входного потока.
   #include "syscalls.h"
   /* getchar:небуферизованный ввод одного символа */
   int getchar(void) {
    char с;
    return (read(0,&c, 1) == 1) ? (unsigned char) с: EOF;
   }
   Переменнаяcдолжна быть типаchar,посколькуreadтребует указателя наchar.Приведениеcкunsigned charперед тем, как вернуть ее в качестве результата, исключает какие-либо проблемы, связанные с распространением знака.
   Вторая версияgetcharосуществляет ввод большими кусками, но при каждом обращении выдает только один символ.
   #include "syscalls.h"

   /* getchar:простая версия с буферизацией */
   int getchar(void)
   {
    static char buf[BUFSIZ];
    static char *bufp = buf;
    static int n = 0;

    if (n == 0) { /* буфер пуст */
     n = read(0, buf, sizeof buf);
     bufp = buf;
    }
    return (--n ›= 0) ? (unsigned char) *bufp++ : EOF;
   }
   Если приведенные здесь версии функции getchar компилируются с включением заголовочного файла ‹stdio.h› и в этом заголовочном файлеgetcharопределена как макрос, то нужно задать строку#undefс именемgetchar.
   8.3Системные вызовы open, creat, close, unlink
   В отличие от стандартных файлов ввода, вывода и ошибок, которые открыты по умолчанию, остальные файлы нужно открывать явно. Для этого есть два системных вызова:openиcreat.
   Функцияopenпочти совпадает сfopen,рассмотренной в главе 7. Разница между ними в том, что первая возвращает не файловый указатель, а дескриптор файла типаint.При любой ошибкеopenвозвращает -1.
   include‹fcntl.h›

   int fd;
   int open(char *name, int flags, int perms);

   fd = open(name, flags, perms);
   Как и вfopen,аргументname -это строка, содержащая имя файла. Второй аргумент,flags,имеет типintи специфицирует, каким образом должен быть открыт файл. Его основными значениями являются:
   O_RDONLY -открыть только на чтение;
   O_WRONLY -открыть только на запись;
   O_RDWR -открыть и на чтение, и на запись.
   В System V UNIX эти константы определены в ‹fcntl.h›, а в версиях Berkley (BSD) - в ‹sys/file.h›.
   Чтобы открыть существующий файл на чтение, можно написать
   fd = open(name, 0_RDONLY, 0);
   Далее везде, где мы пользуемся функциейopen,ее аргументpermsравен нулю.
   Попытка открыть несуществующий файл является ошибкой. Создание нового файла или перезапись старого обеспечивается системным вызовомcreat.Например
   int creat(char *name, int perms);
   fd = creat(name, perms);
   Функцияcreatвозвращает дескриптор файла, если файл создан, и -1, если по каким-либо причинам файл создать не удалось. Если файл уже существует,creat "обрежет" его до нулевой длины, что равносильно выбрасыванию предыдущего содержимого данного файла; создание уже существующего файла не является ошибкой.
   Если строится действительно новый файл, тоcreatего создаст с правами доступа, специфицированными в аргументеperms.В системе UNIX с каждым файлом ассоциированы девять битов, содержащие информацию о правах пользоваться этим файлом для чтения, записи и исполнения лицам трех категорий: собственнику файла, определенной им группе лиц и всем остальным. Таким образом, права доступа удобно специфицировать с помощью трех восьмеричных цифр. Например, 0755 специфицирует чтение, запись и право исполнения собственнику файла, а также чтение и право исполнения группе и всем остальным.
   Для иллюстрации приведем упрощенную версию программыcpсистемы UNIX, которая копирует один файл в другой. В нашей версии копируется только один файл, не позволяется во втором аргументе указывать директорий (каталог), и права доступа не копируются, а задаются константой.
   #include‹stdio.h›
   #include‹fcntl.h›
   #include "syscalls.h"
   #define PERMS 0666 /* RWдля собственника, группы и остальных */

   void error(char *,…);

   /* cp:копирование f1 в f2 */
   main(int argc, char *argv[])
   {
    int f1, f2, n;
    char buf[BUFSIZ];
    if (argc != 3)
     error("Обращение: cp откуда куда");
    if ((f1 = open(argv[1], O_RDONLY, 0)) == -1)
     error("cp: не могу открыть файл %s", argv[1]);
    if ((f2 = creat(argv[2], PERMS)) == -1)
     error("cp: не могу создать файл %s, режим %03o", argv[2], PERMS);
    while ((n = read(f1, buf, BUFSIZ)) › 0)
     if (write(f2, buf, n) != n)
      error ("cp: ошибка при записи в файл %s", argv[2]);
    return 0;
   }
   Данная программа создаст файл вывода с фиксированными правами доступа, определяемыми кодом 0666. С помощью системного вызоваstat,который будет описан в параграфе 8.6, мы можем определить режим использования существующего файла и задать тот же режим для копии.
   Заметим, что функцияerror,вызываемая с различным числом аргументов, во многом похожа наprintf.Реализацияerrorиллюстрирует, как пользоваться другими программами семействаprintf.Библиотечная функцияvprintfаналогичнаprintf,с той лишь оговоркой, что переменная часть списка аргументов заменена в ней одним аргументом, который инициализируется макросомva_start.Подобным же образом соотносятся функцииvfprinfсfprintfиvsprintfсsprintf.
   #include‹stdio.h›
   #include‹stdarg.h›

   /* error:печатает сообщение об ошибке и умирает */
   void error(char *fmt,…) {
    va_list args;

    va_start(args, fmt);
    fprintf(stderr, "ошибка: ");
    vfprintf(stderr, fmt, args);
    fprintf(stderr, "\n");
    va_end(args);
    exit(1);
   }
   На количество одновременно открытых в программе файлов имеется ограничение (обычно их число колеблется около 20). Поэтому любая программа, которая намеревается работать с большим количеством файлов, должна быть готова повторно использовать их дескрипторы. Функцияclose(int fd)разрывает связь между файловым дескриптором и открытым файлом и освобождает дескриптор для его применения с другим файлом. Она аналогична библиотечной функцииfcloseс тем лишь различием, что никакой очистки буфера не делает. Завершение программы с помощьюexitилиreturnв главной программе закрывает все открытые файлы.
   Функцияunlink(char *name)удаляет имя файла из файловой системы. Она соответствует функцииremoveстандартной библиотеки.
   Упражнение 8.1.Перепишите программуcatиз главы 7, используя функцииread,write,openиclose.Замените ими соответствующие функции стандартной библиотеки. Поэкспериментируйте, чтобы сравнить быстродействие двух версий.
   8.4Произвольный доступ (lseek)
   Ввод-вывод обычно бывает последовательным, т. е. каждая новая операция чтения-записи имеет дело с позицией файла, следующей за той, что была в предыдущей операции (чтения-записи). При желании, однако, файл можно читать или производить запись в него в произвольном порядке. Системный вызовlseekпредоставляет способ передвигаться по файлу, не читая и не записывая данные. Так, функция
   long lseek(int fd, long offset, int origin);
   в файле с дескрипторомfdустанавливает текущую позицию, смещая ее на величинуoffsetотносительно места, задаваемого значениемorigin.Значения параметра origin 0, 1 или 2 означают, что на величинуoffsetотступают соответственно отначала,оттекущей позицииили отконцафайла. Например, если требуется добавить что-либо в файл (когда в командном интерпретатореshellсистемы UNIX ввод перенаправлен оператором ›› в файл или когда вfopenзадан аргумент "a"),то прежде чем что-либо записывать, необходимо найти конец файла с помощью вызова функции
   lseek(fd, 0L, 2);
   Чтобы вернуться назад, в начало файла, надо выполнить
   lseek(fd, 0L, 0);
   Следует обратить внимание на аргумент 0L: вместо 0L можно было бы написать (long)0или, если функцияlseekдолжным образом объявлена, просто 0. Благодаряlseekс файлами можно работать так, как будто это большие массивы, правда, с замедленным доступом. Например, следующая функция читает любое число байтов из любого места файла. Она возвращает число прочитанных байтов или -1 в случае ошибки.
   #include "syscalls.h"
   /* get:читает n байт из позиции pos */
   int get(int fd, long pos, char *buf, int n)
   {
    if (lseek(fd, pos, 0) ›= 0) /* установка позиции */
     return read(fd, buf, n);
    else
    return -1;
   }
   Возвращаемое функциейlseekзначение имеет типlongи является новой позицией в файле или, в случае ошибки, равно -1. Функцияfseekиз стандартной библиотеки аналогичнаlseek:от последней она отличается тем, что в случае ошибки возвращает некоторое ненулевое значение, а ее первый аргумент имеет типFILE*.
   8.5Пример. Реализация функций fopen и getc
   Теперь на примере функцийfopenиgetcиз стандартной библиотеки покажем, как описанные выше части согласуются друг с другом.
   Напомним, что файлы в стандартной библиотеке описываются файловыми указателями, а не дескрипторами.Указатель файла -это указатель на структуру, содержащую информацию о файле: указатель на буфер, позволяющий читать файл большими кусками: число незанятых байтов буфера; указатель на следующую позицию в буфере; дескриптор файла; флажки, описывающие режим (чтение/запись), ошибочные состояния и т. д.
   Структура данных, описывающая файл, содержится в ‹stdio.h›, который необходимо включать (с помощью#include)в любой исходный файл, если в том осуществляется стандартный ввод-вывод. Этот же заголовочный файл включен и в исходные тексты библиотеки ввода-вывода.
   В следующем фрагменте, типичном для файла ‹stdio.h›, имена, используемые только в библиотечных функциях, начинаются с подчеркивания. Это сделано для того, чтобы они случайно не совпали с именами, фигурирующими в программе пользователя. Такое соглашение соблюдается во всех программах стандартной библиотеки.
   #define NULL 0
   #define EOF (-1)
   #define BUFSIZ 1024
   #define OPEN_MAX 20 /* maxчисло одновременно открытых файлов */
   typedef struct _iobuf {
    int cnt; /* количество оставшихся символов */
    char *ptr; /* позиция следующего символа */
    char *base; /* адрес буфера */
    int flag; /* режим доступа */
    int fd; /* дескриптор файла */
   } FILE;

   extern FILE _iob[OPEN_MAX];

   #define stdin (&iob[0])
   #define stdout (&_iob[1])
   #define stderr (&_iob[2])

   enum _flags {
    _READ = 01, /* файл открыт на чтение */
    _WRITE = 02, /* файл открыт на запись */
    _UNBUF = 04, /* файл не буферизируется */
    _EOF = 010, /* в данном файле встретился EOF */
    _ERR = 020 /* в данном файле встретилась ошибка */
   };

   int _fillbuf(FILE *);
   int _flushbuf(int, FILE *);

   #define feof(p) (((p)-›flag& _EOF) != 0)
   #define ferror(p) (((p)-›flag& _ERR) != 0)
   #define fileno(p) ((p)-›fd)

   #define getc(p) (--(p)-›cnt ›= 0 \
    ? (unsigned char) *(p)-›ptr++ : _fillbuf(p))
   #define putc(x,p) (--(p)-›cnt ›= 0 \
    ? *(p)-›ptr++ = (x) : _flushbuf((x),p))

   #define getchar() getc(stdin)
   #define putchar(x) putc((x), stdout)
   Макросgetcобычно уменьшает счетчик числа символов, находящихся в буфере, и возвращает символ, после чего приращивает указатель на единицу. (Напомним, что длинные#defineс помощью обратной наклонной черты можно продолжить на следующих строках.) Когда значение счетчика становится отрицательным,getcвызывает_fillbuf,чтобы снова заполнить буфер, инициализировать содержимое структуры и выдать символ. Типы возвращаемых символов приводятся кunsigned;это гарантирует, что все они будут положительными.
   Хотя в деталях ввод-вывод здесь не рассматривается, мы все же привели полное определениеputc.Сделано это, чтобы показать, что она действует во многом так же, как иgetc,вызывая функцию_flushbuf,когда буфер полон. В тексте имеются макросы, позволяющие получать доступ к флажкам ошибки и конца файла, а также к его дескриптору.
   Теперь можно написать функциюfopen.Большая часть инструкцийfopenотносится к открытию файла, к соответствующему его позиционированию и к установке флажковых битов, предназначенных для индикации текущего состояния. Самаfopenне отводит места для буфера; это делает_fillbufпри первом чтении файла.
   #include&lt;fcntl.h&gt;
   #include "syscalls.h"
   #define PERMS 0666 /* RWдля собственника, группы и проч. */

   /* fopen:открывает файл, возвращает файловый указатель */
   FILE *fopen(char *name, char *mode)
   {
    int fd;
    FILE *fp;

    if (*mode != 'r'&& *mode != 'w'&& *mode != 'a'
     return NULL;
    for (fp = _iob; fp&lt; _iob + OPEN_MAX; fp++)
     if ((fp-&gt;flag& (_READ | _WRITE)) == 0)
      break; /* найдена свободная позиция */
    if (fp&gt;= _iob + OPEN_MAX)  /* нет свободной позиция */
     return NULL;

    if (*mode == 'w')
     fd = creat(name, PERMS);
    else if (*mode == 'a') {
     if ((fd = open(name, O_WRONLY, 0)) == -1)
      fd = creat(name, PERMS);
     lseek(fd, 0L, 2);
    } else
     fd = open(name, O_RDONLY, 0);
    if (fd == -1) /* невозможен доступ по имени name */
     return NULL;
    fp-&gt;fd = fd;
    fp-&gt;cnt = 0;
    fp-&gt;base = NULL;
    fp-&gt;flag = (*mode == 'r') ? _READ : _WRITE;
    return fp;
   }
   Приведенная здесь версияfopenреализует не все режимы доступа, оговоренные стандартом; но, мы думаем, их реализация в полном объеме не намного увеличит длину программы. Нашаfopenне распознает буквыb,сигнализирующей о бинарном вводе-выводе (поскольку в системах UNIX это не имеет смысла), и знака+,указывающего на возможность одновременно читать и писать.
   Для любого файла в момент первого обращения к нему с помощью макровызоваgetcсчетчикcntравен нулю. Следствием этого будет вызов_fillbuf.Коли выяснится, что файл на чтение не открыт, то функция_fillbufнемедленно возвратит EOF. В противном случае она попытается запросить память для буфера (если чтение должно быть с буферизацией).
   После получения области памяти для буфера_fillbufобращается кread,чтобы его наполнить, устанавливает счетчик и указатели и возвращает первый символ из буфера. В следующих обращениях_fillbufобнаружит, что память для буфера уже выделена.
   #include "syscalls.h"
   /* _fillbuf:запрос памяти и заполнение буфера */
   int _fillbuf(FILE *fp)
   {
    int bufsize;

    if ((fp-&gt;flag& ( _READ | _EOF | _ERR )) != _READ)
     return EOF;
    bufsize = (fp-&gt;flag& _UNBUF) ? 1 : BUFSIZ;
    if (fp-&gt;base == NULL) /*буфера еще нет */
     if ((fp-&gt;base = (char *) malloc(bufsize)) == NULL)
      return EOF; /* нельзя получить буфер */
    fp-&gt;ptr = fp-&gt;base;
    fp-&gt;cnt = read(fp-&gt;fd, fp-&gt;ptr, bufsize);
    if (--fp-&gt;cnt&lt; 0) {
     if (fp-&gt;cnt == -1)
      fp-&gt;flag |= _EOF;
     else
      fp-&gt;flag |= _ERR;
     fp-&gt;cnt = 0;
     return EOF;
    }
    return (unsigned char) *fp-&gt;ptr++;
   }
   Единственное, что осталось невыясненным, - это каким образом организовать начало счета. Массив_iobследует определить и инициализировать так, чтобы перед тем как программа начнет работать, в нем уже была информация о файлахstdin,stdoutиstderr.
   FILE _iob[OPEN_MAX] = { /* stdin, stdout, stderr: */
    { 0, (char *) 0, (char *) 0, _READ, 0 },
    { 0, (char *) 0, (char *) 0, _WRITE, 1 },
    { 0, (char *) 0, (char *) 0, _WRITE | _UNBUF, 2 }
   };
   Инициализацияflagкак части структуры показывает, чтоstdinоткрыт на чтение,stdout -на запись, аstderr -на запись без буферизации.
   Упражнение 8.2.Перепишите функцииfopenи_fillbuf,работая с флажками как с полями, а не с помощью явных побитовых операций. Сравните размеры и скорости двух вариантов программ.
   Упражнение 8.3.Разработайте и напишите функции_flushbuf,fflushиfclose.
   Упражнение 8.4.Функция стандартной библиотеки
   int fseek(FILE *fp, long offset, int origin)
   идентична функцииlseekс теми, однако, отличиями, чтоfp -это файловый указатель, а не дескриптор, и возвращает она значениеint,означающее состояние файла, а не позицию в нем. Напишите свою версиюfseek.Обеспечьте, чтобы работа вашейfseekпо буферизации была согласована с буферизацией, используемой другими функциями библиотеки.
   8.6Пример. Печать каталогов
   При разного рода взаимодействиях с файловой системой иногда требуется получитьтолькоинформацию о файле, а не его содержимое. Такая потребность возникает, например, в программе печати каталога файлов, работающей аналогично командеlsсистемы UNIX. Она печатает имена файлов каталога и по желанию пользователя другую дополнительную информацию (размеры, права доступа и т. д.). Аналогичной командой в MS-DOS являетсяdir.
   Так как в системе UNIX каталог - это тоже файл, функцииls,чтобы добраться до имен файлов, нужно только его прочитать. Но чтобы получить другую информацию о файле (например узнать его размер), необходимо выполнить системный вызов. В других системах (в MS-DOS, например) системным вызовом приходится пользоваться даже для получения доступа к именам файлов. Наша цель - обеспечить доступ к информации по возможности системно-независимым способом несмотря на то, что реализация может быть существенно системно-зависима. Проиллюстрируем сказанное написанием программыfsize.Функцияfsize -частный случай программыls:она печатает размеры всех файлов, перечисленных в командной строке. Если какой-либо из файлов сам является каталогом, то, чтобы получить информацию о нем,fsizeобращается сама к себе. Если аргументов в командной строке нет, то обрабатывается текущий каталог.
   Для начала вспомним структуру файловой системы в UNIXe.Каталог -это файл, содержащий список имен файлов и некоторую информацию о том, где они расположены. "Место расположения" - это индекс, обеспечивающий доступ в другую таблицу,называемую "списком узловinode".Для каждого файла имеется свойinode,где собрана вся информация о файле, за исключением его имени. Каждый элемент каталога состоит из двух частей: из имени файла и номера узлаinode.
   К сожалению, формат и точное содержимое каталога не одинаковы в разных версиях системы. Поэтому, чтобы переносимую компоненту отделить от непереносимой, разобьем нашу задачу на две. Внешний уровень определяет структуру, названнуюDirent,и три подпрограммыopendir,readdirиclosedir:в результате обеспечивается системно-независимый доступ к имени и номеру узлаinodeкаждого элемента каталога. Мы будем писать программуfsize,рассчитывая на такой интерфейс, а затем покажем, как реализовать указанные функции для систем, использующих ту же структуру каталога, что и Version 7 и System V UNIX. Другие варианты оставим для упражнений.
   СтруктураDirentсодержит номер узлаinodeи имя. Максимальная длина имени файла равна NAME_MAX - это значение системно-зависимо. Функцияopendirвозвращает указатель на структуру, названнуюDIR (по аналогии сFILE),которая используется функциямиreaddirиclosedir.Эта информация сосредоточена в заголовочном файлеdirent.h.
   #define NAME_MAX 14 /*максимальная длина имени файла */
    /* системно-зависимая величина */

   typedef struct { /*универс. структура элемента каталога: */
    long ino; /* номер inode */
    char name[NAME_MAX+1]; /* имя + завершающий '\0' */
   } Dirent;

   typedef struct { /*минимальный DIR: без буферизации и т.д. */
    int fd; /* файловый дескриптор каталога */
    Dirent d; /* элемент каталога */
   } DIR;

   DIR *opendir(char *dirname);
   Dirent *readdir(DIR *dfd);
   void closedir(DIR *dfd);
   Системный вызовstatполучает имя файла и возвращает полную о нем информацию, содержащуюся в узлеinode,или -1 в случае ошибки. Так,
   char *name;
   struct stat stbuf;
   int stat(char *, struct stat *);

   stat(name,&stbuf);
   заполняет структуруstbufинформацией из узлаinodeо файле с именемname.Структура, описывающая возвращаемое функциейstatзначение находится в ‹sys/stat.h› и выглядит примерно так:
   struct stat /*информация из inode, возвращаемая stat */
   {
    dev_t st_dev; /* устройство */
    ino_t st_ino; /* номер inode */
    short st_mode; /* режимные биты */
    short st_nlink; /* число связей с файлом */
    short st_uid; /* имя пользователя-собственника */
    short st_gid; /* имя группы собственника */
    dev_t st_rdev; /* для специальных файлов */
    off_t st_size; /* размер файла в символах */
    time_t st_atime; /* время последнего использования */
    time_t st_mtime; /* время последней модификации */
    time_t st_ctime; /* время последнего изменения inode */
   };
   Большинство этих значений объясняется в комментариях. Типы, подобныеdev_tиino_t,определены в файле ‹sys/types.h›, который тоже нужно включить посредством#include.
   Элементst_modeсодержит набор флажков, составляющих дополнительную информацию о файле. Определения флажков также содержатся в ‹sys/stat.h› нам потребуется только та его часть, которая имеет дело с типом файла
   #define S_IFMT  0160000 /* тип файла */
   #define S_IFDIR 0040000 /*каталог */
   #define S_IFCHR 0020000 /*символьно-ориентированный */
   #define S_IFBLK 0060000 /*блочно-ориентированный */
   #define S_IFREG 0100000 /*обычный */
   Теперь мы готовы приступить к написанию программыfsize.Если режимные биты (st_mode),полученные отstat,указывают, что файл не является каталогом, то можно взять его размер (st_size)и напечатать. Однако если файл - каталог, то мы должны обработать все его файлы, каждый из которых в свою очередь может быть каталогом. Обработка каталога - процесс рекурсивный.
   Программаmainпросматривает параметры командной строки, передавая каждый аргумент функцииfsize.
   #include‹stdio.h›
   #include‹string.h›
   #include "syscalls.h"
   #include‹fcntl.h› /* флажки чтения и записи */
   #include‹sys/types.h› /* определения типов */
   #include‹sys/stat.h› /* структура, возвращаемая stat */
   #include "dirent.h"

   void fsize(char *);

   /*печатает размер файлов */
   main(int argc, char **argv) {
    if (argc == 1) /* по умолчанию берется текущий каталог */
     fsize(".");
    else
     while (--argc › 0)
      fsize(*++argv);
    return 0;
   }
   Функцияfsizeпечатает размер файла. Однако, если файл - каталог, она сначала вызываетdirwalk,чтобы обработать все его файлы. Обратите внимание на то, как используются имена флажковS_IFMTиS_IFDIRиз ‹sys/stat.h› при проверке, является ли файл каталогом. Здесь нужны скобки, поскольку приоритет оператора&ниже приоритета оператора ==.
   int stat(char *, struct stat *);
   void dirwalk(char *, void (*fcn)(char *));

   /* fsize:печатает размер файла "name" */
   void fsize(char *name)
   {
    struct stat stbuf;

    if (stat(name,&stbuf) == -1) {
     fprintf(stderr, "fsize: нет доступа к %s\n", name);
     return;
    }
    if ((stbuf.st_mode& S_IFMT) == S_IFDIR)
     dirwalk(name, fsize);
    printf("%8ld%s\n", stbuf.st_size, name);
   }
   Функцияdirwalk -это универсальная программа, применяющая некоторую функцию к каждому файлу каталога. Она открывает каталог, с помощью цикла перебирает содержащиеся в нем файлы, применяя к каждому из них указанную функцию, затем закрывает каталог и осуществляет возврат. Так какfsizeвызываетdirwalkна каждом каталоге, в этих двух функциях заложена косвенная рекурсия.
   #define MAX_PATH 1024

   /* dirwalk:применяет fcn ко всем файлам из dir */
   void dirwalk(char *dir, void (*fcn)(char *))
   {
    char name[MAX_PATH];
    Dirent *dp;
    DIR *dfd;

    if ((dfd = opendir(dir)) == NULL) {
     fprintf(stderr, "dirwalk: не могу открыть %s\n", dir);
     return;
    }
    while ((dp = readdir(dfd)) != NULL) {
     if (strcmp(dp-›name, ".") == 0 || strcmp(dp-›name, "…") == 0)
      continue; /* пропустить себя и родителя */
     if (strlen(dir)+strlen(dp-›name) + 2 › sizeof(name))
      fprintf(stderr, "dirwalk: слишком длинное имя %s/%s\n", dir, dp-›name);
     else {
      sprintf(name, "%s/%s", dir, dp-›name);
      (*fcn) (name);
     }
    }
    closedir(dfd);
   }
   Каждый вызовreaddirвозвращает указатель на информацию о следующем файле или NULL, если все файлы обработаны. Любой каталог всегда хранит в себе информацию о себе самом в файле под именем "." и о своем родителе в файле под именем "…": их нужно пропустить, иначе программа зациклится. Обратите внимание: код программы этого уровня не зависит от того, как форматированы каталоги. Следующий шаг - представить минимальные версииopendir,readdirиclosedirдля некоторой конкретной системы. Здесь приведены программы для систем Version 7 и System V UNIX. Они используют информацию о каталоге, хранящуюся в заголовочном файле ‹sys/dir.h›, который выглядит следующим образом:
   #ifndef DIRSIZ
   #define DIRSIZ 14
   #endif
   struct direct /*элемент каталога */
   {
    ino_t d_ino; /* номер inode */
    char d_name[DIRSIZ]; /* длинное имя не имеет '\0' */
   };
   Некоторые версии системы допускают более длинные имена и имеют более сложную структуру каталога.
   Типino_tзадан с помощьюtypedefи описывает индекс списка узловnode.В системе, которой пользуемся мы, этот тип естьunsigned short,но в других системах он может быть иным, поэтому его лучше определять черезtypedef.Полный набор "системных" типов находится в ‹sys/types.h›.
   Функцияopendirоткрывает каталог, проверяет, является ли он действительно каталогом (в данном случае это делается с помощью системного вызоваfstat,который аналогиченstat,но применяется к дескриптору файла), запрашивает пространство для структуры каталога и записывает информацию.
   int fstat(int fd, struct stat *);

   /* opendir:открывает каталог для вызовов readdir */
   DIR *opendir(char *dirname)
   {
    int fd;
    struct stat stbuf;
    DIR *dp;

    if ((fd = open(dirname, O_RDONLY, 0)) == -1 || fstat(fd,&stbuf) == -1 || (stbuf.st_mode& S_IFMT) != S_IFDIR || (dp = (DIR *) malloc(sizeof(DIR))) == NULL)
     return NULL;
    dp-›fd = fd;
    return dp;
   }
   Функция closedir закрывает каталог и освобождает пространство.
   /* closedir:закрывает каталог, открытый opendir */
   void closedir(DIR *dp) {
    if (dp) {
     close(dp-›fd);
     free(dp);
    }
   }
   Наконец,readdirс помощьюreadчитает каждый элемент каталога. Если некий элемент каталога в данный момент не используется (соответствующий ему файл был удален), то номер узлаinodeу него равен нулю, и данная позиция пропускается. В противном случае номерinodeи имя размещаются в статической (static)структуре, и указатель на нее выдается в качестве результата. При каждом следующем обращении новая информация занимает место предыдущей.
   #include‹sys/dir.h› /* место расположения структуры каталога */

   /* readdir:последовательно читает элементы каталога */
   Dirent *readdir(DIR *dp) {
    struct direct dirbuf; /* структура каталога на данной системе */
    static Dirent d; /* возвращает унифицированную структуру */

    while (read(dp-›fd, (char *)&dirbuf, sizeof (dirbuf)) == sizeof(dirbuf)) {
     if (dirbuf.d_ino == 0) /* пустой элемент, не используется */
      continue;
     d.ino = dirbuf.d_ino;
     strncpy(d.name, dirbuf.d_name, DIRSIZ);
     d.name[DIRSIZ] = '\0'; /* завершающий символ '\0' */
     return&d;
    }
    return NULL;
   }
   Хотя программаfsize -довольно специализированная, она иллюстрирует два важных факта. Первый: многие программы не являются "системными"; они просто используют информацию, которую хранит операционная система. Для таких программ существенно то, что представление информации сосредоточено исключительно в стандартных заголовочных файлах. Программы включают эти файлы, а не держат объявления в себе. Второе наблюдение заключается в том, что при старании системно-зависимым объектам можно создать интерфейсы, которые сами не будут системно-зависимыми. Хорошие тому примеры ~ функции стандартной библиотеки.
   Упражнение 8.5.Модифицируйтеfsizeтаким образом, чтобы можно было печатать остальную информацию, содержащуюся в узлеinode.
   8.7Пример. Распределитель памяти
   В главе 5 был описан простой распределитель памяти, основанный на принципе стека. Версия, которую мы напишем здесь, не имеет ограничений: вызовыmallocиfreeмогут выполняться в любом порядке:mallocделает запрос в операционную систему на выделение памяти тогда, когда она требуется. Эти программы иллюстрируют приемы, позволяющие получать машинно-зависимый код сравнительно машинно-независимым способом, и, кроме того, они могут служить примером применения таких средств языка, как структуры, объединения и typedef.
   Никакого ранее скомпилированного массива фиксированного размера, из которого выделяются куски памяти, не будет. Функцияmallocзапрашивает память у операционной системы по мере надобности. Поскольку и другие действия программы могут вызывать запросы памяти, которые удовлетворяются независимо от этого распределителя памяти, пространство, которым заведуетmalloc,необязательно представляет собой связный кусок памяти. Поэтому свободная память хранится в виде списка блоков. Каждый блок содержит размер, указатель на следующий блок и само пространство. Блоки в списке хранятся в порядке возрастания адресов памяти, при этом последний блок (с самым большим адресом) указывает на первый.
 [Картинка: fig8_1.png] 
   При возникновении запроса на память просматривается список свободных блоков, пока не обнаружится достаточно большой блок. Такой алгоритм называется "поиском первого подходящего" в отличие от алгоритма "поиска наилучшего подходящего", который ищет наименьший блок из числа удовлетворяющих запросу. Если размер блока в точности соответствует требованиям, то такой блок исключается из списка и отдается в пользование. Если размер блока больше, чем требуется, от него отрезается нужная часть- она отдается пользователю, а ненужная оставляется в списке свободных блоков. Если блока достаточного размера не оказалось, то у операционной системы запрашивается еще один большой кусок памяти, который присоединяется к списку свободных блоков.
   Процедура освобождения сопряжена с прохождением по списку свободных блоков, поскольку нужно найти подходящее место для освобождаемого блока. Если подлежащий освобождению блок примыкает с какой-то стороны к одному из свободных блоков, то он объединяется с ним в один блок большего размера, чтобы по возможности уменьшить раздробленность (фрагментацию) памяти. Выполнение проверки, примыкают ли блоки друг к другу, не составляет труда, поскольку список свободных блоков всегда упорядочен по возрастанию адресов.
   Существует проблема, о которой мы уже упоминали в главе 5, состоящая в том, что память, выдаваемая функциейmalloc,должна быть соответствующим образом выровнена с учетом объектов, которые будут в ней храниться. Хотя машины и отличаются друг от друга, но для каждой из них существует тип, предъявляющий самые большие требования на выравнивание, и, если по некоему адресу допускается размещение объекта этого типа, то по нему можно разместить иобъекты всех других типов. На некоторых машинах таким самым "требовательным" типом являетсяdouble,на других это может бытьintилиlong.
   Свободный блок содержит указатель на следующий блок в списке, свой размер и собственно свободное пространство. Указатель и размер представляют собой управляющую информацию и образуют так называемый "заголовок". Чтобы упростить выравнивание, все блоки создаются кратными размеру заголовка, а заголовок соответствующим образом выравнивается. Этого можно достичь, сконструировав объединение, которое будет содержать соответствующую заголовку структуру и самый требовательный в отношении выравнивания тип. Для конкретности мы выбрали типlong.
   typedef long Align; /*для выравнивания по границе long */
   union header { /*заголовок блока: */
    struct {
     union header *ptr; /* след. блок в списке свободных */
     unsigned size; /* размер этого блока */
    } s;
    Align x; /* принудительное выравнивание блока */
   };
   typedef union header Header;
   ПолеAlignнигде не используется: оно необходимо только для того, чтобы каждый заголовок был выровнен по самому "худшему" варианту границы.
   Затребованное число символов округляется вmallocдо целого числа единиц памяти размером в заголовок (именно это число и записывается в полеsize (размер) в заголовке); кроме того, в блок входит еще одна единица памяти - сам заголовок. Указатель, возвращаемый функциейmalloc,указывает на свободное пространство, а не на заголовок. Со свободным пространством пользователь может делать что угодно, но, если он будет писать что-либо за его пределами, то, вероятно, список разрушится. [Картинка: fig8_2.png] 
   Поскольку память, управляемая функциейmalloc,не обладает связностью, размеры блоков нельзя вычислить по указателям, и поэтому без поля, хранящего размер, нам не обойтись.
   Для организации начала работы используется переменнаяbase.Еслиfreepесть NULL (как это бывает при первом обращении кmalloc),создается "вырожденный" список свободного пространства; он содержит один блок нулевого размера с указателем на самого себя. Поиск свободного блока подходящего размера начинается с этого указателя (freep),т. е. с последнего найденного блока; такая стратегия помогает поддерживать список однородным. Если найденный блок окажется слишком большим, пользователю будет отдана его хвостовая часть; при этом потребуется только уточнить его размер в заголовке найденного свободного блока. В любом случае возвращаемый пользователю указатель является адресом свободного пространства, размещающегося в блоке непосредственно за заголовком.
   static Header base; /*пустой список для нач. запуска */
   static Header *freep = NULL; /*начало в списке своб. блоков */

   /* malloc:универсальный распределитель памяти */
   void *malloc(unsigned nbytes) {
    Header *p, *prevp;
    Header *morecore(unsigned);
    unsigned nunits;

    nunits = (nbytes + sizeof(Header) - 1) / sizeof (Header) + 1;
    if ((prevp = freep) == NULL) { /* списка своб. памяти еще нет */
     base.s.ptr = freep = prevp =&base;
     base.s.size = 0;
    }
    for (p = prevp-›s.ptr; ; prevp = p, p = p-›s.ptr) {
     if (p-›s.size ›= nunits) { /* достаточно большой */
      if (p-›s.size == nunits) /* точно нужного размера */
       prevp-›s.ptr = p-›s.ptr;
      else { /* отрезаем хвостовую часть */
       p-›s.size -= nunits;
       p += p-›s.size;
       p-›s.size = nunits;
      }
      freep = prevp;
      return (void *)(p+1);
     }
     if (p == freep) /* прошли полный цикл по списку */
      if ((p = morecore(nunits)) == NULL) return NULL; /* больше памяти нет */
    }
   }
   Функцияmorecoreполучает память от операционной системы. Детали того, как это делается, могут не совпадать в различных системах. Так как запрос памяти у системы - сравнительно дорогая операция, мы бы не хотели для этого каждый раз обращаться кmalloc.Поэтому используется функцияmorecore,которая запрашивает не менее NALLOC единиц памяти; этот больший кусок памяти будет "нарезаться" потом по мере надобности. После установки в поле размера соответствующего значения функцияmorecoreвызывает функциюfreeи тем самым включает полученный кусок в список свободных областей памяти.
   #define NALLOC 1024 /*миним. число единиц памяти для запроса */

   /* morecore:запрашивает у системы дополнительную память */
   static Header * morecore(unsigned nu)
   {
    char *cp, *sbrk(int);
    Header *up;

    if (nu&lt; NALLOC)
     nu = NALLOC;
    cp = sbrk(nu * sizeof(Header));
    if (cp == (char *) -1) /* больше памяти нет. */
     return NULL;
    up = (Header *) cp;
    up-&gt;s.size = nu;
    free((void *)(up+1));
    return freep;
   }
   Системный вызовsbrk(n)в UNIXе возвращает указатель наnбайт памяти или -1, если требуемого пространства не оказалось, хотя было бы лучше, если бы в последнем случае он возвращал NULL. Константу -1 необходимо привести к типу char *, чтобы ее можно было сравнить с возвращаемым значением. Это еще один пример того, как операция приведения типа делает функцию относительно независимой от конкретного представления указателей на различных машинах. Есть, однако, одна "некорректность", состоящая а том, что сравниваются указатели на различные блоки, выдаваемые функциейsbrk.Такое сравнение не гарантировано стандартом, который позволяет сравнивать указатели лишь в пределах одного и того же массива. Таким образом, эта версияmallocверна только на тех машинах, в которых допускается сравнение любых указателей.
   В заключение рассмотрим функциюfree.Она просматривает список свободной памяти, начиная сfreep,чтобы подыскать место для вставляемого блока. Искомое место может оказаться или между блоками, или в начале списка, или в его конце. В любом случае, если подлежащий освобождению блок примыкает к соседнему блоку, он объединяется с ним в один блок. О чем еще осталось позаботиться, - так это о том, чтобы указатели указывали в нужные места и размеры блоков были правильными.
   /* free:включает блок в список свободной памяти */
   void free(void *ар) {
    Header *bp, *p;

    bp = (Header *)ap -1; /* указатель на заголовок блока */
    for (p = freep; !(bp › p&& bp s.ptr); p = p-›s.ptr)
     if (p ›= p-›s.ptr&& (bp› p || bp s.ptr)) break; /* освобождаем блок в начале или в конце */
    if (bp + bp-›s.size - p-›s.ptr) { /* слить с верхним */
     bp-›s.size += p-›s.ptr-›s.size; /* соседом */
     bp-›s.ptr = p-›s.ptr-›s.ptr;
    } else bp-›s.ptr = p-›s.ptr;
    if (p + p-›s.size == bp) { /* слить с нижним соседом */
     p-›s.size += bp-›s.size;
     p-›s.ptr = bp-›s.ptr;
    } else p-›s.ptr = bp;
    freep = p;
   }
   Хотя выделение памяти по своей сути - машинно-зависимая проблема, с ней можно справиться, что и иллюстрирует приведенная программа, в которой машинная зависимость упрятана в очень маленькой ее части. Что касается проблемы выравнивания, то мы разрешили ее с помощьюtypedefиunion (предполагается, чтоsbrkдает подходящий в смысле выравнивания указатель). Операции приведения типов позволяют нам сделать явными преобразования типов и даже справиться с плохо спроектированным интерфейсом системы. Несмотря на то, что наши рассуждения касались распределения памяти, этот общий подход применим и в других ситуациях.
   Упражнение 8.6.Стандартная функцияcalloc(n, size)возвращает указатель наnэлементов памяти размераsize,заполненных нулями. Напишите свой вариантcalloc,пользуясь функциейmallocили модифицируя последнюю.
   Упражнение 8.7.Функцияmallocдопускает любой размер, никак не проверяя его на правдоподобие:freeпредполагает, что размер освобождаемого блока - правильный. Усовершенствуйте эти программы таким образом, чтобы они более тщательно контролировали ошибки.
   Упражнение 8.8.Напишите программуbfree(p, n),освобождающую произвольный блокp,состоящий изnсимволов, путем включения его в список свободной памяти, поддерживаемый функциямиmallocиfree. Cпомощьюbfreeпользователь должен иметь возможность в любое время добавить в список свободной памяти статический или внешний массив.
   Приложение A. Справочное руководство
   A1.Введение
   Данное руководство описывает язык программирования Си, определенный 31 октября 1989 г. в соответствии с проектом, утвержденным в ANSI в качестве Американского национального стандарта для информационных систем: Язык программирования Си, X3.159-1989 ("American National Standard for Information Systems - Programming Language C, X3.159-1989").Это описание - лишь один из вариантов предлагаемого стандарта, а не сам стандарт, однако мы специально заботились о том, чтобы сделать его надежным руководством по языку.
   Настоящий документ в основном следует общей схеме описания, принятой в стандарте (публикация которого в свою очередь основывалась на первом издании этой книги), однако в организационном плане есть различия. Если не считать отклонений в названиях нескольких продуктов и отсутствия формальных определений лексем и препроцессора, грамматика языка здесь и грамматика в стандарте эквивалентны.
   Далее примечания (как и это) набираются с отступом от левого края страницы. В основном эти примечания касаются отличий стандарта от версии языка, описанной в первом издании этой книги, и от последующих нововведений в различных компиляторах.
   A2.Соглашения о лексике
   Программа состоит из одной или несколькихединиц трансляции,хранящихся в виде файлов. Каждая такая единица проходит несколько фаз трансляции, описанных в A12. Начальные фазы осуществляют лексические преобразования нижнего уровня, выполняют директивы, заданные в программе строками, начинающимися со знака #, обрабатывают макроопределения и производят макрорасширения. По завершении работы препроцессора (A12) программа представляется к виде последовательности лексем.
   A2.1.Лексемы (tokens) 
   Существуют шесть классов лексем (или токенов): идентификаторы, ключевые слона, константы, строковые литералы, операторы и прочие разделители. Пробелы, горизонтальные и вертикальные табуляции, новые строки, переводы страницы и комментарии (имеющие общее название символы-разделители) рассматриваются компилятором только как разделители лексем и в остальном на результат трансляции влияние не оказывают. Любой из символов-разделителей годится, чтобы отделить друг от друга соседние идентификаторы, ключевые слова и константы.
   Если входной поток уже до некоторого символа разбит на лексемы, то следующей лексемой будет самая длинная строка, которая может быть лексемой.
   A2.2.Комментарий
   Символы/*открывают комментарий, а символы*/закрывают его. Комментарии нельзя вкладывать друг в друга, их нельзя помещать внутрь строк или текстовых литералов.
   A2.3.Идентификаторы
   Идентификатор -это последовательность букв и цифр. Первым символом должна быть буква; знак подчеркивания _ считается буквой. Буквы нижнего и верхнего регистров различаются. Идентификаторы могут иметь любую длину; для внутренних идентификаторов значимыми являются первые 31 символ; в некоторых реализациях принято большее число значимых символов. К внутренним идентификаторам относятся имена макросов и все другие имена, не имеющие внешних связей (A11.2).На идентификаторы с внешними связями могут накладываться большие ограничения: иногда воспринимаются не более шести первых символов и могут не различаться буквы верхнего и нижнего регистров.
   A2.4.Ключевые слова
   Следующие идентификаторы зарезервированы в качестве ключевых слов и в другом смысле использоваться не могут:
   auto
   break
   char
   case
   char
   const
   continue
   default
   do
   double
   else
   enum
   extern
   float
   for
   goto
   if
   int
   long
   register
   return
   short
   signed
   sizeof
   static
   struct
   switch
   typedef
   union
   unsigned
   void
   volatile
   while
   В некоторых реализациях резервируются также словаfortranиasm.
   Ключевые слова const, signed и volatile впервые появились в стандарте ANSI; enum и void - новые по отношению к первому изданию книги, но уже использовались; ранее зарезервированное entry нигде не использовалось и поэтому более не резервируется.
   A2.5.Константы 
   Существует несколько видов констант. Каждая имеет свой тип данных; базовые типы рассматриваются в A4.2.
   константа:
       целая-константа
       символьная-константа
       константа-с-плавающей-точкой
       константа-перечисление
   A2.5.1.Целые константы
   Целая константа, состоящая из последовательности цифр, воспринимается как восьмеричная, если она начинается с 0 (цифры нуль), и как десятичная в противном случае. Восьмеричная константа не содержит цифр 8 и 9. Последовательность цифр, перед которой стоят 0x или 0X, рассматривается как шестнадцатеричное целое. В шестнадцатеричныецифры включены буквы от a (или A) до f (или F) co значениями от 10 до 15.
   Целая константа может быть записана с буквой-суффиксомu (илиU)для спецификации ее как беззнаковой константы. Она также может быть с буквой- суффиксомl (илиL)для указания, что она имеет типlong.
   Тип целой константы зависит от ее вида, значения и суффикса (о типах см. A4). Если константа - десятичная и не имеет суффикса, то она принимает первый из следующих типов, который годится для представления ее значения:int,long int,unsigned long int.Восьмеричная или шестнадцатеричная константа без суффикса принимает первый возможный из типов:int,unsigned int,long int,unsigned long int.Если константа имеет суффиксuилиU,то она принимает первый возможный из типов:unsigned int,unsigned long int.Если константа имеет суффиксlилиL,то она принимает первый возможный из типов:long int,unsigned long int.Если константа имеет суффиксulилиUL,то она принимает типunsigned long int.
   Типы целых констант получили существенное развитие в сравнении с первой редакцией языка, в которой большие целые имели просто тип long. Суффиксы U и u введены впервые.
   A2.5.2.Символьные константы
   Символьная константа - это последовательность из одной или нескольких символов, заключенная в одиночные кавычки (например'x').Если внутри одиночных кавычек расположен один символ, значением константы является числовое значение этого символа в кодировке, принятой на данной машине. Значение константы с несколькими символами зависит от реализации.
   Символьная константа не может содержать в себе одиночную кавычку ' или символ новой строки; чтобы изобразить их и некоторые другие символы, могут быть использованыэскейп-последовательности:новая строка (newline, linefeed)NL (LF)\nгоризонтальная табуляция (horizontal tab)HT\tвертикальная табуляция (vertical tab)VT\vвозврат на шаг (backspace)BS\bвозврат каретки (carriage return)CR\rперевод страницы (formfeed)FF\fсигнал звонок (audible alert, bell)BEL\aобратная наклонная черта (backslash)\\\знак вопроса (question mark)?\?одиночная кавычка (single quote)'\'двойная кавычка (double quote)"\"восьмеричный код (octal number)ooo\oooшестнадцатеричный код (hex number)hh\xhh
   Эскейп-последовательность\oooсостоит из обратной наклонной черты, за которой следуют одна, две или три восьмеричные цифры, специфицирующие значение желаемого символа. Наиболее частым примером такой конструкции является \0 (за которой не следует цифра); она специфицирует NULL-символ. Эскейп-последовательность\xhhсостоит из обратной наклонной черты с буквойx,за которыми следуют шестнадцатеричные цифры, специфицирующие значение желаемого символа. На количество цифр нет ограничений, но результат будет не определен, если значение полученного символа превысит значение самого "большого" из допустимых символов. Если в данной реализации типcharтрактуется как число со знаком, то значение и в восьмеричной, и в шестнадцатеричной эскейп-последовательности получается с помощью "распространения знака", как если бы выполнялась операция приведения к типуchar.Если за \ не следует ни один из перечисленных выше символов, результат не определен.
   В некоторых реализациях имеется расширенный набор символов, который не может быть охвачен типомchar.Константа для такого набора пишется с буквойLвпереди (например L'x') и называется расширенной символьной константой. Такая константа имеет типwchar_t (целочисленный тип, определенный в стандартном заголовочном файле‹stddef.h›).Как и в случае обычных символьных констант, здесь также возможны восьмеричные и шестнадцатеричные эскейп- последовательности; если специфицированное значение превысит типwchar_t,результат будет не определен.
   Некоторые из приведенных эскейп-последовательностей новые (шестнадцатеричные в частности). Новым является и расширенный тип для символов. Наборам символов, обычно используемым в Америке и Западной Европе, подходит тип char, а тип wchar_t был добавлен главным образом для азиатских языков.
   А2.5.3. Константы с плавающей точкой
   Константа с плавающей точкой состоит из целой части, десятичной точки, дробной части,eилиEи целого (возможно, со знаком), представляющего порядок, и, возможно, суффикса типа, задаваемого одной из букв:f,F,lилиL.И целая, и дробная часть представляют собой последовательность цифр. Либо целая часть, либо дробная часть (но не обе вместе) могут отсутствовать; также могут отсутствовать десятичная точка илиEс порядком (но не обе одновременно). Тип определяется суффиксом:Fилиfопределяют типfloat,Lилиl -типlong double;при отсутствии суффикса подразумевается типdouble.
   Суффиксы для констант с плавающей точкой являются нововведением.
   A2.5.4.Константы-перечисления 
   Идентификаторы, объявленные как элементы перечисления (A8.4), являются константами типаint.
   A2.6.Строковые литералы
   Строковый литерал, который также называют строковой константой, - это последовательность символов, заключенная в двойные кавычки (Например, "…"). Строка имеет тип "массив символов" и память классаstatic (A4),которая инициализируется заданными символами. Представляются ли одинаковые строковые литералы одной копией или несколькими, зависит от реализации. Поведение программы, пытающейся изменить строковый литерал, не определено.
   Написанные рядам строковые литералы объединяются (конкатенируются) в одну строку. После любой конкатенации к строке добавляется NULL-байт (\0), что позволяет программе, просматривающей строку, найти ее конец. Строковые литералы не могут содержать в себе символ новой строки или двойную кавычку; в них нужно использовать те же эскейп-последовательности, что и в символьных константах.
   Как и в случае с символьными константами, строковый литерал с символами из расширенного набора должен начинаться с буквыL (например L"…"). Строковый литерал из расширенного набора имеет тип "массив изwchar_t".Конкатенация друг с другом обычных и "расширенных" строковых литералов не определена.
   То, что строковые литералы не обязательно представляются разными копиями, запрет на их модификацию, а также конкатенация соседних строковых литералов - нововведения ANSI-стандарта. "Расширенные" строковые литералы также объявлены впервые.
   A3.Нотация синтаксиса 
   В нотации синтаксиса, используемой в этом руководстве, синтаксические понятия набираются курсивом, а слова и символы, воспринимаемые буквально, обычным шрифтом. Альтернативные конструкции обычно перечисляются в столбик (каждая альтернатива на отдельной строке); в редких случаях длинные списки небольших по размеру альтернатив располагаются в одной строке, помеченной словами "один из". Необязательное слово-термин или не термин снабжается индексом "необ.".Так, запись
   {выражениенеоб}
   обозначает выражение, заключенное в фигурные скобки, которое в общем случае может отсутствовать. Полный перечень синтаксических конструкций приведен в A13.
   В отличие от грамматики, данной в первом издании этой книги, приведенная здесь грамматика старшинство и порядок выполнения операций в выражениях описывает явно.
   A4.Что обозначают идентификаторы
   Идентификаторы, или имена, ссылаются на разные объекты (в оригинале -things. -Примеч. ред.): функции; теги структур, объединений и перечислений; элементы структур или объединений;typedef-имена; метки и объекты. Объектом (называемым иногда переменной) является часть памяти, интерпретация которой зависит от двух главных характеристик:класса памятин еетипа.Класс памяти сообщает о времени жизни памяти, связанной с идентифицируемым объектом, тип определяет, какого рода значения находятся в объекте. С любым именем ассоциируются своя область видимости (т. е. тот участок программы, где это имя известно) и атрибут связи, определяющий, обозначает ли это имя в другом файле тот же самый объект или функцию. Область видимости и атрибут связи обсуждаются в A11.
   A4.1.Класс памяти
   Существуют два класса памяти:автоматическийистатический.Несколько ключевых слов в совокупности с контекстом объявлений объектов специфицируют класс памяти для этих объектов.
   Автоматические объекты локальны в блоке (A9.3), при выходе из него они "исчезают". Объявление, заданное внутри блока, если в нем отсутствует спецификация класса памяти или указан спецификатор auto, создаст автоматический объект. Объект, помеченный в объявлении словомregister,является автоматическим и размещается по возможности в регистре машины.
   Статические объекты могут быть локальными в блоке или располагаться вне блоков, но в обоих случаях их значения сохраняются после выхода из блока (или функции) до повторного в него входа. Внутри блока (в том числе и в блоке, образующем тело функции) статические объекты в объявлениях помечаются словомstatic.Объекты, объявляемые вне всех блоков на одном уровне с определениями функций, всегда статические. С помощью ключевого словаstaticих можно сделать локальными в пределах транслируемой единицы (в этом случае они получают атрибутвнутренней связи),и они становятся глобальными для всей программы, если опустить явное указание класса памяти или использовать ключевое словоextern (в этом случае они получают атрибутвнешней связи).
   A4.2.Базовые типы
   Существует несколько базовых типов. Стандартный заголовочный файл ‹limits.h›, описанный в приложении B, определяет самое большое и самое малое значения для каждого типа в данной конкретной реализации. В приложении B приведены минимально возможные величины.
   Размер объектов, объявляемых как символы, позволяет хранить любой символ из набора символов, принятого в машине. Если объект типаcharдействительно хранит символ из данного набора, то его значением является код этого символа, т. е. некоторое неотрицательное целое. Переменные типаcharмогут хранить и другие значения, но тогда диапазон их значений и особенно вопрос о том, знаковые эти значения или беззнаковые, зависит от реализации.
   Беззнаковые символы, объявленные с помощью словunsigned char,имеют ту же разрядность, что и обычные символы, но представляют неотрицательные значения; с помощью словsigned charможно явно объявить символы со знаком, которые занимают столько же места, как и обычные символы.
   Тип unsigned char не упоминался в первой редакции языка, но всеми использовался. Тип signed char - новый.
   Помимоcharсреди целочисленных типов могут быть целые трех размеров:short int,intиlong int.Обычные объекты типаintимеют естественный размер, принятый в архитектуре данной машины, другие размеры предназначены для специальных нужд. Более длинные целые по крайней мере покрываютвсе значения более коротких целых, однако в некоторых реализациях обычные целые могут быть эквивалентны коротким (short)или длинным (long)целым. Все типыintпредставляют значения со знаком, если не оговорено противное.
   Для беззнаковых целых в объявлениях используется ключевое словоunsigned.Такие целые подчиняются арифметике по модулю 2 в степениn,гдеn -число битов в представлении числа, и, следовательно, в арифметике с беззнаковыми целыми никогда не бывает переполнения. Множество неотрицательных значений, которые могут храниться в объектах со знаком, является подмножеством значений, которые могут храниться в соответствующих объектах без знака; знаковое и беззнаковое представления каждого такого значения совпадают. Любые два из типов с плавающей точкой: с одинарной точностью (float),с двойной точностью (double)и с повышенной точностью (long double)могут быть синонимами, но каждый следующий тип этого списка должен по крайней мере обеспечивать точность предыдущего.
   long double -новый тип. В первой редакции языка синонимом для double был long float, теперь последний изъят из обращения.
   Перечисления -единственные в своем роде типы, которым дается полный перечень значений; с каждым перечислением связывается множество именованных констант (A8.4). Перечисления ведут себя наподобие целых, но компилятор обычно выдает предупреждающее сообщение, если объекту некоторого перечислимого типа присваивается нечто, отличное от его константы, или выражение не из этого перечисления.
   Поскольку объекты перечислений можно рассматривать как числа, перечисление относится к арифметическому типу. Типыcharиintвсех размеров, каждый из которых может быть со знаком или без знака, а также перечисления называютцелочисленными (integral)типами. Типыfloat,doubleиlong doubleназываются типами сплавающей точкой.
   Типvoidспецифицирует пустое множество значений. Он используется как "тип возвращаемого функцией значения" в том случае, когда она не генерирует никакого результирующегозначения.
   A4.3.Производные типы
   Помимо базовых типов существует практически бесконечный класс производных типов, которые формируются из уже существующих и описывают следующие конструкции:
   • массивы объектов заданного типа;
   • функции, возвращающие объекты заданного типа;
   • указатели на объекты заданного типа;
   • структуры, содержащие последовательность объектов, возможно, различных заданных типов;
   • объединения, каждое из которых может содержать любой из нескольких объектов различных заданных типов.
   В общем случае приведенные методы конструирования объектов могут применяться рекурсивно.
   A4.4.Квалификаторы типов
   Тип объекта может снабжаться квалификатором. Объявление объекта с квалификаторомconstуказывает на то, что его значение далее не будет изменяться; объявляя объект какvolatile (изменчивый, непостоянный (англ.)),мы указываем на его особые свойства для выполняемой компилятором оптимизации. Ни один из квалификаторов на диапазоны значений и арифметические свойства объектовне влияет. Квалификаторы обсуждаются в A8.2.
   A5.Объекты и Lvalues
   Объект -это некоторая именованная область памяти;lvalue -это выражение, обозначающее объект. Очевидным примеромlvalueявляется идентификатор с соответствующим типом и классом памяти. Существуют операции, порождающиеlvalue.Например, еслиE -выражение типа указатель, то*Eесть выражение дляlvalue,обозначающего объект, на который указываетE.Термин "lvalue"произошел от записи присваивания E1 = E2, в которой левый (left -левый (англ.),отсюда букваl,value -значение) операнд E1 должен быть выражениемlvalue.Описывая каждый оператор, мы сообщаем, ожидает ли онlvalueв качестве операндов и выдает лиlvalueв качестве результата.
   A6.Преобразования
   Некоторые операторы в зависимости от своих операндов мoгут вызывать преобразование их значений из одного типа в другой. В этом параграфе объясняется, что следует ожидать от таких преобразований. В A6.5 формулируются правила, по которым выполняются преобразования для большинства обычных операторов. При рассмотрении каждого отдельного оператора эти правила могут уточняться.
   A6.1.Целочисленное повышение
   Объект типа перечисление, символ, короткое целое, целое в битовом поле - все они со знаком или без могут использоваться в выражении там, где возможно применение целого. Если типintпозволяет "охватить" все значения исходного типа операнда, то операнд приводится кint,в противном случае он приводится кunsigned int.Эта процедура называется целочисленным повышением (Integral promotion -целочисленное повышение - иногда также переводят как "интегральное продвижение" -Примеч. ред.).
   A6.2.Целочисленные преобразования
   Любое целое приводится к некоторому заданному беззнаковому типу путем поиска конгруэнтного (т. е. имеющего то же двоичное представление) наименьшего неотрицательного значения и получения остатка от деления его наnmax + 1,гдеnmax -наибольшее число в этом беззнаковом типе. Для двоичного представления в дополнительном коде это означает либо выбрасывание лишних старших разрядов, если беззнаковый тип "уже" исходного типа, либо заполнение недостающих старших разрядов нулями (для значения без знака) или значением знака (для значения со знаком), если беззнаковый тип "шире" исходного.
   В результате приведения любого целого к знаковому типу преобразуемое значение не меняется, если оно представимо в этом новом типе, и противном случае результат зависит от реализации.
   A6.3.Целые и числа с плавающей точкой
   При преобразовании из типа с плавающей точкой в целочисленный дробная часть значения отбрасывается; если полученное при этом значение нельзя представить в заданном целочисленном типе, то результат не определен. В частности, не определен результат преобразования отрицательных значений с плавающей точкой в беззнаковые целые.
   Если значение преобразуется из целого в величину с плавающей точкой и она находится в допустимом диапазоне, но представляется в новом типе неточно, то результатомбудет одно из двух значений нового типа, ближайших к исходному. Если результат выходит за границы диапазона допустимых значений, поведение программы не определено.
   A6.4.Типы с плавающей точкой
   При преобразовании из типа с плавающей точкой меньшей точности в тип с плавающей точкой большей точности значение не изменяется. Если, наоборот, переход осуществляется от большей точности к меньшей и значение остается в допустимых пределах нового типа, то результатом будет одно из двух ближайших значений нового типа. Если результат выходит за границы диапазона допустимых значений, поведение программы не определено.
   А6.5. Арифметические преобразования
   Во многих операциях преобразование типов операндов и определение типа результата осуществляются по одним и тем же правилам. Они состоят в том, что операнды приводятся к некоторому общему типу, который также является и типом результата. Эти правила называютсяобычными арифметическими преобразованиями.
   • Если какой-либо из операндов имеет тип long double, то другой приводится к long double.
   • В противном случае, если какой-либо из операндов имеет тип double, то другой приводится к double.
   • В противном случае, если какой-либо из операндов имеет тип float, то другой приводится к float.
   • В противном случае для обоих операндов осуществляется целочисленное повышение: затем, если один из операндов имеет тип unsigned long int, то и другой преобразуется в unsigned long int.
   • В противном случае, если один из операндов принадлежит типу long int, а другой - unsigned int, то результат зависит от того, покрывает ли long int все значения unsigned int, и если этотак, то unsigned int приводится к long int; если нет, то оба операнда преобразуются в unsigned long int.
   • В противном случае, если один из операндов имеет тип long int, то другой приводится к long int.
   • В противном случае, если один из операндов - unsigned int, то другой приводится к unsigned int.
   • В противном случае оба операнда имеют тип int.
   Здесь есть два изменения. Во-первых, арифметика с операндами с плавающей точкой теперь может производиться с одинарной точностью, а не только с двойной; в первой редакции языка вся арифметика с плавающей точкой производилась с двойной точностью. Во-вторых, более короткий беззнаковый тип в комбинации с более длинным знаковым типом не распространяет свойство беззнаковости на тип результата; в первой редакции беззнаковый тип всегда доминировал. Новые правила немного сложнее, но до некоторой степени уменьшают вероятность появления неожиданных эффектов в комбинациях знаковых и беззнаковых величин. При сравнении беззнакового выражения со знаковым того же размера все же может возникнуть неожиданный результат.
   A6.6.Указатели и целые 
   К указателю можно прибавлять (и вычитать из него) выражение целочисленного типа; последнее в этом случае подвергается преобразованию, описанному в A7.7 при рассмотрении оператора сложения.
   К двум указателям на объекты одного типа, принадлежащие одному массиву, может применяться операция вычитания; результат приводится к целому посредством преобразования, описанного в A7.7 при рассмотрении оператора вычитания.
   Целочисленное константное выражение со значением 0 или оно же, но приведенное к типуvoid *,может быть преобразовано в указатель любого типа операторами приведения, присваивания и сравнения. Результатом будет NULL-указатель, который равен любому другому NULL-указателю того же типа, но не равен никакому указателю на реальный объект или функцию.
   Для указателей допускаются и другие преобразования, но в связи с ними возникает проблема зависимости результата от реализации. Эти преобразования должны быть специфицированы явным оператором преобразования типа или оператором приведения (A7.5 и A8.8).
   Указатель можно привести к целочисленному типу, достаточно большому для его хранения; требуемый размер зависит от реализации. Функция преобразования также зависит от реализации.
   Объект целочисленного типа можно явно преобразовать в указатель. Если целое получено из указателя и имеет достаточно большой размер, это преобразование даст тот же указатель; в противном случае результат зависит от реализации.
   Указатель на один тип можно преобразовать в указатель на другой тип. Если исходный указатель ссылается на объект, должным образом не выровненный по границам слов памяти, то в результате может произойти ошибка адресации. Если требования на выравнивание у нового типа меньше или совпадают с требованиями на выравнивание первоначального типа, то гарантируется, что преобразование указателя в другой тип и обратно его не изменит; понятие "выравнивание" зависит от реализации, однако в любой реализации объекты типаcharпредъявляют минимальные требования на выравнивание. Как описано в A6.8, указатель может также преобразовываться вvoid *и обратно, значение указателя при этом не изменяется.
   Указатель может быть преобразован в другой указатель того же типа с добавлением или удалением квалификаторов (A4.4, A8.2) того типа объекта, на который этот указатель показывает. Новый указатель, полученный добавлением квалификатора, имеет то же значение, но с дополнительными ограничениями, внесенными новыми квалификаторами. Операция по удалению квалификатора у объекта приводит к тому, что восстанавливается действие его начальных квалификаторов, заданных в объявлении этого объекта.
   Наконец, указатель на функцию может быть преобразован в указатель на функцию другого типа. Вызов функции по преобразованному указателю зависит от реализации; однако, если указатель еще раз преобразовать к его исходному типу, результат будет идентичен вызову по первоначальному указателю.
   A6.7.Тип void
   Значение (несуществующее) объекта типаvoidникак нельзя использовать, его также нельзя явно или неявно привести к типу, отличному отvoid.Поскольку выражение типаvoidобозначает отсутствие значения, его можно применять только там, где не требуется значения. Например, в качестве выражения- инструкции (A9.2) или левого операнда у оператора "запятая" (A7.18). Выражение можно привести к тинуvoidоперацией приведения типа. Например, применительно к вызову функции, используемому в роли выражения-инструкции, операция приведения кvoidявным образом подчеркивает тот факт, что результат функции отбрасывается.
   Тип void не фигурировал в первом издании этой книги, однако за прошедшее время стал общеупотребительным.
   А6.8. Указатели на void
   Любой указатель на объект можно привести к типуvoid *без потери информации. Если результат подвергнуть обратному преобразованию, то мы получим прежний указатель. В отличие от преобразований указатель-в-указатель (рассмотренных в A6.6), которые требуют явных операторов приведения к типу, в присваиваниях и сравнениях указатель любого типа может выступать в паре с указателем типаvoid *без каких-либо предварительных преобразований типа.
   Такая интерпретация указателей void * - новая; ранее роль обобщенного указателя отводилась указателю типа char *. Стандарт ANSI официально разрешает использование указателей void * совместно с указателями других типов в присваиваниях и сравнениях; в иных комбинациях указателей стандарт требует явных преобразований типа.
   A7.Выражения
   Приоритеты описываемых операторов имеют тот же порядок, что и пункты данного параграфа (от высших к низшим). Например, для оператора+,описанного в A7.7, термин "операнды" означает "выражения, определенные в A7.1-A7.6". В каждом пункте описываются операторы, имеющие одинаковый приоритет, и указывается их ассоциативность (левая или правая). Приоритеты и ассоциативность всех операторов отражены в грамматике, приведенной в A13.
   Приоритеты и ассоциативность полностью определены, а вот порядок вычисления выражения не определен за некоторым исключением даже для подвыражений с побочным эффектом. Это значит, что если в определении оператора последовательность вычисления его операндов специально не оговаривается, то в реализации можно свободно выбирать любой порядок вычислений и даже чередовать правый и левый порядок. Однако любой оператор использует значения своих операндов в точном соответствии с грамматическим разбором выражения, в котором он встречается.
   Это правило отменяет ранее предоставлявшуюся свободу в выборе порядка выполнения операций, которые математически коммутативны и ассоциативны, но которые в процессе вычислений могут таковыми не оказаться. Это изменение затрагивает только вычисления с плавающей точкой, выполняющиеся "на грани точности", и ситуации, когда возможно переполнение.
   В языке не определен контроль за переполнением, делением на нуль и другими исключительными ситуациями, возникающими при вычислении выражения. В большинстве существующих реализаций Си при вычислении знаковых целочисленных выражений и присваивании переполнение игнорируется, но результат таких вычислений не определен. Трактовки деления на нуль и всех исключительных ситуаций, связанных с плавающей точкой, могут не совпадать в разных реализациях; иногда для обработки исключительных ситуаций предоставляется нестандартная библиотечная функция.
   A7.1.Генерация указателя 
   Если тип выражения или подвыражения есть "массив изT",гдеT -некоторый тип, то значением этого выражения является указатель на первый элемент массива, и тип такого выражения заменяется на тип "указатель наT".Такая замена не делается, если выражение является операндом унарного оператораamp;,или операндом операций++, --,sizeof,или левым операндом присваивания, или операндом оператора. (точка). Аналогично, выражение типа "функция, возвращающаяТ",кроме случая, когда оно является операндом для&,преобразуется в тип "указатель на функцию, возвращающуюT".
   A7.2.Первичные выражения
   Первичные выражения это идентификаторы, константы, строки и выражения в скобках.
   первичное - выражение:
      идентификатор
      константа
      строка
       (выражение)
   Идентификатор, если он был должным образом объявлен (о том, как это делается, речь пойдет ниже), - первичное выражение. Тип идентификатора специфицируется в его объявлении. Идентификатор естьlvalue,если он обозначает объект (A5) арифметического типа, либо объект типа "структура", "объединение" или "указатель".
   Константа - первичное выражение. Ее тип зависит от формы записи, которая была рассмотрена в A2.5.
   Строковый литерал - первичное выражение. Изначально его тип - "массив изchar" ("массив изwchar_t"для строки символов расширенного набора), но в соответствии с правилом, приведенным в A7.1, указанный тип обычно превращается в "указатель наchar" ("указатель наwchar_t")с результирующим значением "указатель на первый символ строки". Для некоторых инициализаторов такая замена типа не делается. (см. A8.7)
   Выражение в скобках - первичное выражение, тип и значение которого идентичны типу и значению этого же выражения без скобок. Наличие или отсутствие скобок не влияетна то, является ли данное выражениеlvalueили нет.
   A7.3.Постфиксные выражения
   В постфиксных выражениях операторы выполняются слева направо.
   постфиксное-выражение:
      первичное-выражение
      постфиксное-выражение [выражение]
      постфиксное-выражение (список-аргументов-выраженийнеоб)
      постфиксное-выражение.идентификатор
      постфиксное-выражение-&gt;идентификатор
      постфиксное-выражение ++
      постфиксное-выражение --
   список-аргументов-выражений:
      выражение-присваивание
      список-аргументов-выражений ,выражение-присваивание
   A7.3.1.Обращение к элементам массива
   Постфиксное выражение, за которым следует выражение в квадратных скобках, есть постфиксное выражение, обозначающее обращение к индексируемому массиву. Одно из этих двух выражений должно принадлежать типу "указатель на T", где T - некоторый тип, а другое - целочисленному типу; тип результата индексирования есть T. Выражение E1[E2] по определению идентично выражению *((E1)+(E2)). Подробности см. в A8.6.
   A7.3.2.Вызов функции
   Вызов функции есть постфиксное выражение (оно называется именующим выражением функции -function designator),за которым следуют скобки, содержащие (возможно пустой) список разделенных запятыми выражений-присваиваний (A7.17), представляющих собой аргументы этой функции. Если постфиксное выражение - идентификатор, не объявленный в текущей области видимости, то считается, что этот идентификатор как бы неявно описан объявлением
   extern intidentifier();
   помещенным в самом внутреннем блоке, содержащем вызов соответствующей функции. Постфиксное выражение (после, возможно неявного, описания и генерации указателя, см. A7.1) должно иметь тип "указатель на функцию, возвращающуюT",гдеT -тип возвращаемого значения.
   В первой версии языка для именующего выражения функции допускался только тип "функция", и чтобы вызвать функцию через указатель, требовался явный оператор *. ANSI-стандарт поощряет практику некоторых существующих компиляторов, разрешающих иметь одинаковый синтаксис для обращения просто к функции и обращения к функции, специфицированной указателем. Возможность применения старого синтаксиса остается.
   Терминаргументиспользуется для выражения, задаваемого в вызове функции; терминпараметр -для обозначения получаемого ею объекта (или его идентификатора) в определении или объявлении функции. Вместо этих понятий иногда встречаются термины "фактическийаргумент (параметр)" и "формальный аргумент (параметр)", имеющие те же смысловые различия.
   При вызове функции каждый ее аргумент копируется; передача аргументов осуществляется строго через их значения. Функции разрешается изменять значения своих параметров, которые являются лишь копиями аргументов- выражений, но эти изменения не могут повлиять на значения самих аргументов. Однако можно передать указатель, чтобы позволить функции изменить значение объекта, на который указывает этот указатель.
   Имеются два способа объявления функции. В новом способе типы параметров задаются явно и являются частью типа функции; такое объявление называется прототипом функции. При старом способе типы параметров не указываются. Способы объявления функций обсуждаются в A8.6.3 и A10.1.
   Если вызов находится в области видимости объявления, написанного по-старому, каждый его аргумент подвергается операции повышения типа: для целочисленных аргументов осуществляется целочисленное повышение (A6.1), а для аргументов типаfloat -преобразование вdouble.Если число аргументов не соответствует количеству параметров в определении функции или если типы аргументов после повышения не согласуются с типами соответствующих параметров, результат вызова не определен. Критерий согласованности типов зависит от способа определения функции (старого или нового). При старом способе сравниваются повышенный тип аргумента в вызове и повышенный тип соответствующего параметра; при новом способе повышенный тип аргумента и тип параметра (без его повышения) должны быть одинаковыми.
   Если вызов находится в области видимости объявления, написанного по-новому, аргументы преобразуются, как если бы они присваивались переменным, имеющим типы соответствующих параметров прототипа. Число аргументов должно совпадать с числом явно описанных параметров, если только список параметров не заканчивается многоточием (, ...). В противном случае число аргументов должно быть больше числа параметров или равно ему; "скрывающиеся" под многоточием аргументы подвергаются операции повышения типа (так, как это было описано в предыдущем абзаце). Если определение функции задано по-старому, то типы параметров в прототипе, которые неявно присутствуют в вызове, должны соответствовать типам параметров в определении функции после их повышения.
   Эти правила особенно усложнились из-за того, что они призваны обслуживать смешанный способ (старого с новым) задания функций. По возможности его следует избегать.
   Очередность вычисления аргументов не определяется, в разных компиляторах она различна. Однако гарантируется, что аргументы и именующее выражение функции вычисляются полностью (включая и побочные эффекты) до входа в нее. Любая функция допускает рекурсивное обращение.  
   A7.3.3.Обращение к структурам
   Постфиксное выражение, за которым стоит точка с последующим идентификатором, является постфиксным выражением. Выражение первого операнда должно быть структурой или объединением, а идентификатор - именем элемента структуры или объединения. Значение - именованный элемент структуры или объединения, а тип значения - тип элемента структуры или объединения. Выражение являетсяlvalue,если первое выражение -lvalueи если тип второго выражения - не "массив".
   Постфиксное выражение, за которым стоит стрелка (составленная из знаков - и&gt;)с последующим идентификатором, является постфиксным выражением. Выражение первого операнда должно быть указателем на структуру (объединение), а идентификатор - именем элемента структуры (объединения). Результат - именованный элемент структуры (объединения), на которую указывает указатель, а тип значения - тип элемента структуры (объединения); результат -lvalue,если тип не есть "массив".
   Таким образом, выражение E1-&gt;MOSозначает то же самое, что и выражение (*E1).MOS. Структуры и объединения рассматриваются в A8.3.
   В первом издании книги уже было приведено правило, по которому имя элемента должно принадлежать структуре или объединению, упомянутому в постфиксном выражении. Там, однако, оговаривалось, что оно не является строго обязательным. Последние компиляторы и ANSI делают его обязательным.
   A7.3.4.Постфиксные операторы инкремента и декремента
   Постфиксное выражение, за которым следует++или--,есть постфиксное выражение. Значением такого выражения является значение его операнда. После того как значение было взято, операнд увеличивается (++) или уменьшается (--) на 1. Операнд должен бытьlvalue;информация об ограничениях, накладываемых на операнд, и деталях операций содержится в A7.7, где обсуждаются аддитивные операторы, и в A7.17, где рассматривается присваивание. Результат инкрементирования или декрементирования не естьlvalue.
   А7.4. Унарные операторы
   Выражения с унарными операторами выполняются справа налево.
   унарное-выражение:
      постфиксное-выражение
       ++унарное-выражение
       --унарное-выражение
      унарный-оператор выражение-приведенное-к-типу
       sizeofунарное-выражение
       sizeof (имя-типа)
   унарный-оператор:один из
      &   *   +   -   ~   !
   А7.4.1. Префиксные операторы инкремента и декремента
   Унарное выражение, перед которым стоит++или--,есть унарное выражение. Операнд увеличивается (++) или уменьшается (--) на 1.
   Значением выражения является значение его операнда после увеличения (уменьшения). Операнд всегда должен бытьlvalue;информация об ограничениях на операнд и о деталях операции содержится в A7.7, где обсуждаются аддитивные операторы, и в A7.17, где рассматривается присваивание. Результат инкрементирования и декрементирования не естьlvalue.
   A7.4.2.Оператор получения адреса
   Унарный оператор&обозначает операцию получения адреса своего операнда. Операнд должен быть либоlvalue,не ссылающимся ни на битовое поле, ни на объект, объявленный какregister,либо иметь тип "функция". Результат - указатель на объект (или функцию), адресуемый этимlvalue.Если тип операнда естьT,то типом результата является "указатель наT".
   A7.4.3.Оператор косвенного доступа
   Унарный оператор*обозначает операцию косвенного доступа (раскрытия указателя), возвращающую объект (или функцию), на который указывает ее операнд. Результат естьlvalue,если операнд - указатель на объект арифметического типа или на объект типа "структура", "объединение" или "указатель". Если тип выражения - "указатель наT",то тип результата -T.
   A7.4.4.Оператор унарный плюс
   Операнд унарного+должен иметь арифметический тип, результат - значение операнда. Целочисленный операнд подвергается целочисленному повышению. Типом результата является повышенный тип операнда.
   Унарный + был добавлен для симметрии с унарным -.
   A7.4.5.Оператор унарный минус
   Операнд для унарного минуса должен иметь арифметический тип, результат - значение операнда с противоположным знаком. Целочисленный операнд подвергается целочисленному повышению. Отрицательное значение от беззнаковой величины вычисляется вычитанием изnmax+1приведенного к повышенному типу операнда, гдеnmax -максимальное число повышенного типа; однако минус нуль есть нуль. Типом результата будет повышенный тип операнда.
   A7.4.6.Оператор побитового отрицания
   Операнд оператора~должен иметь целочисленный тип, результат - дополнение операнда до единиц по всем разрядам. Выполняется целочисленное повышение типа операнда. Если операнд беззнаковый, то результат получается вычитанием его значения из самого большого числа повышенного типа. Если операнд знаковый, то результат вычисляется посредством приведения "повышенного операнда" к беззнаковому типу, выполнения операции ~ и обратного приведения его к знаковому типу. Тип результата - повышенный тип операнда.
   A7.4.7.Оператор логического отрицания
   Операнд оператора!должен иметь арифметический тип или быть указателем. Результат равен 1, если сравнение операнда с 0 дает истину, и равен 0 в противном случае. Тип результата -int.  
   A7.4.8.Оператор определения размера sizeof
   Операторsizeofдает число байтов, требуемое для хранения объекта того типа, который имеет его операнд. Операнд - либо выражение (которое не вычисляется), либо имя типа, записанное в скобках. Примененный кcharоператорsizeofдает 1. Для массива результат равняется общему количеству байтов в массиве, для структуры или объединения - числу байтов в объекте, включая и байты- заполнители, которые понадобились бы, если бы из элементов составлялся массив. Размер массива изnэлементов всегда равняетсяn,помноженному на размер отдельного его элемента. Данный оператор нельзя применять к операнду типа "функция", к незавершенному типу и к битовому полю. Результат - беззнаковая целочисленная константа: конкретный ее тип зависит от реализации. В стандартном заголовочном файле&lt;stddef.h&gt;(см. приложение B) этот тип определяется под именемsize_t.
   A7.5.Оператор приведения типа
   Имя типа, записанное перед унарным выражением н скобках, вызывает приведение значения этого выражения к указанному типу.
   выражение-приведенное-к-типу:
      унарное-выражение
       (имя-типа)выражение-приведенное-к-типу
   Данная конструкция называетсяприведением.Имена типов даны в A8.8. Результат преобразований описан в A6. Выражение с приведением типа не являетсяlvalue.
   A7.6.Мультипликативные операторы
   Мультипликативные операторы*,/и%выполняются слева направо.
   мультипликативное-выражение:
      выражение-приведенное-к-типу
      мультипликативное-выражение *выражение-приведенное-к-типу
      мультипликативное-выражение /выражение-приведенное-к-типу
      мультипликативное-выражение %выражение-приведенное-к-типу
   Операнды операторов * и / должны быть арифметического типа, оператора % - целочисленного типа. Над операндами осуществляются обычные арифметические преобразования, которые приводят их значения к типу результата.
   Бинарный оператор * обозначает умножение.
   Бинарный оператор / получает частное, а % - остаток от деления первого операнда на второй; если второй операнд есть 0, то результат не определен. В противном случае всегда выполняется соотношение: (a / b) * b + a % b равняется a. Если оба операнда не отрицательные, то остаток не отрицательный и меньше делителя; в противном случае стандартгарантирует только одно: что абсолютное значение остатка меньше абсолютного значения делителя.
   A7.7.Аддитивные операторы
   Аддитивные операторы+и-выполняются слева направо. Если операнды имеют арифметический тип, то осуществляются обычные арифметические преобразования. Для каждого оператора существует еще несколько дополнительных сочетаний типов.
   аддитивное-выражение:
      мультипликативное-выражение
      аддитивное-выражение +мультипликативное-выражение
      аддитивное-выражение -мультипликативное-выражение
   Результат выполнения оператора + есть сумма его операндов. Указатель на объект в массиве можно складывать с целочисленным значением. При этом последнее преобразуется в адресное смещение посредством умножения его на размер объекта, на который ссылается указатель. Сумма является указателем на объект того же типа; только ссылается этот указательна другой объект того же массива, отстоящий от первоначального соответственно вычисленному смещению. Так, еслиp -указатель на объект в массиве, тоp+1 -указатель на следующий объект того же массива. Если полученный в результате суммирования указатель указывает за границы массива, то, кроме случая, когда он указывает на место, находящееся непосредственно за концом массива, результат будет неопределенным.
   Возможность для указателя указывать на элемент, расположенный сразу за концом массива, является новой. Тем самым узаконена общепринятая практика организации циклического перебора элементов массива.
   Результат выполнения оператора - (минус) есть разность операндов. Из указателя можно вычитать значение любого целочисленного типа с теми же преобразованиями и притех же условиях, что и в сложении.
   Если к двум указателям на объекты одного и того же типа применить оператор вычитания, то в результате получится целочисленное значение со знаком, представляющее собой расстояние между объектами, на которые указывают эти указатели: указатель на следующий объект на 1 больше указателя на предыдущий объект. Тип результата зависит от реализации: в стандартном заголовочном файле&lt;stddef.h&gt;он определен под именемptrdiff_t.Значение не определено, если указатели указывают на объекты не одного и того же массива; однако еслиpуказывает на последний элемент массива, тоp+1-pимеет значение, равное 1.
   A7.8.Операторы сдвига
   Операторы сдвига&lt;&lt;и&gt;&gt;выполняются слева направо. Для обоих операторов каждый операнд должен иметь целочисленный тип, и каждый из них подвергается целочисленному повышению. Тип результата совпадает с повышенным типом левого операнда. Результат не определен, если правый операнд отрицателен или его значение превышает число битов в типе левого выражения или равно ему.
   сдвиговое-выражение:
      аддитивное-выражение
      сдвиговое-выражение&gt;&gt;аддитивное-выражение
      сдвиговое-выражение&lt;&lt;аддитивное-выражение
   Значение E1&lt;&lt;E2равно значению E1 (рассматриваемому как цепочка битов), сдвинутому влево на E2 битов; при отсутствии переполнения такая операция эквивалентна умножению на 2E2.Значение E1&gt;&gt;E2равно значению E1, сдвинутому вправо на E2 битовые позиции. Если E1 - беззнаковое или имеет неотрицательное значение, то правый сдвиг эквивалентен делению на 2E2,в противном случае результат зависит от реализации.
   A7.9.Операторы отношения

   Операторы отношения выполняются слева направо, однако это свойство едва ли может оказаться полезным: согласно грамматике языка выражение a&lt; b&lt; cтрактуется так же, как (a&lt; b)&lt; c,а результат вычисления a&lt; bможет быть только 0 или 1.
   выражение-отношения:
      сдвиговое-выражение
      выражение-отношения&lt;сдвиговое-выражение
      выражение-отношения&gt;сдвиговое-выражение
      выражение-отношения&lt;=сдвиговое-выражение
      выражение-отношения&gt;=сдвиговое-выражение
   Операторы:&lt; (меньше),&gt; (больше),&lt;= (меньше или равно) и&gt;= (больше или равно) - все выдают 0, если специфицируемое отношение ложно, и 1, если оно истинно. Тип результата -int.Над арифметическими операндами выполняются обычные арифметические преобразования. Можно сравнивать указатели на объекты одного и того же типа (без учета квалификаторов); результат будет зависеть от относительного расположения в памяти. Допускается, однако, сравнение указателей на разные части одного и того же объекта: еслидва указателя указывают на один и тот же простой объект, то они равны; если они указывают на элементы одной структуры, то указатель на элемент с более поздним объявлением в структуре больше; если указатели указывают на элементы одного и того же объединения, то они равны; если указатели указывают на элементы некоторого массива,то сравнение этих указателей эквивалентно сравнению их индексов. Еслиpуказывает на последний элемент массива, тоp+1больше, чемp,хотяp+1указывает за границы массива. В остальных случаях результат сравнения не определен.
   Эти правила несколько ослабили ограничения, установленные в первой редакции языка. Они позволяют сравнивать указатели на различные элементы структуры и объединения и легализуют сравнение с указателем на место, которое расположено непосредственно за концом массива.
   A7.10.Операторы равенства
   выражение-равенства:
      выражение-отношения
      выражение-равенства ==выражение-отношения
      выражение-равенства !=выражение-отношения
   Операторы== (равно) и!= (не равно) аналогичны операторам отношения с той лишь разницей, что имеют более низкий приоритет. (Таким образом, a&lt; b == c&lt; dесть 1 тогда и только тогда, когда отношения a&lt; bи c&lt; dили оба истинны, или оба ложны.)
   Операторы равенства подчиняются тем же правилам, что и операторы отношения. Кроме того, они дают возможность сравнивать указатель с целочисленным константным выражением, значение которого равно нулю, и с указателем наvoid (см. A6.6.).
   A7.11.Оператор побитового И
   И-выражение:
      выражение-равенства
      И-выражение&выражение-равенства
   Выполняются обычные арифметические преобразования: результат - побитовоеANDоперандов. Оператор применяется только к целочисленным операндам.
   A7.12.Оператор побитового исключающего ИЛИ
   исключающее-ИЛИ-выражение:
      И-выражение
      исключающее-ИЛИ-выражение ^И-выражение
   Выполняются обычные арифметические преобразования; результат - побитовоеXORоперандов. Оператор применяется только к целочисленным операндам.
   A7.13.Оператор побитового ИЛИ
   ИЛИ выражение:
      исключающее-ИЛИ-выражение
      ИЛИ-выражение |исключающее-ИЛИ-выражение
   Выполняются обычные арифметические преобразования; результат - побитовоеORоперандов. Оператор применяется только к целочисленным операндам.
   A7.14.Оператор логического И
   логическое-И-выражение:
      ИЛИ-выражение
      логическое-И-выражение&&ИЛИ-выражение
   Операторы&&выполняются слева направо. Оператор&&выдает 1, если оба операнда не равны нулю, и 0 в противном случае. В отличие от&,&&гарантирует, что вычисления будут проводиться слева направо: вычисляется первый операнд со всеми побочными эффектами; если он равен 0, то значение выражения есть 0.В противном случае вычисляется правый операнд, и, если он ранен 0, то значение выражения есть 0, в противном случае оно равно 1.
   Операнды могут принадлежать к разным типам, но при этом каждый из них должен иметь либо арифметический тип, либо быть указателем. Тип результата -int.
   A7.15.Оператор логического ИЛИ
   логическое-ИЛИ-выражение:
      логическое-И-выражение
      логическое-ИЛИ-выражение ||логическое-И-выражение
   Операторы||выполняются слева направо. Оператор || выдает 1, если по крайней мере один из операндов не равен нулю, и 0 в противном случае. В отличие от |, оператор || гарантирует, что вычисления будут проводиться слева направо: вычисляется первый операнд, включая все побочные эффекты; если он не равен 0, то значение выражения есть 1. В противном случае вычисляется правый операнд, и если он не равен 0, то значение выражения есть 1, в противном случае оно равно 0.
   Операнды могут принадлежать разным типам, но операнд должен иметь либо арифметический тип, либо быть указателем. Тип результата -int.
   А7.16. Условный оператор
   условное-выражение:
      логическое-ИЛИ-выражение
      логическое-ИЛИ-выражение ?выражение :условное-выражение
   Вычисляется первое выражение, включая все побочные эффекты; если оно не равно 0, то результат есть значение второго выражения, в противном случае - значение третьего выражения. Вычисляется только один из двух последних операндов: второй или третий. Если второй и третий операнды арифметические, то выполняются обычные арифметические преобразования, приводящие к некоторому общему типу, который и будет типом результата. Если оба операнда имеют типvoid,или являются структурами или объединениями одного и того же типа, или представляют собой указатели на объекты одного и того же типа, то результат будет иметь тот же тип, что и операнды. Если один из операндов имеет тип "указатель", а другой является константой 0, то 0 приводится к типу "указатель", этот же тип будет иметь и результат. Если один операнд является указателем наvoid,а второй - указателем другого типа, то последний преобразуется в указатель наvoid,который и будет типом результата.
   При сравнении типов указателей квалификаторы типов (A8.2) объектов, на которые указатели ссылаются, во внимание не принимаются, но тип результата наследует квалификаторы обеих ветвей условного выражения
   A7.17.Выражения присваивания
   Существует несколько операторов присваивания; они выполняются справа налево.
   выражение-присваивания:
      условное-выражение
      унарное-выражение оператор-присваивания выражение-присваивания
   оператор-присваивания:один из
       =
       *=
       /=
       %=
       +=
       -=
      &lt;&lt;=
      &gt;&gt;=
      &=
       ^=
       |=
   Операторы присваивания в качестве левого операнда требуютlvalue,причем модифицируемого; это значит, что оно не может быть массивом, или иметь незавершенный тип, или быть функцией. Тип левого операнда, кроме того, не может иметь квалификатораconst;и, если он является структурой или объединением, в них не должно быть элементов или подэлементов (для вложенных структур или объединений) с квалификаторамиconst.
   Тип выражения присваивания соответствует типу его левого операнда, а значение равно значению его левого операнда после завершения присваивания.
   В простом присваивании с оператором = значение выражения замещает объект, к которому обращаетсяlvalue.При этом должно выполняться одно из следующих условий: оба операнда имеют арифметический тип (если типы операндов разные, правый операнд приводится к типу левого операнда); оба операнда есть структуры или объединения одного и того же типа; один операнд есть указатель, а другой - указатель наvoid;левый операнд - указатель, а правый - константное выражение со значением 0; оба операнда - указатели на функции или объекты, имеющие одинаковый тип (за исключением возможного отсутствияconstилиvolatileу правого операнда).
   Выражение E1op= E2эквивалентно выражению E1 = E1op(E2)с одним исключением: E1 вычисляется только один раз.
   A7.18.Оператор запятая
   выражение:
      выражение-присваивания
      выражение ,выражение-присваивания
   Два выражения, разделенные запятой, вычисляются слева направо, и значение левого выражения отбрасывается. Тип и значение результата совпадают с типом и значением правого операнда. Вычисление всех побочных эффектов левого операнда завершается перед началом вычисления правого операнда. В контексте, в котором запятая имеет специальное значение, например в списках аргументов функций (A7.3.2) или в списках инициализаторов (A8.7) (здесь в качестве синтаксических единиц фигурируют выражения присваивания), оператор запятая может появиться только в группирующих скобках. Например, в
   f(a, (t=3, t+2), c)
   три аргумента, из которых второй имеет значение 5.
   A7.19.Константные выражения
   Синтаксически, константное выражение - это выражение с ограниченным подмножеством операторов:
   константное-выражение:
      условное-выражение
   При указанииcase-меток в переключателе, задании границ массивов и длин полей битов, на месте значений перечислимых констант и инициализаторов, а также в некоторых выражениях для препроцессора требуются выражения, вычисление которых приводит к константе.
   Константные выражения не могут содержать присваиваний, операторов инкрементирования и декрементирования, вызовов функций и операторов-запятых; перечисленные ограничения не распространяются на операнд оператораsizeof.Если требуется получить целочисленное константное выражение, то его операнды должны состоять из целых, перечислимых (enum),символьных констант и констант с плавающей точкой; операции приведения должны специфицировать целочисленный тип, а любая константа с плавающей точкой - приводиться к целому. Из этого следует, что в константном выражении не может быть массивов, операций косвенного обращения (раскрытия указателя), получения адреса и доступа к полям структуры. (Однако дляsizeofвозможны операнды любого вида.)
   Для константных выражений в инициализаторах допускается большая свобода; операндами могут быть константы любого типа, а к внешним или статическим объектам и внешним и статическим массивам, индексируемым константными выражениями, возможно применять унарный оператор&.Унарный оператор&может также неявно присутствовать при использовании массива без индекса или функции без списка аргументов. Вычисление инициализатора должно давать константу или адрес ранее объявленного внешнего или статического объекта плюс-минус константа.
   Меньшая свобода допускается для целочисленных константных выражений, используемых после#if:не разрешаютсяsizeof-выражения, константы типаenumи операции приведения типа. (см. A12.5.)
   A8.Объявления
   То, каким образом интерпретируется каждый идентификатор, специфицируется объявлениями; они не всегда резервируют память для описываемых ими идентификаторов. Объявления, резервирующие память, называются определениями и имеют следующий вид:
   объявление:
      спецификаторы-объявления список-инициализаторов-объявителейнеоб
   Объявители всписке-инициализаторов-объявителейсодержат объявляемые идентификаторы;спецификаторы-объявленияпредставляют собой последовательности, состоящие из спецификаторов типа и класса памяти.
   спецификаторы-объявления:
      спецификатор-класса-памяти спецификаторы-объявлениянеоб
      спецификатор-типа спецификаторы-объявлениянеоб
      квалификатор-типа спецификаторы-объявлениянеоб
   список-инициализаторов-объявителей:
      инициализатор-объявитель
      список-инициализаторов-объявителей ,инициализатор-объявитель
   инициализатор-объявитель:
      объявитель
      объявитель =инициализатор
   Объявители содержат подлежащие объявлению имена. Мы рассмотрим их позже, в A8.5. Объявление должно либо иметь по крайней мере один объявитель, либо его спецификатор типа должен определять тег структуры или объединения, либо - задавать элементы перечисления; пустое объявление недопустимо.
   A8.1.Спецификаторы класса памяти

   Класс памяти специфицируется следующим образом:
   спецификатор-класса-памяти:
       auto
       register
       static
       extern
       typedef
   Смысл классов памяти обсуждался в A4.
   Спецификаторыautoиregisterдают объявляемым объектам класс автоматической памяти, и эти спецификаторы можно применять только внутри функции. Объявления сautoиregisterодновременно являются определениями и резервируют намять. Спецификаторregisterэквивалентенauto,но содержит подсказку, сообщающую, что в программе объявленные им объекты используются интенсивно. На регистрах может быть размещено лишь небольшое число объектов, причем определенного типа: указанные ограничения зависят от реализации. В любом случае кregister-объекту нельзя применять (явно или неявно) унарный оператор&.
   Новым является правило, согласно которому вычислять адрес объекта классаregisterнельзя, а классаautoможно.
   Спецификаторstaticдает объявляемым объектам класс статической памяти, он может использоваться и внутри, и вне функций. Внутри функции этот спецификатор вызывает выделение памяти и служит определением; его роль вне функций будет объяснена в A11.2.
   Объявление со спецификаторомextern,используемое внутри функции, объявляет, что для объявляемого объекта где-то выделена память; о ее роли вне функций будет сказано в A11.2.
   Спецификаторtypedefне резервирует никакой памяти и назван спецификатором класса памяти из соображений стандартности синтаксиса; речь об этом спецификаторе пойдет в A8.9.
   Объявление может содержать не более одного спецификатора класса памяти. Если он в объявлении отсутствует, то действуют следующие правила: считается, что объекты, объявляемые внутри функций, имеют классauto;функции, объявляемые внутри функций, - классextern;объекты и функции, объявляемые вне функций, - статические и имеютвнешние связи (см. A10, A11).
   А8.2. Спецификаторы типа
   Спецификаторы типа определяются следующим образом:
   спецификатор-типа:
       void
       char
       short
       int
       long
       float
       double
       signed
       unsigned
    структуры-или-объединения-спецификатор
    спецификатор-перечисления
    typedef-имя
   Вместе сintдопускается использование еще какого-то одного слова -longилиshort;причем сочетаниеlong intимеет тот же смысл, что и простоlong:аналогичноshort int -то же самое, что иshort.Словоlongможет употребляться вместе сdouble.Сintи другими его модификациями (short,longилиchar)разрешается употреблять одно из словsignedилиunsigned.Любое из последних может использоваться самостоятельно, в этом случае подразумеваетсяint.
   Спецификаторsignedбывает полезен, когда требуется обеспечить, чтобы объекты типаcharимели знак; его можно применять и к другим целочисленным типам, но в этих случаях он избыточен.
   За исключением описанных выше случаев объявление не может содержать более одного спецификатора типа. Если в объявлении нет ни одного спецификатора типа, то имеется в виду типint.
   Для указания особых свойств объявляемых объектов предназначаются квалификаторы:
   квалификатор-типа:
       const
       volatile
   Квалификаторы типа могут употребляться с любым спецификатором типа. Разрешается инициализироватьconst-объект, однако присваивать ему что-либо в дальнейшем запрещается. Смысл квалификатораvolatileзависит от реализации.
   Средстваconstиvolatile (изменчивый) введены стандартом ANSI. Квалификаторconstприменяется, чтобы разместить объекты в памяти, открытой только на чтение (ПЗУ), или чтобы способствовать возможной оптимизации. Назначение квалификатораvolatile -подавить оптимизацию, которая без этого указания могла бы быть проведена. Например, в машинах, где адреса регистров ввода-вывода отображены на адресное пространство памяти, указатель на регистр некоторого устройства мог бы быть объявлен какvolatile,чтобы запретить компилятору экономить очевидно избыточную ссылку через указатель. Компилятор может игнорировать указанные квалификаторы, однако обязан сигнализировать о явных попытках изменить значениеconst-объектов.
   A8.3.Объявления структур и объединений
   Структура -это объект, состоящий из последовательности именованных элементов различных типов.Объединение -объект, который в каждый момент времени содержит один из нескольких элементов различных типов. Объявления структур и объединений имеют один и тот же вид.
   спецификатор структуры-или-объединения:
      структуры-или-объединения идентификаторнеоб {список-объявлений-структуры}
      структуры-или-объединения идентификатор
   структура-или-объединение:
       struct
       union
   Список-объявлений-структуры является последовательностью объявлений элементов структуры или объединения:
   список-объявлений-структуры:
      объявление-структуры
      список-объявлений-структуры объявление-структуры
   объявление-структуры:
      список-спецификаторов-квалификаторов список-структуры-объявителей;
   список-спецификаторов-квалификаторов:
      спецификатор-типа список-спецификаторов-квалификаторовнеоб
      квалификатор-типа список-спецификаторов-квалификаторовнеоб
   список-структуры-объявителей:
      структуры-объявитель
      список-структуры-объявителей ,структуры-объявитель
   Обычнообъявление-структурыявляется просто объявлением для элементов структуры или объединения. Элементы структуры, в свою очередь, могут состоять из заданного числа разрядов (битов). Такой элемент называетсябитовым полемили просто полем. Его размер отделяется от имени поля двоеточием:
   структуры-объявитель:
      объявитель
      объявительнеоб :константное-выражение
   Спецификатор типа, имеющий вид
   структуры-или-объединения идентификатор {список-объявлений-структуры }
   объявляет идентификатортегомструктуры или объединения, специфицированных списком. Последующее объявление в той же или внутренней области видимости может обращаться к тому же типу, используяв спецификаторе тег без списка:
   структуры-или-объединения идентификатор
   Если спецификатор с тегом, но без списка появляется там, где тег не объявлен, специфицируетсянезавершенный тип.Объекты с незавершенным типом структуры или объединения могут упоминаться в контексте, где не требуется знать их размер - например в объявлениях (но не определениях) для описания указателя или созданияtypedef,но не в иных случаях. Тип становится завершенным при появлении последующего спецификатора с этим тегом, содержащего список объявлений. Даже в спецификаторах со списком объявляемый тип структуры или объединения является незавершенным внутри списка и становится завершенным только после появления символа }, заканчивающего спецификатор.
   Структура не может содержать элементов незавершенного типа. Следовательно, невозможно объявить структуру или объединение, которые содержат сами себя. Однако, кроме придания имени типу структуры или объединения, тег позволяет определять структуры, обращающиеся сами к себе; структура или объединение могут содержать указатели на самих себя, поскольку указатели на незавершенные типы объявлять можно.
   Особое правило применяется к объявлениям вида
   структуры-или-объединения идентификатор;
   которые объявляют структуру или объединение, но не имеют списка объявления и объявителя. Даже если идентификатор имеет тег структуры или объединения во внешней области видимости (A11.1), это объявление делает идентификатор тегом новой структуры или объединения незавершенного типа во внутренней области видимости.
   Это невразумительное правило - новое в ANSI. Оно предназначено для взаимно рекурсивных структур, объявленных во внутренней области видимости, но теги которых могут быть уже объявлены во внешней области видимости.
   Спецификатор структуры или объединения со списком, но без тега создает уникальный тип, к которому можно обращаться непосредственно только в объявлении, частью которого он является.
   Имена элементов и тегов не конфликтуют друг с другом или обычными переменными. Имя элемента не может появляться дважды в одной и той же структуре или объединении, но тот же элемент можно использовать в разных структурах или объединениях.
   В первой редакции этой книги имена элементов структуры и объединения не связывались со своими родителями. Однако в компиляторах эта связь стала обычной задолго до появления стандарта ANSI.
   Элемент структуры или объединения, не являющийся полем, может иметь любой тип объекта. Поле (которое не имеет объявителя и, следовательно, может быть безымянным) имеет типint,unsigned intилиsigned intи интерпретируется как объект целочисленного типа указанной в битах длины. Считается ли полеintзнаковым или беззнаковым, зависит от реализации. Соседний элемент-поле упаковывается в ячейки памяти в зависимости от реализации в зависящем от реализации направлении. Когда следующее за полем другое поле не влезает в частично заполненную ячейку памяти, оно может оказаться разделенным между двумя ячейками, или ячейка может быть забита балластом. Безымянное поле нулевой ширины обязательно приводит к такой забивке, так что следующее поле начнется с края следующей ячейки памяти.
   Стандарт ANSI делает поля еще более зависимыми от реализации, чем в первой редакции книги. Чтобы хранить битовые поля в "зависящем от реализации" виде без квалификации, желательно прочитать правила языка. Структуры с битовыми полями могут служить переносимым способом для попытки уменьшить размеры памяти под структуру (вероятно, ценой увеличения кода программы и времени на доступ к полям) или непереносимым способом для описания распределения памяти на битовом уровне. Во втором случае необходимо понимать правила местной реализации.
   Элементы структуры имеют возрастающие по мере объявления элементов адреса. Элементы структуры, не являющиеся полями, выравниваются по границам адресов в зависимости от своего типа; таким образом, в структуре могут быть безымянные дыры. Если указатель на структуру приводится к типу указателя на ее первый элемент, результат указывает на первый элемент.
   Объединение можно представить себе как структуру, все элементы которой начинаются со смещением 0 и размеры которой достаточны для хранения любого из элементов. В любой момент времени в объединении хранится не больше одного элемента. Если указатель на объединение приводится к типу указателя на один из элементов, результат указывает на этот элемент.
   Вот простой пример объявления структуры:
   struct tnode {
       char tword[20];
       int count;
       struct tnode *left;
       struct tnode *right;
   };
   Эта структура содержит массив из 20 символов, число типаintи два указателя на подобную структуру. Если дано такое объявление, то
   struct tnode s, *sp;
   объявитsкак структуру заданного вида, asp -как указатель на такую структуру. Согласно приведенным определениям выражение
   sp-&gt;count
   обращается к элементуcountв структуре, на которую указываетsp;
   s.left
   -указатель на левое поддерево в структуреs,а
   s.right-&gt;tword[0]
   -это первый символ изtword -элемента правого поддереваs.
   Вообще говоря, невозможно проконтролировать, тот ли используется элемент объединения, которому последний раз присваивалось значение. Однако гарантируется выполнение правила, облегчающего работу с элементами объединения: если объединение содержит несколько структур, начинающихся с общей для них последовательности данных, и если объединение в текущий момент содержит одну из этих структур, то к общей части данных разрешается обращаться через любую из указанных структур. Так, правомерен следующий фрагмент программы:
   union {
       struct {
           int type;
       } n;

       struct {
           int type;
           int intnode;
       } ni;

       struct {
           int type;
           float floatnode;
       } nf;
   } u;

   ...

   u.nf.type = FLOAT;
   u.nf.floatnode = 3.14;
   ...

   if (u.n.type == FLOAT)
   ... sin(u.nf.floatnode) ...
   A8.4.Перечисления
   Перечисления -это уникальный тип, значения которого покрываются множеством именованных констант, называемых перечислителями. Вид спецификатора перечисления заимствован у структур и объединений.
   спецификатор-перечисления:
       enumидентификаторнеоб {список-перечислителей}
       enumидентификатор
   список-перечислителей:
      перечислитель
      список-перечислителей ,перечислитель
   перечислитель:
      идентификатор
      идентификатор =константное-выражение
   Идентификаторы, входящие в список перечислителей, объявляются константами типаintи могут употребляться везде, где требуется константа. Если в этом списке нет ни одного перечислителя со знаком =, то значения констант начинаются с 0 и увеличиваются на 1 по мере чтения объявления слева направо. Перечислитель со знаком = дает соответствующему идентификатору значение; последующие идентификаторы продолжают прогрессию от заданного значения.
   Имена перечислителей, используемые в одной области видимости, должны отличаться друг от друга и от имен обычных переменных, однако их значения могут и совпадать.
   Роль идентификатора впереч-спецификатореаналогична роли тега структуры вструкт-спецификаторе:он является именем некоторого конкретного перечисления. Правила для списков и переч-спецификаторов (с тегами и без) те же, что и для спецификаторов структур или объединений, с той лишь оговоркой, что элементы перечислений не бывают незавершенного типа; тег переч-спецификатора без списка перечислителей должен иметь в пределах области видимости спецификатор со списком.  
   В первой версии языка перечислений не было, но они уже несколько лет применяются.
   А8.5. Объявители
   Объявители имеют следующий синтаксис:
   объявитель:
      указательнеобсобственно-объявитель
   собственно-объявитель:
      идентификатор
       (объявитель)
      собственно-объявитель [константное-выражениенеоб]
      собственно-объявитель (список-типов-параметров)
      собственно-объявитель (список-идентификаторовнеоб)
   указатель:
       *список-квалификаторов-типанеоб
       *список-квалификаторов-типанеобуказатель
   список-квалификаторов-типа:
      квалификатор-типа
      список-квалификаторов-типа квалификатор-типа
   У структуры объявителя много сходных черт со структурой подвыражений, поскольку в объявителе, как и в подвыражении, допускаются операции косвенного обращения, обращения к функции и получения элемента массива (с тем же порядком применения).
   A8.6.Что означают объявители
   Список объявителей располагается сразу после спецификаторов типа и указателя класса памяти. Главный элемент любого объявителя - это объявляемый им идентификатор; в простейшем случае объявитель из него одного и состоит, что отражено в первой строке продукции грамматики с именемсобственно- объявитель.Спецификаторы класса памяти относятся непосредственно к идентификатору, а его тип зависит от вида объявителя. Объявитель следует воспринимать как утверждение: если в выражении идентификатор появляется в том же контексте, что и в объявителе, то он обозначает объект специфицируемого типа.
   Если соединить спецификаторы объявления, относящиеся к типу (A8.2), и некоторый конкретный объявитель, то объявление примет вид "T D", гдеT -тип, aD -объявитель. Эта запись индуктивно придает тип идентификатору любого объявителя.
   В объявлении T D, гдеD -просто идентификатор, тип идентификатора естьT.
   В объявлении T D, гдеDимеет вид
   ( D1 )
   тип идентификатора вD1тот же, что и вD.Скобки не изменяют тип, но могут повлиять на результаты его "привязки" к идентификаторам в сложных объявителях.
   A8.6.1.Объявители указателей
   В объявления T D, гдеDимеет вид
   *список-квалификаторов-типанеоб D1
   а тип идентификатора объявления T D1 есть "модификатор-типа T",тип идентификатораDесть "модификатор-типа список-квалификаторов-типа указатель на T".Квалификаторы, следующие за *, относятся к самому указателю, а не к объекту, на который он указывает. Рассмотрим, например, объявление
   int *ap[];
   Здесьap[]играет рольD1;объявлениеint ap[]следует расшифровать (см. ниже) как "массив изint":список квалификаторов типа здесь пуст, а модификатор типа есть "массив из".Следовательно, на самом деле объявлениеapгласит: "массив из указателей наint".Вот еще примеры объявлений:
   int i, *pi, *const cpi =&i;
   const int ci = 3, *pci;
   В них объявляются целоеiи указатель на целоеpi.Значение указателяcpiнеизменно;cpiвсегда будет указывать в одно и то же место, даже если значение, на которое он указывает, станет иным. Целоеciесть константа, оно измениться не может (хотя может инициализироваться, как в данном случае). Тип указателяpciпроизносится как "указатель наconst int";сам указатель можно изменить; при этом он будет указывать на другое место, но значение, на которое он будет указывать, с помощьюpciизменить нельзя.
   А8.6.2. Объявители массивов
   В объявления T D, где D имеет вид
   D1 [константное-выражениенеоб]
   и где тип идентификатора объявления T D1 есть "модификатор-типа Т",тип идентификатора D есть "модификатор-типамассив из T". Если константное выражение присутствует, то оно должно быть целочисленным и больше 0. Если константное выражение, специфицирующее количество элементов в массиве, отсутствует, то массив имеет незавершенный тип.
   Массив можно конструировать из объектов арифметического типа, указателей, структур и объединений, а также других массивов (генерируя при этом многомерные массивы). Любой тип, из которого конструируется массив, должен быть завершенным, он не может быть, например, структурой или массивом незавершенного типа. Это значит, что длямногомерного массива пустой может быть только первая размерность. Незавершенный тип массива получает свое завершение либо в другом объявлении этого массива (A10.2),либо при его инициализации (A8.7). Например, запись
   float fa[17], *afp[17];
   объявляет массив из чисел типаfloatи массив из указателей на числа типаfloat.Аналогично
   static int x3d[3][5][7];
   объявляет статический трехмерный массив целых размера 3 x 5 x 7. На самом деле, если быть точными,x3dявляется массивом из трех элементов, каждый из которых есть массив из пяти элементов, содержащих по 7 значений типаint.
   Операция индексирования E1[E2] определена так, что она идентична операции *(E1+E2). Следовательно, несмотря на асимметричность записи, индексирование - коммутативная операция. Учитывая правила преобразования, применяемые для оператора + и массивов (A6.6, A7.1, A7.7), можно сказать, что если E1 - массив, а E2 - целое, то E1[E2] обозначает E2-й элемент массива E1.
   Так, x3d[i][j][k] означает то же самое, что и *(x3d[i][j]+k). Первое подвыражение, x3d[i][j], согласно A7.1, приводится к типу "указатель на массив целых"; по A7.7 сложение включает умножение на размер объекта типаint.Из этих же правил следует, что массивы запоминаются "построчно" (последние индексы меняются чаще) и что первая размерность в объявлении помогает определить количество памяти, занимаемой массивом, однако в вычислении адреса элемента массива участия не принимает.
   А8.6.3. Объявители функций

   В новом способе объявление функции T D, где D имеет вид
   D1 (список-типов-параметров)
   и тип идентификатора объявления T D1 есть "модификатор-типа T",тип идентификатора в D есть "модификатор-типафункция с аргументамисписок-типов- параметров,возвращающая T". Параметры имеют следующий синтаксис:
   список-типов-параметров:
      список-параметров
      список-параметров , ...
   список-параметров:
      объявление-параметра
      список-параметров,объявление-параметра
   объявление-параметра:
      спецификаторы-объявления объявитель
      спецификатор-объявления абстрактный-объявительнеоб
   При новом способе объявления функций список параметров специфицирует их типы, а если функция вообще не имеет параметров, на месте списка типов указывается одно слово -void.Если список типов параметров заканчивается многоточием ",...", то функция может иметь больше аргументов, чем число явно описанных параметров. (См. A7.3.2.)
   Типы параметров, являющихся массивами и функциями, заменяются на указатели в соответствии с правилами преобразования параметров (A10.1). Единственный спецификатор класса памяти, который разрешается использовать в объявлении параметра, - этоregister,однако он игнорируется, если объявитель функции не является заголовком ее определения. Аналогично, если объявители в объявлениях параметров содержат идентификаторы, а объявитель функции не является заголовком определения функции, то эти идентификаторы тотчас же выводятся из текущей области видимости.
   При старом способе объявление функции T D, где D имеет вид
   D1 (список-идентификаторовнеоб)
   и тип идентификатора объявления T D1 есть "модификатор-типаТ", тип идентификатора в D есть "модификатор-типафункция от неспецифицированных аргументов, возвращающая Т". Параметры, если они есть, имеют следующий вид:
   список-идентификаторов:
      идентификатор
      список-идентификаторов,идентификатор
   При старом способе, если объявитель функции не используется в качестве заголовка определения функции (A10.1), список идентификаторов должен отсутствовать. Никакой информации о типах параметров в объявлениях не содержится.
   Например, объявление
   int f(), *fpi(), (*pfi)();
   объявляет функциюf,возвращающую число типаint,функциюfpi,возвращающую указатель на число типаint,и указательpfiна функцию, возвращающую число типаint.Ни для одной функции в объявлении не указаны типы параметров; все функции описаны старым способом.
   Вот как выглядит объявление в новой записи:
   int strcpy(char *dest, const char *source), rand(void);
   Здесьstrcpy -функция с двумя аргументами, возвращающая значение типаint;первый аргумент - указатель на значение типаchar,а второй - указатель на неизменяющееся значение типаchar.Имена параметров играют роль хороших комментариев. Вторая функция,rand,аргументов не имеет и возвращаетint.
   Объявители функций с прототипами параметров - наиболее важное нововведение ANSI-стандарта. В сравнении со старым способом, принятым в первой редакции языка, они позволяют проверять и приводить к нужному типу аргументы во всех вызовах. Следует однако отметить, что их введение привнесло в язык некоторую сумятицу и необходимостьсогласования обеих форм. Чтобы обеспечить совместимость, потребовались некоторые "синтаксические уродства", а именноvoid,для явного указания на отсутствие параметров.
   Многоточие ", ..." применительно к функциям с варьируемым числом аргументов - также новинка, которая вместе со стандартным заголовочным файлом макросов&lt;stdarg.h&gt;формализует неофициально используемый, но официально запрещенный в первой редакции механизм. Указанные способы записи заимствованы из языка C++.
   A8.7.Инициализация
   С помощью иниц-объявителя можно указать начальное значение объявляемого объекта. Инициализатору, представляющему собой выражение или список инициализаторов, заключенный в фигурные скобки, предшествует знак =. Этот список может завершаться запятой; ее назначение сделать форматирование более четким.
   инициализатор:
      выражение-присваивания
       {список-инициализаторов }
       {список-инициализаторов, }
   список-инициализаторов:
      инициализатор
      список-инициализаторов ,инициализатор
   В инициализаторе статического объекта или массива все выражения должны быть константными (A7.19). Если инициализаторauto-иregister-объекта или массива находится в списке, заключенном в фигурных скобки, то входящие в него выражения также должны быть константными. Однако в случае автоматического объекта с одним выражением инициализатор не обязан быть константным выражением, он просто должки иметь соответствующий объекту тип.
   В первой редакции не разрешалась инициализация автоматических структур, объединений и массивов. ANSI-стандарт позволяет это; однако, если инициализатор не может быть представлен одним простым выражением, инициализация может быть выполнена только с помощью константных конструкций.
   Статический объект, инициализация которого явно не указана, инициализируется так, как если бы ему (или его элементам) присваивалась константа 0. Начальное значениеавтоматического объекта, явным образом не инициализированного, не определено.
   Инициализатор указателя или объекта арифметического типа - это одно выражение (возможно, заключенное в фигурные скобки), которое присваивается объекту.
   Инициализатор структуры - это либо выражение того же структурного типа, либо заключенные в фигурные скобки инициализаторы ее элементов, заданные по порядку. Безымянные битовые поля игнорируются и не инициализируются. Если инициализаторов в списке меньше, чем элементов, то оставшиеся элементы инициализируются нулем. Инициализаторов не должно быть больше числа элементов.
   Инициализатор массива - это список инициализаторов его элементов, заключенный в фигурные скобки. Если размер массива не известен, то он считается равным числу инициализаторов, при этом тип его становится завершенным. Если размер массива известен, то число инициализаторов не должно превышать числа его элементов; если инициализаторов меньше, оставшиеся элементы обнуляются.
   Как особый выделен случай инициализации массива символов. Последний можно инициализировать с помощью строкового литерала; символы инициализируют элементы массива в том порядке, как они заданы в строковом литерале. Точно так же, с помощью литерала из расширенного набора символов (A2.6), можно инициализировать массив типаwchar_t.Если размер массива не известен, то он определяется числом символов в строке, включая и завершающий NULL-символ; если размер массива известен, то число символов в строке, не считая завершающего NULL-символа, не должно превышать его размера.
   Инициализатором объединения может быть либо выражение того же типа, либо заключенный в фигурные скобки инициализатор его первого элемента.
   В первой версии языка не позволялось инициализировать объединения. Правило "первого элемента" не отличается изяществом, однако не требует нового синтаксиса. Стандарт ANSI проясняет еще и семантику не инициализируемых явно объединений.
   Введем для структуры и массива обобщенное имя:агрегат.Если агрегат содержит элементы агрегатного типа, то правила инициализации применяются рекурсивно. Фигурные скобки в некоторых случаях инициализации можно опускать. Если инициализатор элемента агрегата, который сам является агрегатом, начинается с левой фигурной скобки, то этот подагрегат инициализируется последующим списком разделенных запятыми инициализаторов; считается ошибкой, если количество инициализаторов подагрегата превышает число его элементов. Если, однако, инициализатор подагрегата не начинается с левой фигурной скобки, то чтобы его инициализировать, нужно отсчитать соответствующее число элементов из списка; при этом остальные элементы инициализируются следующими инициализаторами агрегата, для которого данный подагрегат является частью.
   Например
   int x[] = { 1, 3, 5 };
   объявляет и инициализируетxкак одномерный массив с тремя элементами, поскольку размер не был указан, а список состоит из трех инициализаторов.
   float y[4][3] = {
       { 1, 3, 5 },
       { 2, 4, 6 },
       { 3, 5, 7 },
   };
   представляет собой инициализацию с полным набором фигурных скобок: 1, 3 и 5 инициализируют первую строку в массиве у[0], т. е. y[0][0], у[0][1] и y[0][2]. Аналогично инициализируются следующие две строки: y[1] и y[2]. Инициализаторов не хватило на весь массив, поэтому элементы строки y[3] будут нулевыми. В точности тот же результат был бы достигнут с помощью следующего объявления:
   floatу[4][3] = { 1, 3, 5, 2, 4, 6, 3, 5, 7 };
   Инициализатор дляyначинается с левой фигурной скобки, но для y[0] скобки нет, поэтому из списка будут взяты три элемента. Аналогично по три элемента будут взяты для y[1], а затем и для y[2]. В
   floatу[4][3] = {
       { 1 }, { 2 }, { 3 }, { 4 }
   };
   инициализируется первый столбец матрицыy,все же другие элементы остаются нулевыми.
   Наконец,
   char msg[] = "Синтаксическая ошибка в строке %s\n";
   представляет собой пример массива символов, элементы которого инициализируются с помощью строки; в его размере учитывается и завершающий NULL-символ.
   A8.8.Имена типов
   В ряде случаев возникает потребность в применении имени типа данных (например при явном приведении к типу, в указании типов параметров внутри объявлений функций, в аргументе оператораsizeof).Эта потребность реализуется с помощьюимени типа,определение которого синтаксически почти совпадает с объявлением объекта того же типа. Оно отличается от объявления лишь тем, что не содержит имени объекта.
   имя-типа:
      список-спецификаторов-квалификаторов абстрактный-объявительнеоб
   абстрактный-объявитель:
      указатель
      указательнеобсобственно-абстрактный-объявитель
   собственно-абстрактный-объявитель:
       (абстрактный-объявитель )
      собственно-абстрактный-объявительнеоб[константное-выражениенеоб]
      собственно-абстрактный-объявительнеоб(список-типов-параметровнеоб)
   Можно указать одно-единственное место в абстрактном объявителе, где мог бы оказаться идентификатор, если бы данная конструкция была полноценным объявителем. Именованный тип совпадает с типом этого "невидимого идентификатора". Например
   intint *int *[3]int (*)[]int *()int (*[])(void)
   соответственно обозначают типыint, "указатель наint", "массив из трех указателей наint", "указатель на массив из неизвестного количестваint", "функция неизвестного количества параметров, возвращающая указатель наint", "массив неизвестного количества указателей на функции без параметров, каждая из которых возвращаетint".
   А8.9. Объявлениеtypedef
   Объявления, в которых спецификатор класса памяти естьtypedef,не объявляют объектов - они определяют идентификаторы, представляющие собой имена типов. Эти идентификаторы называютсяtypedef-именами.
   typedef-имя:
      идентификатор
   Объявлениеtypedefприписывает тип каждому имени своего объявителя обычным способом (см. A8.6.). С этого моментаtypedef-имя синтаксически эквивалентно ключевому слову спецификатора типа, обозначающему связанный с ним тип. Например, после
   typedef long Blockno, *Blockptr;
   typedef struct { double r, theta; } Complex;
   допустимы следующие объявления:
   Blockno b;
   extern Blockptr bp;
   Complex z, *zp;
   bпринадлежит типуlong,bp -типу "указатель наlong";z -это структура заданного вида, azp -принадлежит типу "указатель на такую структуру".
   Объявлениеtypedefне вводит новых типов, оно только дает имена типам, которые могли бы быть специфицированы и другим способом. Например,bимеет тот же тип, что и любой другой объект типаlong.
   typedef-имена могут быть перекрыты другими определениями во внутренней области видимости, но при условии, что в них присутствует указание типа. Например
   extern Blockno;
   не переобъявляет Blockno, а вот
   extern int Blockno;
   переобъявляет.
   A8.10.Эквивалентность типов
   Два списка спецификаторов типа эквивалентны, если они содержат одинаковый набор спецификаторов типа с учетом синонимичности названий (например,longиint longсчитаются одинаковыми типами). Структуры, объединения и перечисления с разными тегами считаются разными, а каждое безтеговое объединение, структура или перечисление представляет собой уникальный тип.
   Два типа считаются совпадающими, если их абстрактные объявители (A8.8) после замены всехtypedef-имен их типами и выбрасывания имен параметров функций составят эквивалентные списки спецификаторов типов. При сравнении учитываются размеры массивов и типы параметров функция.
   A9.Инструкции
   За исключением оговоренных случаев инструкции выполняются том порядке, как они написаны. Инструкции не имеют значений и выполняются, чтобы произвести определенные действия. Все виды инструкций можно разбить на несколько групп:
   инструкция:
      помеченная-инструкция
      инструкция-выражение
      составная-инструкция
      инструкция-выбора
      циклическая-инструкция
      инструкция-перехода
   A9.1.Помеченные инструкции
   Инструкции может предшествовать метка.
   помеченная-инструкция:
      идентификатор :инструкция
       caseконстантное-выражение :инструкция
       default :инструкция
   Метка, состоящая из идентификатора, одновременно служит и объявлением этого идентификатора. Единственное назначение идентификатора-метки - указать место перехода дляgoto.Областью видимости идентификатора-метки является текущая функция. Так как метки имеют свое собственное пространство имен, они не "конфликтуют" с другими идентификаторами и не могут быть перекрыты (см. A11.1.).
   case-метки иdefault-метки используются в инструкцииswitch (A9.4).Константное выражение вcaseдолжно быть целочисленным.
   Сами по себе метки не изменяют порядка вычислений.
   A9.2.Инструкция-выражение
   Наиболее употребительный вид инструкции - это инструкция-выражение.
   инструкция-выражение:
      выражениенеоб ;
   Чаще всего инструкция-выражение - это присваивание или вызов функции. Все действия, реализующие побочный эффект выражения, завершаются, прежде чем начинает выполняться следующая инструкция. Если выражение в инструкции опущено, то она называется пустой; пустая инструкция часто используется для обозначения пустого тела циклической инструкции или в качестве места для метки.
   A9.3.Составная инструкция
   Так как в местах, где по синтаксису полагается одна инструкция, иногда возникает необходимость выполнить несколько, предусматривается возможность задания составной инструкции (которую также называют блоком). Тело определения функции есть составная инструкция;
   составная-инструкция:
       {список-объявлений список-инструкцийнеоб }
   список-объявлений:
      объявление
      список-объявлений объявление
   список-инструкций:
      инструкция
      список-инструкций инструкция
   Если идентификатор из списка объявлений находился в области видимости объемлющего блока, то действие внешнего объявления при входе внутрь данного блока приостанавливается (A11.1), а после выхода из него возобновляется. Внутри блока идентификатор может быть объявлен только один раз. Для каждого отдельного пространства имен эти правила действуют независимо (A11); идентификаторы из разных пространств имен всегда различны.
   Инициализация автоматических объектов осуществляется при каждом входе в блок и продолжается по мере продвижения по объявителям. При передаче управления внутрь блока никакие инициализации не выполняются. Инициализации статических объектов осуществляются только один раз перед запуском программы. 
   A9.4.Инструкции выбора
   Инструкции выбора осуществляют отбор одной из нескольких альтернатив, определяющих порядок выполнения инструкций.
   инструкция-выбора:
       if (выражение )инструкция
       if (выражение )инструкция elseинструкция
       switch (выражение )инструкция
   Оба видаif-инструкций содержат выражение, которое должно иметь арифметический тип или тип указателя. Сначала вычисляется выражение со всеми его побочными эффектами, результат сравнивается с 0. В случае несовпадения с 0 выполняется первая подинструкция. В случае совпадения с 0 для второго типаifвыполняется вторая подинструкция. Связанная со словомelseнеоднозначность разрешается тем, что словоelseсоотносят с последней еще не имеющейelse if-инструкцией, расположенной в одном с этимelseблоке и на одном уровне вложенности блоков.
   Инструкцияswitchвызывает передачу управления на одну из нескольких инструкций в зависимости от значения выражения, которое должен иметь целочисленный тип.
   Управляемая с помощьюswitchподинструкция обычно составная. Любая инструкция внутри этой подинструкции может быть помечена одной или несколькимиcase-метками (A9.1). Управляющее выражение подвергается целочисленному повышению (A6.1), аcase-константы приводятся к повышенному типу. После такого преобразования никакие двеcase-константы в одной инструкцииswitchне должны иметь одинаковых значений. Coswitch-инструкцией может быть связано не более однойdefault-метки. Конструкцииswitchдопускается вкладывать друг в друга;caseиdefault-метки относятся к самой внутреннейswitch-инструкции из тех, которые их содержат.
   Инструкцияswitchвыполняется следующим образом. Вычисляется выражение со всеми побочными эффектами, и результат сравнивается с каждойcase-константой. Если одна изcase-констант равна значению выражения, управление переходит на инструкцию с соответствующейcase-меткой. Если ни с одной изcase-констант нет совпадения, управление передается на инструкцию сdefault-меткой, если такая имеется, в противном случае ни одна из подинструкцийswitchне выполняется.
   В первой версии языка требовалось, чтобы выражение иcase-константы вswitchбыли типаint.
   A9.5.Циклические инструкции
   Циклические инструкции специфицируют циклы.
   циклическая-инструкция:
       while (выражение)инструкция
       doинструкция while (выражение)
       for (выражениенеоб ;выражениенеоб ;выражениенеоб )инструкция
   В инструкцияхwhileиdoвыполнение подинструкций повторяется до тех пор, пока значение выражения не станет нулем. Выражение должно иметь арифметический тип или тип указателя. Вwhileвычисление выражения со всеми побочными эффектами и проверка осуществляются перед каждым выполнением инструкции, a вdo -после.
   В инструкцииforпервое выражение вычисляется один раз, тем самым осуществляется инициализация цикла. На тип этого выражения никакие ограничения не накладываются. Второе выражение должно иметь арифметический тип или тип указателя; оно вычисляется перед каждой итерацией. Как только его значение становится равным 0,forпрекращает свою работу. Третье выражение вычисляется после каждой итерации и, следовательно, выполняет повторную инициализацию цикла. Никаких ограничений на его тип нет. Побочные эффекты всех трех выражений заканчиваются по завершении их вычислений. Если подинструкция не содержит в себеcontinue)то
   for (выражение1 ;выражение2 ;выражениеЗ)инструкция
   эквивалентно конструкции
   выражение1;
       while (выражение2) {
          инструкция
          выражениеЗ;
   }
   Любое из трех выражений цикла может быть опущено. Считается, что отсутствие второго выражения равносильно сравнению с нулем ненулевой константы.
   A9.6.Инструкции перехода
   Инструкции перехода осуществляют безусловную передачу управления.
   инструкция-перехода:
       gotoидентификатор;
       continue ;
       break ;
       returnвыражениенеоб;
   Вgoto-инструкции идентификатор должен быть меткой (A9.1), расположенной в текущей функции. Управление передается на помеченную инструкцию.
   Инструкциюcontinueможно располагать только внутри цикла. Она вызывает переход к следующей итерации самого внутреннего содержащего ее цикла. Говоря более точно, для каждой из конструкций
   while (...){
       ...
   contin: ;
   }

   do {
       ...
   contin: ;
   } while (...);

   for (...){
       ...
   contin: ;
   }
   инструкцияcontinue,если она не помещена в еще более внутренний цикл, делает то же самое, что иgoto contin.
   Инструкцияbreakвстречается в циклической или вswitch-инструкции, и только в них. Она завершает работу самой внутренней циклической илиswitch-инструкции, содержащей данную инструкциюbreak,после чего управление переходит к следующей инструкции.
   С помощьюreturnфункция возвращает управление в программу, откуда была вызвана. Если заreturnследует выражение, то его значение возвращается вызвавшей эту функцию программе. Значение выражения приводится к типу так, как если бы оно присваивалось переменной, имеющей тот же тип, что и функция.
   Ситуация, когда "путь" вычислений приводит в конец функции (т. е. на последнюю закрывающую фигурную скобку), равносильна выполнениюreturn-инструкции без выражения. При этом, а также в случае явного заданияreturnбез выражения возвращаемое значение не определено
   А10. Внешние объявления
   То, что подготовлено в качестве ввода для Си-компилятора, называется единицей трансляции. Она состоит из последовательности внешних объявлений, каждое из которых представляет собой либо объявление, либо определение функции.
   единица-трансляции:
      внешнее-объявление
      единица-трансляции внешнее-объявление
   внешнее-объявление:
      определение-функции
      объявление
   Область видимости внешних объявлений простирается до конца единицы трансляции, в которой они объявлены, точно так же, как область видимости объявлений в блоке распространяется до конца этого блока. Синтаксис внешнего объявления не отличается от синтаксиса любого другого объявления за одним исключением: код функции можно определять только с помощью внешнего объявления.
   A10.1.Определение функции

   Определение функции имеет следующий вид:
   определение-функции:
      спецификаторы-объявлениянеобобъявитель список-объявленийнеоб
      составная-инструкция
   Из спецификаторов класса памяти в спецификаторах-объявлениях возможны толькоexternиstatic;различия между последними рассматриваются в A11.2.
   Типом возвращаемого функцией значения может быть арифметический тип, структура, объединение, указатель иvoid,но не "функция" и не "массив". Объявитель в объявлении функции должен явно указывать на то, что описываемый им идентификатор имеет тип "функция", т. е. он должен иметь одну из следующих двух форм (A8.6.3):
   собственно-объявитель (список-типов-параметров )
   собственно-объявитель (список-идентификаторовнеоб)
   гдесобственно-объявительесть идентификатор или идентификатор, заключенный в скобки. Заметим, что тип "функция" посредствомtypedefполучить нельзя.
   Первая форма соответствует определению функции новым способом, для которого характерно объявление параметров в списке-типов-параметров вместе с их типами; за объявителем не должно быть списка-объявлений. Если список-типов-параметров не состоит из одного-единственного словаvoid,показывающего, что параметров у функции нет, то в каждом объявителе в списке-типов-параметров обязан присутствовать идентификатор. Если список-типов-параметров заканчивается знаками ", ...", то вызов функции может иметь аргументов больше, чем параметров; в таком случае, чтобы обращаться к дополнительным аргументам, следует пользоваться механизмом макросаva_argиз заголовочного файла&lt;stdarg.h&gt;,описанного в приложении B. Функции с переменным числом аргументов должны иметь по крайней мере один именованный параметр.
   Вторая форма - определение функции старым способом. Список-идентификаторов содержит имена параметров, а список-объявлений приписывает им типы. В списке- объявлении разрешено объявлять только именованные параметры, инициализация запрещается, и из спецификаторов класса памяти возможен толькоregister.
   И в том и другом способе определения функции мыслится, что все параметры как бы объявлены в самом начале составной инструкции, образующей тело функции, и совпадающие с ними имена здесь объявляться не должны (хотя, как и любые идентификаторы, их можно переобъявить в более внутренних блоках). Объявление параметра "массив изтипа"можно трактовать как "указатель натип",аналогично объявлению параметра объявление "функция, возвращающаятип"можно трактовать как "указатель на функцию, возвращающуютип".В момент вызова функции ее аргументы соответствующим образом преобразуются и присваиваются параметрам (см. A7.3.2).
   Новый способ определения функций введен ANSI-стандартом. Есть также небольшие изменения в операции повышения типа; в первой версии языка параметры типаfloatследовало читать какdouble.Различие междуfloatиdoubleстановилось заметным, лишь когда внутри функции генерировался указатель на параметр.
   Ниже приведен пример определения функции новым способом:
   int max(int a, int b, int c)
   {
       int m;

       m = (a&gt; b) ? a: b;
       return (m&gt;с) ? m : с;
   }
   Здесьint-спецификаторы-объявления; max(int a, int b, int с) - объявитель функции, a { ... } - блок, задающий ее код. Определение старым способом той же функции выглядит следующим образом:
   int max(a, b,с)
   intа, b, с;
   {
       /* ... */
   }
   где max(a, b, c) – объявитель, а int a, b, c - список-объявлений для параметров.
   A10.2.Внешние объявления
   Внешние объявления специфицируют характеристики объектов, функций и других идентификаторов. Термин "внешний" здесь используется, чтобы подчеркнуть тот факт, что объявления расположены вне функций; впрямую с ключевым словомextern ("внешний") он не связан. Класс памяти для объекта с внешним объявлением либо вообще не указывается, либо специфицируется какexternилиstatic.
   В одной единице трансляции для одного идентификатора может содержаться несколько внешних объявлений, если они согласуются друг с другом по типу и способу связи и если для этого идентификатора существует не более одного определения.
   Два объявления объекта или функции считаются согласованными по типу в соответствии с правилами, рассмотренными в A8.10. Кроме того, если объявления отличаются лишь тем, что в одном из них тип структуры, объединения или перечисления незавершен (A8.3), а в другом соответствующий ему тип с тем же тегом завершен, то такие типы считаются согласованными. Если два типа массива (A8.6.2) отличаются лишь тем, что один завершенный, а другой незавершенный, то такие типы также считаются согласованными. Наконец, если один тип специфицирует функцию старым способом, а другой - ту же функцию новым способом (с объявлениями параметров), то такие типы также считаются согласованными.
   Если первое внешнее объявление функции или объекта помечено спецификаторомstatic,то объявленный идентификатор имеетвнутреннюю связь;в противном случае -внешнюю связь.Способы связей обсуждаются в A11.2.
   Внешнее объявление объекта считается определением, если оно имеет инициализатор. Внешнее объявление, в котором нет инициализатора и нет спецификатораextern,считаетсяпробным определением.Если в единице трансляции появится определение объекта, то все его пробные определения просто станут избыточными объявлениями. Если никакого определения для этого объекта в единице трансляции не обнаружится, то все его пробные определения будут трактоваться как одно определение с инициализатором 0.
   Каждый объект должен иметь ровно одно определение. Для объекта с внутренней связью это правило относится к каждой отдельной единице трансляции, поскольку объектыс внутренними связями в каждой единице уникальны. В случае объектов с внешними связями указанное правило действует в отношении всей программы в целом.
   Хотя правило одного определения формулируется несколько иначе, чем в первой версии языка, по существу оно совпадает с прежним. Некоторые реализации его ослабляют,более широко трактуя понятие пробного определения. В другом варианте указанного правила, который распространен в системах UNIX и признан как общепринятое расширение стандарта, все пробные определения объектов с внешними связями из всех транслируемых единиц программы рассматриваются вместе, а не отдельно в каждой единице. Если где-то в программе обнаруживается определение, то пробные определения становятся просто объявлениями, но, если никакого определения не встретилось, то все пробные определения становятся одним-единственным определением с инициализатором 0.
   A11.Область видимости и связи
   Каждый раз компилировать всю программу целиком нет необходимости. Исходный текст можно хранить в нескольких файлах, представляющих собой единицы трансляции. Ранее скомпилированные программы могут загружаться из библиотек. Связи между функциями программы могут осуществляться через вызовы и внешние данные.
   Следовательно, существуют два вида областей видимости: первая - этолексическая областьидентификатора: т. е. область в тексте программы, где имеют смысл все его характеристики; вторая область - это область, ассоциируемая с объектами и функциями, имеющими внешние связи, устанавливаемые между идентификаторами из раздельно компилируемых единиц трансляции.
   A11.1.Лексическая область видимости

   Каждый идентификатор попадает в одно из нескольких пространств имен. Эти пространства никак не связаны друг с другом. Один и тот же идентификатор может использоваться в разных смыслах даже в одной области видимости, если он принадлежит разным пространствам имен. Ниже через точку с запятой перечислены классы объектов, имена которых представляют собой отдельные независимые пространства: объекты, функции,typedef-имена иenum-константы; метки инструкций; теги структур, объединений и перечислений; элементы каждой отдельной структуры или объединения.
   Сформулированные правила несколько отличаются от прежних, описанных в первом издании. Метки инструкций не имели раньше собственного пространства; теги структур и теги объединений (а в некоторых реализациях и теги перечислений) имели отдельные пространства. Размещение тегов структур, объединений и перечислений в одном общем пространстве - это дополнительное ограничение, которого раньше не было. Наиболее существенное отклонение от первой редакции в том, что каждая отдельная структура(или объединение) создает свое собственное пространство имен для своих элементов. Таким образом, одно и то же имя может использоваться в нескольких различных структурах. Это правило широко применяется уже несколько лет.
   Лексическая область видимости идентификатора объекта (или функции), объявленного во внешнем объявлении, начинается с места, где заканчивается его объявитель, и простирается до конца единицы трансляции, в которой он объявлен. Область видимости параметра в определении функции начинается с начала блока, представляющего собой тело функции, и распространяется на всю функцию; область видимости параметра в описании функции заканчивается в конце этого описания. Область видимости идентификатора, объявленного в начале блока, начинается от места, где заканчивается его объявитель, и продолжается до конца этого блока. Областью видимости метки является всяфункция, где эта метка встречается. Область видимости тега структуры, объединения или перечисления начинается от его появления в спецификаторе типа и продолжается до конца единицы трансляции для объявления внешнего уровня и до конца блока для объявления внутри функции.
   Если идентификатор явно объявлен в начале блока (в том числе тела функции), то любое объявление того же идентификатора, находящееся снаружи этого блока, временно перестает действовать вплоть до конца блока.
   A11.2.Связи
   Если встречается несколько объявлений, имеющих одинаковый идентификатор и описывающих объект (или функцию), то все эти объявления в случае внешней связи относятся к одному объекту (функции) - уникальному для всей программы; если же связь внутренняя, то свойство уникальности распространяется только на единицу трансляции.
   Как говорилось в A10.2, если первое внешнее объявление имеет спецификаторstatic,то оно описывает идентификатор с внутренней связью, если такого спецификатора нет, то - с внешней связью. Если объявление находится внутри блока и не содержитextern,то соответствующий идентификатор ни с чем не связан и уникален для данной функции. Если объявление содержитexternи блок находится к области видимости внешнего объявления этого идентификатора, то последний имеет ту же связь и относится к тому же объекту (функции). Однако если ни одного внешнего объявления для этого идентификатора нет, то он имеет внешнюю связь.
   A12.Препроцессирование
   Препроцессор выполняет макроподстановку, условную компиляцию, включение именованных файлов. Строки, начинающиеся со знака # (перед которым возможны символы-разделители), устанавливают связь с препроцессором. Их синтаксис не зависит от остальной части языка; они могут появляться где угодно и оказывать влияние (независимо от области видимости) вплоть до конца транслируемой единицы. Границы строк принимаются во внимание: каждая строка анализируется отдельно (однако есть возможность "склеивать" строки, см. A12.2). Лексемами для препроцессора являются все лексемы языка и последовательности символов, задающие имена файлов, как, например, в директиве #include (A12.4). Кроме того, любой символ, неопределенный каким-либо другим способом, воспринимается как лексема. Влияние символов-разделителей, отличающихся от пробелов и горизонтальных табуляций, внутри строк препроцессора не определено.
   Само препроцессирование проистекает в нескольких логически последовательных фазах. В отдельных реализациях некоторые фазы объединены.
   1.Трехзнаковые последовательности, описанные в A12.1, заменяются их эквивалентами. Между строками вставляются символы новой строки, если того требует операционная система.
   2. Выбрасываются пары символов, состоящие из обратной наклонной черты с последующим символом новой строки; тем самым осуществляется "склеивание" строк (A12.2).
   3.Программа разбивается на лексемы, разделенные символами-разделителями. Комментарии заменяются единичными пробелами. Затем выполняются директивы препроцессора и макроподстановки (A12.3-A12.10).
   4. Эскейп-последовательности в символьных константах и строковых литералах (A2.5.2, A2.6) заменяются на символы, которые они обозначают. Соседние строковые литералы конкатенируются.
   5. Результат транслируется. Затем устанавливаются связи с другими программами и библиотеками посредством сбора необходимых программ и данных и соединения ссылок на внешние функции и объекты с их определениями.
   A12.1.Трехзнаковые последовательности
   Множество символов, из которых набираются исходные Си-программы, основано на семибитовом ASCII-коде. Однако он шире, чем инвариантный код символов ISO 646-1983 (ISO 646-1983 Invariant Code Set). Чтобы дать возможность пользоваться сокращенным набором символов, все указанные ниже трехзнаковые последовательности заменяются на соответствующие им единичные символы. Замена осуществляется до любой иной обработки.

   ??=    #
   ??(    [
   ??&lt;    {
   ??/    \
   ??)    ]
   ??&gt;    }
   ??'    ^
   ??!    |
   ??-    ~
   Никакие другие замены, кроме указанных, не делаются.
   Трехзнаковые последовательности введены ANSI-стандартом.
   A12.2.Склеивание строк
   Строка, заканчивающаяся обратной наклонной чертой, соединяется со следующей, поскольку символ \ и следующий за ним символ новой строки выбрасываются. Это делаетсяперед "разбиением" текста на лексемы.
   А12.3. Макроопределение и макрорасширение

   Управляющая строка вида
   #defineидентификатор последовательность-лексем
   заставляет препроцессор заменятьидентификаторнапоследовательность-лексем;символы-разделители в начале и в конце последовательности лексем выбрасываются. Повторная строка#defineс тем же идентификатором считается ошибкой, если последовательности лексем неидентичны (несовпадения в символах-разделителях при сравнении во внимание не принимаются). Строка вида
   #defineидентификатор(список-идентификаторов)последовательность-лексем
   где между первым идентификатором и знаком ( не должно быть ни одного символа-разделителя, представляет собой макроопределение с параметрами, задаваемыми списком идентификаторов. Как и в первом варианте, символы-разделители в начале и в конце последовательности лексем выбрасываются, и макрос может быть повторно определен только с тем же списком параметров и с той же последовательностью лексем. Управляющая строка вида
   #undefидентификатор
   предписывает препроцессору "забыть" определение, данное идентификатору. Применение#undefк неизвестному идентификатору ошибкой не считается.
   Если макроопределение было задано вторым способом, то текстовая последовательность, состоящая из его идентификатора, возможно, со следующими за ним символами-разделителями, знака (, списка лексем, разделенных запятыми, и знака ), представляет собой вызов макроса. Аргументами вызова макроса являются лексемы, разделенные запятыми (запятые, "закрытые" кавычками или вложенными скобками, в разделении аргументов не участвуют). Аргументы при их выделении макрорасширениям не подвергаются. Количество аргументов в вызове макроса должно соответствовать количеству параметров макроопределения. После выделения аргументов окружающие их символы-разделители выбрасываются. Затем в замещающей последовательности лексем макроса идентификаторы-параметры (если они не закавычены) заменяются на соответствующие им аргументы.Если в замещающей последовательности перед параметром не стоит знак # и ни перед ним, ни после него нет знака ##, то лексемы аргумента проверяются: не содержат ли онив себе макровызова, и если содержат, то прежде чем аргумент будет подставлен, производится соответствующее ему макрорасширение.
   На процесс подстановки влияют два специальных оператора. Первый -это оператор #, который ставится перед параметром. Он требует, чтобы подставляемый вместо параметра и знака # (перед ним) текст был заключен в двойные кавычки. При этом в строковых литералах и символьных константах аргумента перед каждой двойной кавычкой " (включая и обрамляющие строки), а также перед каждой обратной наклонной чертой \ вставляется \.
   Второй оператор записывается как ##. Если последовательность лексем в любого вида макроопределении содержит оператор ##, то сразу после подстановки параметров он вместе с окружающими его символами-разделителями выбрасывается, благодаря чему "склеиваются" соседние лексемы, образуя тем самым новую лексему. Результат не определен при получении неправильных лексем или когда генерируемый текст зависит от порядка применения операторов ##. Кроме того, ## не может стоять ни в начале, ни в конце замещающей последовательности лексем.
   В макросах обоих видов замещающая последовательность лексем повторно просматривается на предмет обнаружения там новыхdefine-имен. Однако, если некоторый идентификатор уже был заменен в данном расширении, повторное появление такого идентификатора не вызовет его замены.
   Если полученное расширение начинается со знака #, оно не будет воспринято как директива препроцессора.
   В ANSI-стандарте процесс макрорасширения описан более точно, чем в первом издании книги. Наиболее важные изменения касаются введения операторов # и ##, которые предоставляют возможность осуществлять расширения внутри строк и конкатенацию лексем. Некоторые из новых правил, особенно касающиеся конкатенации, могут показаться несколько странными. (См. приведенные ниже примеры.)
   Описанные возможности можно использовать для показа смысловой сущности констант, как, например, в
   #define TABSIZE 100
   int table[TABSIZE];
   Определение
   #define ABSDIFF(a,b) ((a)&gt;(b) ? (a)-(b) : (b)-(a))
   задает макрос, возвращающий абсолютное значение разности его аргументов. В отличие от функции, делающей то же самое, аргументы и возвращаемое значение здесь могутиметь любой арифметический тип и даже быть указателями. Кроме того, аргументы, каждый из которых может иметь побочный эффект, вычисляются дважды: один раз - при проверке, другой раз - при вычислении результата.
   Если имеется определение
   #define tempfile(dir) #dir "/%s"
   то макровызовtempfile(/usr/tmp)даст в результате
   "/usr/tmp" "/%s"
   Далее эти две строки превратятся в одну строку. По макросу
   #define cat(x,y) x ## y
   вызовcat(var, 123)сгенерируетvar123.Однакоcat (cat (1,2),3)не даст желаемого, так как оператор ## воспрепятствует получению правильных аргументов для внешнего вызоваcat.В результате будет выдана следующая цепочка лексем:
   cat ( 1 , 2 )3
   где )3 (результат "склеивания" последней лексемы первого аргумента с первой лексемой второго аргумента) не является правильной лексемой. Если второй уровень макроопределения задан в виде
   #define xcat(x,y) cat(x,y)
   то никаких коллизий здесь не возникает;
   xcat(хсat(1, 2), 3)
   в итоге даст 123, поскольку самxcatне использует оператора ##.
   Аналогично сработает и ABSDIFF(ABSDIFF(a, b), c), и мы получим правильный результат.
   A12.4.Включение файла
   Управляющая строка
   #include&lt;имя-файла&gt;
   заменяется на содержимое файла с именемимя-файла.Среди символов, составляющихимя-файла,не должно быть знака&gt;и символа новой строки. Результат не определен, еслиимя-файласодержит любой из символов ", ', \ или пару символов /*. Порядок поиска указанного файла зависит от реализации.
   Подобным же образом выполняется управляющая строка
   #include "имя-файла"
   Сначала поиск осуществляется по тем же правилам, по каким компилятор ищет первоначальный исходный файл (механизм этого поиска зависит от реализации), а в случае неудачи осуществляется методом поиска, принятым в #include первого типа. Результат остается неопределенным, если имя файла содержит ", \ или /*; использование знака&gt;разрешается.
   Наконец, директива
   #includeпоследовательность-лексем
   не совпадающая ни с одной из предыдущих форм, рассматриваетпоследовательность лексемкак текст, который в результате всех макроподстановок должен дать#include&lt;...&gt;или#include "...".Сгенерированная таким образом директива далее будет интерпретироваться в соответствии с полученной формой.
   Файлы, вставляемые с помощью#include,сами могут содержать в себе директивы#include.
   A12.5.Условная компиляция
   Части программы могут компилироваться условно, если они оформлены в соответствии со следующим схематично изображенным синтаксисом:
   условная - конструкция -препроцессора:
      if-строка текст elif-части else-частьнеоб #endif
   if-строка:
       #ifконстантное-выражение
       #ifdefидентификатор
       #ifndefидентификатор
   elif-части:
      elif-строка текст
      elif-частинеоб
   elif-строка:
       #elifконстантное-выражение
   else-часть:
      else-строка текст
   else-строка:
       #else
   Каждая из директив (if-строка,elif-строка,else-строка и#endif)записывается на отдельной строке. Константные выражения в#ifи последующих строках#elifвычисляются по порядку, пока не обнаружится выражение с ненулевым (истинным) значением; текст, следующий за строкой с нулевым значением, выбрасывается. Текст, расположенный за директивой с ненулевым значением, обрабатывается обычным образом. Под словом "текст"здесь имеется в виду любая последовательность строк, включая строки препроцессора, которые не являются частью условной структуры; текст может быть и пустым. Если строка#ifили#elifс ненулевым значением выражения найдена и ее текст обработан, то последующие строки#elifи#elseвместе со своими текстами выбрасываются. Если все выражения имеют нулевые значения и присутствует строка#else,то следующий за ней текст обрабатывается обычным образом. Тексты "неактивных" ветвей условных конструкций, за исключением тех, которые заведуют вложенностью условных конструкций, игнорируются.
   Константные выражения в#ifи#elifявляются объектами для обычной макроподстановки. Более того, прежде чем просматривать выражения вида
   definedидентификатор
   и
   defined (идентификатор )
   на предмет наличия в них макровызова, они заменяются на 1L или 0L в зависимости от того, был или не был определен препроцессором указанный в них идентификатор. Все идентификаторы, оставшиеся после макрорасширения, заменяются на 0L. Наконец, предполагается, что любая целая константа всегда имеет суффикс L, т. е. вся арифметика имеет дело с операндами только типаlongилиunsigned long.
   Константное выражение (A7.19) здесь используется с ограничениями: оно должно быть целочисленным, не может содержать в себе перечислимых констант, преобразований типа и операторовsizeof.
   Управляющие строки
   #ifdefидентификатор
   #ifndefидентификатор
   эквивалентны соответственно строкам
   #if definedидентификатор
   #if !definedидентификатор
   Строки#elifне было в первой версии языка, хотя она и использовалась в некоторых препроцессорах. Оператор препроцессораdefined -также новый.
   A12.6.Нумерация строк
   Для удобства работы с другими препроцессорами, генерирующими Си-программы, можно использовать одну из следующих директив:
   #lineконстанта "имя-файла"
   #lineконстанта
   Эти директивы предписывают компилятору считать, что указанные десятичное целое и идентификатор являются номером следующей строки и именем текущего файла соответственно. Если имя файла отсутствует, то ранее запомненное имя не изменяется. Расширения макровызовов в директиве#lineвыполняются до интерпретации последней.

   A12.7.Генерация сообщения об ошибке

   Строка препроцессора вида
   #errorпоследовательность-лексемнеоб
   приказывает ему выдать диагностическое сообщение, включающее заданную последовательность лексем.
   A12.8.Прагма
   Управляющая строка вида
   #pragmaпоследовательность-лексемнеоб
   призывает препроцессор выполнить зависящие от реализации действия. Неопознанная прагма игнорируется.
   A12.9.Пустая директива
   Строка препроцессора вида
   #
   не вызывает никаких действий.
   A12.10.Заранее определенные имена
   Препроцессор "понимает" несколько заранее определенных идентификаторов; их он заменяет специальной информацией. Эти идентификаторы (и оператор препроцессораdefinedв том числе) нельзя повторно переопределять, к ним нельзя также применять директиву#undef.Это следующие идентификаторы:
   __LINE__Номер текущей строки исходного текста, десятичная константа.
   __FILE__Имя компилируемого файла, строка.
   __DATE__Дата компиляции в виде "MMM DD YYYY",строка.
   __TIME__Время компиляции в виде "hh:mm:ss", строка.
   __STDC__Константа 1. Предполагается, что этот идентификатор определен как 1
            только в тех реализациях, которые следуют стандарту.
   Строки#errorи#pragmaвпервые введены ANSI-стандартом. Заранее определенные макросы препроцессора также до сих пор не описывались, хотя и использовались в некоторых реализациях.
   A13.Грамматика
   Ниже приведены грамматические правила, которые мы уже рассматривали в данном приложении. Они имеют то же содержание, но даны в ином порядке.
   Здесь не приводятся определения следующих символов-терминов:целая-константа,символьная-константа,константа-с-плавающей-точкой,идентификатор,строкаиконстанта-перечисление.Слова, набранные обычным латинским шрифтом (не курсивом), и знаки рассматриваются как символы-термины и используются точно в том виде, как записаны. Данную грамматику можно механически трансформировать в текст, понятный системе автоматической генерации грамматического распознавателя. Для этого помимо добавления некоторых синтаксических пометок, предназначенных для указания альтернативных продукций, потребуется расшифровка конструкции со словами "один из" и дублирование каждой продукции, использующей символ с индексомнеоб.,причем один вариант продукции должен быть написан с этим символом, а другой - без него. С одним изменением, а именно - удалением продукцииtypedef-имя:идентификатори объявлениемtypedef-именисимволом-термином, данная грамматика будет понятна генератору грамматического распознавателя YACC. Ей присуще лишь одно противоречие, вызываемое неоднозначностьюконструкцииif-else.
   единица–трансляции:
      внешнее-объявление
      единица-трансляции внешнее-объявление
   внешнее-объявление:
      определение-функции
      объявление
   определение функции:
      спецификаторы-объявлениянеобобъявитель
      список-объявленийнеобсоставная-инструкция
   объявление:
      спецификаторы-объявления список-инициализаторов-объявителейнеоб
   список-объявлений:
      объявление
      список-объявлений объявление
   спецификаторы-объявления:
      спецификатор-класса-памяти спецификаторы-объявлениянеоб
      спецификатор-типа спецификаторы-объявлениянеоб
      квалификатор-типа спецификаторы-объявлениянеоб
   спецификатор-класса-памяти:один из
       auto     register     static     extern     typedef
   спецификатор-типа:один из
       void char short int long float double signed unsigned
      спецификатор-структуры-или-объединения
      спецификатор-перечисления
      typedef-имя
   квалификатор-типа:один из
       const    volatile
   спецификатор-структуры-или-объединения:
      структуры-или-объединения-идентификаторнеоб {список-объявлений-структуры }
      структуры-или-объединения идентификатор
   структура-или-объединение:одно из
       struct   union
   список-объявлений-структуры:
      объявление-структуры
      список-объявлений-структуры объявление-структуры
   список-объявителей-ииициализаторов:
      объявитель-инициализатор
      список-объявителей-инициализаторов ,объявитель-инициализатор
   объявитель-инициализатор:
       объявитель
      объявитель =инициализатор
   объявление-структуры:
      список-спецификаторов-квалификаторов список-объявителей-структуры
   список-спецификаторов-квалификаторов:
      спецификатор-типа список-спецификаторов-квалификаторовнеоб
      квалификатор-типа список-спецификаторов-квалификаторовнеоб
   список-структуры-объявителей:
      структуры–объявитель
      список-структуры-объявителей ,структуры-объявитель
   структуры-объявитель:
      объявитель
      объявительнеоб :константное-выражение
   спецификатор-перечисления:
       enumидентификаторнеоб {список-перечислителей }
       enumидентификатор
   список-перечислителей:
      перечислитель
      список-перечислителей перечислитель
   перечислитель:
      идентификатор
      указательнеобсобственно-объявитель
   собственно-объявитель:
      идентификатор
       (объявитель )
      собственно-объявитель [константное-выражениенеоб ]
      собственно-объявитель (список-типов-параметров )
      собственно-объявитель (список-идентификаторовнеоб )
   указатель:
       *список~квалификаторов-типанеоб
       *список-квалификаторов-типанеобуказатель
   список-квалификаторов-типа:
      квалификатор-типа
      список-квалификаторов-типа квалификатор-типа
   список-типов-параметров:
      список-параметров
      список-параметров , ...
   список-параметров:
      объявление-параметра
      список-параметров ,объявление-параметра
   объявление-параметра:
      спецификаторы-объявления объявитель
      спецификаторы-объявления абстрактный-объявительнеоб
   список-идентификаторов:
      идентификатор
      список-идентификаторов ,идентификатор
   инициализатор:
      выражение-присваивания
       {список-инициализаторов }
       {список-инициализаторов, }
   список-инициализаторов:
      инициализатор
      список-инициализаторов ,инициализатор
   имя-типа:
      список-спецификаторое-квалификаторов абстрактный-объявительнеоб
   абстрактный-объявитель:
      указатель
      указательнеобсобственно-абстрактный-объявитель
   собственно-абстрактный-объявитель:
       (абстрактный-объявитель )
      собственно-абстрактный-объявительнеоб [константное-выражениенеоб]
      собственно-абстрактный-объявительнеоб (список-типов-параметровнеоб)
   typedef-имя:
      идентификатор
   инструкция:
      помеченная-инструкция
      инструкция–выражение
      составная-инструкция
      инструкция-выбора
      циклическая-инструкция
      инструкция-перехода
   помеченная-инструкция:
      идентификатор :инструкция
       caseконстантное-выражение :инструкция
       default :инструкция
   инструкция-выражение:
      выражениенеоб;
   составная-инструкция:
       (список-объявленийнеобсписок-инструкцийнеоб)
   список-инструкций:
      инструкция
      список-инструкций инструкция
   инструкция-выбора:
       if (выражение )инструкция
       if (выражение )инструкция elseинструкция
       switch (выражение )инструкция
   циклическая-инструкция:
       while (выражение )инструкция
       doинструкция while (выражение )
       returnвыражениенеоб;
   выражение:
      выражение-присваивания
      выражение ,выражение-присваивания
   выражение-присваивания:
      условное-выражение
      унарное-выражение оператор-присваивания выражение-присваивания
   оператор-присваивания:один из
       =   *=   /=   %=   +=   -=  &lt;&lt;=  &gt;&gt;=  &=   ^=   |=
   условное-выражение:
      логическое-ИЛИ-выражение
      логическое-ИЛИ-выражение ?выражение :условное-выражение
   константное-выражение:
      условное-выражение
   логическое-ИЛИ-выражение:
      логическое-И-выражение
      логическое-ИЛИ-выражение ||логическое-И-выражение
   логическое-И-выражение:
      ИЛИ-выражение
      логическое-И-выражение&&ИЛИ-выражение
   ИЛИ-выражение:
      исключающее-ИЛИ-выражение
      ИЛИ-выражение |исключающее-ИЛИ-выражение
   исключающее-ИЛИ-выражение:
      И-выражение
      исключающее-ИЛИ-выражение ^И-выражение
   И-выражение:
      выражение-равенства
      И-выражение&выражение-равенства
   выражение-равенства:
      выражение-отношения
      выражение-равенства ==выражение-отношения
      выражение-равенства !=выражение-отношения
   выражение-отношения:
      сдвиговое-выражение
      выражение-отношения&lt;сдвиговое-выражение
      выражение-отношения&gt;сдвиговое-выражение
      выражение-отношения&lt;=сдвиговое-выражение
      выражение-отношения&gt;=сдвиговое-выражение
   сдвиговое-выражение:
      аддитивное-выражение
      сдвиговое-выражение&gt;&gt;аддитивное-выражение
      сдвиговое-выражение&lt;&lt;аддитивное-выражение
   аддитивное-выражение:
      мультипликативное-выражение
      аддитивное-выражение +мультипликативное-выражение
      аддитивное-выражение -мультипликативное-выражение
   мультипликативное-выражение:
      выражение-приведенное-к-типу
      мультипликативное-выражение *выражение-приведенное-к-типу
      мультипликативное-выражение /выражение-приведенное-к-типу
      мультипликативное-выражение %выражение-приведенное-к-типу
   выражение-приведенное-к-типу:
      унарное-выражение
       (имя-типа )выражение-приведенное-к-типу
   унарное-выражение:
      постфиксное –выражение
       ++унарное-выражение
       --унарное-выражение
      унарный-оператор выражение-приведенное-к-типу
       sizeofунарное-выражение
       sizeof(имя-типа )
   унарный-оператор:один из
      &   *   +   -   ~   !
   постфиксное-выражение:
      первичное-выражение
      постфиксное-выражение [выражение ]
      постфиксное-выражение (список-аргументов-выраженийнеоб )
      постфиксное-выражение ,идентификатор
      постфиксное-выражение -&gt;идентификатор
      постфиксное-выражение ++
      постфиксное-выражение --
   первичное -выражение:
      идентификатор
      константа
      строка
       (выражение )
   список-аргументов-выражений:
      выражение-присваивания
      список-аргументов-выражений ,выражение-присваивания
   константа:
      целая-константа
      символьная-константа
      константа-с-плавающей-точкой
      константа-перечисление
   Ниже приводится грамматика языка препроцессора в виде перечня структур управляющих строк. Для механического получения программы грамматического разбора она не годится. Грамматика включает символтекст,который означает текст обычной программы, безусловные управляющие строки препроцессора и его законченные условные конструкции.
   управляющая-строка:
       #defineидентификатор последовательность-лексем
       #defineидентификатор (идентификатор, ...,идентификатор)последовательность-лексем
       #undefидентификатор
       #include&lt;имя-файла&gt;
       #include "имя-файла"
       #includeпоследовательность-лексем
       #lineконстанта "идентификатор"
       #lineконстанта
       #errorпоследовательность-лексемнеоб
       #pragmaпоследовательность-лексемнеоб
       #
      условная-конструкция-препроцессора
   условная-конструкция-препроцессора:
      if-строка текст elif-части else-частьнеоб #endif
   if-строка:
       #ifконстантное-выражение
       #ifdefидентификатор
       #ifndefидентификатор
   elif-части:
      elif-строка текст
      elif-частинеоб
   elif-строка:
       #elifконстантное-выражение
   else-часть:
      else-строка текст
   else-строка:
       #else
   Приложение B. Стандартная библиотека
   Настоящее приложение представляет собой краткое изложение библиотеки, утвержденной в качестве ANSI-стандарта. Сама по себе библиотека не является частью языка, однако, заложенный в ней набор функций, а также определений типов и макросов составляет системную среду, поддерживающую стандарт Си. Мы не приводим здесь несколько функций с ограниченной областью применения – те, которые легко синтезируются из других функций, а также опускаем все то, что касается многобайтовых символов и специфики, обусловленной языком, национальными особенностями и культурой.
   Функции, типы и макросы объявляются в следующих стандартных заголовочных файлах:
   &lt;assert.h&gt;
   &lt;ctype.h&gt;
   &lt;errno.h&gt;
   &lt;float.h&gt;
   &lt;limits.h&gt;
   &lt;locale.h&gt;
   &lt;math.h&gt;
   &lt;setjmp.h&gt;
   &lt;signal.h&gt;
   &lt;stdarg.h&gt;
   &lt;stddef.h&gt;
   &lt;stdio.h&gt;
   &lt;stdlib.h&gt;
   &lt;string.h&gt;
   &lt;time.h&gt;
   Доступ к заголовочному файлу осуществляется с помощью строки препроцессора
   #include&lt;заголовочный файл&gt;
   Заголовочные файлы можно включать в любом порядке и сколько угодно раз. Строка#includeне должна быть внутри внешнего объявления или определения и должна встретиться раньше, чем что-нибудь из включаемого заголовочного файла будет востребовано. В конкретной реализации заголовочный файл может и не быть исходным файлом.
   Внешние идентификаторы, начинающиеся со знака подчеркивания, а также все другие идентификаторы, начинающиеся с двух знаков подчеркивания или с подчеркивания и заглавной буквы, зарезервированы для использования в библиотеке.
   B1.Ввод-вывод: ‹stdio.h› 
   Определенные в&lt;stdio.h&gt;функции ввода-вывода, а также типы и макросы составляют приблизительно одну треть библиотеки.
   Поток -это источник или получатель данных; его можно связать с диском или с каким-то другим внешним устройством. Библиотека поддерживает два вида потоков:текстовыйибинарный,хотя на некоторых системах, в частности в UNIXe, они не различаются.Текстовый поток -это последовательность строк; каждая строка имеет нуль или более символов и заканчивается символом '\n'. Операционная среда может потребовать коррекции текстовогопотока (например, перевода '\n' в символы возврат-каретки и перевод-строки).
   Бинарный поток -это последовательность непреобразованных байтов, представляющих собой некоторые промежуточные данные, которые обладают тем свойством, что если их записать, а затем прочесть той же системой ввода- вывода, то мы получим информацию, совпадающую с исходной.
   Поток соединяется с файлом или устройством посредством егооткрытия,указанная связь разрывается путемзакрытияпотока. Открытие файла возвращает указатель на объект типаFILE,который содержит всю информацию, необходимую для управления этим потоком. Если не возникает двусмысленности, мы будем пользоваться терминами "файловый указатель"и "поток" как равнозначными.
   Когда программа начинает работу, уже открыты три потока:stdin,stdoutиstderr.
   B1.1.Операции над файлами
   Ниже перечислены функции, оперирующие с файлами. Типsize_t -беззнаковый целочисленный тип, используемый для описания результата оператораsizeof.
   FILE *fopen(const char *filename, const char *mode);
   fopenоткрывает файл с заданным именем и возвращает поток или NULL, если попытка открытия оказалась неудачной. Режимmodeдопускает следующие значения:"r"текстовый файл открывается для чтения (отread (англ.) - читать);"w"текстовый файл создается для записи; старое содержимое (если оно было) выбрасывается (отwrite (англ.) - писать);"а"текстовый файл открывается или создается для записи в конец файла (отappend (англ.) - добавлять);"r+"текстовый файл открывается для исправления (т. е. для чтения и для записи);"w+"текстовый файл создается для исправления; старое содержимое (если оно было) выбрасывается;"a+"текстовый файл открывается или создается для исправления уже существующей информации и добавления новой в конец файла.
   Режим "исправления" позволяет читать и писать в один и тот же файл; при переходах от операций чтения к операциям записи и обратно должны осуществляться обращения кfflushили к функции позиционирования файла. Если указатель режима дополнить буквойb (например "rb" или "w+b"), то это будет означать, что файл бинарный. Ограничение на длину имени файла задано константой FILENAME_MAX. Константа FOPEN_MAX ограничивает число одновременно открытых файлов.
   FILE *freopen(const char *filename, const char *mode, FILE *stream);
   freopenоткрывает файл с указанным режимом и связывает его с потокомstream.Она возвращаетstreamили, в случае ошибки, NULL. Обычноfreopenиспользуется для замены файлов, связанных сstdin,stdoutилиstderr,другими файлами.
   int fflush(FILE *stream);
   Применяемая к потоку вывода функцияfflushпроизводит дозапись всех оставшихся в буфере (еще не записанных) данных, для потока ввода эта функция не определена. Возвращает EOF в случае возникшей при записи ошибки или нуль в противном случае. Обращение видаfflush(NULL)выполняет указанные операции для всех потоков вывода.
   int fclose(FILE *stream);
   fсloseпроизводит дозапись еще не записанных буферизованных данных, сбрасывает несчитанный буферизованный ввод, освобождает все автоматически запрошенные буфера, после чего закрывает поток. Возвращает EOF в случае ошибки и нуль в противном случае.
   int remove(const char *filename);
   removeудаляет файл с указанным именем; последующая попытка открыть файл с этим именем вызовет ошибку. Возвращает ненулевое значение в случае неудачной попытки.
   int rename(const char *oldname, const char *newname);
   renameзаменяет имя файла; возвращает ненулевое значение в случае, если попытка изменить имя оказалась неудачной. Первый параметр задает старое имя, второй - новое.
   FILE *tmpfile(void);
   tmpfileсоздает временный файл с режимом доступа "wb+", который автоматически удаляется при его закрытии или обычном завершении программой своей работы. Эта функция возвращает поток или, если не смогла создать файл, NULL.
   char *tmpnam(char s[L_tmpnam]);
   tmpnam(NULL)создает строку, не совпадающую ни с одним из имен существующих файлов, и возвращает указатель на внутренний статический массив.tmpnam(s)запоминает строку вsи возвращает ее в качестве значения функции; длинаsдолжна быть не менееL_tmpnam.При каждом вызовеtmpnamгенерируется новое имя; при этом гарантируется не более TMPMAX различных имен за один сеанс работы программы. Заметим, чтоtmpnamсоздает имя, а не файл.
   int setvbuf(FILE *stream, char *buf, int mode, size_t size);
   setvbufуправляет буферизацией потока; к ней следует обращаться прежде, чем будет выполняться чтение, запись или какая-либо другая операция,modeсо значением_IOFBFвызывает полную буферизацию, с_IOLBF - "построчную" буферизацию текстового файла, amodeсо значением_IONBFотменяет всякую буферизацию. Если параметрbufне есть NULL, то его значение - указатель на буфер, в противном случае под буфер будет запрашиваться память. Параметрsizeзадает размер буфера. Функцияsetvbufв случае ошибки выдает ненулевое значение.
   void setbuf(FILE *stream, char *buf);
   Еслиbufесть NULL, то для потокаstreamбуферизация выключается. В противном случае вызовsetbufприведет к тем же действиям, что и вызов (void) setvbuf (stream, buf, _IOFBF, BUFSIZ).
   B1.2.Форматный вывод
   Функцииprintfосуществляют вывод информации по формату.
   int fprintf(FILE *stream, const char *format, ...);
   fprintfпреобразует и пишет вывод в потокstreamпод управлениемformat.Возвращаемое значение - число записанных символов или, в случае ошибки, отрицательное значение.
   Форматная строкасодержит два вида объектов:обычные символы,копируемые в выводной поток, испецификации преобразования,которые вызывают преобразование и печать остальных аргументов в том порядке, как они перечислены. Каждая спецификация преобразования начинается с%и заканчивается символом-спецификатором преобразования. Между % и символом- спецификатором в порядке, в котором они здесь перечислены, могут быть расположены следующие элементы информации:
   • Флаги (в любом порядке), модифицирующие спецификацию:-указывает на то, что преобразованный аргумент должен быть прижат к левому краю поля;+предписывает печатать число всегда со знаком;пробелесли первый символ - не знак, то числу должен предшествовать пробел;0указывает, что числа должны дополняться слева нулями до всей ширины поля;#указывает на одну из следующих форм вывода: дляoпервой цифрой должен быть 0; дляxилиXненулевому результату должны предшествовать 0x или 0X; дляe,E,f,gиGвывод должен обязательно содержать десятичную точку; дляgиGзавершающие нули не отбрасываются.
   • Число, специфицирующее минимальную ширину поля. Преобразованный аргумент будет напечатан в поле, размер которого не меньше указанной ширины, а если потребуется, в поле большего размера. Если число символов преобразованного аргумента меньше ширины поля, то поле будет дополнено слева (или справа, если число прижимается к левому краю). Обычно поле дополняется пробелами (или нулями, если присутствует флаг дополнения нулями).
   • Точка, отделяющая указатель ширины поля от указателя точности.
   • Число, задающее точность, которое специфицирует максимальное количество символов, печатаемых из строки, или количество цифр после десятичной точки в преобразованиях e, E или f, или количество значащих цифр для g или G - преобразования, или минимальное количество цифр при печати целого (до необходимой ширины поля число дополняется слева нулями).
   • Модификаторыh,l (буква ell) илиL. "h"указывает на то, что соответствующий аргумент должен печататься какshortилиunsigned short; "l"сообщает, что аргумент имеет типlongилиunsigned long; "L"информирует, что аргумент принадлежит типуlong double.
   Ширина, или точность, или обе эти характеристики могут быть специфицированы с помощью*;в этом случае необходимое число "извлекается" из следующего аргумента, который должен иметь типint (в случае двух звездочек используются два аргумента).
   Символы-спецификаторы и разъяснение их смысла приведены в таблице B-1. Если за%нет правильного символа-спецификатора, результат не определен.
   int printf(const char *format, ...);
   printf(...)полностью эквивалентнаfprintf(stdout, ...).
   int sprintf(char *s, const char *format, ...)
   sprintfдействует так же, как иprintf,только вывод осуществляет в строкуs,завершая ее символом '\0'. Строкаsдолжна быть достаточно большой, чтобы вмещать результат вывода. Возвращает количество записанных символов, в число которых символ '\0' не входит.
   int vprintf (const char *format, va_list arg)
   int vfprintf (FILE *stream, const char *format, va_list arg)
   int vsprintf (char *s, const char *format, va_list arg)
   Функцииvprintf,vfprintfиvsprintfэквивалентны соответствующимprintf-функциям с той лишь разницей, что переменный список аргументов представлен параметромarg,инициализированным макросомva_startи, возможно, вызовамиva_arg (см. в B7 описание&lt;stdarg.h&gt;).
   Таблица B-1. ПреобразованияprintfСимволТип аргумента; вид печатиd,iint;знаковая десятичная записьounsigned int;беззнаковая восьмеричная запись (без 0 слева)x,Xunsigned int;беззнаковая шестнадцатеричная запись (без 0x или 0X слева), в качестве цифр от 10 до 15 используются abcdef для x и ABCDEF для Xuunsigned int;беззнаковое десятичное целоеcint;единичный символ после преобразования вunsigned charschar *;символы строки печатаются, пока не встретится '\0' или не исчерпается количество символов, указанное точностьюfdouble;десятичная запись вида [-]mmm.ddd, где количествоdспецифицируется точностью. По умолчанию точность равна 6; нулевая точность подавляет печать десятичной точкиe,Edouble;десятичная запись вида [-]m.dddddde±xx или запись вида [-]m.ddddddE±xx, где количествоdспецифицируется точностью. По умолчанию точность равна 6; нулевая точность подавляет печать десятичной точкиg,Gdouble;используется%eи%E,если порядок меньше -4 или больше или равен точности; в противном случае используется%f.Завершающие нули и точка в конце не печатаютсяpvoid *;печатает в виде указателя (представление зависит от реализацииnint *;число символов, напечатанных к данному моменту данным вызовомprintf,записываетсяв аргумент. Никакие другие аргументы не преобразуются%никакие аргументы не преобразуются; печатается%
   B1.3.Форматный ввод
   Функцииscanfимеют дело с форматным преобразованием при вводе
   int fscanf(FILE *stream, const char *format, ...);
   fscanfчитает данные из потокаstreamпод управлениемformatи преобразованные величины присваивает по порядку аргументам, каждый из которых должен быть указателем. Завершает работу, если исчерпался формат. Выдает EOF по исчерпании файла или перед любым преобразованием, если возникла ошибка; в остальных случаях функция возвращает количество преобразованных и введенных элементов.
   Форматная строка обычно содержит спецификации преобразования, которые используются для управления вводом. В форматную строку могут входить:
   • пробелы и табуляции, которые игнорируются;
   • обычные символы (кроме%),которые ожидаются в потоке ввода среди символов, отличных от символов-разделителей;
   • спецификации преобразования, состоящие из%;необязательного знака*,подавляющего присваивание; необязательного числа, специфицирующего максимальную ширину поля; необязательныхh,lилиL,указывающих размер присваиваемого значения, и символа-спецификатора преобразования.
   Спецификация преобразования определяет преобразование следующего поля ввода. Обычно результат размещается в переменной, на которую указывает соответствующий аргумент. Однако если присваивание подавляется с помощью знака*,как, например, в %*s, то поле ввода просто пропускается, и никакого присваивания не происходят. Поле ввода определяется как строка символов, отличных от символов-разделителей; при этом ввод строки прекращается при выполнении любого из двух условий: если встретился символ-разделитель или если ширина поля (в случае, когда она указана) исчерпана. Из этого следует, что при переходе к следующему полюscanfможет "перешагивать" через границы строк, поскольку символ новой строки является символом-разделителем. (Под символами-разделителями понимаются символы пробела, табуляции, новой строки, возврата каретки, вертикальной табуляции и смены страницы.)
   Символ-спецификатор указывает на способ интерпретации поля ввода. Соответствующий аргумент должен быть указателем. Список допустимых символов-спецификаторов приводится в таблице B-2.
   Символам-спецификаторамd,i,n,o,uиxможет предшествоватьh,если аргумент есть указатель наshort (а неint)илиl (буква ell), если аргумент есть указатель наlong.Символам-спецификаторамe,fиgможет предшествоватьl,если аргумент - указатель наdouble (а неfloat),илиL,если аргумент - указатель наlong double.
   int scanf (const char *format, ...);
   scanf(...)делает то же, что иfscanf(stdin, ...).
   int sscanf (const char *s, const char *format, ...);
   sscanf(s, ...)делает то же, что иscanf(...),только ввод символов осуществляет из строкиs.
   Таблица B-2. ПреобразованияscanfСимволДанные на вводе; тип аргументаdдесятичное целое;int *iцелое:int *.Целое может быть восьмеричным (с нулем слева) или шестнадцатеричным (с 0x или 0X слева)oвосьмеричное целое (с нулем слева или без него);int *uбеззнаковое десятичное целое;unsigned int *xшестнадцатеричное целое (с 0x или 0X слева или без них):int *cсимволы,char *.Символы ввода размещаются в указанном массиве в количестве, заданном шириной поля; по умолчанию это количество равно 1. Символ'\0' не добавляется. Символы-разделители здесь рассматриваются как обычные символы и поступают в аргумент. Чтобы прочесть следующий символ-разделитель, используйте %1ssстрока символов, отличных от символов-разделителей (записывается без кавычек);char *,указывающий на массив размера достаточного, чтобы вместить строку и добавляемый к ней символ '\0'e,f,gчисло с плавающей точкой;float *.Формат ввода дляfloatсостоит из необязательного знака, строки цифр, возможно с десятичной точкой, и необязательного порядка, состоящего изEилиeи целого, возможно со знакомpзначение указателя в виде, в котором printf ("%р") его напечатает;void *nзаписывает в аргумент число символов, прочитанных к этому моменту в этом вызове;int *.Никакого чтения ввода не происходит. Счетчик числа введенных элементов не увеличивается[...]выбирает из ввода самую длинную непустую строку, состоящую из символов, заданных в квадратных скобках:char *.В конец строки добавляется '\0'. Спецификатор вида[]...]включает]в задаваемое множество символов[^...]выбирает из ввода самую длинную непустую строку, состоящую из символов, не входящих в заданное в скобках множество. В конец добавляется '\0'. Спецификатор вида[^]...]включает]в задаваемое множество символов%обычный символ%;присваивание не делается
   B1.4.Функции ввода-вывода символов
   int fgetc(FILE *stream);
   fgetcвозвращает следующий символ из потокаstreamв видеunsigned char (переведенную вint)или EOF, если исчерпан файл или обнаружена ошибка.
   char *fgets(char *s, int n, FILE *stream);
   fgetsчитает не болееn-1символов в массивs,прекращая чтение, если встретился символ новой строки, который включается в массив; кроме того, записывает в массив '\0'. Функцияfgetsвозвращаетsили, если исчерпан файл или обнаружена ошибка, NULL.
   int fputc(intс, FILE *stream);
   fputcпишет символc (переведенный вunsigned char)вstream.Возвращает записанный символ или EOF в случае ошибки.
   int fputs(const char *s, FILE *stream);
   fputsпишет строкуs (которая может не иметь '\n' ) вstream;возвращает неотрицательное целое или EOF в случае ошибки.
   int getc(FILE *stream);
   getcделает то же, что иfgetc,но в отличие от последней, если она - макрос,streamможет браться более одного раза.
   int getchar(void);
   getchar()делает то же, чтоgetc(stdin).
   char *gets(char *s);
   getsчитает следующую строку ввода в массивs,заменяя символ новой строки на '\0'. Возвращаетsили, если исчерпан файл или обнаружена ошибка, NULL.
   int putc(intс, FILE *stream);
   putcделает то же, что иfputc,но в отличие от последней, еслиputc -макрос, значениеstreamможет браться более одного раза.
   int putchar(int c);
   putchar(c)делает тоже, чтоputc(c, stdout).
   int puts(const char *s);
   putsпишет строкуsи символ новой строки вstdout.Возвращает EOF в случае ошибки, или неотрицательное значение, если запись прошла нормально.
   int ungetc(intс, FILE *stream);
   ungetcотправляет символc (переведенный вunsigned char)обратно вstream;при следующем чтении изstreamон будет получен снова. Для каждого потока вернуть можно не более одного символа. Нельзя возвращать EOF. В качестве результатаungetcвыдает отправленный назад символ или, в случае ошибки, EOF.
   B1.5.Функции прямого ввода-вывода
   size_t fread(void *ptr, size_t size, size_t nobj, FILE *stream);
   freadчитает из потокаstreamв массивptrне болееnobjобъектов размераsize.Она возвращает количество прочитанных объектов, которое может быть меньше заявленного. Для индикации состояния после чтения следует использоватьfeofиferror.
   size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream);
   fwriteпишет из массиваptrвstream nobjобъектов размераsize;возвращает число записанных объектов, которое в случае ошибки меньшеnobj.
   B1.6.Функции позиционирования файла
   int fseek(FILE *stream, long offset, int origin);
   fseekустанавливает позицию дляstream;последующее чтение или запись будет производиться с этой позиции. В случае бинарного файла позиция устанавливается со смещениемoffset -относительно начала, еслиoriginравенSEEK_SET;относительно текущей позиции, еслиoriginравенSEEK_CUR;и относительно конца файла, еслиoriginравенSEEK_END.Для текстового файлаoffsetдолжен быть нулем или значением, полученным с помощью вызова функцииftell.При работе с текстовым файломoriginвсегда должен быть равенSEEK_SET.
   long ftell(FILE *stream);
   ftellвозвращает текущую позицию потокаstreamили -1L, в случае ошибки.
   void rewind(FILE *stream);
   rewind(fp)делает то же, что и fseek(fp, 0L, SEEK_SET); clearerr(fp).
   int fgetpos(FILE *stream, fpos_t *ptr);
   fgetposзаписывает текущую позицию потокаstreamв*ptrдля последующего использования ее вfsetpos.Типfpos_tпозволяет хранить такого рода значения, В случае ошибкиfgetposвозвращает ненулевое значение.
   int fsetpos(FILE *stream, const fpos_t *ptr);
   fsetposустанавливает позицию вstream,читая ее из*ptr,куда она была записана ранее с помощьюfgetpos.В случае ошибкиfsetposвозвращает ненулевое значение.
   B1.7.Функции обработки ошибок
   Многие функции библиотеки в случае ошибки или конца файла устанавливают индикаторы состояния. Эти индикаторы можно проверять и изменять. Кроме того, целое выражениеerrno (объявленное в&lt;errno.h&gt;)может содержать номер ошибки, который дает дополнительную информацию о последней из обнаруженных ошибок.
   void clearerr(FILE *stream);
   clearerrочищает индикаторы конца файла и ошибки потокаstream.
   int feof(FILE *stream);
   feofвозвращает ненулевое значение, если для потокаstreamустановлен индикатор конца файла.
   int ferror(FILE *stream);
   ferrorвозвращает ненулевое значение, если для потокаstreamустановлен индикатор ошибки.
   void perror(const char *s);
   perror(s)печатаетsи зависимое от реализации сообщение об ошибке, соответствующее целому значению вerrno,т. е. делает то же, что и обращение к функцииfprintfвида
   fprintf(stderr, "%s: %s\n", s, "сообщение об ошибке")
   См.strerrorв параграфе B3.
   B2.Проверки класса символа: ‹ctype.h›
   Заголовочный файл&lt;ctype.h&gt;объявляет функции, предназначенные для проверок символов. Аргумент каждой из них имеет типintи должен либо представлять собой EOF, либо быть значениемunsigned char,приведенным кint;возвращаемое значение тоже имеет типint.Функции возвращают ненулевое значение ("истина"), когда аргумент c удовлетворяет описанному условию или принадлежит указанному классу символов, и нуль в противном случае.isalnum(c)isalpha(c)илиisdigit(c)есть истинаisalpha(c)isupper(c)илиislower(c)есть истинаiscntrl(c)управляющий символisdigit(c)десятичная цифраisgraph(c)печатаемый символ кроме пробелаislower(c)буква нижнего регистраisprint(c)печатаемый символ, включая пробелispunct(c)печатаемый символ кроме пробела, буквы или цифрыisspace(c)пробел, смена страницы, новая строка, возврат каретки, табуляция, вертикальная табуляцияisupper(c)буква верхнего регистраisxdigit(c)шестнадцатеричная цифра
   В наборе семибитовых ASCII-символов печатаемые символы находятся в диапазоне от0x20 (' ')до0x7E ('~');управляющие символы - от0 (NUL)до0x1F (US)и 0x7F (DEL).
   Помимо перечисленных есть две функции, приводящие буквы к одному из регистров:
   inttolower(int c)– переводитcна нижний регистр;
   inttoupper(int c) -переводитcна верхний регистр.
   Еслиc -буква на верхнем регистре, тоtolower(c)выдаст эту букву на нижнем регистре; в противном случае она вернетc.Еслиc -буква на нижнем регистре, тоtoupper(c)выдаст эту букву на верхнем регистре; в противном случае она вернетc.
   B3.Функции, оперирующие со строками:&lt;string.h&gt;
   Имеются две группы функций, оперирующих со строками. Они определены в заголовочном файле&lt;string.h&gt;.Имена функций первой группы начинаются с буквstr,второй - сmem.Если копирование имеет дело с объектами, перекрывающимися по памяти, то, за исключениемmemmove,поведение функций не определено. Функции сравнения рассматривают аргументы как массивы элементов типаunsigned char.
   В таблице на с. 321 переменныеsиtпринадлежат типуchar *,csиct– типуconst char *,n -типуsize_t,аc -значение типаint,приведенное к типуchar.
   Последовательные вызовыstrtokразбивают строкуsна лексемы. Ограничителем лексемы служит любой символ из строкиct.В первом вызове указательsне равен NULL. Функция находит в строкеsпервую лексему, состоящую из символов, не входящих вct;ее работа заканчивается тем, что поверх следующего символа пишется '\0' и возвращается указатель на лексему. Каждый последующий вызов, в котором указательsравен NULL, возвращает указатель на следующую лексему, которую функция будет искать сразу за концом предыдущей. Функцияstrtokвозвращает NULL, если далее никакой лексемы не обнаружено. Параметрctот вызова к вызову может варьироваться.
   Здесь и ниже под такими выражениями как cs&lt;ctне следует понимать арифметическое сравнение указателей. Подразумевается лексикографическое сравнение, т. е.csменьше (больше)ct,если первый несовпавший элемент вcsарифметически меньше (больше) соответствующего элемента изct.—Примеч. ред.char *strcpy(s,ct)копирует строкуctв строкуs,включая '\0'; возвращаетschar *strncpy(s,ct,n)копирует не болееnсимволов строкиctвs;возвращаетs.Дополняет результат символами '\0', если символов вctменьшеnchar *strcat(s,ct)приписываетctкs;возвращаетschar *strncat(s,ct,n)приписывает не болееnсимволовctкs,завершаяsсимволом '\0'; возвращаетscharstrcmp(cs,st)сравниваетcsиct;возвращает&lt;0,если cs&lt;ct; 0,если cs==ct; и&gt;0,если cs&gt;ct (I.B.:вообще-то, функция возвращает int)charstrncmp(cs,ct)сравнивает не болееnсимволовcsиct;возвращает&lt;0,если cs&lt;ct, 0,если cs==ct, и&gt;0,если cs&gt;ct (I.B.:тоже int должна возвращать)char *strchr(cs,c)возвращает указатель на первое вхождениеcвcsили, если такового не оказалось, NULLchar *strrchr(cs,c)возвращает указатель на последнее вхождениеcвcsили, если такового не оказалось, NULLsize_tstrspn(cs,ct)возвращает длину начального сегментаcs,состоящего из символов, входящих в строкуctsize_tstrcspn(cs,ct)возвращает длину начального сегментаcs,состоящего из символов, не входящих в строкуctchar *strpbrk(cs,ct)возвращает указатель вcsна первый символ, который совпал с одним из символов, входящих вct,или, если такового не оказалось, NULLchar *strstr(cs, ct)возвращает указатель на первое вхождениеctвcsили, если такового не оказалось, NULLsize_tstrlen(cs)возвращает длинуcschar *strerror(n)возвращает указатель на зависящую от реализации строку, соответствующую номеру ошибкиnchar *strtok(s, ct)strtokищет вsлексему, ограниченную символами изct;более подробное описание этой функции см. ниже
   Функцииmem...предназначены для манипулирования с объектами как с массивами символов; их назначение - получить интерфейсы к эффективным программам. В приведенной ниже таблицеsиtпринадлежат типуvoid *;csиct -типуconst void *;n -типуsize_t;аcимеет значение типаint,приведенное к типуchar.void *memcpy(s,ct, n)копируетnсимволов изctвsи возвращаетsvoid *memmove(s,ct,n)делает то же самое, что иmemcpy,но работает и в случае "перекрывающихся" объектов.intmemcmp(cs, ct, n)сравнивает первыеnсимволовcsиct;выдает тот же результат, что и функцияstrcmpvoid *memchr(cs, c, n)возвращает указатель на первое вхождение символаcвcsили, если среди первыхnсимволовcне встретилось, NULLvoid *memset(s, c, n)размещает символcв первыхnпозициях строкиsи возвращаетs
   B4.Математические функции:&lt;math.h&gt;
   В заголовочном файле&lt;math.h&gt;описываются математические функции и определяются макросы.
   МакросыEDOMиERANGE (находящиеся в&lt;errno.h&gt;)задают отличные от нуля целочисленные константы, используемые для фиксации ошибки области и ошибки диапазона;HUGE_VALопределена как положительное значение типаdouble.Ошибка областивозникает, если аргумент выходит за область значений, для которой определена функция. Фиксация ошибки области осуществляется присвоениемerrnoзначенияEDOM;возвращаемое значение зависит от реализации. Ошибка диапазона возникает тогда, когда результат функции не может быть представлен в видеdouble.В случае переполнения функция возвращаетHUGE_VALс правильным знаком и вerrnoустанавливается значениеERANGE.Если результат оказывается меньше, чем возможно представить данным типом, функция возвращает нуль, а устанавливается ли в этом случаеerrnoвERANGE,зависит от реализации. Далееxиyимеют типdouble,n -типint,и все функции возвращают значения типаdouble.Углы в тригонометрических функциях задаются врадианах.sin(x)синусxcos(x)косинусxtan(x)тангенсxasin(x)арксинусxв диапазоне[-pi/2,pi/2],xв диапазоне[-1,1]acos(x)арккосинусxв диапазоне[0, pi],xв диапазоне[-1,1]atan(x)арктангенсxв диапазоне[-pi/2, pi/2]atan2(y,x)арктангенсy/xв диапазоне[-pi, pi]sinh(x)гиперболический синусxcosh(x)гиперболический косинусxtanh(x)гиперболический тангенсxexp(x)Экспоненциальная функцияexlog(x)натуральный логарифмln(x),x&gt; 0log10(x)десятичный логарифмlg(x),x&gt; 0pow(x,y)xy,ошибка области, еслиx = 0илиy&lt;=0илиx&lt;0иy– не целоеsqrt(x)квадратный кореньx,x&gt;= 0ceil(x)наименьшее целое в видеdouble,которое не меньшеxfloor(x)наибольшее целое в видеdouble,которое не большеxfabs(x)абсолютное значение |x|ldexp(x, n)x * 2nfrexp(x, int *еxр)разбиваетxна два сомножителя, первый из которых - нормализованная дробь в интервале [1/2, 1), которая возвращается, а второй - степень двойки, эта степень запоминается в*exp.Еслиx -нуль, то обе части результата равны нулюmodf(x,double *ip)разбивается на целую и дробную части, обе имеют тот же знак, что иx.Целая часть запоминается в*ip,дробная часть выдается как результатfmod(x, y)остаток от деленияxнаyв виде числа с плавающей точкой. Знак результата совпадает со знакомx.Еслиyравен нулю, результат зависит от реализации
   B5.Функции общего назначения:&lt;stdlib.h&gt;
   Заголовочный файл&lt;stdlib.h&gt;объявляет функции, предназначенные для преобразования чисел, запроса памяти и других задач.
   double atof(const char *s)
   atofпереводитsвdouble;эквивалентна strtod(s, (char**) NULL).
   int atoi(const char *s)
   atoiпереводитsвint;эквивалентна (int)strtol(s, (char**)NULL, 10).
   int atol(const char *s)
   atolпереводитsвlong;эквивалентна strtol(s, (char**) NULL, 10).
   double strtod(const char *s, char **endp)
   strtodпреобразует первые символы строкиsвdouble,игнорируя начальные символы-разделители; запоминает указатель на непреобразованный конец в*endp (еслиendpне NULL), при переполнении она выдаетHUGE_VALс соответствующим знаком, в случае, если результат оказывается меньше, чем возможно представить данным типом, возвращается 0; в обоих случаях вerrnoустанавливаетсяERANGE.
   long strtol(const char *s, char **endp, int base)
   strtolпреобразует первые символы строкиsвlong,игнорируя начальные символы-разделители; запоминает указатель на непреобразованный конец в*endp (еслиendpне NULL). Еслиbaseнаходится в диапазоне от 2 до 36, то преобразование делается в предположении, что на входе - запись числа по основаниюbase.Еслиbaseравно нулю, то основанием числа считается 8, 10 или 16; число, начинающееся с цифры 0, считается восьмеричным, а с 0x или 0X - шестнадцатеричным. Цифры от 10 доbase-1записываются начальными буквами латинского алфавита в любом регистре. При основании, равном 16, в начале числа разрешается помещать 0x или 0X. В случае переполнения функция возвращает LONG_MAX или LONG_MIN (в зависимости от знака), a вerrnoустанавливается ERANGE.
   unsigned long strtoul(const char *s, char **endp, int base)
   strtoulработает так же, как иstrtol,с той лишь разницей, что возвращает результат типаunsigned long,а в случае переполнения - ULONG_MAX.
   int rand(void)
   randвыдает псевдослучайное число в диапазоне от 0 до RAND_MAX; RAND_MAX не меньше 32767.
   void srand(unsigned int seed)
   srandиспользуетseedв качестве семени для новой последовательности псевдослучайных чисел. Изначально параметрseedравен 1.
   void *calloc(size_t nobj, size_t size)
   callocвозвращает указатель на место в памяти, отведенное для массиваnobjобъектов, каждый из которых размераsize,или, если памяти запрашиваемого объема нет, NULL. Выделенная область памяти обнуляется.
   void *malloc(size_t size)
   mallocвозвращает указатель на место в памяти для объекта размераsizeили, если памяти запрашиваемого объема нет, NULL. Выделенная область памяти не инициализируется.
   void *realloc(void *p, size_t size)
   reallocзаменяет наsizeразмер объекта, на который указываетp.Для части, размер которой равен наименьшему из старого и нового размеров, содержимое не изменяется. Если новый размер больше старого, дополнительное пространство не инициализируется,reallocвозвращает указатель на новое место памяти или, если требования не могут быть удовлетворены, NULL (*pпри этом не изменяется).
   void free(void *р)
   freeосвобождает область памяти, на которую указываетp;эта функция ничего не делает, еслиpравно NULL. Вpдолжен стоять указатель на область памяти, ранее выделенную одной из функций:calloc,mallocилиrealloc.
   void abort(void *р)
   abortвызывает аварийное завершение программы, ее действия эквивалентны вызовуraise(SIGABRT).
   void exit(int status)
   exitвызывает нормальное завершение программы. Функции, зарегистрированные с помощьюatexit,выполняются в порядке, обратном их регистрации. Производится опорожнение буферов открытых файлов, открытые потоки закрываются, и управление возвращается в среду,из которой был произведен запуск программы. Значениеstatus,передаваемое в среду, зависит от реализации, однако при успешном завершении программы принято передавать нуль. Можно также использовать значения EXIT_SUCCESS (в случае успешного завершения) и EXIT_FAILURE (в случае ошибки).
   int atexit(void (*fcn)(void))
   atexitрегистрируетfcnв качестве функции, которая будет вызываться при нормальном завершении программы; возвращает ненулевое значение, если регистрация не может быть выполнена.
   int system(const char *s)
   systemпepeдaeт cтpoкуs oпepaциoннoй cpeдe для выпoлнeния. Еслиsесть NULL и существует командный процессор, тоsystemвозвращает ненулевое значение. Еслиsне NULL, то возвращаемое значение зависит от реализации.
   char *getenv(const char *name)
   getenvвозвращает строку среды, связанную сname,или, если никакой строки не существует, NULL. Детали зависят от реализации.
   void *bsearch(const void *key, const void *base, size_t n, size_t size, int (*cmp)(const void *keyval, const void *datum))
   bsearchищет средиbase[0]...base[n-1]элемент с подходящим ключом*key.Функцияcmpдолжна сравнивать первый аргумент (ключ поиска) со своим вторым аргументом (значением ключа в таблице) и в зависимости от результата сравнения выдавать отрицательное число, нуль или положительное значение. Элементы массиваbaseдолжны быть упорядочены в возрастающем порядке,bsearchвозвращает указатель на элемент с подходящим ключом или, если такого не оказалось, NULL.
   void qsort(void *base, size_t n, size_t size, int (*cmp)(const void *, const void *))
   qsortсортирует массивbase[0]...base[n-1]объектов размераsizeв возрастающем порядке. Функция сравненияcmp -такая же, как и вbsearch.
   int abs(int n)
   absвозвращает абсолютное значение аргумента типаint.
   long labs(long n)
   labsвозвращает абсолютное значение аргумента типаlong.
   div_t div(int num, int denom)
   divвычисляет частное и остаток от деленияnumнаdenom.Результаты типаintзапоминаются в элементахquotиremструктурыdiv_t.
   ldiv_t ldiv(long num, long denom)
   ldivвычисляет частное и остаток от деленияnumнаdenom.Результаты типаlongзапоминаются в элементахquotиremструктурыldiv_t.
   B6.Диагностика:&lt;assert.h&gt;
   Макросassertиспользуется для включения в программу диагностических сообщений.
   void assert (intвыражение)
   Есливыражениеимеет значение нуль, то
   assert (выражение)
   напечатает вstderrсообщение следующего вида:
   Assertion failed:выражение, fileимя-файла, linennn
   после чего будет вызвана функцияabort,которая завершит вычисления. Имя исходного файла и номер строки будут взяты из макросов __FILE__ и __LINE__.
   Если в момент включения файла&lt;assert.h&gt;было определено имяNDEBUG,то макросassertигнорируется.
   B7.Списки аргументов переменной длины:&lt;stdarg.h&gt;
   Заголовочный файл&lt;stdarg.h&gt;предоставляет средства для перебора аргументов функции, количество и типы которых заранее не известны. Пустьlastarg -последний именованный параметр функцииfс переменным числом аргументов. Внутриfобъявляется переменнаяapтипаva_list,предназначенная для хранения указателя на очередной аргумент:
   va_listар;
   Прежде чем будет возможен доступ к безымянным аргументам, необходимо один раз инициализироватьap,обратившись к макросуva_start:
   va_start(va_list ap, lastarg);
   С этого момента каждое обращение к макросу:
   typeva_arg(va_list ap, type);
   будет давать значение очередного безымянного аргумента указанного типа, и каждое такое обращение будет вызывать автоматическое приращение указателяap,чтобы последний указывал на следующий аргумент. Один раз после перебора аргументов, но до выхода изfнеобходимо обратиться к макросу
   voidva_end(va_list ap);
   B8.Дальние переходы:&lt;setjmp.h&gt;
   Объявления в&lt;setjmp.h&gt;предоставляют способ отклониться от обычной последовательности "вызов - возврат"; типичная ситуация - необходимость вернуться из "глубоко вложенного" вызова функции на верхний уровень, минуя промежуточные возвраты.
   int setjmp(jmp_buf env);
   Макросsetjmpсохраняет текущую информацию о вызовах вenvдля последующего ее использования вlongjmp.Возвращает нуль, если возврат осуществляется непосредственно изsetjmp,и не нуль, если - от последующего вызоваlongjmp.Обращение кsetjmpвозможно только в определенных контекстах, в основном это проверки вif,switсhи циклах, причем только в простых выражениях отношения.
   if (setjmp() == 0)
       /* после прямого возврата */
   else
       /* после возврата из longjmp */

   void longjmp(jmp_buf env, int val);
   longjmpвосстанавливает информацию, сохраненную в самом последнем вызовеsetjmp,по информации изenv;выполнение программы возобновляется, как если бы функцияsetjmpтолько что отработала и вернула ненулевое значениеval.Результат будет непредсказуемым, если в момент обращения кlongjmpфункция, содержащая вызовsetjmp,уже "отработала" и осуществила возврат. Доступные ей объекты имеют те значения, которые они имели в момент обращения кlongjmp;setjmpне сохраняет значений.
   B9.Сигналы:&lt;signal.h&gt;
   Заголовочный файл&lt;signal.h&gt;предоставляет средства для обработки исключительных ситуаций, возникающих во время выполнения программы, таких как прерывание, вызванное внешним источником или ошибкой в вычислениях.
   void (*signal(int sig, void (*handler)(int)))(int)
   signalустанавливает, как будут обрабатываться последующие сигналы. Если параметрhandlerимеет значениеSIG_DFL,то используется зависимая от реализации "обработка по умолчанию"; если значениеhandlerравноSIG_IGN,то сигнал игнорируется; в остальных случаях будет выполнено обращение к функции, на которую указываетhandlerс типом сигнала в качестве аргумента. В число допустимых видов сигналов входят:SIGABRTаварийное завершение, например отabort;SIGFPEарифметическая ошибка: деление на 0 или переполнение;SIGILLневерный код функции (недопустимая команда);SIGINTзапрос на взаимодействие, например прерывание;SIGSEGVневерный доступ к памяти, например выход за границы;SIGTERMтребование завершения, посланное в программу.
   signalвозвращает предыдущее значениеhandlerв случае специфицированного сигнала, илиSIGERRв случае возникновения ошибки.
   Когда в дальнейшем появляется сигналsig,сначала восстанавливается готовность поведения "по умолчанию", после чего вызывается функция, заданная в параметреhandler,т.е. как бы выполняется вызов (*handler)(sig).Если функцияhandlerвернет управление назад, то вычисления возобновятся с того места, где застал программу пришедший сигнал. Начальное состояние сигналов зависит от реализации.
   int raise(int sig)
   raiseпосылает в программу сигналsig.В случае неудачи возвращает ненулевое значение.  
   B10.Функции даты и времени: ‹time.h›
   Заголовочный файл&lt;time.h&gt;объявляет типы и функции, связанные с датой и временем. Некоторые функции имеют дело с местным временем, которое может отличаться от календарного, например в связис зонированием времени. Типыclосk_tиtime_t -арифметические типы для представления времени, astruct tmсодержит компоненты календарного времени:
   int tm_sec; -секунды от начала минуты (0,61); -- I.B.: все же наверно от 0 до 59
   int tm_min; -минуты от начала часа (0,59);
   int tm_hour; -часы от полуночи (0,23);int tm_mday; - число месяца (1,31);
   int tm_mon; -месяцы с января(0,11);
   int tm_year; -годы с 1900;
   int tm_wday; -дни с воскресенья (0,6);
   int tm_yday; -дни с 1 января (0,365);
   int tm_isdst; -признак летнего времени.
   Значениеtm_isdst -положительное, если время приходится на сезон, когда время суток сдвинуто на 1 час вперед, нуль в противном случае и отрицательное, если информация не доступна.
   clock_t clock(void)
   clockвозвращает время, фиксируемое процессором от начала выполнения программы, или -1, если оно не известно. Для выражения этого времени в секундах применяется формула clock()/CLOCKS_PER_SEC.
   time_t time(time_t *tp)
   timeвозвращает текущее календарное время (т. е. время, прошедшее после определенной даты, - обычно после 0 ч 00 мин 00 с GMT 1-го января 1970 г. - примеч. ред.) или -1, если время не известно. Еслиtpне равно NULL, то возвращаемое значение записывается и в*tp.
   double difftime(time_t time2, time_t time1)
   difftimeвозвращает разностьtime2 - time1,выраженную в секундах.
   time_t mktime(struct tm *tp)
   mktimeпреобразует местное время, заданное структурой*tp,в календарное, выдавая его в том же виде, что и функцияtime.Компоненты будут иметь значения в указанных диапазонах. Функцияmktimeвозвращает календарное время или -1, если оно не представимо.
   Следующие четыре функции возвращают указатели на статические объекты, каждый из которых может быть изменен другими вызовами.
   char *asctime(const struct tm *tp)
   asctimeпереводит время в структуре*tpв строку вида
   Sun Jan 3 15:14:13 1988\n\0

   char *ctime(const time_t *tp)
   ctimeпереводит календарное время в местное, что эквивалентно выполнению asctime(localtime(tp))
   struct tm *gmtime(const time_t *tp)
   gmtimeпереводит календарное время во Всемирное координированное время (Coordinated Universal Time - UTC). Выдаст NULL, если UTC не известно. Имя этой функции,gmtime,происходит от Greenwich Mean Time (среднее время по Гринвичскому меридиану).
   struct tm *localtime(const time_t *tp)
   localtimeпереводит календарное время*tpв местное.
   size_t strftime(char *s, size_t smax, const char *fmt, const struct tm *tp)
   strftimeформатирует информацию о дате и времени из*tpв строкуsсогласно форматуfmt,который имеет много общих черт с форматом, задаваемым в функцииprintf.Обычные символы (включая и завершающий символ '\0') копируются вs.Каждая пара, состоящая из%и буквы, заменяется, как показано ниже, с использованием значений по форме, соответствующей местным традициям. Вsразмещается не болееsmaxсимволов;strftimeвозвращает число символов без учета '\0' или нуль, если число сгенерированных символов большеsmax.%aсокращенное название дня недели%Aполное название дня недели%bсокращенное название месяца%Bполное название месяца%cместное представление даты и времени%dдень месяца (01-31)%Hчас (24-часовое время) (00-23)%Iчас (12-часовое время) (01-12)%jдень от начала года (001-366)%mмесяц (01-12)%Mминута (00-59)%pместное представление AM или РМ (до или после полудня)%Sсекунда (00-61)%Uнеделя от начала года (считая, что воскресенье - 1-й день недели) (00-53)%wдень недели (0-6, номер воскресенья - 0)%Wнеделя от начала года (считая, что понедельник - 1-й день недели) (00-53)%xместное представление даты%Xместное представление времени%yгод без указания века (00-99)%Yгод с указанием века%Zназвание временной зоны, если она есть%%%
   B11.Зависящие от реализации пределы:&lt;limits.h&gt;и&lt;float.h&gt;
   Заголовочный файл&lt;limits.h&gt;определяет константы для размеров целочисленных типов. Ниже перечислены минимальные приемлемые величины, но в конкретных реализациях могут использоваться и большие значения.CHAR_BIT8битов в значенииcharSCHAR_MAXUCHAR_MAXилиSCHAR_MAXмаксимальное значениеcharCHAR_MIN0илиSCHAR_MINминимальное значениеcharINT_MAX+32767максимальное значениеintINT_MIN-32767 (I.B.:обычно это значение -32768)минимальное значениеintLONG_MAX+2147463647максимальное значениеlongLONG_MIN-2147483647 (I.B.:обычно это значение -2147483648)минимальное значениеlongSCHAR_MAX+127максимальное значениеsigned charSCHAR_MIN-127 (I.B.:обычно это значение -128)минимальное значениеsigned charSHRT_MAX+32767максимальное значениеshortSHRT_MIN-32767 (I.B.:обычно это значение -32768)минимальное значениеshortUCHAR_MAX255максимальное значениеunsigned charUINT_MAX65535максимальное значениеunsigned intULONG_MAX4294967295максимальное значениеunsigned longUSHRT_MAX65535максимальное значениеunsigned short
   Имена, приведенные в следующей таблице, взяты из&lt;float.h&gt;и являются константами, имеющими отношение к арифметике с плавающей точкой. Значения (если они есть) представляют собой минимальные значения для соответствующих величин. В каждой реализации устанавливаются свои значения.FLT_RADIX2основание для представления порядка, например: 2, 16FLT_ROUNDSспособ округления при сложении чисел с плавающей точкойFLT_DIG6количество верных десятичных цифрFLT_EPSILON1E-5минимальное х, такое, что 1.0 + х != 1.0FLT_MANT_DIGколичество цифр по основаниюFLT_RADIXв мантиссеFLT_MAX1E+37максимальное число с плавающей точкойFLT_MAX_EXPмаксимальное n, такое, чтоFLT_RADIXn-1представимоFLT_MIN1E-37минимальное нормализованное число с плавающей точкойFLT_MIN_EXPминимальное n, такое, что 10nпредставимо в виде нормализованного числаDBL_DIG10количество верных десятичных цифр для типаdoubleDBL_EPSILON1E-9минимальное х, такое, что 1.0 + x != 1.0, где x принадлежит типуdoubleDBL_MANT_DIGколичество цифр по основаниюFLT_RADIXв мантиссе для чисел типаdoubleDBL_MAX1E+37максимальное число с плавающей точкой типаdoubleDBL_MAX_EXPмаксимальное n, такое, чтоFLT_RADIXn-1представимо в виде числа типаdoubleDBL_MIN1E-37минимальное нормализованное число с плавающей точкой типаdoubleDBL_MIN_EXPминимальное n, такое, что 10nпредставимо в виде нормализованного числа типаdouble
   Приложение C. Перечень изменений
   С момента публикации первого издания этой книги определение языка Си претерпело изменения. Почти все нововведения - это расширения исходной версии языка, выполненные так, чтобы сохранилась совместимость с существующими программами; некоторые изменения касаются устранения двусмысленностей первоначального описания, а некоторые представляют собой модификации, привнесенные существующей практикой. Многие из новых возможностей, впоследствии принятые другими разработчиками Си-компиляторов, были первоначально объявлены в документах, прилагаемых к компиляторам. Комитет ANSI, подготавливая стандарт языка, включил большинство этих изменений, а такжеввел другие значительные модификации. Некоторые коммерческие компиляторы реализовали их еще до выпуска официального Си-стандарта.
   В этом приложении сведены воедино различия между языком, определенным в первой его редакции, и той его версии, которая принята в качестве стандарта. Здесь рассматривается только сам язык; вопросы, относящиеся к его окружению и библиотеке, не затрагиваются. Хотя последние и являются важной частью стандарта, но, поскольку в первом издании не делалось попытки описать среду и библиотеку, с соответствующими стандартными элементами сравнивать практически нечего.
   • В стандарте более тщательно, по сравнению с первым изданием, определено и расширено препроцессирование: в его основу явно положены лексемы; введены новые операторы для "склеивания" лексем (##)и создания символьных строк (#),а также новые управляющие строки, такие как#elifи#pragma;разрешено повторное определение макроса с той же последовательностью лексем; отменена подстановка параметров внутри строк. Разрешено "склеивание" строк с помощью знака\в любом месте, не только в строках и макроопределениях (см. A.12).
   • Минимальное число значимых символов всех внутренних идентификаторов доведено до 31; для идентификаторов с внешней связью оно остается равным 6; буквы нижнего и верхнего регистров не различаются. (Многие реализации допускают большее число значимых символов.)
   • Для знаков#,\,^,[,],{,},|,~,которых может не быть в некоторых наборах символов, введены трехзнаковые последовательности, начинающиеся с?? (см. A12.1). Следует заметить, что введение трехзнаковых последовательностей может повредить значения строк, в которых содержатся??.
   • Введены новые ключевые слова (void,const,volatile,signed,enum),а мертворожденное словоentryиз обращения изъято.
    • Для символьных констант и строковых литералов определены новые эскейп-последовательности. Объявлено, что появление за\символов не из принятых эскейп-последовательностей приводит к непредсказуемому результату (см. A2.5.2.).
   • Узаконено полюбившееся всем тривиальное изменение: 8 и 9 не являются восьмеричными цифрами.
   • Введен расширенный набор суффиксов для явного указания типов констант:UиL -для целых иFиL -для типов с плавающей точкой. Уточнены также правила определения типа для констант без суффиксов (A2.5).
   • Объявлено, что соседние строки конкатенируются.
   • Предоставлены средства, позволяющие записывать строковые литералы и символьные константы из расширенного набора символов (A2.6).
   • Объекты типаchar (как и объекты другого типа) можно специфицировать явно со знаком или без знака. Исключается использование словосочетанияlong floatв смыслеdouble,но вводится типlong doubleдля чисел с плавающей точкой повышенной точности.
   • С некоторых пор доступен типunsigned char.Стандарт вводит ключевое словоsignedдля явного указания, что объект типаcharили другого целочисленного типа имеет знак.
   • Уже несколько лет в большинстве реализаций доступен типvoid.Стандарт вводитvoid *в качестве типа обобщенного указателя; раньше для этой цели использовалиchar *.Одновременно вступают в силу правила, по которым запрещается без преобразования типа "смешивать" указатели и целые или указатели разных типов.
   • Стандарт устанавливает минимальные пределы диапазонов арифметических типов, предусматривает заголовочные файлы&lt;limits.h&gt;и&lt;float.h&gt;,в которых помещаются эти характеристики для каждой конкретной реализации.
   • Перечисление -новый тип, которого не было в первой редакции.
   • Стандарт заимствует из C++ способ записи квалификатора типа, в частности квалификатораconst (A8.2).
   • Вводится запрет на модификацию строк: это значит, что их разрешается размещать в памяти, доступной только на чтение (ПЗУ).
   • Изменены "обычные арифметические преобразования"; по существу, выполнен переход от принципа "для целых всегда превалируетunsigned;для плавающей точки всегда используетсяdouble"к принципу "повышение до минимального достаточно вместительного типа" (см. A6.5).
   • Отменены старые операторы присваивания вроде=+.Каждый оператор присваивания теперь представляется одной отдельной лексемой. В первом издании оператор присваивания мог изображаться парой символов, возможно, разделенных символами-разделителями.
   • Компиляторам более не разрешается трактовать математическую ассоциативность операторов как вычислительную ассоциативность.
   • Введен унарный оператор+для симметрии с унарным-.
   • Разрешено использовать указатель на функцию в качестве ее именующего выражения без явного оператора* (см. A7.3.2).
   • Структурами разрешено оперировать при присваиваниях, можно передавать структуры в качестве аргументов функциям и получать их в качестве результата от функций.
   • Разрешено применять оператор получения адреса&к массиву; результатом является указатель на массив.
   • В первой редакции результат операцииsizeofимел типint;во многих реализациях он заменен наunsigned.Стандарт официально объявляет его зависимым от реализации, но требует, чтобы он был определен в заголовочном файле&lt;stddef.h&gt;под именемsize_t.Аналогичное изменение было сделано в отношении типа разности указателей) который теперь выступает под именемptrdiff_t (см. A7.4.8 и A7.7).
   • Запрещено применять оператор получения адреса&к объекту типаregisterдаже тогда, когда данный компилятор не располагает его на регистре.
   • Типом результата операции сдвига является тип ее левого операнда; тип правого операнда на повышение типа результата влияния не оказывает (см. A7.8).
   • Стандарт разрешает адресоваться с помощью указателей на место, лежащее сразу за последним элементом массива, и позволяет оперировать с такими указателями, как с обычными, см. A7.7.
   • Стандарт вводит (заимствованный из C++) способ записи прототипа функции с включением в него типов параметров и явного указания о возможности их изменения и формализует метод работы с переменным списком аргументов. (см. A7.3.2, A8.6.3, B7.) С некоторыми ограничениями доступен и старый способ записи.
   • Стандартом запрещены пустые объявления, т. е. такие, в которых нет объявителей и не объявляется ни одной структуры, объединения или перечисления. Однако объявление с одним тегом структуры (или объединения) переобъявит ее даже в том случае, если она была объявлена во внешней области действия.
   • Запрещены объявления внешних данных, не имеющие спецификаторов и квалификаторов (т. е. объявления с одним "голым" объявителем).
   • В некоторых реализациях, когдаextern-объявление расположено во внутреннем блоке, его область видимости распространяется на остальную часть файла. Стандарт вносит ясность в эту ситуацию и объявляет, что область видимости такого объявления ограничена блоком.
   • Область видимости параметров "вставляется" в составную инструкцию, представляющую собой тело функции, так что объявления на верхнем уровне функции не могут их "затенить".
   • Несколько изменены именные пространства идентификаторов. Всем тегам структур, объединений и перечислений стандарт выделяет одно именное пространство; для меток инструкций вводится отдельное именное пространство (см. A11.1). Кроме того, имена элементов связаны со структурой или объединением, частью которого они являются. (С некоторых пор это общепринятая практика.)
   • Допускается инициализация объединения; инициализатор относится к первому элементу объединения.
   • Разрешается инициализация автоматических структур, объединений и массивов, хотя и с некоторыми ограничениями.
   • Разрешается инициализация массива символов с помощью строкового литерала по точному количеству указанных символов (без '\0').
   • Управляющее выражение иcase-метки вswitchмогут иметь любой целочисленный тип.
   Предметный указатель
   0...константа восьмеричная 2.3, A2.5.1
   0x...константа шестнадцатеричная 2.3, A2.5.1
   ...многоточие 7.3, A7.3.2
   &gt;=оператор больше или равно 2.6, A7.9
   &gt;оператор больше чем 2.6, A7.9
   -оператор вычитания 2.5, A7.7
   --оператор декремента 1.5.2, 2.8, 5.5, A7.3.4, A7.4.1
   /оператор деления 1.2, 2.5, A7.6
   %оператор деления по модулю 2.5, A7.6
   .оператор доступа к элементу структуры 6.1, A7.3, A7.3.3
   -&gt;оператор доступа к элементу структуры через указатель 6.2, A7.3, A7.3.3
   ,оператор запятая 3.5, A7.18
   ++оператор инкремента 1.5.2, 2.8, 5.5, A7.4, A7.4.1
   *оператор косвенного доступа 5.1, A7.4.3
   &&оператор логического И 1.5.4, 2.6, 2.9, A7.14
   ||оператор логического ИЛИ 1.5.4, 2.6, 2.9, A7.15
   !оператор логического отрицания 2.6, A7.4, A7.4.7
   &lt;=оператор меньше или равно 2.6, A7.9
   &lt;оператор меньше чем 2.6, A7.9
   !=оператор неравенства 1.5.1, 2.6, A7.10
   &оператор побитового И 2.9, A7.11
   |оператор побитового ИЛИ 2.9, A7.13
   ^оператор побитового исключающего ИЛИ 2.9, A7.12
   ~оператор побитового отрицания 2.9, A7.4.6
   &оператор получения адреса 5.1, A7.4.2
   #оператор препроцессора 4.11.2, A12.3
   ##оператор препроцессора 4.11.2, A12.3
   =оператор присваивания 1.5.1, 2.6, A7.17
   +=оператор присваивания 2.10
   ==оператор равенства 1.5.3, 2.6, A7.10
   &lt;&lt;оператор сдвига влево 2.9, A7.8
   &gt;&gt;оператор сдвига вправо 2.9, A7.8
   +оператор сложения 2.5, A7.7
   *оператор умножения 2.5, A7.6
   -оператор унарный минус A7.4.5
   +оператор унарный плюс A7.4.4
   "символ двойная кавычка 1.1, 1.5.3, 2.3, A2.5.2, A2.6
   'символ кавычка 1.5.3, 2.3, A2.5.2
   \0символ нулевой 1.9, 2.3, A2.5.2
   \\символ обратная наклонная черта 1.1, 2.3
   _символ подчеркивания 2.1, A2.3, B
   ?:условное выражение 2.11, A7.16А
   аргументы командной строки 5.10Б
   бесконечный цикл for( ; ; ) 3.5, 4.11.2
   библиотечная функция 1.1, 4.1, 4.3, Приложение B
    abort B5
    abs B5
    acos B4
    asctime B10
    asin B4
    atan, atan2 7.8.6, B4
    atof B5
    atoi B5
    atol B5
    bsearch B5
    calloc 7.8.5, B5
    ceil B4
    clearerr B1.7
    clock B10
    cos 7.8.6, B4
    cosh B4
    ctime B10
    difftime B10
    div B5
    exit 7.6, B5
    exp 7.8.6, B4
    fabs 7.8.6, B4
    fclose 7.5, B1.1
    feof 7.6, B1.7
    ferror B1.7
    fflush B1.1
    fgetc B1.4
    fgetpos B1.6
    fgets 7.7, B1.4
    filecopy 7.6
    floor B4
    fmod B4
    fopen 7.5, B1.1
    fprintf 7.5, B1.2
    fputc B1.4
    fputs 7.7, B1.4
    fread B1.5
    free B5
    freopen B1.1
    frexp B4
    fscanf 7.5, B1.3
    fseek B1.6
    fsetpos B1.6
    ftell B1.6
    fwrite B1.5
    getc 7.5, B1.4
    getchar 1.5, 7.1, 7.5, B1.4
    getenv B5
    gets B1.4
    gmtime B10
    isalnum 7.8.2, B2
    isalpha 7.8.2, B2
    iscntrl B2
    isdigit 7.8.2, B2
    isgraph B2
    islower 7.8.2, B2
    isprint B2
    ispunct B2
    isspace 7.8.2, B2
    isupper 7.8.2, B2
    isxdigit B2
    labs B5
    ldexp B4
    ldiv B5
    localtime B10
    log, log10 7.8.6, B4
    longjmp B8
    malloc 6.5, 7.8.5, B5
    memchr B3
    memcmp B3
    memcpy B3
    memmove B3
    memset B3
    mktime B10
    modf B4
    perror B1.7
    pow 7.8.6, B4
    printf B1.2
    putc 7.5, B1.4
    putchar 1.5, 7.1, B1.4
    puts 7.7, B1.4
    qsort B5
    raise B9
    rand B5
    realloc B5
    remove B1.1
    rename B1.1
    rewind B1.6
    scanf 7.4, B1.3
    setbuf B1.1
    setjmp B8
    setvbuf B1.1
    signal B9
    sin 7.8.6, B4
    sinh B4
    sprintf 7.2, B1.2
    sqrt 7.8.6, B4
    srand B5
    sscanf B1.3
    strcat 7.8.1, B3
    strchr 7.8.1, B3
    strcmp 7.8.1, B3
    strcpy 7.8.1, B3
    strcspn B3
    strerror B3
    strftime B10
    strlen 7.8.1, B3
    strncat 7.8.1, B3
    strncmp 7.8.1, B3
    strncpy 7.8.1, B3
    strpbrk B3
    strrchr 7.8.1, B3
    strspn B3
    strstr B3
    strtod B5
    strtok B3
    strtol B5
    strtoul B5
    system B5
    tan B4
    tanh B4
    time B10
    tmpfile B1.1
    tmpnam B1.1
    tolower 7.8.2, B2
    toupper 7.8.2, B2
    ungetc 7.8.3, B1.4
    vfprintf 8.3, B1.2
    vprintf 8.3, B1.2
    vsprintf 8.3, B1.2
   бинарное дерево 6.5
   бинарный поток 7.5, B1
   битовое поле
    выравнивание 6.9, A8.3
    объявление 6.9, A8.3
   биты, образцы манипулирования 2.9, 6.9
   блок см.такжесоставная инструкция
    структура 3.1, 4.8, A9.3
    инициализация в. 4.9, A9.3
   буферизация см. setbuf, setvbuf
   буферизованный getchar 8.2
   быстрая сортировка 4.10, 5.6В
   ввод
    без буферизации 8.2
    возврат символа на 4.3
    с буферизацией 8.2
    с клавиатуры 1.1, 7.1, 8.1
    форматный см. scanf
   ввод-вывод
    символов 1.5, 7.1
    ошибки 7.6, B1.7
    перенаправление 7.1, 7.5, 8.1
    с терминала 1.5
   високосный год, вычисление 2.5, 5.7
   вывод на экран 1.5, 7.1, 7.5, 8.1
    перенаправление 7.1
    форматный см. printf
   вызов
    по значению 1.8, 5.2, A7.3.2
    по указателю 1.8, 5.3
   выравнивание битового поля
    с помощью union 8.7
    ограничения по 6.4, 6.5, 6.8, 7.8.5, 8.7, A6.6
   выражение A7
    в скобках A7.2
    константное 2.3, 3.4, 4.11.3, A7.19
    логическое, численное значение 2.7
    очередность вычисления 2.12, A7
    первичное A7.2
    присваивания 1.5.1, 1.5.4, 2.10, A7.17
   выражение-инструкция 3.1, 3.2, A9.2
   вычисление, порядок 1.5.4, 2.9, 2.12, 3.5, 4.3, 4.11.2, 5.1, A7
   вычитание из указателя 5.4, 6.4, A6.6Г
   грамматический разбор методом рекурсивного спуска 5.12
   граничные условия 1.5.2, 3.7Д
   деление целых 1.2, 2.5
   дерево
    бинарное 6.5
    разбора 5.12
   дескриптор файла 8.1
   длина
    имени 2.1, A2.3
    переменной A2.3
    строки 2.3Е
   единица трансляции A2, A7.17, A8.2З
   завершение программы 7.6
   загадочные числа 1.4
   знак, размножение 2.7, A2.5.2И
   идентификатор A2.3
   имени затенение 4.8
   имен пространство A11.1
   именующее выражение функции A7.3.2
   имя A2.3
   индекс отрицательный 5.3
   индексирование массива 1.6, 5.3, A7.3.1, A8.6.2
    и указатели 5.3, A8.6.2
   инициализатор 4.9, A8.7
   инициализация 2.4, 4.9, A8.7
    в блоке 4.9, A9.3
    двумерных массивов 5.7, A8.7
    массива 4.9, 5.8, A8.7
    массивов структур 6.3
    объединения A8.7
    переменных
     автоматических 1.10, 2.4, 4.9, A8.7
     внешних 2.4, 4.4, 4.9, A8.7
     статических 2.4, 4.9, A8.7
    по умолчанию 4.9, A8.7
    строковой константой 4.9, A8.7
    структуры 6.1, A8.7
    указателя 5.4
   инструкции A9
    выбора A9.4
    перехода A9.6
    присваивания вложенные 1.5.1, 1.5.4, 2.11
    последовательность выполнения A9.3
   инструкция
    окончание 1.5.2, 3.1
    помеченная A9.1
    пустая 1.5.2, A9.2
   исключительные ситуации B9К
   квалификатор типа A7.17, A8.2
   ключевые слова A2.4
   командная строка аргументов 5.10
   комментарий 1.2, A2.2, A12
   компиляция
    нескольких файлов 4.1
    раздельная 4, 4.4, A11
    Си-программ 1.1, 1.7
   конец файла см. EOF
   конкатенация
    лексем 4.11.2, A12.3
    строк 2.3, 4.11.2, A2.6
   константа 2.3, A2.5
    восьмеричная 0... 2.3, A2.5.1
    из расширенного набора A2.5.2
    перечисления 2.3, A2.5.4, A8.4
    символьная 1.5.3, 2.3, A2.5.2
    с плавающей точкой 1.2, 2.3, A2.5.3
    строковая 1.1, 1.5.3, 1.9, 2.3, 5.3, 5.5, A2.6
    суффикс 2.3, A2.5.1
    тип 2.2, A2.5
    шестнадцатеричная 0x... 2.3, A2.5.1
   константное выражение 2.3, 3.4, 4.11.3, A7.19Л
   лексема A2.1, A12.3
    конкатенация 4.11.2, A12.3
    подстановка A12.3
   лексика, соглашения A2
   лексикографическая сортировка 5.11
   лексическая область видимости A11.1
   литерал строковый см.константа строковаяМ
   макро-процессор 4.11, A12
    см. такжепрепроцессор
   макрос
    расширение A12.3
    с аргументами 4.11.2
    feof 8.5
    ferror 8.5
    getc 8.5
    putc 8.5
   массив
    а не указатель 5.3, 5.5, 5.7
    двумерный 5.7, A8.7
    имя в роли аргумента 1.8, 5.3, 5.7
    индексирование в 1.6, 5.4, A7.3.1
    многомерный 5.7, A8.6.2
    объявитель A8.6.2
    объявление 1.6, 5.7, A8.6.2
    порядок элементов в памяти 5.7, A8.6.2
    преобразование имени 5.3, A7.1
    размер по умолчанию 4.9, 5.8, 6.3
    символов 1.9, 5.5
    ссылки на элементы A7.3.1
    структур 6.3
     инициализация 6.3
    указателей 5.6
   масштабирование целых в арифметике с указателями 5.4, 6.4, A7.7
   метка 3.8, A9.1
    область видимости 3.8, A9.1, A11.1
    case 3.4, A9.1
    default 3.4, A9.1
   многопутевое ветвление 1.6, 3.3
   многоточие ... 7.3, A7.3.2
   множественное присваивание 1.5
   модульность 1.7, 1.9, 1.10, 4, 4.3, 5.6H
   небуферизованный getchar 8.2
   незавершенный тип A8.3
   неоднозначность if-else 3.2, A9.4, A13
   неправильная арифметика с указателями 5.4, 6.4, A7.7
   несоответствие типов объявлений 4.2
   нотация синтаксиса A3
   нуль, опущенная проверка на нуль 3.2, 5.5O
   область видимости A4, A11.1
    автоматических переменных 4.4, A11.1
    внешних объектов 4.4, A11.1
    лексическая A11.1
    меток 3.8, A9.1, A11.1
    правила определения 4.4, A10_2
   обобщенный указатель см.void *,указатель
   обратная польская запись 4.3
   объединение, тег A8.3
   объект A4.1, A5
   объявитель A8.5
   абстрактный A8.8
   массива A8.6.2
   функции A8.6.3
   объявление 1.2, 2.4, A8
    а не определение 1.10, 4.4, A8.1
    битового поля 6.9, A8.3
    внешнее A10, A10.2
    внешней переменной 1.10, A10
    класса памяти A8.1
    массива 1.6, 5.7, A8.6.2
    структуры 6.1, A8.3
    типа A8.6
    указателя 5.1, 5.3, A8.6.1
    функции A8.6.3
     неявное 1.7, 4.2, A7.3.2
     новым способом A7.3.2
     старым способом 1.7, 1.10, 4.2, A7.3.2
    typedef 6.7, A8.1, A8.9
    union 6.8, A8.3
   оператор
    больше&gt; 2.6, A7.9
    больше или равно&gt;= 2.6, A7.9
    вычитания - 2.5, A7.7
    декремента -- 1.5.2, 2.8, 5.5, A7.3.4, A7.4.1
    деления / 1.2, 2.5, A7.6
    деления по модулю % 2.5, A7.6
    доступа к элементу структуры
     точка . 6.1, A7.3, A7.3.3
     через указатель -&gt; 6.2, A7.3
    запятая , 3.5, A7.18
    инкремента ++ 1.5.2, 2.8, 5.5, A7.3.4, A7.4.1
    косвенного доступа * 5.1, A7.4.3
    логический отрицания ! 2.6, A7.4, A7.4.7
    логического И&& 1.5.4, 2.6, 2.9, A7.14
    логического ИЛИ || 1.5.4, 2.6, 2.9, A7.15
    меньше&lt; 2.6, A7.9
    меньше или равно&lt;= 2.6, A7.9
    неравенства != 1.5.1, 2.6, A7.10
    побитового отрицания ~ 2.9, A7.4.6
    получения адреса& 5.1, A7.4.2
    приведения к типу 2.7, 2.7, 6.5, A6.6, A7.5, A8.8
    присваивания = 1.5.1, 2.6, A7.17
    присваивания += 2.10
    равенства == 1.5.3, 2.6, A7.10
    сдвига влево&lt;&lt; 2.9, A7.8
    сдвига вправо&gt;&gt; 2.9, A7.8
    сложения + 2.5, A7.7
    умножения * 2.5, A7.6
    унарного минуса - A7.4.5
    унарного плюса + A7.4.4
    sizeof 4.11.3, 5.4, 6.3, A7.4, A7.4.8
   операторы
    аддитивные A7.7
    арифметические 2.5
    ассоциативность 2.12, A7
    мультипликативные A7.6
    отношения 1.5.1, 2.6, 2.7, A7.9
    побитовые 2.9, A7.11
    приоритет 1.5.1, 2.12, 5.1, 6.2, A7
    присваивания 2.6, 2.10, A7.17
    равенства 2.6, A7.10
   операции над
    объединениями 6.8
    указателями 5.4
   определение
    аргумента 1.7, A7.3.2
    внешней переменной 1.10, A10.2
    макросов A12.3
    памяти A8
    параметра 1.7, A7.3.2
    пробное A10.2
    удаление см. #undef
    функции 1.7, 4.1, A10.1
   опущенный спецификатор
    класса памяти A8.1
    типа A8.2
   отбрасывание
    значения с плавающей точкой 2.7, A6.3
    при делении 1.2, 2.5, A7.6
   отрицательные индексы 5.3
   отступы в тексте программы 1.2, 1.5.3, 1.6, 3.2П
   память
    автоматическая 1.10, A4.1
    класс A4.1
    объявление класса A8.1
    определение A8.1
    распределитель 6.5, 8.7
    резервирование A8.1
    спецификатор класса A8.1
     опущенный A8.1
    статическая 1.10, 4.6, A4.1
   параметр 4.7, 5.3, A7.3.2
    определение 1.7, A7.3.2
   первичное выражение A7.2
   переменная A4
    автоматическая 1.8, 4.3, A4.1
    адрес 1.8, 5.1, A7.4.2
    внешняя 1.10, 4.3, A4.1
    синтаксис имени 2.1, A2.1
   переносимость Введение, 2.3, 2.7, 6.7, 7, 8.6
   переполнение A6, B4, B9
   перечисление
    константа 2.3, A2.5.4, A8.4
    тег A8.4
    тип A4.2
   перечислитель A2.5.4, A8.4
   побочный эффект 2.12, 4.11.2, A7, A7.3.2
   повышение
    типа аргумента 2.7, A7.3.2
    целочисленное 2.7, A6.1
   подмассив-аргумент 5.3
   поле см. битовое поле
   польская запись 4.3
   порядок
    в записи числа 2.3, A2.5.3
    выполнения инструкций A9
    вычислений 1.5.4, 2.9, 2.12, 3.5, 4.3, 4.11.2, 5.1, A7
    трансляции A12
   поток
    бинарный 7.5, B1
    текстовый 1.5, 7.1, B1
   по умолчанию
    инициализация 4.9, A8.7
    размер массива 4.9, 5.8, 6.3
    тип функции 1.9, A7.3.2
   преобразование A6
    даты 5.7
    имени массива 5.3, A7.1
    инструкцией return 4.2, A9.6
    обычное арифметическое 2.7, A6.5
    оператором приведения 2.7, A6.6, A7.5
    присваиванием 2.7, A7.17
    символ - целое 1.6, 2.7, A6.1
    с плавающей точкой - целое 2.7, A6.3
    указатель - целое A6.6
    указателя 6.5, A6.6
    функции A7.1
    целое - символ 2.7
    целое - с плавающей точкой 1.2, A6.3
    целое - указатель A6.6
    double - float 2.7, A6.4
    float - double 2.7, A6.4
   препроцессор
    заранее определенные имена A12.10
     __FILE__ A12.10, B6
     __LINE__ A12.10, B6
    макрос 4.11, A12
    оператор препроцессора
     # 4.11.2, A12.3
     ## 4.11.2, A12.3
     defined 4.11.3, A12.5
   приведение к типу 2.7, A6.6, A7.5
   приоритеты операторов 1.5.1, 2.12, 5.1, 6.2, A7
   присваивание
    выражение 1.5.1, 1.5.4, 2.9, A7.17
    инструкция вложенная 1.5.1, 1.5.4, 2.10
    множественное 1.5.4
    подавленное scanf 7.4, B1.3
   пробное определение A10.2
   программа
    аргументы см. аргументы командной строки
    калькулятор 4.2, 4.3, 7.4
    конкатенации файлов 7.5
    копирования файлов 1.5.1, 8.2, 8.3
    перевода в нижний регистр 7.1
    печати
     каталога 8.6
     самой длинной строки 1.9, 1.10
    подсчета
     ключевых слов 6.3
     символов 1.5.2
     символов-разделителей 1.6, 3.4
     слов 1.5.4, 6.5
     строк 1.5.3
    поиска
     в таблице 6.6
     по образцу 4.1, 5.10
    преобразования температур 1.2
    сортировки 5.6, 5.11
    формат 1.2, 1.5.2, 1.6, 2.4, 6.4, A
    читаемость 1.2, 2.10, 3.6, 4.9, 6.7
   производные типы Введение, 1.2, A4.3
   пространство имен A11.1
   прототип функции 1.7, 1.9, 2.7, 4.2, 5.11, A7.3.2Р
   раскрытие указателя см.оператор косвенного обращения
   расположение фигурных скобок 1.2
   распределитель памяти 6.5, 8.7
   регистр, адрес A8.1
   резервирование памяти A8
   рекурсивный спуск в грамматическом разборе 5.12
   рекурсия 4.10, 6.5, 8.6, A7.3.2
   Ритчи Д. М. Предисловие к первому изданию
   Ричардс М. ВведениеС
   связь A4.1, A11.1
    внешняя 4.3, A2.3, A4.1, A8.1, A11.2
    внутренняя A4.1, A11.2
   символ
    беззнаковый 2.7, A4.2
    ввод-вывод 1.5
    вертикальная табуляция \v 2.3, A2.5.2
    возврат каретки \r 2.3, A2.5.2
    двойная кавычка " 1.1, 1.5.3, 2.3, A2.5.2, A2.6
    знаковый 2.7, A4.2
    кавычка ' 1.5.3, 2.3, A2.5.2
    новая страница \f 2.3, A2.5.2
    новая строка \n 1.1, 1.4, 1.5.3, 2.3, 2.3, A2.1, A2.5.2, A12.2, B1
    обратная наклонная черта \\ 1.1, 2.3
    подчеркивания _ 2.1, A2.3, B
    сигнал-звонок \a 2.3, A2.5.2
   символы
    набор A12
     ASCII 1.5.3, 2.3, 2.7, A12.1, B2
     EBCDIC 2.7
     ISO A12.1
    разделители 7.4, 7.8.2, A2.1, B1.3, B2
    строка см. константа строковая
   символы-разделители 7.4, 7.8.2, A2.1, B1.3, B2
   синтаксис имен переменных 2.1, A2.3
   системный вызов 8
    close 8.3
    creat 8.3
    fstat 8.6
    lseek 8.4
    open 8.3
    read 8.2
    sbrk 8.7
    stat 8.6
    unlink 8.3
    write 8.2
   склеивание строк A12.2
   сокрытие информации 4.1, 4.3, 4.3
   сортировка
    лексикографическая 5.11
    текстовых строк 5.6, 5.11
    численная 5.11
   составная инструкция 3.2, 4.8, A9.3, A9.5
   спецификатор
    класса памяти A8.1
     опущенный A8.1
    типа A8.2
    auto A8.1
    enum 2.3, A8.4
    extern 49-51, 4.4, A8.1
    register 4.7, A8.1
    static 4.6, A8.1
    struct A8.3
    union A8.3
   список
    аргументов переменной длины 7.3, 8.3, A7.3.2, A8.6.3, A10.1, B7
    ключевых слов A2.4
   сравнение указателей 5.4, 6.4, 8.7, A7.9
   стандартный
    ввод 7.1, 7.5, 8.1
    вывод 7.1, 8.1
   строка
    длина 2.3
    конкатенация 2.3, 4.11.2, A2.6
    пустая 2.3
    тип A7.2
   структура
    вложенная 6.1
    имя элемента 6.1, A8.3
    инициализация 6.1, A8.7
    объявление 6.1, A8.3
    оператор доступа к ее элементу
     . (точка) 6.1, A7.3.3
     через указатель -&gt; 6.2, A7.3.3
    размер 6.4, A7.4.8
    семантика ссылки на нее A7.3.3
    синтаксис ссылки на нее A7.3.3
    ссылающаяся на себя 6.5, A8.3
    тег 6.1, A8.3
    указатель на нее 6.4
   структуры взаимно рекурсивные 6.5, A8.3
   суффикс в константе A2.5.1Т
   таблица
    операторов 2.12
    преобразований в printf 7.2, B1.2
    преобразований в scanf 7.4, B1.3
    стандартных заголовочных файлов B
    эскейп-последовательностей 2.3, A2.5.2
   тег
    объединения A8.3
    перечисления A8.4
    структуры 6.1, A8.3
   текстовый поток 1.5, 7.1, B1
   тип
    имя A8.8
    квалификатор A7.17, A8.2
    константы 2.3, A2.5
    незавершенный A8.3
    несовместимость в объявлениях 4.2
    объявление A8.6
    опущенный спецификатор A8.2
    правила преобразования 2.7, A6.5
    преобразование в return 4.2, A9.6
    спецификатор A8.2
    строки A7.2
    эквивалентность A8.9
   типы
    арифметические 5.4
    базовые 1.2, 55, A4.2
    производные Введение, 1.2, A4.3
    с плавающей точкой A4.2
    целочисленные A4.2
   Томпсон К. Л. Введение
   точка с запятой ; 1.2, 1.4, 1.5.2, 3.1, 3.2
   транслируемая единица (единица трансляции) A2, A10, A11
   трансляция
    порядок A12
    фазы A2, A12
   трехзнаковая последовательность A12.1У
   удаленное определение см. #undef
   указатели
    арифметика с 5.1, 5.3, 5.4, 5.10, 6.4, A7.7
    вычитание 5.4, 6.4, A6.6
    и индексирование 5.3, A8.6.2
    коэффициент домножения целых в арифметике с 5.4, 6.4, A7.7
    массив из 5.6
    неправильная арифметика с 5.4, 6.4, A7.7
    операции над 5.4
    сравнение 5.4, 6.4, 8.7, A7.9
   указатель
    а не массив 5.3, 5.5, 5.7
    аргумент 5.2, 5.3
    генерация A7.1
    инициализация 5.4
    на структуру 6.4
    на функцию 5.11, 6.7, A7.3.2
    объявление 5.1, 5.3, A8.6.1
    преобразование 6.5, A6.6
    пустой 5.4, A6.6
    файла 7.5, 8.5, B1
    void * 5, 5.4, 5.11, A6.8
   управляющая строка 4.11, A12.3
   управляющий символ B2
   условная компиляция 4.11.3, A12.5
   условное выражение 2.11, A7.16Ф
   фазы трансляции A12
   файл
    включаемый
     dir.h 8.6
     fcntl.h 8.3
     stat.h 8.6
     syscalls.h 8.2
     types.h 8.6
    включение 4.11
    дескриптор 8.1
    добавление к 7.5, 8.4, B1
    доступ к 7.5, 8.1, 8.5, B1
    заголовочный 1.10, 4.5
    &lt;assert.h&gt; B6
    &lt;ctype.h&gt; 2.7, B2
    &lt;errno.h&gt; B1.7
    &lt;float.h&gt; 2.2, B11
    &lt;limits.h&gt; B11
    &lt;locale.h&gt; B
    &lt;math.h&gt; 2.7, B4
    &lt;setjmp.h&gt; B8
    &lt;signal.h&gt; B9
    &lt;stdarg.h&gt; 7.3, 8.3, B7
    &lt;stddef.h&gt; 5.4, B
    &lt;stdio.h&gt; 1.1, 1.5.1, 4.11.1, 4.11.2, 5.4, 7, 7.1, B
    &lt;stdlib.h&gt; 4.2, 6.5, B, B5
    &lt;string.h&gt; 2.3, 5.6, B3
    &lt;time.h&gt; B10
    открытие 7.5, 8.1, 8.3
    права доступа 8.3
    режим доступа 7.5, 8.5, B1.1
    создание 7.5, 8.1
    суффикс имени .h 1.10
    указатель 7.5, 8.5, B1
   фигурные скобки 1.1, 1.2, 3.1, 4.7
    расположение 1.2
   формальный параметр
    см. параметр
   форматный
    ввод см. scanf
    вывод см. printf
   функции проверки символов 7.8.2, B2
   функция
    аргумент 1.7, A7.3.2
    аргумента преобразование см.повышение типа аргумента
    в новом стиле A7.3.2
    в старом стиле 1.7, 1.10, 4.2, A7.3.2
    вызов
     семантика A7.3.2
     синтаксис A7.3.2
    длина имени 2.1, A2.3
    именующее выражение A7.3.2
    неявное объявление 1.7, 4.2, A7.3.2
    объявление A8.6.3
    определение 1.7, 4.1, A10.1
    преобразование имени A7.3.2
    прототип 1.7, 1.9, 2.7, 4.2, 5.11, A7.3.2
    пустая 4.1
    тип по умолчанию 1.9, A7.3.2
    указатель на 5.11, 6.7, A7.3.2
    addpoint 6.2
    addtree 6.5
    afree 5.4
    alloc 5.4
    atof 4.2
    atoi 2.7, 3.5, 4.2
    binsearch 6.3, 6.4
    bitcount 2.10
    canonrect 6.2
    cat 7.5
    closedir 8.6
    copy 1.9, 1.10
    day_of_year 5.7
    dcl 5.12
    dirdcl 5.12
    dirwalk 8.6
    echo 5.10
    error 8.3
    fgets 7.7
    _fillbuf 8.5
    fopen 8.5
    fputs 7.7
    free 8.7
    fsize 8.6
    getbits 2.9
    getch 4.3
    getint 5.2
    getline 1.9, 1.10, 4.1
    getop 4.3
    gettoken 5.12
    getword 6.3
    hash 6.6
    install 6.6
    itoa 3.6
    lookup 6.6
    lower 2.7
    main 1.1
    makepoint 6.2
    malloc 8.7
    month_day 5.7
    month_name 5.8
    morecore 8.7
    numcmp 5.11
    opendir 8.6
    pop 4.3
    power 1.7, 1.8
    printd 4.10
    ptinrect 6.2
    push 4.3
    qsort 4.10, 5.6, A7.3.2
    rand 2.7
    readdir 8.6
    readlines 5.6
    reverse 3.5
    shellsort 3.5
    squeeze 2.8
    srand 2.7
    strcat 2.8
    strcmp 5.5
    strcpy 5.5
    strdup 6.5
    strindex 4.1
    strlen 2.3, 5.3, 5.4
    swap 4.10, 5.2, 5.6, 5.11
    talloc 6.5, 6.7
    treeprint 6.5
    trim 3.7
    undcl 5.12
    ungetch 4.3
    writelines 5.5Х
   XoapЧ.A.P. 4.10Ц
   целая константа 2.3, A2.5.1
   целочисленное повышение 2.7, A6.1
   целочисленные типы A4.2
   цикл см. while, for, do
   циклические инструкции A9.5Ч
   числа
    размер 1.2, 1.5.2, 2.2, B11
    сортировка 5.11
   численное значение
    выражения отношения 2.6, 2.7
    логического выражения 2.7Ш
   Шелл Д.Л. 3.5
   шестнадцатеричная константа 0х 2.3, A2.5.1Э
   эквивалентность типов A8.10
   экспоненциальная функция 1.7, B4
   элемент структуры, имя 4.3, A8.3
   эскейп-последовательность 1.1, 1.5.3, 2.3, A2.5.2
    шестнадцатеричная \x 2.3, A2.5.2
   эффективность 2.10, 4.7, 4.10, 6.5, 8.7A
   \a 2.3, A2.5.2
   American National Standards Institute (ANSI)Предисловие, A
   a.out 1.1, 4.1
   argc 5.10
   argv 5.10
   ASCII 1.5.3, 2.3, 2.7, A12.1, B2
   asm A2.4
   auto A8.1B
   \b (забой) 1.1, 2.3, A2.5.2
   break 3.4, 3.7, A9.6
   BUFSIZ B1.1C
   case-метка 3.4, A9.1
   cc 1.1, 4.1
   char 1.5.1, 2.2, 2.2, A4.2, A8.2
   CLOCKS_PER_SEC B10
   clock_t B10
   const 2.4, A8.2
   continue 3.7, A9.6D
   default 3.4, A9.4
   #define 1.4, 4.11.2, A12.3
    вместо enum 2.3, 5.12
    в несколько строк 4.11.2
    с аргументами 4.11.2
   defined 4.11, A12.5
   DIR-структура 8.6
   Dirent-структура 8.6
   div_t B5
   do-инструкция 3.6, A9.5
   double
    константа 2.3, A2.5.3
    тип 1.2, 1.5.2, 2, 2.2, A4.2, A8.2E
   E (спецификатор порядка) 2.3, A2.5.3
   EBCDIC 2.7
   EDOM B4
   #elif 4.11.3
   elseсм. if-else-инструкция
   #else 4.11.3
   else-if 1.6, 3.3
   #endif 4.11.3
   enum
    а не #define 2.3, 6.9
    спецификатор 2.3, A8.4
   EOF 1.5.1, 7.1, B1.1
   ERANGE B4
   errno B1.7, B4
   #error A12.7
   EXIT_FAILURE, EXIT_SUCCESS B5
   extern 1.10, 4.4, A8.1F
   \fсимвол новой страницы 2.3, A2.5.2
   __FILE__ (имя для препроцессора) B6
   FILE 7.5
   FILENAME_MAX B1.1
   float
    константа 2.3, A2.5.3
    тип 1.5.2, 2.2, A4.2, A8.2
   FOPEN_MAX B1.1
   for( ; ; )бесконечный цикл 3.5, 4.11.2
   forвместо while 1.3, 3.5
   for-инструкция 1.3, 1.5.2, 3.5, A9.5
   fortran A2.4
   fpos_t B1.6G
   getchar
    без буферизации 8.2
    с буферизацией 8.2
   goto-инструкция 3.8, A9.6H
   .h (суффикс имени файла) 1.10
   hash-таблица 6.6
   HUGE_VAL B4I
   #if 4.11.3, 6.3, A12.5
   #ifdef 4.11.3, A12.5
   if-else
    инструкция 1.5.2, 1.5.4, 3.1, A9.4
    неоднозначность 3.2, A9.4, A13
   #ifndef 4.11.3, A12.5
   #include 1.10, 4.11.1, 7.1, A12.4
   inode 8.6
   int,тип 1.2, 2.2, A8.2
   _IOFBF, _IOLBF, _IONBF B1.1
   ISO A12.1L
   %ldпреобразование 1.5.2
   ldiv_t B5
   #line A12.6
   __LINE__ (имя для препроцессора) B6
   long
    константа 2.3, A2.5.1
    тип 1.2, 1.5.2, 2.2, A4.2, A8.2
   long double
    константа 2.3, A2.5.3
    тип 2.2, A4.2
   LONG_MAX, LONG_MIN B5
   ls 8.6
   lvalue A5M
   main,возврат из 1.7, 7.6N
   \nсимвол новая строка 1.1, 1.5, 1.5.3, 2.3, 2.3, A2.5.2, B1
   NULL 5.4
   null-символ, \0 1.9, 2.3, A2.5.2
   null-указатель 5.4, A6.6O
   O_RDONLY, O_RDWR, O_WRONLY 8.3P
   #pragma A12.8
   ptrdiff_t 5.4, 6.7R
   \rсимвол возврат каретки 2.3, A2.5.2
   RAND_MAX B5
   register 4.7, A8.1
   return
    из main 1.7, 7.6
    преобразование типа в 4.2, A9.6
   return-инструкция 1.7, 1.9, 4.1, 4.2, A9.6S
   scanf,подавление присваивания в 7.4, B1.3
   SEEK_CUR, SEEK_END, SEEK_SET B1.6
   short 1.2, 2.2, A4.2, A8.2
   SIG_DFL, SIG_ERR, SIG_IGN B9
   signed 2.2, A8.2
   size_t 5.4, 6.3, 6.7, A7.4.8, B1.1
   static
    объявление функции 4.6
    спецификатор класса памяти 4.6, A8
    статические переменные
     внешние 4.6
     внутренние 4.6
   stderr 7.5, 7.6, B1
   stdin 7.5, B1
   &lt;stdio.h&gt; 8.5
   stdout 7.5, B1
   struct,спецификатор A8.3
   switch-инструкция 3.4, 4.3, A9.4T
   \tсимвол табуляция 2.3, A2.5.2
   time_t B10
   TMP_MAX B1.1
   typedef-объявление 6.7, A8.1, A8.9U
   ULONG_MAX B11
   #undef 4.11.2, 8.2, A12.3
   union
    выравнивание с помощью 8.7
    объявление 6.8, A8.3
    спецификатор A8.3
   UNIX,файловая система 8.1, 8.6
   unsigned
    константа 2.3, A2.5
    тип 2.2, 2.10, A4.2, A8.2
   unsigned char (тип) 2.2, 8.2
   unsigned long (константа) 2.3, A2.5.1V
   \vсимвол вертикальная табуляция 2.3, A2.5.2
   va_list, va_start, va_arg, va_end 7.3, 8.3, B1.2, B7
   void
    список аргументов 1.10, 4.2, A8.6.3, A10.1
    тип 1.9, A4.2, A6.7, A8.2
    указатель 5, 5.4, 5.11, A6.8
   volatile A4.4, A8.2W
   wchar_t A2.5.2
   while
    инструкция 1.2, 3.5, A9.5
    против for 1.3, 3.5X
   \х шестнадцатеричная эскейп-последовательность 2.3, A2.5.2

Взято из Флибусты, http://flibusta.net/b/168075
