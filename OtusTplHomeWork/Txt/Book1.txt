
   C++
   Сборник рецептов
   Предисловие
   C++работает практически на любой платформе и используется в бесчисленном количестве приложений. Если вы купили или собираетесь купить эту книгу, вы, вероятно, являетесь программистом, инженером или исследователем, пишущим одно из таких приложений. Но независимо от того, что и для какой платформы вы пишете, велика вероятность, что вам придется снова решать многие из тех же проблем, которые уже решены другими программистами на C++ много лет назад. В этой книге мы будем решать многие из часто встречающихся проблем и объяснять каждое из решений.
   Независимо от того, программируете ли вы на C++ уже много лет или используете его недавно, вы, скорее всего, знакомы с фрагментами, которые приходится переписывать для каждого нового проекта: арифметика и синтаксический анализ дат и времени, манипуляции со строками и текстом, работа с файлами, синтаксический анализ XML, использование стандартных контейнеров и т.п. Решения для всех таких проблем приведены в этой книге. Для некоторых случаев (например, арифметические операции с датами и временем) стандартная библиотека почти не содержит поддержки. Для других (например, работа со строками) стандартная библиотека содержит функционально богатые классы, но они не могут делать все, и решения некоторых очень часто встречающихся задач оказываются громоздкими.
   Формат очень прост. Каждый рецепт содержит описание проблемы и код решения, а большинство содержит последующее обсуждение. Мы попытались быть прагматиками и решать проблемы, не слишком отклоняясь от цели, но во многих случаях имеются связанные проблемы, решение которых также очень полезно (или просто интересно), и мы приводим одну или две страницы пояснений.
   Эта книга посвящена решению общих проблем с С++, но не является книгой для изучения С++. Мы предполагаем, что вы, по крайней мере, обладаете базовыми знаниями C++ и объектно-ориентированного программирования. В частности, будет полезно, если вы знакомы, по крайней мере, с:
   • наследованием и виртуальными функциями С++;
   • стандартной библиотекой;
   • компонентами Standard Template Library (стандартной библиотекой шаблонов) (контейнерами, итераторами и алгоритмами);
   • шаблонами.
   Для чтения этой книги нет строгих предварительных требований, но наличие базовых знаний окажется весьма кстати.О примерах
   При создании наших примеров кода мы стремились к простоте, переносимости и производительности. Разработка каждого решения использовала сходный метод: если возможно, использовался стандартный C++ (язык или библиотека); если невозможно, то в качестве замены использовался стандарт де-факто. Например, многие из рецептов, относящихся к строкам, применяют стандартный классstring,а большинство математических и научных рецептов используют стандартные численные типы, контейнеры и шаблоны. Стандартная библиотека имеет мощную поддержку в этих областях, так что стандартных возможностей более чем достаточно. Однако C++ либо имеет слабую стандартную поддержку, либо не имеет ее вовсе в части многопоточностиили синтаксического анализа XML. Таким образом, мы используем поддержку многопоточности, предоставляемую библиотекой Boost Threads, а для функциональности синтаксического анализа XML-парсер (parser) Xerces.
   Часто в C++ имеется множество способов сделать одно и то же, что дает разработчикам определенную гибкость, но и приводит к спорам. Большая часть примеров иллюстрирует наилучшее общее решение, которое мы смогли найти, но это не означает, что не существует еще лучшего решения. Если есть альтернативные решения, которые оказываются лучшими в одних случаях, но не являются таковыми в других (возможно, решение, использующее стандартную библиотеку, некрасиво или неинтуитивно — в этом случае мы показываем альтернативное решение с использованием Boost), мы представляем альтернативные решения, чтобы показать вам различные имеющиеся решения.
   Большое количество примеров используют шаблоны. Если у вас нет опыта в написании шаблонов, вам следует получить его как можно скорее. В этой книге очень мало вводного материала по шаблонам, за исключением двух рецептов в главе 8: 8.11 и 8.12. Большая часть интересных разработок на C++ относится к области метапрограммирования с использованием шаблонов и методического проектирования.
   В момент написания этой книги в сообществе C++ происходят большие изменения. Первый технический отчет (называемый TR1) более или менее стабилен. Он стандартизирует набор функций, которые будут добавлены в следующую версию стандарта С++. Не существует требования поддержки его реализациями стандартной библиотеки, но многие поставщики уже начали реализовывать TR1, и можно ожидать, что скоро эти функции появятся в поставляемых компиляторах. Многие из библиотек из TR1 впервые появились в проектеBoost.
   Мы активно используем библиотеки из Boost. Boost — это набор рецензируемых переносимых библиотек с открытым кодом, который заполняет многие пробелы в стандартной библиотеке. Текущая версия в момент написания книги 1.32, и скоро должна появиться версия 1.33. В примерах мы приводим много указаний на конкретные библиотеки Boost. Для получения дополнительной информации по Boost посетите Web-сайт проекта по адресуwww.boost.org.Соглашения, принятые в этой книге
   В этой книге используются следующие типографские соглашения.
   Курсив
   Указывает на новые термины, URL, адреса e-mail, имена файлов, расширения файлов, пути, директории, утилиты Unix, команды и параметры командной строки.
   &lt;...&gt;
   В угловые скобки заключены элементы, которые требуется указать в командах и параметрах командной строки, и они выделены курсивом.
   Шрифт постоянной ширины
   Указывает код или его фрагменты. Например, шрифтом постоянной ширины набраны имена классов, методов и другие подобные элементы, при их появлении в тексте.
   Жирный шрифт постоянной ширины
   Показывает ввод пользователя в примерах ввода-вывода.
   Курсив постоянной ширины
   Указывает задаваемые пользователем элементы в примерах синтаксиса.
    [Картинка: tip_yellow.png] Указывает на подсказки, советы или общие замечания.
    [Картинка: warning_yellow.png] Указывает на предупреждения или предостережения.Использование примеров кода
   Целью этой книги является помощь в вашей работе. Вы можете использовать код этой книги в ваших программах и документации. Вам не требуется обращаться к нам за разрешением, если вы не воспроизводите значительные фрагменты кода. Например, написание программы, которая использует несколько небольших кусков кода из этой книги, нетребует разрешения. Продажа или распространение CD-ROM с примерами книг O'Reilly требует разрешения. Ответы на вопросы с помощью цитат из этой книги и цитирования кода не требуют разрешения. Встраивание значительного количества примеров кода из этой книги в вашу документацию к продукту требует разрешения.
   Мы приветствуем, но не требуем полного указания источника. Обычно указание источника включает название, автора, издателя и ISBN. Например: «C++ Cookbook by D. Ryan Stephens, Christopher Diggins, Jonathan Turkanis, and Jeff Cogswell. Copyright 2006 O'Reilly Media, Inc., 0-596-00761-2».
   Если вы полагаете, что использование вами примеров кода выходит за рамки личного пользования или подпадает под один из требующих разрешения вариантов, указанных выше, свяжитесь с нами по адресуpermissions@oreilly.com.Комментарии и вопросы
   Пожалуйста, направляйте комментарии и вопросы по этой книге издателю:
   O'Reilly Media, Inc.
   1005 Gravenstein Highway North
   Sebastopol, CA 95472
   (800) 998-9938 (в США и Канаде)
   (707) 829-0515 (международная или местная поддержка)
   (707) 829-0104 (факс)
   Для этой книги имеется Web-страница, на которой приводятся все исправления, примеры и дополнительная информация. Эта страница находится по адресу:
   http://www.oreilly.com/catalog/cplusplusckbk
   Чтобы высказать комментарий или задать технический вопрос по этой книге, отправьте электронное письмо по адресу:
   bookquestions@oreilly.com
   Для получения дополнительной информации о нашей книге, ссылок, содержимого Resource Centers и сети O'Reilly Network посетите наш Web-сайт:
   http://www.oreilly.comSafari Enabled
    [Картинка: img_1.png] Когда вы на обложке вашей любимой технической книги видите пиктограмму Safari® Enabled, это означает что книга доступна в сети через O'Reilly Network Safari Bookshelf.
   Safariпредлагает решение лучшее, чем электронные книги. Это виртуальная библиотека, которая позволяет вам с легкостью выполнять поиск по тысячам лучших технических книг, использовать примеры кода из них, скачивать главы и быстро находить ответы, получая наиболее точную и современную информацию. Попробуйте сделать это по адресуhttp://safari.oreilly.com.БлагодарностиОт Д. Райана Стивенса (D. Ryan Stephens)
   Наиболее важными людьми, которых я хочу поблагодарить, являются моя жена Дафна (Daphne) и мои дети Джесс (Jesse), Паскаль (Pascal) и Хлоя (Chloe). Написание книги это тяжелый труд,но еще важнее, что он отнимает много времени, и моя семья поддерживала меня и стойко терпела мою работу допоздна.
   Я также благодарю технических редакторов, сделавших эту книгу лучше, чем она могла бы быть. Как и во многих других случаях, всегда полезно иметь вторую, третью и четвертую пару глаз, которые оценят ясность изложения и его правильность. Большое спасибо Дэну Саксу (Dan Saks), Уве Шниткер (Uwe Schnitker) и Дэвиду Тизу (David Theese).
   Наконец, я должен поблагодарить моего редактора Джонатана Генника (Jonathan Gennick) за его всегда полезные советы по вопросам грамматики, стиля изложения и за философскую поддержку.От Кристофера Диггинса (Christopher Diggins)
   Я хочу поблагодарить Криса Ангера (Kris Unger), Джонатана Турканиса (Jonathan Turkanis), Джонатана Генника (Jonathan Gennick) и Райана Стивенса (Ryan Stephens) за их полезные предложения и критику, которые помогли мне писать лучше, чем я мог. Отдельное большое спасибо моей жене Мелани Карбонно (Melanie Charbonneau) за то, что она сделала мою жизнь светлее.От Джонатана Турканиса (Jonathan Turkanis)
   Так как мои главы затрагивают так много различных коммерческих продуктов и проектов с открытыми кодами и по каждому из них у меня было так много вопросов, мой список благодарностей необычно велик.
   Во-первых, позвольте мне поблагодарить Рона Лихти (Ron Liechty), Говарда Хиннанта (Howard Hinnant) и инженеров в Metrowerks за их ответы на все мои вопросы и предоставление мне нескольких версий CodeWarrior.
   Также я хочу поблагодарить разработчиков Boost.Build, особенно Владимира Пруса (Vladimir Prus), Рене Ривера (Rene Rivera) и Девида Абрамса (David Abrahams) — не только за ответы на мои вопросы, но также и за сборку системы компиляции Boost, которая сама по себе стала наиболее важным источником информации в главе 1.
   Кроме того, спасибо Вальтеру Брайту (Walter Bright) из Digital Mars; Грегу Комю (Greg Comeau) из Comeau Computing; Пи Джей Плагеру (Р. J. Plauger) из Dinkumware; Колину Лапласу (Colin Laplace) из Bloodshed Software; Эду Малрою (Ed Mulroy) и Павлу Возенилеку (Pavel Vozenilek) из группы новостей borland.public.*; Арноду Дебене (Arnaud Debaene) и Игорю Тандетнику (Igor Tandetnik) из microsoft.public.vc.languages; Эрни Бойду (Earnie Boyd), Грегу Чикаресу (Greg Chicares), Адибу Тарабену (Adib Taraben), Джону Ванденбергу (John Vandenberg) и Леннарту Боргману (Lennart Borgman) из списка рассылки MinGW/MSYS; Кристоферу Фейлору (Christopher Faylor), Ларри Холлу (Larry Hall), Игорю Петчански (Igor Pechtchanski), Джошуа Даниелю Франклину (Joshua Daniel Franklin) и Дэйву Корну (Dave Korn) из списка Cygwin; Майку Стампу (Mike Stump) и Джефри Китингу (Geoffrey Keating) из списка разработчиков GCC; Марку Гудхенду (Mark Goodhand) из DecisionSoft и Дэвиду Н. Бертони (David N. Bertoni) из apache.org.
   Я также в долгу перед Робертом Мекленбургом (Robert Mecklenburg), чье третье издание книгиManaging Projects with GNU make (O'Reilly)дало основу моему знакомству с GNU make.
   Кроме того, Владимир Прус (Vladimir Prus), Мэтью Вилсон (Matthew Wilson), Райан Стивенc (Ryan Stephens) и Кристофер Диггинс (Christopher Diggins) выполнили подробный анализ ранних черновиков моихтекстов.
   Наконец, я должен поблагодарить моего редактора Джонатана Генника (Jonathan Gennick), мою жену Дженнифер (Jennifer) и моего деда Луиса С. Гудмэна (Louis S. Goodman), научившего меня писать.
   Глава 1
   Сборка приложений на C++
   1.0.Введение в сборку
   Эта глава содержит рецепты по преобразованию исходного кода на C++ в исполняемые программы и библиотеки. При изучении этих рецептов вы узнаете об основных инструментах, используемых при сборке приложений на С++, различных типах двоичных файлов, используемых в этом процессе, и системах, предназначенных для упрощения управленияпроцессом сборки.
   Если посмотреть на названия рецептов в этой главе, то можно получить впечатление, что я снова и снова решаю одни и те же проблемы. И это будет правильно. Это происходит потому, что имеется большое количество способов сборки приложений С++, и хотя я не могу описать их все, я пытаюсь описать несколько наиболее важных методов. В первой десятке рецептов я показываю, как различными методами выполнять три базовые задачи - собирать статические библиотеки, собирать динамические библиотеки и собирать исполняемые файлы. Рецепты сгруппированы по методам; сначала я рассматриваю сборку из командной строки, затем с помощью системы Boost (Boost.Build), затем с помощью интегрированной среды разработчика (Integrated Development Environment (IDE), и наконец, с помощью GNUmake.
   Прежде чем вы начнете читать рецепты, обязательно прочтите следующие вводные разделы. Я объясню некоторую базовую терминологию, дам обзор инструментов командной строки, систем сборки и IDE, описываемых в этой главе, и покажу примеры исходного кода.
    [Картинка: tip_yellow.png] Даже если вы будете использовать систему сборки или IDE, вы должны начать с чтения рецептов по сборке из командной строки: эти рецепты представляют некоторые важныеконцепции, которые потребуются для понимания материала в дальнейшей части этой главы.Базовая терминология
   Три базовых инструмента, используемых для сборки приложений С++, — этокомпилятор,компоновщикиархиватор (илибиблиотекарь).Набор этих программ и, возможно, других инструментов называетсяинструментарием.
   Компилятор принимает на входе исходные файлы на C++ и создаетобъектные файлы,которые содержат смесь исполняемого машинного кода и символьных ссылок на функции и данные. Архиватор на входе принимает набор объектных файлов и создаетстатическую библиотеку,или архив, который просто является подборкой объектных файлов, собранных для удобства использования вместе. Компоновщик принимает на входе набор объектных файлов и библиотек и разрешает их символьные ссылки, создавая либоисполняемый файл,либодинамическую библиотеку.Грубо говоря, компоновщик выполняет работу по сопоставлению каждого использования символа с его определением. Когда создается исполняемый файл или динамическая библиотека, то говорят, что оникомпонуются (линкуются)используемые при их построении библиотеки называютсяприлинкованными.
   Исполняемый файл, илиприложение,— это просто любая программа, которая может выполняться операционной системой. Динамическая библиотека, также называемаясовместно используемой библиотекой,похожа на исполняемый файл, за исключением того, что она не может исполняться самостоятельно. Она состоит из тела машинного кода, которое загружается в память после запуска приложения, и может использоваться одним или несколькими приложениями. В Windows динамические библиотеки также называютсядинамически подключаемыми библиотеками (dynamic link libraries (DLL)).
   Объектные файлы и статические библиотеки, от которых зависит исполняемый файл, требуются только при сборке исполняемого файла. Однако динамические библиотеки, откоторых зависит исполняемый файл, должны иметься в системе пользователя при запуске исполняемого файла.
   Таблица 1.1 приводит расширения файлов, обычно связанные с этими четырьмя базовыми типами файлов в Microsoft Windows и Unix. Когда я упоминаю файл, имеющий в Windows и Unix различные расширения, я иногда опускаю расширение, если оно ясно из контекста.

   Табл. 1.1. Расширения файлов в Windows и UnixТип файлаWindowsMac OS XДругие UnixОбъектные файлы.obj.o.oСтатические библиотеки.lib.a.aДинамические библиотеки.dll.dylib.soИсполняемые файлы.exeНет расширенияНет расширения
    [Картинка: tip_yellow.png] В этой главе, когда я говорю Unix, я также имею в виду и Linux.
    [Картинка: tip_yellow.png] При сборке примеров из этой главы ваши инструменты будут создавать большое количество вспомогательных файлов с расширениями, не приведенными в табл. 1.1. Если я не указываю другого, вы можете игнорировать эти файлы. Если вы действительно хотите знать, для чего они нужны, обратитесь к документации по вашему инструментарию.IDEи системы сборки
   Компилятор, компоновщик и архиватор — этоинструменты командной строки,что означает, что они предназначены для запуска из оболочки, такой какbashв Unix илиcmd.exeв Microsoft Windows. Имена входных и выходных файлов, а также вся остальная необходимая настроечная информация передаются в компилятор, компоновщик и архиватор как текст в командной строке. Однако вызов этих команд вручную довольно утомителен. Даже для небольших проектов может быть сложно запомнить параметры командной строки для каждого инструмента и порядок, в котором исходные и двоичный файлы проекта должны компилироваться и компоноваться. При изменении одного исходного файла вы должны определить, какие объектные файлы требуется перекомпилировать, какие статические библиотеки требуется обновить и какие исполняемые файлы или динамические библиотеки требуется перекомпоновать. Если вы пересоберете больше файлов, чем требуется, вы зря потратите время, а если пересоберете не все требуемые, то получите ошибки при сборке или неработоспособное приложение. В случае больших проектов на С++, которые могут включать тысячи отдельных файлов, включая исходные файлы, объектные файлы, библиотеки и исполняемые файлы, сборка из командной строки просто невозможна.
   Имеется два основных подхода к сборке больших приложений на С++.
   • IDE предоставляет графический интерфейс для организации набора исходных файлов и описания двоичных файлов, которые из них должны быть сгенерированы. После указания этой информации вы можете сгенерировать двоичные файлы просто выбрав в меню или на панели инструментов соответствующую команду. IDE отвечает за определение порядка генерации двоичных файлов, вызов инструментов, необходимых для их генерации, и опций командной строки, которые требуется передать в эти инструменты. Когда вы изменяете один или несколько исходных файлов вы можете указать IDE сгенерировать только устаревшие двоичные файлы.
   IDEорганизуют исходные файлы в наборы, которые называютсяпроектами.Проекты IDE обычно связаны с единственным двоичным файлом или несколькимивариантамиодного двоичного файла, такими как отладочная и окончательная сборки приложения. Большинство IDE позволяет пользователю организовать проекты в группы, которые называютсягруппами проектовилирешениями,и указать зависимости между проектами в группе.
   • Система сборкипредоставляет формат текстового файла для описания набора исходных и генерируемых из них двоичных файлов, а такжеинструмент сборки,который читает эти текстовые файлы и генерирует двоичные файлы, вызывая соответствующие инструменты командной строки. Обычно эти текстовые файлы создаются и редактируются с помощью текстового редактора, а инструмент сборки вызывается из командной строки. Однако некоторые системы сборки предоставляют для редактирования этих файлов и вызова инструмента сборки графический интерфейс.
   В то время как IDE организует файлы впроекты,система сборки организует файлы вцели.Большинство целей соответствует генерируемым двоичным файлам, другие соответствуют действиям, выполняемым инструментом сборки, таким как установка приложения.
   Наиболее часто в качестве инструмента сборки используется утилитаmake;текстовые файлы, на которых она основана, называютсяmakefile (make-файл). Хотя имеется множество версийmake,в этой главе я обсуждаю GNUmake— наиболее мощную и переносимую инкарнациюmake. GNUmake— это очень гибкий инструмент, который может использоваться не только для сборки приложений на С++. Он также имеет целый ряд преимуществ и широко используется и хорошо понимается разработчиками. К сожалению, заставить GNUmakeсделать именно то, что вам требуется, может оказаться не так просто, особенно в случае сложных проектов, использующих различные инструментарии. По этой причине я также описываюBoost.Build— мощную и расширяемую систему сборки, изначально предназначенную для сборки приложений на С++.
    [Картинка: tip_yellow.png] За подробным исследованием GNU make обратитесь к книге Роберта Мекленбурга (Robert Mecklenburg)Managing Projects with GNU make, Third Edition (издательство O'Reilly).
   Boost.Buildбыла разработана членами проекта Boost C++ Libraries. Она уже несколько лет используется большим сообществом разработчиков и постоянно активно совершенствуется. Boost.Build использует инструмент сборки, который называетсяbjam,и текстовые файлы, которые называютсяJamfile (Jam-файлы).Ее самой сильной стороной является простота, с которой она позволяет управлять сложными проектами, предназначенными для нескольких платформ и содержащими несколько сборочных конфигураций. Хотя Boost.Build изначально создавалась как расширение системы сборкиPerforce's Jam,она с тех пор подверглась значительной переработке. В момент сдачи этой книги в печать разработчики Boost.Build готовили официальный релиз второй основной версии этой системы сборки, и именно она описывается в этой главеОбзор инструментария
   В этой главе я буду обсуждать семь наборов инструментов командной строки: GCC, Visual C++, Intel, Metrowerks, Borland, Comeau и Digital Mars. Таблица 1.2 показывает имена инструментов команднойстроки из различных инструментариев, а табл. 1.3 показывает, где они расположены в вашей системе, если они установлены. Имена инструментов для Windows используют суффикс.exe,который требуется для исполняемых файлов Windows. Для инструментария, доступного как для Windows, так и для Unix, я заключаю этот суффикс в квадратные скобки.

   Табл. 1.2. Имена инструментов командной строки в различном инструментарииИнструментарийКомпиляторКомпоновщикАрхиваторGCCg++[.exe]g++ar[.exe] ranlib[.exe]Visual C++cl.exelink.exelib.exeIntel (Windows)icl.exexilink.exexilib.exeIntel (Linux)lcpcicpcarranlibMetrowerksmwcc[.exe]mwld[.exe]mwld[.exe]Comeaucomo[.exe]como[.exe]Зависит от инструментарияBorlandbcc32.exebcc32.exe ilink32.exetlib.exeDigital Marsdmc.exelink.exelib.exe

   Табл. 1.3. Расположение ваших инструментов командной строкиИнструментарийРасположениеGCC (Unix)Обычно/usr/binили/usr/local/binGCC (Cygwin)Поддиректорияbinустановки CygwinGCC (MinGW)Поддиректорияbinустановки MinGWVisual C++ПоддиректорияVC/binустановки Visual Studio?Intel (Windows)ПоддиректорияBinустановки компилятора IntelIntel (Linux)Поддиректорияbinустановки компилятора IntelMetrowerksПоддиректорияOther Metrowerks Tools/Command Line Toolsустановки CodeWarriorComeauПоддиректорияbinустановки ComeauBorlandПоддиректорияBinустановки C++Builder, C++BuilderX или инструментов командной строки Borland
   ? В предыдущих версиях Visual Studio директорияVCназываласьVC98илиVc7.

   Пусть количество инструментария вас не пугает - вам не требуется изучать их все. В большинстве случаев можно просто пропустить материал, который не относится к вашему инструментарию. Однако, если вы хотите узнать немного о другом инструментарии, прочтите разделы о Visual C++ и GCC, так как это основной инструментарий для Windows и Unix.
   Теперь давайте посмотрим на каждый из этих семи наборов.GNU Compiler Collection (GCC)
   GCC— это набор компиляторов для большого количества языков, включая С и С++. Следует заметить, что он является проектом с открытыми исходными кодами, доступен почти для всех имеющихся в природе платформ и обладает высокой степенью соответствия стандарту языка С++. Это основной компилятор для многих платформ Unix, он также широко используется в Microsoft Windows. Даже если GCC не является вашим основным инструментарием, вы можете многое узнать, используя его для компиляции своего кода. Также, если вы думаете, что знаете способ улучшить язык C++, проверьте свою идею на базе кода GCC.
   GCCпоставляется вместе с libstdc++ — хорошей реализацией с открытыми кодами стандартной библиотеки С++. Также он может использоваться совместно со стандартной библиотекой C++ с открытыми исходниками STLPort и со стандартной библиотекой Dinkumware
    [Картинка: tip_yellow.png] Чтобы узнать, где взять GCC, обратитесь к рецепту 1.1.
    [Картинка: tip_yellow.png] Примеры GCC в этой главе были протестированы с GCC 3.4.3 и GCC 4.0.0 на GNU/Linux (Fedora Core 3), с GCC 4.0.0 на Mac OS X (Darwin 8.2.0) и с GCC 3.4.2 (MinGW) и 3.4.4 (Cygwin) на Windows 2000 Professional.Visual C++
   Инструментарий Microsoft является главным на платформе Windows. Хотя до сих пор широко используются некоторые старые версии, лучше всего соответствуют стандарту самые последние версии. Также он может создавать хорошо оптимизированный код. Инструменты Microsoft распространяются вместе со средами разработки Visual C++ и Visual Studio, которые обсуждаются в следующем разделе. В момент написания этой книги они также были доступны в составе Visual C++ Toolkit 2003, который можно бесплатно скачать сwww.microsoft.com.
   Visual C++поставляется в комплекте с модифицированной версией реализации стандартной библиотеки C++ Dinkumware. Стандартная библиотека C++ Dinkumware является одной из наиболее эффективных и наиболее полно соответствующих стандарту коммерческих реализаций. Она доступна на различных платформах и поддерживает многие из наборов инструментов, описываемых в этой главе.
    [Картинка: tip_yellow.png] Примеры Visual C++ в этой главе были протестированы с Microsoft Visual Studio .NET 2003 и Microsoft Visual Studio 2005 (Beta 2) (См. табл. 1.4.)

   Табл. 1.4. Версии Microsoft Visual StudioНазвание продуктаВерсия IDEВерсия компилятораMicrosoft Visual Studio6.01200Microsoft Visual Studio .NET7.01300Microsoft Visual Studio .NET 20037.11310Microsoft Visual Studio 2005 (Beta 2)8.01400Intel
   Intelпроизводит несколько компиляторов С++, предназначенных для использования со своими процессорами. Они отличаются генерацией очень быстрого кода — возможно, самого быстрого, доступного для архитектуры Intel. Основанные на интерфейсной части C++ производства Edison Design Group (EDG), они также очень хорошо соответствуют стандарту.
   Компилятор Intel C++ для Windows используется совместно со средой разработки Microsoft's Visual C++ или Visual Studio, которая требуется для его правильного функционирования. Этот компилятор разработан с учетом совместимости с Visual С++: он может использоваться как дополнение к среде разработки Visual С++, может генерировать код, который на двоичном уровне совместим с кодом, генерируемым компилятором Visual С++, он предлагает многие из таких же опций командной строки, что и компилятор Visual C++, и, если вы не указали не делать этого, даже эмулирует некоторые из ошибок Microsoft. Коммерческую версию компилятора Intel C++ для Windows можно приобрести по адресуwww.intel.com.Также имеется академическая версия по более низкой цене.
   В то время как компилятор Intel для Windows разработан с учетом совместимости с компилятором Visual С++, компилятор Intel для Linux разработан с учетом совместимости с GCC. Для работы ему требуется GCC, он поддерживает многие опции GCC и по умолчанию реализует некоторые из расширений GCC. Коммерческую версию компилятора Intel C++ для Linux можно приобрести по адресуwww.intel.com.Некоммерческая версия доступна для бесплатного скачивания.
   В Windows компилятор Intel использует стандартную библиотеку Dinkumware, поставляемую вместе с Visual С++. В Linux он использует libstdc++.
    [Картинка: tip_yellow.png] Примеры Intel в этой главе были протестированы с компилятором Intel C++ Compiler 9.0 for Linux на GNU/Linux (Fedora Core 3) и с Intel C++ Compiler 9.0 for Windows на Windows 2000 Professional.Metrowerks
   Инструменты командной строки Metrowerks, распространяемые вместе со средой разработки CodeWarrior, относятся к числу лучших как с точки зрения соответствия стандарту, так ис точки зрения эффективности генерируемого кода. Они также поставляются вместе с MSL — превосходной реализацией стандартной библиотеки C++ от Metrowerks.До недавнего времени Metrowerks разрабатывала инструменты для Windows, Mac OS и некоторых встраиваемых платформ. Однако в 2004 году Metrowerks продала свои технологии компилятора иотладчика для Intel х86 фирме Nokia и прекратила выпуск линии продуктов CodeWarrior для Windows. В 2005 году, после того как Apple Computer анонсировала планы по переходу на процессоры Intel,Metrowerks объявила, что будущая версия CodeWarrior 10 для Mac OS будет, скорее всего, последней для этой платформы. В будущем Metrowerks сосредоточит свое внимание на разработке для встраиваемых систем на основе чипов производства Freescale Semiconductor.
    [Картинка: tip_yellow.png] К тому моменту, как вы будете читать эти строки, Metrowerks станет частью Freescale Semiconductor, и имя Metrowerks больше не будет связано с линейкой продуктов CodeWarrior. Однако я буду использовать имя Metrowerks, так как пока не ясно, каково будет ее имя в дальнейшем.
    [Картинка: tip_yellow.png] Примеры Metrowerks в этой главе были протестированы с CodeWarrior 9.6 и 10.0 (Beta) on Mac OS X (Darwin 8.2.0) и с CodeWarrior 9.4 на Windows 2000 Professional.Borland
   Инструменты командной строки Borland когда-то считались очень хорошими. Однако к сентябрю 2005 года последнее обновление насчитывало уже три года и представляло собой только незначительные улучшения предыдущей версии, которая была выпущена в 2000 году. В результате теперь инструменты Borland являются несколько устаревшими. В 2003 году Borland анонсировала планы по серьезному редизайну компилятора С++, используя интерфейсную часть EGD. К сожалению, в течение прошедшего времени Borland не делала больше никаких новых анонсов. Однако инструменты командной строки Borland остаются важны, так как все еще широко используются.
   В настоящее время самая последняя версия инструментов командной строки Borland может быть приобретена в составе сред разработки C++Builder или C++BuilderX, описываемых в следующем разделе, или в составе доступной для бесплатной закачки персональной редакции C++BuilderX.
   Инструментарий Borland поставляется с двумя стандартными библиотеками С++: STLPort и устаревшей версией стандартной библиотеки Rogue Wave. Также Borland разрабатывает версию инструментов, которые будут поставляться со стандартной библиотекой Dinkumware.
    [Картинка: tip_yellow.png] Примеры Borland в этой главе были протестированы с Borland C++ Builder 6.0 (версия компилятора 5.6.4) на Windows 2000 ProfessionalComeau
   Компилятор Comeau широко известен своим полным соответствием стандарту С++. Кроме реализации самых последних версий языка C++ он поддерживает несколько версий С и большое количество ранних диалектов С++. Он также является одним из самых дешевых, стоя на настоящий момент $50.
   Аналогично компилятору Intel Comeau использует интерфейс EDG и требует для корректной работы отдельного компилятора С. В отличие от Intel, Comeau может использовать в качестве внутреннего интерфейса различные компиляторы С.
   Comeauдоступен для Microsoft Windows и для многих видов Unix. Если для вашей платформы Comeau недоступен, вы можете оплатить Comeau Computing создание отдельной версии, но это значительно дороже. Заказать компилятор Comeau можно по адресуwww.comeaucomputing.com.
    [Картинка: tip_yellow.png] При обсуждении Comeau в Unix я буду в качестве внутреннего компилятора подразумевать GCC. При обсуждении Comeau в Windows я попробую указать, как опции командной строки зависятот используемого компилятора. Но так как Comeau может использоваться с большим количеством других компиляторов, не всегда возможно дать исчерпывающую информацию.
   Comeauпоставляется с libcomo — реализацией стандартной библиотеки С++, основанной на стандартной библиотеке Silicon Graphics. Также он может использовать стандартную библиотеку Dinkumware.
    [Картинка: tip_yellow.png] Примеры Comeau в этой главе предполагают, что используется libcomo и что компилятор настроен так, что он автоматически находит libcomo. Примеры были проверены с Comeau 4.3 3 и libcomo31, используя GCC 3.4.3 на GNU/Linux (Fedora Core 3) и используя Visual C++ .NET 2003 на Windows 2000 Professional. (См. табл 1.4.)Digital Mars
   Digital Mars— это компилятор С++, написанный Вальтером Брайтом (Walter Bright). Его можно бесплатно скачать сwww.digitalmars.com,а за небольшую сумму можно заказать CD, содержащий компилятор Digital Mars, IDE и некоторые полезные инструменты. Бесплатная версия компилятора может компилировать все примеры Digital Mars из этой главы, за исключением тех, которые требуют динамическую версию рабочей библиотеки, доступную только на CD.
   Digital Mars— это очень быстрый компилятор, создающий сильно оптимизированный код. К сожалению, у него есть некоторые проблемы с компиляцией кода, использующего расширенные идиомы шаблонов. К счастью, Вальтер Брайт очень быстро отвечает на сообщения об ошибках и стремится сделать Digital Mars соответствующим стандарту.
   Digital Marsпоставляется с двумя стандартными библиотеками: портом стандартной библиотеки STLPort и более старой "стандартной библиотекой, которая не соответствует стандарту и неполна. В целях обратной совместимости STLPort должен явно подключаться пользователем. Все примеры Digital Mars в этой главе используют стандартную библиотеку STLPort.
    [Картинка: tip_yellow.png] Примеры Digital Mars в этой главе были проверены с Digital Mars 8.45 на Windows 2000 Professional.Обзор IDE
   В этой главе я описываю четыре IDE: Microsoft Visual С++, Metrowerks CodeWarrior, Borland C++Builder и Bloodshed Software Dev-C++. Есть большое количество различных IDE, не охватываемых мной, — примерами являются Apple Xcode и Eclipse Project, — но рассмотрение этих четырех IDE должно дать вам достаточно материала для начала изучения других IDE.
    [Картинка: tip_yellow.png] Как и в случае с инструментами командной строки, вы можете пропустить материал, не относящийся к вашей IDE.Visual C++
   Microsoft Visual C++— это главная среда разработки C++ для Microsoft Windows. Она доступна как отдельное приложение или как часть набора Visual Studio и поставляется в комплекте с большим набором инструментов для разработки под Windows. Для переносимой разработки на C++ наиболее важными ее качествами являются
   • высокое соответствие компилятора стандарту С++;
   • стандартная библиотека C++ Dinkumware;
   • хороший визуальный отладчик;
   • менеджер проектов, который отслеживает зависимости между проектами.
   Широко используются несколько версий Visual Studio. Так как названия различных версий могут сбить с толку, я перечислил наиболее широко используемые версии в табл. 1.4.
   Первая версия Visual С++, включающая первоклассные компилятор и стандартную библиотеку, находится в третьей строке табл. 1.4. Все предшествующие версии имеют серьезныепроблемы с реализацией стандарта.CodeWarrior
   CodeWarrior— это кросс-платформенная среда разработки Metrowerks. Она имеет большинство таких же функций, что и Visual С++, включая:
   • высокое соответствие компилятора стандарту С++;
   • превосходную стандартную библиотеку C++;
   • хороший визуальный отладчик;
   • менеджер проектов, который отслеживает зависимости между проектами.
   Одной из сильных сторон CodeWarrior традиционно являлось большое количество платформ, для которых он был доступен, однако, как было сказано в предыдущем разделе, его линия для Windows была закрыта, а линия для Macintosh будет закрыта в скором будущем. Однако он остается важной платформой для разработки встраиваемых систем.
    [Картинка: tip_yellow.png] При обсуждении CodeWarrior IDE я предполагаю, что вы используете CodeWarrior 10 для Mac OS X. CodeWarrior IDE для других платформ очень похожа на эту версию.C++Builder
   C++Builder— это среда разработки Borland для приложений Microsoft Windows. Одной из ее привлекательных черт является поддержка библиотеки Borland's Visual Component Library. Однако для переносимой (мобильной) разработки на C++ наиболее важными ее качествами являются:
   • проверенный временем компилятор С++;
   • стандартная библиотека STLPort;
   • хороший визуальный отладчик;
   • менеджер проектов с ограниченной способностью управлять зависимостями проектов.
   Я описываю C++Builder, потому что он широко используется и у него есть большое сообщество преданных пользователей.
   C++Builderне следует путать с C++BuilderX — кросс-платформенной средой разработки, выпущенной Borland в 2003 году. Хотя C++BuilderX является полезным инструментом разработки, он не имел коммерческого успеха и неизвестно, будет ли Borland выпускать его новые версии.Dev-C++
   Bloodshed Software Dev-C++— это бесплатная среда разработки C++ для Windows, использующая порт MinGW GCC, описанный в рецепте 1.1. Он содержит вполне удобный текстовый редактор и визуальный интерфейсдля отладчика GNU.
   Dev-C++предлагает неполный графический интерфейс для многочисленных опций командной строки GCC: во многих случаях пользователи должны настраивать свои проекты, вводя в текстовые поля опции командной строки. Кроме того, его менеджер проектов может управлять только одним проектом, а визуальный отладчик ненадежен. Несмотря на эти ограничения, Dev-C++ поддерживается большим сообществом пользователей, включая студентов многих университетов. Это хорошая среда для того, кто хочет изучить С++, но не имеет никаких инструментов для разработки на С++.John, Paul, George, and Ringo
   Coвремен, когда в 1978 году Брайан Керниган (Brian Kernighan) и Деннис Ритчи (Dennis Ritchie) опубликовали книгуTheС Programming Language (Язык программирования С),стало традицией начинать изучение нового языка программирования с написания, компиляции и запуска небольшой программки, которая печатает в консоли «Hello, World!» («Привет, мир!»). Так как эта глава описывает статические и динамические библиотеки, а также исполняемые файлы, мне потребуется несколько более сложный пример.
   Примеры 1.1, 1.2 и 1.3 представляют исходный код приложенияhellobeatles,которое выводит текст
   John, Paul, George, and Ringo
   на консоль. Это приложение можно написать в виде единого исходного файла, но я разбил его на три модуля: статическую библиотекуlibjohnpaul,динамическую библиотекуlibgeorgeringoи исполняемый файлhellobeatles.Более того, хотя каждая из этих библиотек могла бы быть легко реализована как один заголовочный файл и один файл.cpp,я, чтобы проиллюстрировать компиляцию и компоновку проектов, содержащих более одного исходного файла, разбил реализацию на несколько исходных файлов.
    [Картинка: tip_yellow.png] Прежде чем вы начнете прорабатывать рецепты в этой главе, создайте четыре расположенные на одном уровне директорииjohnpaul,georgeringo,hellobeatlesиbinaries.В первые три директории поместите исходные файлы из примеров 1.1, 1.2 и 1.3. Четвертая директория будет использоваться для двоичных файлов, генерируемых IDE.
   Исходный кодlibjohnpaulпредставлен в примере 1.1. Открытый интерфейсlibjohnpaulсостоит из одной функцииjohnpaul(),объявленной в заголовочном файлеjohnpaul.hpp.Функцияjohnpaul()отвечает за печать:
   John, Paul,
   на консоль. Реализацияjohnpaul()разбита на два. исходных файла —john.cppиpaul.cpp,каждый из которых отвечает за печать одного имени.
   Пример 1.1. Исходный код libjohnpaul

   johnpaul/john.hpp
   #ifndef JOHN_HPP_INCLUDED
   #define JOHN_HPP_INCLUDED

   void john(); //Печатает "John, "
   #endif // JOHN _HPP_INCLUDED

   johnpaul/john.cpp
   #include&lt;iostream&gt;
   #include "john.hpp"

   void john() {
    std::cout&lt;&lt; "John, ";
   }

   johnpaul/paul.hpp
   #ifndef PAUL_HPP_INCLUDED
   #define PAUL_HPP_INCLUDED

   void paul(); //Печатает " Paul, "

   #endif // PAUL_HPP_INCLUDED

   johnpaul/paul.cpp
   #include&lt;iostream&gt;
   #include "paul.hpp"

   void paul() {
    std::cout&lt;&lt; "Paul, ";
   }

   johnpaul/johnpaul.hpp
   #ifndef JOHNPAUL_HPP_INCLUDED
   #define JOHNPAUL_HPP_INCLUDED

   void johnpaul(); //Печатает "John, Paul, "

   #endif // JOHNPAUL_HPP_INCLUDED

   johnpaul/johnpaul.cpp
   #include "john.hpp"
   #include "paul.hpp"
   #include "johnpaul.hpp"

   void johnpaul() {
    john();
    paul();
   }
   Исходный кодlibgeorgeringoпредставлен в примере 1.2. Открытый интерфейсlibgeorgeringoсостоит из одной функцииgeorgeringo(),объявленной в заголовочном файлеgeorgeringo.hpp.Как вы могли догадаться, функцияgeorgeringo()отвечает за печать:
   George, and Ringo
   на консоль. И снова реализацияgeorgeringo()разделена на два исходных файла —george.cppиringo.cpp.
   Пример 1.2. Исходный код libgeorgeringo

   georgeringo/george.hpp
   #ifndef GEORGE_HPP_INCLUDED
   #define GEORGE_HPP_INCLUDED

   void george(); //Печатает "George, "

   #endif // GEORGE_HPP_INCLUDED

   georgeringo/george.cpp
   #include&lt;iostream&gt;
   #include "george.hpp"

   void george()
    std::cout&lt;&lt; "George, ";
   }

   georgeringo/ringo.hpp
   #ifndef RINGO_HPP_INCLUDED
   #define RINGO_HPP_INCLUDED

   void ringo(); //Печатает "and Ringo\n"

   #endif // RINGO_HPP_INCLUDED

   georgeringo/ringo.cpp
   #include&lt;iostream&gt;
   #include "ringo.hpp"

   void ringo() {
    std::cout&lt;&lt; "and Ringo\n";
   }

   georgeringo/georgeringo.hpp
   #ifndef GEORGERINGO_HPP_INCLUDED
   #define GEORGERINGO_HPP_INCLUDED

   //определите GEORGERINGO_DLL при сборке libgeorgeringo.dll
   #if defined(_WIN32)&& !defined(__GNUC__)
   #ifdef GEORGERINGO_DLL
   # define GEORGERINGO_DECL __declspec(dllexport)
   #else
   # define GEORGERINGO_DECL __declspec(dllimport)
   #endif
   #endif // WIN32
   #ifndef GEORGERINGO_DECL
   # define GEORGERINGO_DECL
   #endif

   //Печатает "George, and Ringo\n"
   #ifdef __MWERKS__
   # pragma export on
   #endif

   GEORGERINGO_DECL void georgeringo();

   #ifdef __MWERKS__
   # pragma export off
   #endif
   #endif // GEORGERINGO_HPP_INCLUDED

   georgeringo/georgeringo.cpp
   #include "george.hpp"
   #include "ringo.hpp"
   #include "georgeringo.hpp"

   void georgeringo() {
    george();
    ringo();
   }
   Заголовокgeorgeringo.hppсодержит несколько сложных директив препроцессора. Если вы их не понимаете, не страшно. Я объясню их в рецепте 1.4.
   Наконец, исходный код исполняемого файлаhellobeatlesпредставлен в примере 1.3. Он состоит из единственного исходного файлаhellobeatles.cpp,который просто включает заголовкиjohnpaul.hppиgeorgeringo.hppи вызывает функциюjohnpaul(),а вслед за ней — функциюgeorgeringo().
   Пример 1.3. Исходный код hellobeatles

   hellobeatles/ hellobeatles.cpp
   #include "johnpaul/johnpaul.hpp"
   #include "georgeringo/georgeringo.hpp"

   int main() {
    // Печатает "John, Paul, George, and Ringo\n"
    johnpaul();
    georgeringo();
   }
   1.1.Получение и установка GCCПроблема
   Вы хотите получить GCC — свободно распространяемый компилятор GNU C/С++.Решение
   Решение зависит от вашей операционной системы.Windows
   Установите MinGW, Cygwin или оба.
   Чтобы установить MinGW, посетите страницу MinGW по адресуwww.mingw.orgи проследуйте по ссылкам до страницы загрузки MinGW. Скачайте последнюю версию программы установки MinGW, которая должна иметь имяMinGW-&lt;версия&gt;.exe.
   Далее запустите программу установки. Она попросит вас указать, куда вы хотите установить MinGW. Также она может спросить, какие пакеты вы хотите установить, - как минимум вы должны установитьgcc-core,gcc-g++,binutilsи среду выполнения MinGW, но можно установить и другие. По окончании установки вы сможете запустить из командной строки Windowsgcc,g++,ar,ranlib,dlltoolи некоторые другие инструменты GNU. Вам может потребоваться добавить директориюbinустановки MinGW в переменную среды окруженияPATH,с тем чтобы эти инструменты в командной строке вызывались по их имени, без указания полного пути к ним.
   Чтобы установить Cygwin, посетите страницу Cygwin по адресуwww.cygwin.comи для загрузки программы установки Cygwin проследуйте по ссылкеInstall Cygwin Now.Далее запустите программу установки. Она попросит вас выбрать несколько опций, таких как путь, куда следует устанавливать Cygwin.
    [Картинка: tip_yellow.png] Я подробно описываю процесс установки Cygwin, потому что он может оказаться несколько запутанным, в зависимости от того, что вы хотите установить. К тому моменту, как вы будете читать эту книгу, этот процесс может измениться, и, если это произойдет, он, возможно, станет проще.
   Наиболее важным выбором является выбор пакетов. Если у вас достаточно места на диске и высокоскоростное соединение с Интернетом, я рекомендую устанавливать все пакеты. Чтобы сделать это, щелкните на слове Default (По умолчанию) рядом со словом All (Все) в верхней части иерархии пакетов. После паузы (возможно, продолжительной) слово Default должно измениться на Install (Установить).
   Если места на диске недостаточно или у вас медленное соединение с Интернетом, можете выбрать меньшее количество пакетов. Чтобы выбрать только инструменты разработки, щелкните на слове Default рядом со словом Devel. После паузы (возможно, продолжительной) слово Default должно измениться на Install. Для выбора еще меньшего набора пакетов раскройте список пакетов для разработки, щелкнув на пиктограмме + рядом со словом Devel. Выберите пакетыgcc-core,gcc-g++иmake,щелкнув на слове Skip (Пропустить) напротив каждого из этих пакетов, в результате чего это слово сменится на Install.
   По окончании выбора пакетов нажмите наFinish (Готово).Когда программа установки завершит работу, директория установки Cygwin должна содержать файлcygwin.bat.Запуск этого сценария приведет к отображению оболочки Cygwin — среды с командной строкой, из которой можно запускатьgcc,g++,ar,ranlib,dlltool,makeи любые другие установленные вами утилиты. Процесс установки добавляет поддиректориюbinустановки Cygwin в переменную среды окруженияPATH,так что запускать эти утилиты можно также и из оболочки Windowscmd.exe.Однако вы увидите, что оболочка Cygwin — порт оболочкиbash— гораздо удобнее для запуска утилит GNU.Unix
   Введя в командной строкеg++ -v,проверьте, установлен ли в вашей системе GCC. Если GCC установлен и если доступна поддержка языка С++, эта команда должна напечатать сообщение, похожее на следующее.
   Using built-in specs.
   Target: powerpc-apple-darwin8
   Configured with /private/var/tmp/gcc/gcc-5026.obj~19/src/configure
   --disable-checking --prefix=/usr ...
   Если GCC не установлен или если он установлен без поддержки С++, вы должны самостоятельно установить его. Обычно это сложный процесс, который зависит от вашей платформы. Среди прочего вам потребуется установить пакеты GNUmakeи GNUbinutils.Подробные инструкции доступны по адресуgcc.gnu.org/install.
   Если вы используете Mac OS X, то простейшим способом получения GCC является скачивание с Web-сайта Apple среды разработки Xcode и следование простым инструкциям ее установки.В настоящий момент Xcode доступен по адресуdeveloper.apple.com/tools.
   Если вы используете Linux, то какая-то версия GCC уже должна быть установлена. Чтобы проверить номер версии, введитеg++ -v.Текущая версия GCC — это 4.0.0. Если ваша версия сильно устарела, используйте систему управления пакетами, применяемую в вашем дистрибутиве Linux, и установите наиболее новую.Обсуждение
   Cygwinи MinGW представляют очень разные подходы к портированию инструментов GNU в Windows. Cygwin — это амбициозный проект, стремящийся воспроизвести Unix-подобную среду, работающую под Windows. Он предоставляет уровень совместимости с Unix, что позволяет компилировать и выполнять под Windows программы, написанные для Unix. Следовательно, для Cygwin доступно огромное количество утилит Unix. Даже если вы не разрабатываете для Unix, вы, возможно, скоро станете считать, что вам необходимы инструменты Cygwin.
   MinGW,что означает «Minimalist GNU for Windows» (минимальный GNU для Windows), предоставляет минимальную среду для сборки исполняемых файлов для Windows с помощью GCC. Среди других вещей MinGW включает порт GCC, порт архиватора и компоновщика GNU и порт отладчика GNU GDB. Он также включает MSYS — среду командной строки, способную выполнять make-файлы GNU и сценарииconfigure. MSYSбудет обсуждаться в рецепте 1.14.
   Одно из важных различий между Cygwin и MinGW относится к лицензированию. За некоторыми исключениями вы можете распространять двоичные файлы, скомпилированные с помощью порта MinGW GCC, под любой удобной вам лицензией. С другой стороны, двоичные файлы, собранные с помощью порта Cygwin GCC, по умолчанию подпадают под действие лицензии GNU GeneralPublic License (GPL). Если вы хотите распространять программы, скомпилированные в Cygwin, не делая их исходники открытыми, вы должны приобрести лицензию у Red Hat. За полным описанием обратитесь к Web-сайтам Cygwin и MinGW.Смотри также
   Рецепт 1.14.
   1.2.Сборка простого приложения «Hello, World» из командной строкиПроблема
   Вы хотите собрать простую программу «Hello, World», подобную приведенной в примере 1.4.
   Пример 1.4. Простая программа «Hello, World»

   hello.cpp
   #include&lt;iostream&gt;

   int main() {
    std.:cout&lt;&lt; "Hello, World!\n";
   }Решение
   Выполните следующие шаги.
   1. Установите все переменные среды окружения, необходимые для вашего инструментария.
   2. Введите команду, которая говорит компилятору скомпилировать и скомпоновать вашу программу.
   Сценарии для установки переменных среды окружения перечислены в табл 1.5. Эти сценарии расположены в той же директории, что и инструменты командной строки (табл. 1.3),Если ваш инструментарий в табл. 1.5 не указан, пропустите первый шаг. В противном случае, если вы используете Windows, запустите соответствующий сценарий из командной строки, а если используете Unix, то укажите его в качестве источника переменных окружения.

   Табл. 1.5. Сценарии для установки переменных среды окружения, необходимые для инструментов командной строкиИнструментарийСценарийVisual C++vcvars32.batIntel (Windows)iclvars.bat?Intel (Linux)iccvars.shилиiccvars.cshMetrowerks (Mac OS X)iccvars.shилиmwvars.csh?Metrowerks (Windows)cwenv.batComeauТот же, что и для используемого базового инструментария
   ?В предыдущих версиях компилятора Intel этот сценарий называлсяiccvars.bat.
   ?В версиях CodeWarrior до 10.0 имелся единственный сценарийcshс именем mwvars.

   Команды для компиляции и компоновкиhello.cppприведены в табл. 1.6. Для корректной работы эти команды требуют, чтобы ваша текущая директория была директорией, содержащейhello.cpp,и чтобы директория, в которой находится компилятор командной строки, была указана в переменной средыPATH.Если на шаге 1 вы запустили сценарий, то последнее требование будет удовлетворено автоматически. Также возможно, что директорию, содержащую инструменты командной строки, в переменнуюPATHдобавил инсталлятор при установке инструментария. В противном случае вы можете либо добавить эту директорию в переменнуюPATH,как показано в табл. 1.7, либо указать в командной строке полный путь к файлу.

   Табл. 1.6. Команды для компиляции и компоновки hello.cpp за один шагИнструментарийКомандная строкаGCCg++ -o hello hello.cppVisual C++cl -nologo -EHsc -GR -Zc:forScope -Zc:wchar_t -Fehello hello.cppIntel (Windows)id -nologo -EHsc -GR -Zc:forScope -Zc:wchar_t -Fehello hello.cppIntel (Linux)icpc -o hello hello.cppMetrowerksmwcc -wchar_t on -cwd include -o hello hello.cppComeaucomo -o hello hello.cppBorlandbcc32 -q -ehello hello.cppDigital Marsdmc -Ae -Ar -l&lt;dmcroot&gt;/stlport/stlport -o hello hello.cpp

   Табл. 1.7. Добавление директории в переменную среды окружения PATH для одной сессии работы с командной строкойОболочкаКомандная строкаbash,sh,ksh (Unix)export PATH=&lt;directory&gt;:$PATHcsh,tsch (Unix)setenv PATH&lt;directory&gt;:$PATHcmd.exe (Windows)set PATH=&lt;direcfory&gt;;%PATH%
   Например, при использовании Microsoft Visual Studio .NET 2003 и установке ее по стандартному пути на диск С перейдите в директорию, содержащуюhello.cpp,и введите показанные ниже команды.
   &gt;"C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\bin\vcvars32.bat"
   Setting environment for using Microsoft Visual Studio .NET 2003 tools.
   (If you have another version of Visual Studio or Visual C++ installed
   and wish to use its tools from the command line, run vcvars32.bat for
   that version.)
   &gt;cl -nologo -EHsn -GR -Zc:forScope -Zc:wchar_t -Fehello hello.cpp hello
   hello.cpp
   hello
   Теперь программу можно запустить.
   &gt;hello
   Hello World!
   Аналогично при использовании Intel 9.0 для Linux и установке его по стандартному пути/opt/intel/cc/9.0откройте оболочкуbash,перейдите в директорию, содержащуюhello.cpp,и введите команды:
   $. /opt/intel/cc/9.0/bin/iccvars.sh
   $icpc -о hello hello.cpp
   $ ./hello
   Hello, World!Обсуждение
   Переменные среды окружения — это пары строк, поддерживаемые системой и доступные для работающих приложений. Инструменты командной строки часто используют переменные среды, для того чтобы узнать некоторые подробности о вашей системе и для получения настроечной информации, которую в противном случае пришлось бы вводить в командной строке. Переменная среды, с которой вы чаще всего будете сталкиваться, — этоPATH,которая хранит перечень директорий, в которых операционная система ищет имя исполняемого файла, введенного в командной строке в виде простого имени без указания полного пути к нему. В Windows в директориях из переменнойPATHтакже ищутся динамические библиотеки при их загрузке.
   Инструменты командной строки используют переменные среды как в Unix, так и в Windows, но в Unix обычно есть системный компилятор С++, и переменные среды для его работы обычно по умолчанию устанавливаются в правильные значения. Однако в Windows традиционно имелось несколько конкурирующих компиляторов С++. Например, два различных компилятора будут, скорее всего, искать стандартные заголовочные файлы и библиотеки в различных местах. Следовательно, для Windows инструментарий часто предоставляет сценарии,которые устанавливают несколько переменных среды, в которых записано расположение заголовочных файлов и библиотек, а также другая информация.
   Один из способов использовать такой сценарий — запускать его из командной строки перед вызовом какого-либо инструмента командной строки, как я продемонстрировалдля Visual C++ и для Intel 9.0 для Linux. Также можно сделать установки переменных среды постоянными, с тем чтобы не приходилось каждый раз при запуске сессии командной строкизапускать этот сценарий. Как это сделать, зависит от вашей операционной системы и вашей оболочки. Однако изменение постоянных значений переменных среды является плохой идеей, так как некоторые наборы инструментов могут содержать инструменты с одинаковыми именами, что приведет к вызову в процессе сборки неправильного инструмента. Например, если у вас установлено несколько версий Visual С++, вы должны быть уверены, что перед использованием инструментов командной строки вы запустили правильную версиюvcvars32.bat.Другим примером является то, что Visual C++ и Digital Mars содержат инструменты с именамиlink.exeиlib.exe.
   Теперь давайте посмотрим на командные строки в табл. 1.7. Помните, что вам требуется обратить внимание только на ту строку, которая соответствует вашему инструментарию. В общем случае информация, передаваемая компилятору, делится на четыре категории.
   • Имя (имена) входного (исходного) файла (файлов).
   • Имя (имена) выходного файла (файлов).
   • Пути поиска файлов.
   • Общая конфигурационная информация.
   В табл. 1.6 указан только один входной файлhello.cpp,и он передается компилятору с помощью указания его имени в командной строке. Не имеет значения, в каком месте строки находится имя входного файла, при условии, что оно не находится в середине другой опции командной строки. В табл. 1.7 я поместилhello.cppв самый конец командной строки.
   Также в ней присутствует один выходной файл —hello.exeилиhello,в зависимости от операционной системы. Однако в этом случае способ передачи имени файла компилятору зависит от инструментария. Большая часть инструментов для указания выходного файла использует-о&lt;file&gt;,но Visual C++ и Intel для Windows используют-Fe&lt;file&gt;, a Borlandиспользует-e&lt;file&gt;.Заметьте, что указывать расширение исполняемого файла не обязательно.
   Единственная информация в табл. 1.7, относящаяся к третьей категории — путям поиска файлов, — имеется в строке для Digital Mars. Так как библиотека STLPort не является встроенной стандартной библиотекой Digital Mars, компилятору с помощью опции-Iтребуется сообщить, где искать заголовочные файлы STLPort. Заголовочные файлы STLPort расположены в поддиректории/stlport/stlportустановки Digital Mars. В табл. 1.7 я указал эту директорию с помощью опции&lt;dmcroot&gt;/stlport/stlport.За дополнительной информацией об опции-Iобратитесь к рецепту 1.5.
   Большая часть опций командной строки в табл. 1.7 относится к четвертой категории: общей конфигурационной информации. Эти опции не относятся к какому-либо отдельному файлу, а включают или отключают определенные функции компилятора.
   • Опции-nologo (Visual C++и Intel для Windows) и-q (Borland)говорят компилятору не печатать в консоли свои название и версию. Это делает вывод компилятора более простым для чтения.
   • Опции-EHsc (Visual C++и Intel для Windows) и-Ае (Digital Mars)говорят компилятору включить обработку исключений С++.
   • Опции-GR (Visual C++и Intel для Windows) и -Ar (Digital Mars)говорят компилятору включить информацию времени исполнения (RTTI).
   • Опции-Zc:wchar_t (Visual C++и Intel для Windows) и-wchar_t (Metrowerks)говорят компилятору распознаватьwchar_tкак встроенный тип.
   • Опция-Zc:forScope (Visual C++и Intel для Windows) говорит компилятору задействовать современные правила для областей видимости цикловfor.
   • Опция -cwd include (Metrowerks)говорит компилятору начинать поиск включенного заголовка с директории исходного файла, содержащего директивуinclude.Это поведение по умолчанию для всех инструментов, кроме Metrowerks.
   Далее давайте рассмотрим второе решение нашей проблемы. Вместо того чтобы компилировать и компоновать с помощью одной команды, второй шаг можно разбить на две части.
   2a.Введите команду, говорящую компилятору скомпилировать программу в объектный файл без компоновки.
   2b.Введите команду, говорящую компоновщику создать исполняемый файл из объектных файлов, созданных на шаге 2a.
   В нашем простом случае нет причин для раздельной компиляции и компоновки. Однако раздельная компиляция и компоновка требуются достаточно часто, так что важно, чтобы вы знали, как это делается. Например, при создании статической библиотеки вы должны скомпилировать файлы без компоновки, а затем передать готовые объектные файлы в архиватор.
   Команды для компиляции и компоновки в два этапа представлены в табл. 1.8 и 1.9. В некоторых случаях я устанавливаю для объектного файла расширениеo[bj],указывающее, что одна и та же командная строка годится и для Windows, и для Unix, за исключением расширения объектного файла.

   Табл. 1.8. Команды для компиляции hello.cpp без компоновкиИнструментарийКомандная строкаGCCg++ --c -o hello.o hello.cppVisual C++cl -с -nologo -EHsc -GR -Zc:forScope -Zc:wchar_t -Fohello hello.cppIntel (Windows)icl -с -nologo -EHsc -GR -Zc:forScope Zc:wchar_t -Fohello hello.cppIntel (Linux)icpc -с о hello.о hello.cppMetrowerksmwcc -c -wchar_t on -cwd include -o hello.o[bj] hello.cppComeaucomo -с -o hello.o[bj] hello.cppBorlandbcc32 -c -q -o hello.obj hello.cppDigital Marsdmc -c -Ae -Ar -l&lt;dmcroot&gt;/stlport/stlport -o hello.obj hello.cpp

   Табл. 1.9. Команды для компоновки hello.exe или helloИнструментарийКомандная строкаGCCg++ -о hello hello.oVisual C++link -nologo -out:hello.exe hello.objIntel (Windows)xilink -nologo -out:hello.exe hello.objIntel (Linux)icpc -o hello hello.oMetrowerksmwld -o hello hello.o[bj]Comeaucomo --no_prelink_verbose -о hello hello.o[bj]Borlandbcc32 -q -ehello hello.cppDigital Marslink -noi hello.obj, hello.exe,NUL,user32.lib kernel32.lib
   Например, чтобы собрать исполняемый файлhelloс помощью инструментария GCC, перейдите в директорию, содержащуюhello.cpp,и введите следующие команды.
   $g++ -с -о hello.о hello.cpp
   $g++ -о hello hello.о
   Теперь программу можно запустить вот так.
   $./hello Hello, World!
   Таблица 1.9 почти идентична табл. 1.6. Имеется только два различия. Во-первых, используется опция-с,говорящая компилятору скомпилировать без компоновки. Во-вторых, указанный выходной файл является объектным файломhello.objилиhello.o,а не исполняемым. Большая часть компиляторов для указания выходного файла использует опцию-о&lt;file&gt;,но Visual C++ и Intel для Windows используют опцию-Fo&lt;file&gt;.Кроме того, все компиляторы, за исключением Visual C++ и Intel для Windows, требуют, чтобы было указано расширение объектного файла.
   Теперь все командные строки в табл. 1.9 должны быть просты и понятны, так что я сделаю только два замечания.
   • Компоновщик Digital Mars имеет необычный синтаксис, содержащий шесть полей, разделенных запятыми, которые используются для указания различных типов входных файлов. Сейчас вам требуется знать только то, что первое поле предназначено для объектных файлов, а второе — для выходного файла. Опция-noiговорит компоновщику выполнить компоновку с учетом регистра, что необходимо для программ на C++.
   • Компоновщик Borlandilink32.exeиспользует синтаксис, похожий на Digital Mars. Чтобы упростить командную строку, я использовал для выполнения этапа компоновки компиляторbcc32.exe.Внутри себяbcc32.exeвызываетilink32.exe.Смотри также
   Рецепты 1.7 и 1.15.
   1.3.Сборка статической библиотеки из командной строкиПроблема
   Вы хотите использовать свои инструменты командной строки для сборки статической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.1.Решение
   Во-первых, используйте компилятор для компиляции исходных файлов в объектные файлы. Если ваши исходные файлы включают заголовочные файлы, расположенные в других директориях, то для указания компилятору, где искать эти заголовочные файлы, вам может потребоваться использовать опцию-I.За дополнительной информацией обратитесь к рецепту 1.5. Во-вторых, для объединения объектных файлов в статическую библиотеку используйте архиватор.
   Чтобы скомпилировать каждый из трех исходных файлов из примера 1.1, используйте командные строки из табл. 1.8, изменив соответственно имена входного и выходного файлов. Чтобы объединить результирующие объектные файлы в статическую библиотеку, используйте команды, приведенные в табл. 1.10.

   Табл. 1.10. Команды для создания архива libjohnpaul.lib или libjohnpaul.аИнструментарийКомандная строкаGCC (Unix) Intel (Linux) Comeau (Unix)ar ru libjohnpaul.a john.c paul.о johnpaul.o ranlib libjohnpaul.aGCC (Windows)ar ru libjohnpaul.a john.o paul.o johnpaul.оVisual C++lib -nologo -out:libjohnpaul.lib john.obj paul.obj johnpaul.objComeau (with VisualС++)Intel (Windows)xilib -nologo/out:libjohnpaul.lib john.obj paul.obj johnpaul.objMetrowerks (Windows)mwld -library -o libjohnpaul.lib john.obj paul.obj johnpaul.objMetrowerks (Mac OS X)mwld -library -o libjohnpaul.a john.о paul.o johnpaul.оBorlandtlib libjohnpaul lib /u /a /C +john +paul +johnpaulDigital Marslib -c -n libjohnpaul.lib john.obj paul.obj johnpaul.obj
   Например, чтобы скомпилироватьjohn.cpp,paul.cppиjohnpaul.cppв объектные файлы с помощью GCC, перейдите в директориюjohnpaulи введите следующие команды, создающие объектные файлыjohn.о,paul.оиjohnpaul.о:
   $g++ -с -о john.o john.cpp
   $g++ -с -о paul.o paul.cpp
   $g++ -с -о johnpaul.о johnpaul.cpp
   Теперь скомпонуйте эти объектные файлы в статическую библиотеку следующим образом.
   $ar ru libjohnpaul.a john.o paul.o johnpaul.о
   $ranlib libjohnpaul.аОбсуждение
   При использовании GCC в Unix для создания статической библиотеки вы используете две отдельные команды: во-первых, вы вызываете архиваторar,а затем вызываете инструмент с именемranlib.Опцияruговоритarдобавить указанные объектные файлы в указанный архив, если в нем отсутствуют члены с такими же именами, а обновить существующий член архива только в том случае, если указанный объектный файл новее, чем существующий член архива. Традиционно после создания или обновления архива использовался инструментranlib,который создает или обновляет таблицу символов архива, т.е. указатель символов, которые присутствуют в содержащихся в архиве объектных файлах. Сегодня на многих системах архиватор ar самостоятельно заботится об обновлении таблицы символов, так что запускranlibнеобязателен. В частности, это верно для версии GNUar.Однако на некоторых системах компилятор GCC может использоваться в сочетании с не-GNU-версиейar,и по этой причине для безопасности лучше запуститьranlib.
   Как вы можете видеть в табл. 1.10, архиватор Borlandtlibиспользует несколько необычный синтаксис: знак «плюс» перед объектными файлами говоритtlibдобавить объектные файлы в библиотеку. Остальные командные строки должны быть вам понятны без пояснений.
    [Картинка: tip_yellow.png] В некоторых наборах инструментов в качестве архиватора может использоваться компоновщик, если ему передать соответствующую опцию командной строки. В других наборах должен использоваться отдельный архиватор.Смотри также
   Рецепты 1.8, 1.11 и 1.16.
   1.4.Сборка динамической библиотеки из командной строкиПроблема
   Вы хотите использовать свои инструменты командной строки для сборки динамической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.2.Решение
   Выполните следующие шаги.
   1. Используйте компилятор для компиляции исходных файлов в объектные файлы. Если вы используете Windows, то для определения макросов, необходимых для организации экспорта символов динамической библиотеки, используйте опцию-D.Например, чтобы собрать динамическую библиотеку из примера 1.2, вы должны определить макросGEORGERINGO_DLL.Если вы собираете библиотеку, написанную кем-то другим, то макросы, которые требуется определить, должны быть описаны в инструкции по установке.
   2. Используйте компоновщик для создания из объектных файлов, созданных на шаге 1, динамической библиотеки.
    [Картинка: tip_yellow.png] Если динамическая библиотека зависит от других библиотек, то компилятору требуется сказать, где искать заголовочные файлы этих библиотек, а компоновщику требуется указать имена этих библиотек и их расположение. Этот вопрос подробно обсуждается в рецепте 1.5.
   Основные команды для выполнения первого шага приведены в табл. 1.8 Вы должны соответственно изменить имена входных и выходных файлов. Команды для выполнения второго шага приведены в табл. 1.11. Если вы используете инструментарий, который поставляется как со статическим, так и с динамическим вариантами библиотек времени исполнения, укажите компилятору и компоновщику использовать динамический вариант, как описано в рецепте 1.23.

   Табл. 1.11. Команды для создания динамической библиотеки libgeorgeringo.so, libgeorgeringo.dll или libgeorgeringo.dylibИнструментарииКомандная строкаGCCg++ -shared -fPIC -o libgeorgeringo.so george.o ringo.с georgeringo.оGCC (Mac OS X)g++ -dynamclib -fPIC -o libgeorgeringo.dylib george.o ringo.о georgeringo.oGCC (Cygwin)g++ -shared -o libgeorgeringo.dll -Wl,--out-implib,libgeorgeringo.dll,a -Wl,--export- all-symbols -Wl,--enable-auto-image-base george.o ringo.o georgeringo.oGCC (MinGW)g++ -shared -о libgeorgeringo.dll -Wl,-out-implib,libgeorgeringo.a -Wl,--export-all- symbols, -Wl,--enable-auto-image-base george.о ringo.о georgeringo.oVisual C++link -nologo -dll -out:libgeorgeringo.dll -implib:libgeorgeringo.lib george.obj ringo.obj georgeringo.objIntel (Windows)xilink -nologo -dll -out:libgeorgeringo.dll -implib:libgeorgeringo.lib george.obj ringo.obj georgeringo.objIntel (Linux)g++ -shared -fPIC -lrt -o libgeorgeringo.so george.o ringo.о georgeringo.o georgeringo.objMetrowerks (Windows)mwld -shared -export dllexport -runtime dm -o libgeorgeringo.dll implib libgeorgeringo.lib george.obj ringo.obj georgeringo.objMetrowerks (Mac OS X)mwld -shared -export pragma -o libgeorgeringo.dylib george.o ringo.о georgeringo.оCodeWarrior 10.0 (Mac OS X)?Сверьтесь с документацией MetrowerksBorlandbcc32 -q -WD -WR -elibgeorgeringo.dll george.obj ringo.obj georgeringo.obj implib -c libgeorgeringo.lib libgeorgeringo.dllDigital Marsdmc -WD -L/implib:libgeorgeringo.lib -о libgeorgeringo.dll george.obj ringo.obj georgeringo.obj user32.lib kernel32.lib
   ? CodeWarrior 10.0 для Mac OS X будет содержать динамический вариант своих библиотек. При сборке libgeorgeringo.dylib следует использовать именно их. (См. рецепт 1.23.)
    [Картинка: tip_yellow.png] По состоянию на сентябрь 2005 года инструментарий Comeau не поддерживал сборку динамических библиотек в Unix или Windows. Однако Comeau Computing работает над поддержкой динамических библиотек, и ожидается, что к концу 2005 года эта поддержка будет реализована для некоторых платформ Unix, включая Linux.
   Например, чтобы скомпилировать исходные файлы из примера 1.2 в объектные файлы с помощью компилятора Borland, предполагая, что директория, в которой находятся инструменты Borland, включена в переменнуюPATH,перейдите в директориюgeorgeringoи введите следующие команды.
   &gt;bcc32 -с -a -WR -о george.obj george.cpp
   george.cpp:
   &gt;bcc32 -c -q -WR -o ringo.obj ringo.cpp
   ringo.cpp:
   &gt;bcc32 -c -q -WR -DGERORGERINGO_DLL -o georgeringo.obj georgeringo.cpp
   georgeringo.cpp:
   Здесь опция компилятора-WRиспользуется для указания того, что применяется динамический вариант рабочей библиотеки. Эти три команды сгенерируют объектные файлыgeorge.obj,ringo.objиgeorgeringo.obj.Затем введите команду:
   &gt;bcc32 -q -WD -WR -elibgeorgeringo.dll george.obj ringo.obj georgeringo.obj
   Она сгенерирует динамическую библиотекуlibgeorgeringo.dll.Наконец, введите команду:
   &gt;implib -с libgeorgeringo.lib libgeorgeringo.dll
   Она сгенерирует библиотеку импортаlibgeorgeringo.lib.Обсуждение
   То, как обрабатываются динамические библиотеки, в основном зависит от операционной системы и инструментария. С точки зрения программиста, два наиболее значительных отличия — это:Видимость символов
   Динамические библиотеки могут содержать определения классов, функции и данные. На некоторых платформах все такие символы автоматически доступны для кода, использующего динамическую библиотеку, а другие системы предлагают программистам различные возможности управления доступом к этим символам. Наличие возможности определить, какие символы и в каком случае должны быть видны, очень полезно, так как дает программисту возможность более явного управления внешним интерфейсом его библиотеки и часто приводит к более высокой производительности. Однако она также делает более сложными сборку и использование динамических библиотек.
   В случае с большинством инструментариев для Windows, чтобы символ, определенный в динамической библиотеке, был доступен коду, использующему эту библиотеку, он должен быть явноэкспортированпри сборке динамической библиотеки иимпортированпри сборке исполняемого файла или другой динамической библиотеки, использующей эту библиотеку. Некоторые инструменты для Unix также предлагают такие возможности. Это верно для последних версий GCC для некоторых платформ, для Metrowerks на Mac OS X и для Intel для Linux. Однако в некоторых случаях нет никакого выбора, кроме как сделать все символы видимыми.Передача библиотек компоновщику
   В Unix динамическая библиотека может быть указана как входной файл компоновщика при компоновке кода, использующего эту динамическую библиотеку. В Windows, кроме случаев использования GCC, динамические библиотеки не указываются напрямую как вход компоновщика, а вместо этого используется библиотека импорта или файл определения модуля.Библиотеки импорта и файлы определения модулей
   Библиотеки импорта, грубо говоря, являются статическими библиотеками, содержащими информацию, необходимую для вызова функций, содержащихся в DLL, во время исполнения. Нет необходимости знать, как они работают, надо только знать, как их создавать и использовать. Большинство компоновщиков создает библиотеки импорта автоматически при сборке DLL, но в некоторых случаях может оказаться необходимо использовать отдельный инструмент, который называетсябиблиотекарь импорта (import librarian).В табл. 1.11 с целью избежать запутанного синтаксиса командной строки, требуемого компоновщиком Borlandilink32.exe,я использовал библиотекарь импорта Borlandimplib.exe.
   Файл определения модуля, или файл.def— это текстовый файл, который описывает функции и данные, экспортируемые из DLL. Файл.defможет быть написан вручную или автоматически сгенерирован каким-либо инструментом. Пример файла.defдля библиотекиlibgeorgeringo.dllпоказан в примере 1.5.
   Пример 1.5. Файл определения модуля для libgeorgeringo.dll
   LIBRARY LIBGEORGERINGO.DLL
   EXPORTS
    Georgeringo @1Экспорт символов из DLL
   Имеется два стандартных метода экспорта символов из Windows DLL.
   • Использование атрибута__declspec(dllexport)в заголовочных файлах DLL и сборка библиотеки импорта, предназначенной для применения при сборке кода, использующего эту DLL.
   Атрибут__dеclspec(dllexport)должен указываться в начале объявления экспортируемой функции или данных, вслед за какими-либо спецификаторами сборки, и сразу за ним должно следовать ключевое словоclassилиstructдля экспортируемого класса. Это проиллюстрировано в примере 1.6. Заметьте, что__declspec(dllexport)не является частью языка С++; это расширение языка, реализованное для большинства компиляторов для Windows.
   • Создание файла.def,описывающего функции и данные, экспортируемые из динамической библиотеки.
   Пример 1.6. Использование атрибута __declspec(dllexport)
   __declspec(dllexport) int m = 3; //Экспортируемое определение данных
   extern __declspec(dllexport) int n; //Экспортируемое объявление данных
   __declspec(dllexport) void f(); //Экспортируемое объявление функции class
   __declspec(dllexport) c { //Экспортируемое определение класса
    /* ... */
   };
   Использование файла.defимеет несколько преимуществ — например, он может позволить осуществлять доступ к функциям в DLL по номеру, а не по имени, что сокращает размер DLL. Он также устраняет необходимость запутанных директив препроцессора, таких как показанные в примере 1.2 в заголовочном файлеgeorgeringo.hpp.Однако он также имеет и несколько серьезных недостатков. Например, файл.defне может использоваться для экспорта классов. Более того, можно забыть обновить свой файл.defпри добавлении, удалении или изменении функций в вашей DLL. Таким образом, я рекомендую вам всегда использовать__declspec(dllexport).Чтобы изучить полный синтаксис файлов.def,а также научиться их использовать, обратитесь к документации по своему инструментарию.Импорт символов из DLL
   Как есть два способа экспорта символов из DLL, так есть и два способа импорта символов.
   • В заголовочных файлах, включенных в исходный код, использующий DLL, используйте атрибут__declspec(dllimport)и при сборке этого кода передайте библиотеку импорта компоновщику.
   • При сборке кода, использующего DLL, укажите файл.def.
   Как и в случае с экспортом символов, я рекомендую вместо файлов.defиспользовать в вашем исходном коде атрибут__declspec(dllimport).Атрибут__declspec(dllimport)используется точно так же, как и атрибут__declspec(dllexport),обсуждавшийся ранее. Аналогично__declspec(dllexport)атрибут__declspec(dllimport)не является частью языка С++, а является расширением языка, реализованным для большинства компиляторов для Windows.
   Если вы выбрали использование__declspec(dllexport)и__declspec(dllimport),вы должны убедиться, что при сборке DLL использовали__declspec(dllexport),а при компиляции кода, использующего эту DLL, использовали__declspec(dllimport).Одним из подходов является использование двух наборов заголовочных файлов: одного для сборки DLL, а другого для компиляции кода, использующего эту DLL. Однако это неудобно, так как сложно одновременно сопровождать две отдельные версии одних и тех же заголовочных файлов.
   Вместо этого обычно используют определение макроса, который при сборке DLL расширяется как__declspec(dllexport),а в противном случае — как__declspec(dllimport).В примере 1.2 я использовал для этой цели макроопределениеGEORGERINGO_DECL.В Windows, если определен символGEORGERINGO_SOURCE,тоGEORGERINGO_DECLраскрывается как__declspec(dllexport),а в противном случае — как__declspec(dllimport).Описанный результат вы получите, определивGEORGERINGO_SOURCEпри сборке DLLlibgeorgeringo.dll,но не определяя его при компиляции кода, использующегоlibgeorgeringo.dll.Сборка DLL с помощью GCC
   Порты GCC Cygwin и MinGW, обсуждавшиеся в рецепте 1.1, работают с DLL по-другому, нежели остальные инструменты для Windows. При сборке DLL с помощью GCC по умолчанию экспортируются все функции, классы и данные. Это поведение можно изменить, использовав опцию компоновщика--no-export-all-symbols,применив в исходных файлах атрибут__declspec(dllexport)или используя файл.def.В каждом из этих трех случаев, если вы не используете опцию--export-all-symbols,чтобы заставить компоновщик экспортировать все символы, экспортируются только те функции, классы и данные, которые помечены атрибутом__declspec(dllexport)или указаны в файле.def.
   Таким образом, инструментарий GCC можно использовать для сборки DLL двумя способами: как обычный инструментарий Windows, экспортирующий символы явно с помощью__declspec,или как инструментарий Unix, автоматически экспортирующий все символы[1].В примере 1.2 и табл. 1.11 я использовал последний метод. Если вы выберете этот метод, вы должны в целях предосторожности использовать опцию--export-all-symbols— на тот случай, если у вас окажутся заголовки, содержащие__declspec(dllexport).
   GCCотличается от других инструментов для Windows и еще в одном: вместо того чтобы передавать компоновщику библиотеку импорта, связанную с DLL, вы можете передать саму DLL. Это обычно быстрее, чем использование библиотеки импорта. Однако это может привести к проблемам, так как в одной и той же системе может существовать несколько версийодной DLL, и вы должны быть уверены, что компоновщик выберет правильную версию. В табл. 1.11 при демонстрации того, как создавать библиотеки импорта с помощью GCC, я решил не использовать эту возможность.
    [Картинка: tip_yellow.png] В случае с Cygwin библиотека импорта для DLLxxx.dllобычно называетсяxxx.dll.a,в то время как в случае с MinGW она обычно называетсяxxx.a.Это просто вопрос соглашения.Опция -fvisibility в GCC 4.0
   Последние версии GCC на некоторых платформах, включая Linux и Mac OS X, дают программистам возможность более тонкого управления экспортом символов из динамических библиотек: опция командной строки-fvisibilityиспользуется для указания видимости символов динамической библиотеки по умолчанию, а специальный атрибут, аналогичный__declspec(dllexport)в Windows, используется в исходном коде для изменения видимости символов по отдельности. Опция-fvisibilityимеет несколько различных значений, но два наиболее интересных — этоdefaultиhidden.Грубо говоря, видимостьdefaultозначает, что символ доступен для кода других модулей, а видимостьhiddenозначает, что не доступен. Чтобы включить выборочный экспорт символов, укажите в командной строке-fvisibility=hiddenи используйте атрибутvisibility (видимость)для пометки символов как видимых, как показано в примере 1.7.
   Пример 1.7. Использование атрибута visibility с опцией командной строки -fvisibility=hidden
   extern __attribute__((visibility("default"))) int m; //экспортируется
   extern int n; //не экспортируется

   __attribute__((visibility("default"))) void f(); //экспортируется
   void g(); //не экспортируется
   struct __attribute__((visibility("default"))) S { }; //экспортируется
   struct T { }; //не экспортируется
   В примере 1.7 атрибут__attribute__((visibility("default")))играет ту же роль, что и__declspec(dllexport)в коде Windows.
   Использование атрибутаvisibilityпредставляет те же проблемы, что и использование__declspec(dllexport)и__declspec(dllimport),так как вам требуется, чтобы этот атрибут присутствовал при сборке общей библиотеки и отсутствовал при компиляции кода, использующего эту общую библиотеку, и чтобы он полностью отсутствовал на платформах, его не поддерживающих. Как и в случае с__declspec(dllexport)и__declspec(dllimport),эта проблема решается с помощью препроцессора. Например, вы можете изменить заголовочный файлgeorgeringo.hppиз примера 1.2 так, чтобы использовать атрибут видимости, следующим образом.
   georgeringo/georgeringo.hpp

   #ifndef GEORGERINGO_HPP_INCLUDED
   #define GEORGERINGO_HPP_INCLUDED

   //определите GEORGERINGO_DLL при сборке libgeorgeringo
   #if defined(_WIN32)&& !defined(__GNUC__)
   #ifdef GEORGERINGO_DLL
   #define GEORGERINGO_DECL __declspec(dllexport)
   #else
   #define GEORGERINGO_DECL __declspec(dllimport)
   #endif
   #else // Unix
   # if defined(GEORGERINGO_DLL)&& defined(HAS_GCC_VISIBILITY)
   # define GEORGERINGO_DECL __attribute__((visibility("default")))
   # else
   #define GEORGERINGO_DECL
   #endif
   # endif

   //Печатает "George, and Ringo\n"
   GEORGERINGO_DECL void georgeringo();

   #endif // GEORGERINGO_HPP_INCLUDED
   Чтобы заставить это работать, вы должны при сборке в системах, поддерживающих опцию-fvisibility,определить макросHAS_GCC_VISIBILITY.
    [Картинка: tip_yellow.png] Последние версии компилятора Intel для Linux также поддерживают опцию-fvisibility.Видимость символов в Metrowerks для Mac OS X
   Metrowerksдля Mac OS X предоставляет несколько опций для экспорта символов из динамической библиотеки. При использовании IDE CodeWarrior вы можете использовать файлэкспорта символов,который играет роль файла.defв Windows. Вы также можете экспортировать все символы с помощью опции-export all,что при сборке из командной строки является поведением по умолчанию. Я рекомендую метод, использующий для пометки в вашем исходном коде экспортируемых функций#pragma export,и указание в командной строке-export pragmaпри сборке динамической библиотеки. Использование#pragma exportиллюстрируется в примере 1.2: просто вызовите#pragma export onв ваших заголовочных файлах сразу перед группой функций, которые требуется экспортировать, а сразу после нее —#pragma export off.Если вы хотите, чтобы ваш код работал с инструментарием, отличным от Metrowerks, вы должны поместить обращения к#pragma exportмежду директивами#ifdef/#endif,как показано в примере 1.2.Опции командной строки
   Давайте кратко посмотрим на опции, использованные в табл. 1.11. Каждая строка команды определяет:
   • имя (имена) входного файла (файлов):george.obj,ringo.objиgeorgeringo.obj;
   • имя создаваемой динамической библиотеки;
   • в Windows имя библиотеки импорта.
   Кроме того, компоновщик требует опции, которая говорит ему создать динамическую библиотеку, а не исполняемый файл. Большинство компоновщиков используют опцию-shared,но Visual C++ и Intel для Windows используют-dll, Borlandи Digital Mars используют-WD, a GCCдля Mac OS X использует-dynamiclib.
   Несколько опций в табл. 1.11 способствуют более эффективному использованию динамических библиотек во время выполнения. Например, некоторым компоновщикам для Unix требуется с помощью опции-fPICсгенерировать независимый от положения код (position- independent code) (GCCи Intel для Linux). Эта опция приводит к тому, что несколько процессов смогут использовать единственную копию кода динамической библиотеки. На некоторых системах отсутствие этой опции приведет к ошибке компоновщика. Аналогично в Windows опция компоновщика GCC--enable-auto-image-baseснижает вероятность того, что операционная система попытается загрузить две динамические библиотеки в одно и то же место. Использование этой опции помогает ускорить загрузку DLL.
    [Картинка: tip_yellow.png] Передать опцию в компоновщик GCC можно через компилятор, используя опциюg++ -Wl,&lt;option&gt;. (За буквойWследует строчная букваl.)
   Большая часть других опций используется для указания вариантов рабочей библиотеки и описывается в рецепте 1.23.Смотри также
   Рецепты 1.9, 1.12, 1.17, 1.19 и 1.23.
   1.5.Сборка сложного приложения из командной строкиПроблема
   Вы хотите использовать для сборки исполняемого файла, зависящего от нескольких статических и динамических библиотек, инструменты командной строки.Решение
   Начните со сборки статических и динамических библиотек, от которых зависит ваше приложение. Если библиотеки получены от сторонних разработчиков, следуйте инструкциям, поставляемым с этими библиотеками; в противном случае соберите их так, как описано в рецептах 1.3 и 1.4.
   Затем скомпилируйте в объектные файлы.cpp-файлы своего приложения, как описано в разделе «Сборка простой программы «Hello, World» из командной строки». Чтобы сказать компилятору, где искать заголовочные файлы, требуемые для вашего приложения, используйте опцию-I,как показано в табл. 1.12.

   Табл. 1.12. Указание директорий для поиска заголовочных файловИнструментарийОпцияВсе-I&lt;директория&gt;
   Наконец, для создания исполняемого файла из набора объектных файлов и библиотек используйте компоновщик. Для каждой библиотеки вы должны либо указать ее полный путь и имя, либо сказать компоновщику, где ее искать.
   На каждой стадии этого процесса при использовании инструментария, поставляемого со статическим и динамическим вариантами рабочих библиотек, и если программа использует хотя бы одну динамическую библиотеку, вы должны указать компилятору или компоновщику использовать динамическую библиотеку времени выполнения, как описано в рецепте 1.23.
   Таблица 1.13 предоставляет команды для компоновки приложенияhellobeatlesиз примера 1.3. Она предполагает, что:
   • текущей директорией являетсяhellobeatles;
   • статическая библиотекаlibjohnpaul.libилиlibjohnpaul.абыла создана в директорииjohnpaul;
   • динамическая библиотекаgeorgeringo.dll,georgeringo.soилиgeorgeringo.dylibи, если есть, ее библиотека импорта были созданы в директорииgeorgeringo.
    [Картинка: tip_yellow.png] Так как Comeau, как сказано в рецепте 1.4, не может создавать динамические библиотеки, строка для Comeau в табл. 1.13 предполагает, чтоlibgeorgeringoбыла создана как статическая, а не как динамическая библиотека. Чтобы собратьlibgeorgeringoкак статическую библиотеку, в примере 1.2 удалите из объявления функцииgeorgeringo()модификаторGEORGERINGO_DECL.

   Табл. 1.13. Команды для компоновки приложения hellobeatles.exeИнструментарийВходные файлыКомандная строкаGCC (Unix)hellobeatles.o libjohnpaul.a libgeorgeringo.sog++ -о hellobeatles hellobeatles.o -L ./johnpaul -L./georgeringo -ljohnpaui -lgeorgeringoилиg++ -o hellobeatles hellobeatles.o ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.soIntel (Linux)icpc -o hellobeatles hellobeatles.o -L./johnpaul -L./georgeringo -ljohnpaul -lgeorgeringoилиicpc -о hellobeatles hellobeatles.o ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.soComeau (Unix)como -no_prelink_verbose -o hellobeatles hellobeatles.o -L./johnpaul L./georgeringo -ljohnpaul -lgeorgeringoилиcomo -no_prelink_verbose -o hellobeatles hellobeatles.о ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.aGCC (Mac OS X)hellobeatles.о libjohnpaul.a libgeorgeringo.dylibg++ -o hellobeatles hellobeatles.o -L/johnpaul -L./georgeringo -ljohnpaul -lgeorgeringoилиg++ -o hellobeatles hellobeatles.o ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.dylibMetrowerks (Mac OS X)mwld -o hellobeatles hellobeatles.о -search -L/johnpaul -search -L ./georgeringo -ljohnpaui -lgeorgeringoилиmwld -о hellobeatles hellobeatles.о ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.dylibGCC (Cygwin)hellobeatles.о libjohnpaul.a libgeorgeringo.dll.ag++ -о hellobeatles hellobeatles.o -L./johnpaul -L./georgeringo -Ijohnpaul -Igeorgeringoилиg++ -o hellobeatles hellobeatles.о ./johnpaul/libjohnpaul.a ./georgeringo/libgeorgeringo.dll.aGCC (MinGW)hellobeatles.о libjohnpaul.a libgeorgeringo.ag++ -o hellobeatles hellobeatles.o -L./johnpaul -L./georgeringo -Ijohnpaul -Igeorgeringoилиg++ -о hellobeatles hellobeatles.o ./johnpaul/libjohnpaul.a. /georgeringo/libgeorgeringo.aVisual C++hellobeatles.obj libjohnpaul.lib libgeorgeringo.liblink -nologo -out:hellobeatles.exe -libpath:./johnpaul -libpath:./georgeringo libjohnpaul.lib libgeorgeringo.lib hellobeatles.objIntel (Windows)xilink -nologo -out:hellobeatles -libpath:./johnpaul -libpath:./georgeringo.lib johnpaul.lib libgeorgeringo.lib hellobeatles.objMetrowerks (Windows)mwld -o hellobeatles -search -L./johnpaul libjohnpaul.lib -search -L./georgeringo libgeorgeringo.lib hellobeatles.objMetrowerks (Mac OS X)?mwld -o hellobeatles hellobeatles.o -search -L./johnpaul -search -L./georgeringo libjohnpaul libgeorgeringo.dylibCodeWarrior 10.0 (Mac OS X)?Сверьтесь с документацией MetrowerksBorlandbcc32 -q -WR -WC -ehellobeatles -L./johnpaul -L./georgeringo/libjohnpaul.lib libgeorgeringo.lib hellobeatles.objDigital Marslink -noi hellobeatles.obj,hellobeatles.exe,NUL,user32.lib kernel32.lib ..\johnpaul\ .\georgeringo\libjohnpaul.lib libgeorgeringo.lib,,илиlink -noi hellobeatles.obj,hellobeatles.exe,NUL,user32.lib kernel32.lib ..\johnpaul\libjohnpaul.lib ..\georgeringo\libgeorgeringo.lib,,Comeau (Windows)hellobeatles.obj libjohnpaul.lib libgeorgeringo.libcomo -no_prelink_verbose -o hellobeatles ./johnpaul/libjohnpaul.lib ./georgeringo/libgeorgeringo.lib hellobeatles.obj
   ?При сборке с помощью указанной командной строкиhellobeatlesможет работать неправильно, так как это приложение будет использовать две копии рабочих библиотек Metrowerks. (См. рецепт 1.23.)
   ? CodeWarrior 10.0для Mac OS X будет содержать динамический вариант своих библиотек. При сборкеhellobeatlesследует использовать именно их. (См. рецепт 1.23.)

   Например, при использовании Microsoft Visual Studio .NET 2003 и если она установлена в стандартную директорию на диске С, чтобы собратьhellobeatles.exeиз командной строки, перейдите в директориюhellobeatlesи введите следующие команды.
   &gt;"С:Program Files\Microsoft Visual Studio .NET 2003\VC\bin\vcvars32.bat"
   Setting environment for using Microsoft Visual Studio 2005 tools.
   (IF you have another version of Visual Studio or Visual C++ installed
   and wish to use its tools from the command line, run vcvars32.bat for
   that version.)
   &gt;cl -c -nologo -EHsc -GR -Zc:forScope -Zc:wchar_t -MD -I.. -Fohollobeatles hellobeatles.cpp
   hellobeatles.cpp
   &gt;link -nologo -out:hellobeatles.exe -libpath:../johnpaul -libpath:../georgeringo libjohnpaul.lib libgeorgeringo.lib
   &gt; hellobeatles.objОбсуждениеПоиск включенных заголовочных файлов
   Опция-Iиспользуется для указания пути, где находятся заголовочные файлы. Когда компилятор — а на самом деле препроцессор — встречает директивуincludeв виде:
   #include "file"
   он обычно пытается вначале найти подключаемый файл, интерпретируя указанный путь относительно директории, в которой находится обрабатываемый исходный файл. Еслиэтот поиск не дает результатов, он пытается найти этот файл в одной из директорий, указанных в опции-I,а затем в директориях, указанных в инструментарии, который часто настраивается с помощью переменных среды.
   Эта ситуация аналогична включению заголовочного файла с помощью угловых скобок, как здесь:
   #include&lt;file&gt;
   за исключением того, что обычно компиляторы не интерпретируют указанный таким образом путь относительно местоположения обрабатываемого исходного файла.Передача библиотек компоновщику
   Есть несколько интересных аспектов, связанных с командными строками из табл. 1.13.
   В Windows вход компоновщика состоит из объектных файлов, статических библиотек и библиотек импорта. В Unix он состоит из объектных файлов, статических и динамических библиотек.
   Как в Windows, так и в Unix библиотеки могут передаваться компоновщику двумя способами:
   • с помощью указания пути в командной строке;
   • с помощью указания только имени библиотеки и места поиска библиотек.
   Таблица 1.13 иллюстрирует оба метода.
   Места поиска библиотек обычно могут быть указаны в командной строке. Большинство компоновщиков для этой цели используют опцию-L&lt;directory&gt;,но Visual C++ и Intel для Windows используют опцию-lipath:&lt;directory&gt;, a Metrowerksиспользует опцию-search -L&lt;directory&gt;.Компоновщик Digital Mars позволяет указывать пути поиска библиотек в командной строке вместе с файлами библиотек, при условии, что пути поиска отличаются от файлов библиотек завершающей обратной косой чертой. Также он требует, чтобы эти обратные слеши использовались как разделители в путях.
    [Картинка: tip_yellow.png] Comeauв Windows не имеет опции для указания путей поиска библиотек.
   Кроме явно указанных директорий компоновщики обычно используют список собственных директорий, который часто может быть настроен с помощью переменных среды. В Windows список директорий обычно включаетlib-поддиректорию пути установки инструментария. В результате, если скопировать.lib-файлы в эту директорию, их можно будет указать в командной строке по имени, не указывая их местоположения. Если объединить этот метод с действиями, описанными в рецепте 1.25, то можно вообще избежать передачи компоновщику какой-либо информации о библиотеке.
   Способ, которым имя библиотеки передается компоновщику, для Unix и Windows различается. В Windows указывается полный путь библиотеки, включая расширение файла. В Unix — и в Windows при использовании инструментария GCC — библиотеки указываются с помощью опции-l,за которой следует имя библиотеки с удаленными из него расширением файла и префиксомlib.Это означает, что для того, чтобы компоновщик автоматически находил библиотеку, ее имя должно начинаться с префикса lib. Еще интереснее то, что это дает компоновщикувозможность выбрать между несколькими версиями библиотек. Если компоновщик находит как статическую, так и динамическую версии библиотеки, выбирается, если не указано другого, динамическая библиотека. На некоторых системах компоновщик может выбрать между несколькими версиями динамической библиотеки, используя часть имени файла, за которой следует.so.
    [Картинка: tip_yellow.png] Metrowerksподдерживает как Windows, так и Unix-стили указания имен библиотек.
   Наконец, будьте осторожны, так как компоновщики Unix могут быть очень чувствительны к порядку, в котором в командной строке указаны объектные файлы и статические библиотеки: если статическая библиотека или объектный файл ссылаются на символ, определенный во второй статической библиотеке или объектном файле, первый файл должен быть указан в командной строке до второго. Чтобы разрешить круговые зависимости, иногда требуется указать библиотеку или объектный файл несколько раз. Еще одним решением является передача последовательности из объектных файлов и статических библиотек компоновщику обрамленными в-(и-).Это приведет к тому, что поиск в файле будет производиться до тех пор, пока не будут разрешены все зависимости. Этой опции по возможности следует избегать, так как она значительно снижает производительность.Запуск вашего приложения
   Если ваше приложение использует динамический вариант библиотеки времени исполнения инструментария, то эта библиотека должна быть доступна приложению при его запуске и должна находиться в таком месте, где динамический загрузчик операционной системы сможет автоматически найти ее. Обычно это означает, что динамическая библиотека времени исполнения должна находиться либо в той же директории, что и ваше приложение, либо в одной из директорий, указанных системе. Это больше относится к разработке для Windows, чем для Unix, так как в Unix соответствующие библиотеки обычно уже установлены по правильным путям. Имена динамических библиотек времени исполнения, поставляемых с различным инструментарием, приведены в рецепте 1.23.Смотри также
   Рецепты 1.10, 1.13, 1.18 и 1.23.
   1.6.Установка Boost.BuildПроблема
   Вы хотите получить и установить Boost.Build.Решение
   Обратитесь к документации Boost.Build по адресуwww.boost.org/boost-build2или выполните эти шаги.
   1. Перейдите на домашнюю страницу Boost —www.boost.orgи проследуйте по ссылке Download (скачать) на страницу SourceForge Boost.
   2. Скачайте и распакуйте либо самый последний релиз пакетаboost,либо самый последний релиз пакетаboost-build.Первый включает полный набор библиотек Boost, а второй — это отдельный релиз Boost.Build. Распакованные файлы поместите в подходящую временную директорию.
   3. Скачайте и распакуйте последнюю версию пакетаboost-jamдля вашей платформы. Этот пакет включает собранный исполняемый файлbjam.Если пакетboost-jamдля вашей платформы недоступен, то для сборки исполняемого файла из исходников следуйте инструкциям, прилагаемым к пакету, скачанному вами на шаге 2.
   4. Скопируйтеbjamв директорию, указанную в переменной средыPATH.
   5. Установите переменную средыBOOST_BUILD_PATHв значение корневой директории BoostBuild. Если вы на шаге 1 скачали пакетboost,то корневая директория — это поддиректорияtools/build/v2установки Boost, а в противном случае это директорияboost-build.
   6. Настройте BoostBuild на ваш инструментарий и библиотеки, отредактировав файлuser-config.jam,расположенный в корневой директории Boost.Build. Файлuser-config.jamсодержит комментарии, поясняющие, как это сделать.Обсуждение
   Наиболее сложной частью использования Boost.Build является его скачивание и установка. Со временем Boost может предоставить графическую программу установки, но в настоящий момент вы должны следовать приведенным выше шагам.
   Целью пятого шага является помощь инструменту сборки —bjamв поиске корневой директории системы сборки. Однако этот шаг необязателен, так как есть другой способ выполнить эту же задачу: просто создайте файл, который называетсяboost-build.jam,с единственной строкой:
   boost-build boost-build-root ;
   и поместите его в корневую директорию вашего проекта или любую из его родительских директорий. Если вы хотите распространять BoostBuild вместе с вашим исходным кодом, то второй метод может оказаться предпочтительнее, так как он делает процесс установки более простым для конечных пользователей.
   Шестой шаг, вероятно, является наиболее сложным, но на практике он обычно довольно прост. Если у вас установлена только одна версия инструментария, и она установлена в стандартном месте, то файлuser-config.jamможет содержать всего одну строку вида:
   using&lt;toolset&gt; ;
   Например, при использовании Visual C++ будет достаточно следующего:
   using msvc ;
   А при использовании GCC просто напишите:
   using gcc ;
   Дела становятся несколько более сложными при использовании нескольких версий инструментария или при установке инструментария не по стандартному пути. Если ваш инструментарий установлен в нестандартную директорию, скажите Boost.Build, где искать его, передав ему в качестве третьего аргументаusingкоманду на вызов компилятора инструментария. Например:
   using msvc : : "С:/Tools/Compilers/Visual Studio/Vc7/bin/cl" ;
   Если у вас установлено несколько версий инструментария, вы можете указать правилоusingнесколько раз с одним и тем же именем инструментария, передавая ему в качестве второго аргумента номер версии, а в качестве третьего — команду компилятора. Например, чтобы настроить две версии инструментария Intel, используйте следующее:
   using intel : 7.1 : "C:/Program Files/Intel/Compiler70/IA32/Bin/icl" ;
   using intel : 8.0 : "C./Program Files/Intel/CPP/Compiler80/IA32/Bin/icl" ;
   Имена, используемые Boost.Build для нескольких разных инструментариев, описываемых в этой главе, приведены в табл 1.14.

   Табл. 1.14. Имена инструментариев Boost.BuildИнструментарийИмяGCCgccVisual C++msvcIntelintelMetrowerkscwComeaucomoBorlandborlandDigital Marsdmc
   1.7.Сборка простого приложения «Hello, World» с помощью Boost.BuildПроблема
   Вы хотите собрать простую программу «Hello, World», подобную приведенной в примере 1.4, с помощью BoostBuild.Решение
   В директории, где вы хотите создать исполняемый файл и все создаваемые при этом промежуточные файлы, создайте текстовый файл с именемJamroot.В файлеJamrootукажите два правила, приведенных далее. Во-первых, укажите правило exe, объявляющее целевой исполняемый файл и исходные файлы.cpp.Далее укажите правилоinstall,определяющее имя целевого исполняемого файла и директорию, в которую его следует устанавливать. Наконец, запуститеbjam,чтобы собрать программу.
   Например, чтобы собрать исполняемый файлhelloилиhello.exeиз файлаhello.cppиз примера 1.4, создайте в директории, содержащей файлhello.cpp,файл с именемJamrootс содержимым, показанным в примере 1.8.
   Пример 1.8. Jamfile для проекта hello
   # jamfileдля проекта hello
   exe hello : hello.cpp ;
   install dist : hello :&lt;location&gt;. ;
   Далее перейдите в директорию, содержащуюhello.cppиJamroot,и введите следующую команду.
   &gt;bjam hello
   Эта команда собирает исполняемый файлhelloилиhello.exeв поддиректории текущей директории. Наконец, введите команду:
   &gt; bjam dist
   Эта команда копирует исполняемый файл в директорию, указанную в свойствеlocation,которое в нашем случае равно текущей директории.
    [Картинка: tip_yellow.png] В момент сдачи этой книги в печать разработчики Boost.Build готовят официальный релиз BoostBuild версии 2. К моменту, когда вы будете это читать, версия 2 уже, возможно, будет выпущена. Если нет, вы можете задействовать поведение, описанное в этой главе, передав в bjam опцию командной строки--v2.Например, вместо вводаbjam helloвведитеbjam --v2 hello.Обсуждение
   ФайлJamrootявляется примером файлаJamfile.В то время как для управления небольшим набором исходных файлов C++ можно использовать один Jam-файл, большой набор файлов обычно требует нескольких Jam-файлов с иерархической организацией. Каждый Jam-файл находится в отдельной директории и соответствует отдельномупроекту.Большая часть Jam-файлов просто называетсяJamfile,но самый верхний Jam-файл — Jam-файл, который расположен в директории, родительской по отношению ко всем другим директориям, содержащим остальные Jam-файлы, — называетсяJamroot.Проект, определяемый этим верхним Jam- файлом, называется корнем проекта. Каждый проект, за исключением корня проекта, имеет родительский проект определяемый проектом, расположенным в ближайшей к нему родительской директории, содержащей Jam-файл.
   Эта иерархическая организация обладает большими преимуществами: например, она облегчает применение к проекту и всем его дочерним проектамтребований,таких как поддержка потоков.
   Каждый проект — это наборцелей.Цели объявляются с помощью вызоваправил,таких как правилоexeи правилоinstall.Большая часть целей соответствует двоичным файлам или, более точно, набору связанных двоичных файлов, таких как отладочная и финальная (релиз) сборки приложения.
   Правилоexeиспользуется для объявления исполняемой цели. Вызов этого правила имеет вид, показанный в примере 1.9.
   Пример 1.9. Вызов правила exe
   exeимя-целевого-файла
    :исходные-файлы
    :требования
    :сборка-по-умолчанию
    :требования-к-использованию
    ;
   Здесьимя-целевого-файлаопределяет имя исполняемого файла,исходные-файлыопределяет список исходных файлов и библиотек, требования определяет свойства, которые должны применяться к цели независимо от каких-либо дополнительных свойств, указанных в командной строке или унаследованных от другого проекта,сборка-по-умолчаниюопределяет свойства, которые будут применены к цели, если не явно запрошено другое значение свойства, итребования-к-использованиюопределяет свойства, которые будут переданы всем остальным целям, зависящим от данной цели.
   Свойства указываются в виде&lt;функция&gt;значение.Например, чтобы объявить исполняемый файл, который будет всегда собираться с поддержкой потоков, вы должны написать:
   exe hello
    : hello.cpp
    :&lt;threading&gt;multi
    ;
    [Картинка: tip_yellow.png] От вас не требуется писать двоеточия, разделяющие последовательные аргументы правила Boost.Build, если вы не указываете значения этих аргументов.
   Некоторые часто используемые функции и их возможные значения перечислены в табл. 1.15.

   Табл. 1.15. Часто используемые функции Boost.BuildФункцияЗначениеЭффектincludePathОпределяет путь для поиска заголовочных файловdefinename=[value]Определяет макросthreadingmultiилиsingleВключает или отключает поддержку потоковruntime-linkstaticилиsharedОпределяет тип компоновки с библиотекой времени выполнения?variantdebugилиreleaseЗапрашивает отладочную или окончательную сборку
   ?См. рецепт 1.23.
   Когда собирается целевой исполняемый файл, или цель, соответствующая статической или динамической библиотеке, файл, соответствующий этой цели, создается в директории, дочерней по отношению к директории, содержащей Jam-файл. Относительным путь этой директории зависит от инструментария и конфигурации сборки, но он всегда начинается сbin.Например, исполняемый файл из примера 1.8 может быть создан в директорииbin/msvc/debug.
   Для простоты я попросил вас создать Jam-файл из примера 1.8 в той же директории, в которой находится исходный файлhello.cpp.Однако в реальных проектах вам часто придется хранить исходные и двоичные файлы в различных директориях. В примере 1.8 Jam-файл можно поместить в любое место при условии, что вы укажете путьhello.cppтак, что он будет указывать на реальный файлhello.cpp.
   Правилоinstallуказывает Boost.Build скопировать один или несколько файлов, указанных как имена файлов или как имена главных целей, в указанное место. Вызов этого правила имеет вид, показанный в примере 1.10.
   Пример 1.10. Вызов правила install
   installимя-цели
    :файлы
    :требования
    :сборка-по-умолчанию
    :требования-к-использованию
    ;
   Здесьимя-цели— это имя объявляемой цели, афайлы— это список из одного или более файлов или целей, которые требуется скопировать. Остальные аргументы —требования,сборка-по-умолчаниюитребования-к-использованию— имеют такие же значения, как и в примере 1.9.
   Место, куда файлы должны быть скопированы, может указываться либо как имя цели, либо как значение свойстваlocationтребований цели. Например, в примере 1.8 можно написать цельinstallследующим образом.
   install . : hello ;
   Затем установка исполняемого файла выполняется так:
   &gt;bjam .
   Однако метод, использованный в примере 1.8, предпочтителен, так как проще запомнить именованную цель, чем путь файла.
   Наконец, давайте быстро взглянем на синтаксис командной строкиbjam.Чтобы собрать цельxxx,используя инструментарий по умолчанию, введите команду:
   &gt;bjamxxx
   Чтобы собрать цельxxx,используя инструментарийyyy,введите команду:
   &gt;bjamxxxtoolset=yyy
   Чтобы собрать цельxxx,используя версиюvvvинструментарияyyy,введите команду:
   &gt;bjamхххtoolset=yyy-vvv
   Чтобы в командной строке указать использовать при сборке стандартную библиотекуzzz,используйте синтаксис:
   &gt;bjamxxxstdlib=zzz
   Чтобы собрать несколько целей одновременно, введите в командной строке несколько имен целей, а чтобы собрать все цели данного проекта, не указывайте целей. Следовательно, чтобы собрать и установить исполняемый файл из примера 1.9, просто введите:
   &gt;bjam
   Чтобы удалить все файлы, созданные в процессе сборки, включая исполняемый файл, введите:
   &gt;bjam --clean
   Свойство в виде&lt;функция&gt;значениеможет быть указано в командной строке какфункция=значение.Смотри также
   Рецепты 1.2 и 1.15.
   1.8.Сборка статической библиотеки с помощью Boost.BuildПроблема
   Вы хотите использовать Boost.Build для сборки статической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.1.Решение
   В директории, где вы хотите создать статическую библиотеку, создайте файлJamroot.В файлеJamrootвызовите правилоlib,объявляющее целевую библиотеку, указав в качестве исходных файлов свои файлы.cppи используя в качестве требования свойство&lt;link&gt;static.Чтобы указать директорию поиска заголовочных файлов библиотеки, т. е. директорию, относительно которой должны разрешаться директивыincludeдля заголовочных файлов этой библиотеки, добавьте требование к использованию в виде&lt;include&gt;путь.Чтобы указать компилятору, где искать включенные заголовки, может потребоваться использовать несколько директив вида&lt;include&gt;путь.Наконец, в директории, содержащейJamroot,запуститеbjam,как описано в рецепте 1.7.
   Например, чтобы собрать статическую библиотеку из исходных файлов, перечисленных в примере 1.1, вашJamrootможет выглядеть как в примере 1.11.
   Пример 1.11. Jam файл для сборки статической библиотеки libjohnpaul.lib или libjohnpaul.a
   # Jamfileдля проекта libjohnpaul
   lib libjohnpaul
   : #исходники
   john.cpp paul.cpp johnpaul.cpp
   : #требования
   &lt;link&gt;static
   : #сборка-по-умолчанию
   : #требования-к-использованию
   &lt;include&gt;..
   ;
   Чтобы собрать библиотеку, введите:
   &gt;bjam libjohnpaulОбсуждение
   Правилоlibиспользуется для объявления цели, представляющей статическую или динамическую библиотеку. Как показано в примере 1.9, оно имеет такой же вид, что и правило exe. Использование требования&lt;include&gt;..освобождает проект, который зависит от вашей библиотеки, от необходимости явно указывать в своих требованиях директорию заголовочных файлов вашей библиотеки. Требование&lt;link&gt;staticуказывает, что ваша цель должна всегда собираться как статическая библиотека. Если вы хотите сохранить возможность сборки целевой библиотеки как статической и как динамической, опустите требование&lt;link&gt;static.Должна ли библиотека собираться как статическая или как динамическая, может быть указано в командной строке или в требованиях цели, которая зависит от целевой библиотеки. Например, если в примере 1.11 требование&lt;link&gt;staticопустить, то чтобы собрать цельlibjohnpaulкак статическую библиотеку, потребуется ввести команду:
   &gt; bjam libjohnpaul link=static
   Однако написание исходного кода для библиотеки, которая может быть собрана и как статическая, и как динамическая, является нетривиальной задачей, что показано в рецепте 1.9.Смотри также
   Рецепты 1.3, 1.11 и 1.16.
   1.9.Сборка динамической библиотеки с помощью Boost.BuildПроблема
   Вы хотите использовать Boost.Build для сборки динамической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.2.Решение
   В директории, где вы хотите создать динамическую библиотеку и, если надо, библиотеку импорта, создайте файлJamroot.В файлеJamrootвызовите правилоlib,объявляющее целевую библиотеку, указав в качестве исходных файлов свои файлы .cpp и используя в качестве требования свойство&lt;link&gt;shared.Чтобы указать директорию поиска заголовочных файлов библиотеки, т.е. директорию, относительно которой должны разрешаться директивыincludeдля заголовочных файлов этой библиотеки, добавьте требование к использованию в виде&lt;include&gt;путь.Если исходные файлы включают заголовки от других библиотек, то чтобы сказать компилятору, где искать заголовочные файлы, вам может потребоваться добавить несколько требований в виде&lt;include&gt;путь.Чтобы гарантировать, что символы вашей динамической библиотеки будут экспортированы в Windows с помощью директивы__declspec(dllexport),вам также может потребоваться добавить одно или несколько требований в виде&lt;define&gt;символ.Наконец, в директории, содержащейJamroot,запуститеbjam,как описано в рецепте 1.7.
   Например, чтобы собрать из исходных файлов, перечисленных в примере 1.2, динамическую библиотеку, создайте в директорииgeorgeringoфайл с именемJamroot,показанный в примере 1.12.
   Пример 1.12. Jam-файл для сборки динамической библиотеки georgeringo.so, georgeringo.dll или georgeringo.dylib
   # Jamfileдля проекта georgeringo
   lib libgeorgeringo
    : # исходники
     george.cpp ringo.cpp georgeringo.cpp
    : # требования
    &lt;link&gt;shared
    &lt;define&gt;GEORGERINGO_DLL
    : # сборка-по-умолчанию
    : # требования-к-использованию
    &lt;include&gt;..
    ;
   Чтобы собрать библиотеку, введите:
   &gt;bjam libgeorgeringoОбсуждение
   Как обсуждалось в рецепте 1.8, правилоlibиспользуется для объявления цели, представляющей статическую или динамическую библиотеку. Использование требования&lt;include&gt;..освобождает проект, который зависит от вашей библиотеки, от необходимости явно указывать в своих требованиях директорию заголовочных файлов вашей библиотеки. Требование&lt;link&gt;sharedуказывает, что цель должна всегда собираться как динамическая библиотека. Если вы хотите иметь возможность собирать библиотеку и как статическую, и как динамическую, опустите требование&lt;link&gt;sharedи укажите это свойство в командной строке или в требованиях цели, которая зависит от вашей целевой библиотеки. Однако написание библиотеки, которая может быть собрана и как статическая, и как динамическая, требует особого внимания, так как для правильного экспорта символов в Windows требуется использовать директивы препроцессора. Хорошим упражнением является переписывание примера 1.2 так, чтобы его можно было собрать и как статическую, и как динамическую библиотеку.Смотри также
   Рецепты 1.4, 1.12, 1.17 и 1.19.
   1.10.Сборка сложного приложения с помощью BoostBuildПроблема
   Вы хотите использовать Boost.Build для сборки исполняемого файла, зависящего от нескольких статических и динамических библиотек.Решение
   Выполните следующие шаги.
   1. Для каждой библиотеки, от которой зависит исполняемый файл, — при условии, что она не распространяется в виде готового бинарного файла, — создайте Jam-файл, как описано в рецептах 1.8 и 1.9.
   2. В директории, где вы хотите создать исполняемый файл, создайте файлJamroot.
   3. В файлеJamrootвызовите правило exe, объявляющее целевой исполняемый файл. Укажите свои файлы.cppи цели библиотек, от которых исполняемый файл зависит как от источников. Также, если требуется, добавьте свойства вида&lt;include&gt;путь,чтобы сказать компилятору, где искать заголовочные файлы библиотек.
   4. В файлеJamrootвызовите правилоinstall,определяющее в качестве требований свойства&lt;install-dependencies&gt;on,&lt;install-type&gt;EXEи&lt;install-type&gt;SHARED_LIB.
   5. В директории, содержащейJamroot,запуститеbjam,как описано в рецепте 1.7.
   6. Например, чтобы собрать из исходных файлов, перечисленных в примере 1.3, исполняемый файл, создайте в директорииhellobeatlesфайл с именемJamroot,показанный в примере 1.13.
   Пример 1.13. Jam-файл для сборки исполняемого файла hellobeatles.exe или hellobeatles
   # Jamfileдля проекта hellobeatles
   exe hellobeatles
    : # исходники
     ../johnpaul//libjohnpaul
     ../georgeringo//libgeorgeringo
     hellobeatles.cpp
    ;

   install dist
    : # исходники
     hellobeatles
    : # требования
    &lt;install-dependencies&gt;on
    &lt;install-type&gt;EXE
    &lt;install-type&gt;SHARED_LIB
    &lt;location&gt;.
    ;
   Теперь введите:
   &gt;bjam hellobeatles
   находясь в директорииhellobeatles.В результате этого вначале будут собраны два проекта, от которых зависит цельhellobeatles,а затем будет собрана цельhellobeatles.Наконец, введите:
   &gt;bjam dist
   В результате исполняемый файлhellobeatlesи динамическая библиотекаgeorgeringoбудут скопированы в директорию, содержащую файлhellobeatles.cpp.
   Как было сказано в рецепте 1.5, прежде чем запускатьhellobeatles,вы должны поместить копию рабочей библиотеки вашего инструментария в такое место, где операционная система сможет ее найти.ОбсуждениеЦели библиотек
   Цели библиотек, от которых зависит данная цель, указываются как источники с помощью записиpath//target-name.В рецептах 1.8 и 1.9 я показал, как объявлять цель для сборки библиотеки из исходного кода с помощью Boost.Build Однако если библиотека доступна в виде готового двоичного файла, вы можете объявить цель для нее следующим образом.
   libимя-цели
    :
    :&lt;file&gt;имя-файла
    ;
   Как объяснялось в рецепте 1.7, большая часть основных целей соответствует не одному файлу, а набору связанных файлов, таких как отладочная и окончательная сборка исполняемого файла. Чтобы объявить цель для готовой библиотеки, у которой есть несколько вариантов, используйте следующую запись.
   libимя цели
    :
    :&lt;file&gt;имя-файла требования
    ;
   libимя-цели
    :&lt;file&gt;другое-имя-файла другие-требования
    ;
   Например, отладочный и окончательный варианты готовой библиотеки могут быть объявлены следующим образом.
   lib cryptolib
    :
    :&lt;file&gt; ../libraries/cryptolib/cryptolib_debug.lib
    &lt;variant&gt;debug
    ;
    lib cryptolib
    :&lt;file&gt; ../libraries/cryptolib/cryptolib.lib
    &lt;variant&gt;release
    ;
   Если готовая библиотека расположена в одной из директорий, в которых компоновщик выполняет поиск автоматически, как описано в рецепте 1.5, цель можно объявить следующим образом.
   libимя-цели
    :&lt;name&gt;имя-библиотеки
    ;
   Здесьимя-библиотеки— это имя, которое должно быть передано компоновщику и которое может отличаться от реального имени файла, как обсуждалось в рецепте 1.5. Чтобы дать указание компоновщику искать в определенной директории, напишите
   libимя-цели
    :&lt;name&gt;имя-библиотеки
    &lt;search&gt;путь-к-библиотеке
    ;Установка
   Сложное приложение может требовать установки вместе с несколькими дополнительными исполняемыми файлами и динамическими библиотеками, от которых оно зависит. Вместо того чтобы указывать эти файлы по отдельности, используйте функциюinstall-dependencies,которая позволяет вам указать только главный исполняемый файл и тип зависимостей, которые должны быть установлены. В примере 1.13 требование&lt;install-dependencies&gt;onвключает функциюinstall-dependencies,а требования&lt;install-type&gt;EXEи&lt;install-type&gt;SHARED_LIBговорят BoostBuild установить все зависимости, которые являются исполняемыми файлами или динамическими библиотеками. Другие возможные значения функцииinstall-typeвключаютLIBиIMPORT_LIB.Организация проекта
   Все три Jam-файла, используемые при сборке исполняемого файлаhellobeatles,называютсяJamroot.Это хорошо для такого простого проекта, но обычно следует организовывать набор Jam-файлов в иерархию с единственным высшим Jam-файлом, определяющим корень проекта. Организация проектов подобным образом позволяет использовать некоторые из более сложных функций Boost.Build's, таких как наследование свойств дочерними проектами. Однимиз способов сделать такую организацию в нашем случае является изменение имен Jam-файлов в директорияхjohnpaul,georgeringoиhellobeatlesсJamrootнаJamfileи добавление файлаJamrootсо следующим содержимым в родительскую директорию.
   # jamfileдля примера приложения
   build-project hellobeatles ;
   Правилоbuild-projectпросто говоритbjamсобрать данный проект, который может быть указан либо по пути, либо с помощью символьного идентификатора. Если вы перейдете в директорию, содержащую Jamroot, и запуститеbjam,то будут собраны три дочерних проекта.Смотри также
   Рецепты 1.5, 1.13 и 1.18.
   1.11.Сборка статической библиотеки с помощью IDEПроблема
   Вы хотите использовать IDE для сборки статической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.1.Решение
   Основная процедура выглядит следующим образом.
   1. Создайте новый проект и укажите, что требуется собрать статическую библиотеку, а не исполняемый файл или динамическую библиотеку.
   2. Выберите конфигурацию сборки (т. е. отладочную или окончательную версию и поддержку или отсутствие поддержки многопоточности).
   3. Укажите имя библиотеки и директорию, в которой она должна быть создана.
   4. Добавьте в проект исходные файлы.
   5. Если необходимо, укажите одну или несколько директорий, где компилятор должен искать подключаемые заголовочные файлы. (См. рецепт 1.13.)
   6. Соберите проект.
   Шаги этой процедуры могут варьироваться в зависимости от IDE — например, для некоторых IDE некоторые шаги будут объединены в один или изменится их порядок. Второй шаг подробно описывается в рецептах 1.21, 1.22 и 1.23. А сейчас вы. насколько это возможно, должны использовать параметры по умолчанию.
   Например, вот как надо собирать статическую библиотеку из исходных файлов из примера 1.1 с помощью Visual C++ IDE.
   В меню File выберите New->Project,в левой панели выберите Visual С++[2],выберите Win32 Console Application и введите в качестве имени проектаlibjohnpaul.В мастере Win32 Application Wizard перейдите в раздел Application Settings (Параметры приложения), выберите Static library, отключите опцию Precompiled header (Прекомпилированные заголовочные файлы) и нажмите на Finish (Готово). Теперь у вас должен иметься пустой проект с двумя конфигурациями сборки — Debug и Release, и первая будет активной.
   Затем, сделав щелчок правой кнопкой мыши на Solution Explorer и выбрав Properties, отобразите страницы свойств проекта. Перейдите в раздел Configuration Properties (Свойства конфигурации)->Librarian (Библиотекарь)->General (Общие) и в поле с именем Output File (Выходной файл) введите имя и путь выходного файла проекта. Директория этого пути должна указывать на директориюbinaries,созданную в начале этой главы, а имя должно бытьlibjohnpaul.lib.
   Наконец, чтобы добавить в проект исходные файлы из примера 1.1, используйте Add Existing Item (добавить существующий элемент) из меню Project. Теперь страницы свойств проекта должны содержать узел с именем «C/C++». Перейдите к Configuration Properties->C/C++->Code Generation (Генерация кода) и укажите в качестве библиотеки времени выполнения Multi-threaded Debug DLL (многопоточная отладочная динамическая библиотека). Теперь можно собрать проект, выбрав в меню Build пункт Build Solution. Проверьте, что в директорииbinariesбыл создан файл с именемlibjohnpaul.lib.
    [Картинка: tip_yellow.png] Вместо использования опции Add Existing Item, добавляющей в проект исходные файлы из примера 1.1, можно использовать Add New Item (Добавить новый элемент), добавляющую в проект пустые исходные файлы. После этого во вновь созданные файлы требуется ввести или вставить через буфер обмена содержимое из примера 1.1. Аналогичные замечания действительны и для других IDE.Обсуждение
   IDEразличаются гораздо больше, чем инструментарий. Каждая IDE предоставляет свой собственный способ создания проекта, указания свойств конфигурации и добавления в него файлов. Тем не менее после того, как вы узнаете, как использовать несколько разных IDE, изучение использования еще одной IDE будет довольно простым.
   При изучении того, как использовать новую IDE, вам следует обратить особое внимание на следующие моменты.
   • Как создать новый проект.
   • Как указать тип проекта (исполняемый файл, статическая библиотека или динамическая библиотека).
   • Как добавить в проект существующий файл.
   • Как создать и добавить в проект новый файл.
   • Как указать имя выходного файла проекта.
   • Как указать пути для включаемых заголовков.
   • Как указать пути для поиска библиотек.
   • Как указать библиотеки, от которых зависит проект.
   • Как собрать проект.
   • Как организовать набор проектов в группу и указать их зависимости.
   Этот рецепт демонстрирует многие из этих функций. Большая часть других функций описывается в рецептах 1.12 и 1.13.
   Теперь давайте посмотрим на то, как собрать статическую библиотеку с помощью CodeWarrior, C++Builder и Dev-C++.CodeWarrior
   В меню File выберите New… и в диалоге New выберите вкладку Project. В качестве имени проекта введитеlibjohnpaul.mcp,выберите место для сохранения настроечных файлов проекта и дважды щелкните мышью на Mac OS C++ Stationery. В диалоге New Project раскройте узел Mac OS X Mach-O and Standard Console, а затем дважды щелкните на C++ Console Mach-O. Теперь у вас должен быть проект с двумя целями — Mach-O C++ Console Debug и Mach-O C++ Console Final, и активной должна быть первая из них.
   Так как при создании проекта, зависящего от этого проекта, вам придется ссылаться на эти цели по их имени, им следует дать понятные имена. Сейчас переименуйте только отладочную цель. Выберите вкладку Targets окна проекта и дважды щелкните мышью на имени отладочной цели, чтобы: отобразить окно Target Settings (Параметры цели). Затем перейдите к Target->Target Settingsи в первом поле Target Name (Имя цели) введитеlibjohnpaul Debug.
   Далее в окне Target Settings перейдите к Target->PPC Mac OS X Target.В качестве Project Туре (Тип проекта) укажите Library, а в поле с именем File Name (Имя файла) введитеlibjohnpaul.а.Чтобы указать в качестве места для создания выходного файлаlibjohnpaul.aдиректорию binaries; перейдите к Target->Target Settingsи нажмите на Choose….
   Наконец выберите вкладку files окна проекта и удалите существующие исходные файлы и файлы библиотек, перетащив их в Trash (корзину). Затем, чтобы добавить в проект исходные файлы из примера 1.1, используйте Add Files (Добавить файлы) из меню Project. Теперь можно собрать проект, выбрав в меню Project пункт Make. Проверьте, что в директорииbinariesбыл создан файл с именемlibjohnpaul.a.C++Builder
   В меню File выберите New->Otherи выберите Library. Теперь у вас должен иметься пустой проект. В меню File выберите Save Project As, выберите директорию для сохранения настроечных файлов проекта и в качестве имени проекта введитеlibjohnpaul.bpr.
   Затем, чтобы отобразить диалог Project Options (Параметры проекта), в меню Project выберите Options. Затем перейдите в Directories and Conditionals (Директории и условия) и используйте элементуправления рядом с надписью Final output (Окончательный вывод), чтобы указать, где должен создаваться выходной файлlibjohnpaul.lib.По умолчанию этот файл будет создан в той же директории, где находитсяlibjohnpaul.bpr,но вы должны сказать C++Builder, что его требуется создать в директорииbinaries.Если хотите, то также можно использовать элемент управления рядом сIntermediate output (Промежуточный вывод) и указать место создания объектных файлов. По умолчанию они создаются в той же директории, где находятся исходные файлы.
   Наконец, чтобы добавить в проект исходные файлы из примера 1.1, используйте Add to Project (Добавить в проект) из меню Project. Теперь можно собрать проект, выбрав в меню Project пункт Make libjohnpaul. Проверьте, что в директорииbinariesбыл создан файл с именемlibjohnpaul.lib.Dev-C++
   В меню File выберите New->Project.В диалоге New project (Новый проект) выберите Static Library и C++ Project и в качестве имени проекта введитеlibjohnpaul.После нажатия на OK укажите место для сохранения настроечных файлов проекта.
   Затем, чтобы отобразить диалог Project Options, в меню Project выберите Project Options. Затем перейдите к Build Options и проверьте, что в качестве имени выходного файла проекта указаноlibjohnpaul.a.В поле Executable output directory (Директория для записи исполняемого файла) введите путь к директорииbinaries.Если хотите, то в поле Object File output directory (Директория для записи объектных файлов) можно указать директорию для создания объектных файлов.
   Наконец, чтобы добавить в проект исходные файлы из примера 1.1, используйте Add to project (Добавить в проект) из меню Project. Теперь можно собрать проект, выбрав в меню Execute пункт Compile. Проверьте, что в директорииbinariesбыл создан файл с именемlibjohnpaul.a.Смотри также
   Рецепты 1.3, 1.8 и 1.16.
   1.12.Сборка динамической библиотеки с помощью IDEПроблема
   Вы хотите использовать IDE для сборки динамической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.2.Решение
   Основная процедура выглядит следующим образом.
   1. Создайте новый проект и укажите, что требуется собрать динамическую библиотеку, а не исполняемый файл или статическую библиотеку.
   2. Выберите конфигурацию сборки (т. е. отладочную или окончательную версию и поддержку или отсутствие поддержки многопоточности).
   3. Укажите имя библиотеки и директорию, в которой она должна быть создана.
   4. Добавьте в проект исходные файлы.
   5. В Windows определите макросы, необходимые для организации экспорта символов динамической библиотеки с помощью__declspec(dllexport).
   6. Если необходимо, укажите одну или несколько директорий, где компилятор должен искать подключаемые заголовочные файлы. (См. рецепт 1.13.)
   7. Соберите проект.
   Как и в рецепте 1.11, шаги в этой процедуре будут различаться в зависимости от IDE. Второй шаг подробно описывается в рецептах 1.21, 1.22 и 1.23. А сейчас вы, насколько это возможно, должны использовать параметры по умолчанию.
   Например, вот как надо собирать динамическую библиотеку из исходных файлов из примера 1.2 с помощью Visual C++ IDE.
   В меню File выберите New->Project,в левой панели выберите Visual С++[3],выберите Win32 Console Application и в качестве имени проекта введитеlibgeorgeringo.В мастере Win32 Application Wizard перейдите к Application Settings, выберите DLL и Empty Project (Пустой проект) и нажмите на Finish. Теперь у вас должен иметься пустой проект с двумя конфигурациями сборки — Debug и Release, и первая будет активной.
   Затем, сделав щелчок правой кнопкой мыши на Solution Explorer и выбрав Properties, отобразите страницы свойств проекта. Перейдите в раздел Configuration Properties (Свойства конфигурации)->Linker (Компоновщик)->General (Общие) и в поле с именем Output File (Выходной файл) введите имя и путь выходного файла проекта. Директория этого пути должна указывать на директориюbinaries,созданную в начале этой главы, а имя должно бытьlibgeorgeringo.dll.Аналогично перейдите в раздел Configuration Properties (Свойства конфигурации)->Linker (Компоновщик)->Advanced (Дополнительно) и в поле с именем Import Library (Библиотека импорта) введите имя и путь библиотеки импорта проекта. Директория этого пути должна указывать на директориюbinaries,созданную в начале этой главы, а имя должно бытьlibgeorgeringo.lib.
   Затем, чтобы добавить в проект исходные файлы из примера 1.2, используйте Add Existing Item… (Добавить существующий элемент…) из меню Project.
    [Картинка: tip_yellow.png] Вместо использования опции Add Existing Item…, добавляющей в проект исходные файлы из примера 1.2, можно использовать Add New Item… (Добавить новый элемент…), добавляющую в проект пустые исходные файлы. После этого во вновь созданные файлы требуется ввести или вставить через буфер обмена содержимое из примера 1.2. Аналогичные замечания действительны и для других IDE.
   Теперь страницы свойств проекта должны содержать узел с именем «С/С++». Перейдите к Configuration Properties->С/С++->Code Generation (Генерация кода) и, как описано в рецепте 1.19, определите макросGEORGERINGO_DLL.Затем перейдите к Configuration Properties->C/C++->Code Generationи укажите в качестве библиотеки времени выполнения Multi-threaded Debug DLL (многопоточная отладочная динамическая библиотека).
   Теперь можно собрать проект, выбрав в меню Build пункт Build Solution. Проверьте, что в директорииlibgeorgeringo.libбыли созданы два файла с именамиlibgeorgeringo.dllиlibgeorgeringo.lib.Обсуждение
   Как вы уже видели в рецепте 1.11, каждая IDE предоставляет свой собственный способ создания проекта, указания свойств конфигурации и добавления в него файлов. Теперь давайте посмотрим на то, как собрать динамическую библиотеку с помощью CodeWarrior, C++Builder и Dev-C++.CodeWarrior
   В меню File выберите New… и в диалоге New выберите вкладку Project. В качестве имени проекта введитеlibgeorgeringo.mcp,выберите место для сохранения настроечных файлов проекта и дважды щелкните мышью на Mac OS C++ Stationery. В диалоге New Project раскройте узел Mac OS X Mach-O and Standard Console, а затем дважды щелкните на C++ Console Mach-O. Теперь у вас должен быть проект с двумя целями — Mach-O C++ Console Debug и Mach-О C++ Console Final, и активной должна быть первая из них.
   Так как при создании проекта, зависящего от этого проекта, вам придется ссылаться на эти цели по их именам, им следует дать понятные имена. Сейчас переименуйте только отладочную цель. Выберите вкладку Targets окна проекта и дважды щелкните мышью на имени отладочной цели, чтобы отобразить окно Target Settings (Параметры цели). Затем перейдите к Target->Target Settingsи в первом поле Target Name (Имя цели) введитеlibgeorgeringo Debug.
   Далее в окне Target Settings перейдите к Target->PPC Mac OS X Target.В качестве Project Туре (Тип проекта) укажите Dynamic Library, а в поле с именем File Name (Имя файла) введитеlibgeorgeringo.dylib.Чтобы в качестве места для создания выходного файлаlibjohnpaul.ауказать директориюbinaries,перейдите к Target->Target Settingsи нажмите на Choose…. Затем перейдите к Linker->PPC Mac OS X Linker.В раскрывающемся списке Export Symbols (Экспорт символов) выберите Use #pragma и проверьте, что поле Main Entry Point (Главная точка входа) пусто.
   Наконец выберите вкладку Files окна проекта и удалите существующие исходные файлы и файлы библиотек, перетащив их в Trash (корзину). Чтобы добавить в проект исходные файлы из примера 1.2, используйте Add Files… (Добавить файлы…) из меню Project. Затем используйте Add Files…, чтобы добавить файлdylib1.оиз директории/usr/libи файлыMSL_All_Mach-O_D.dylibиMSL_Shared_AppAndDylib_Runtime_D.libиз директорииMetrowerks CodeWarrior/MacOS X Support/Libraries/Runtime/Runtime PPC/Runtime_MacOSX/Libs.Если бы вы вместо отладочной цели настраивали окончательную, то вместо этих библиотек должны были бы добавить библиотекиMSL_All_Mach-O.dylibиMSL_Shared_AppAndDylib_Runtime.lib.Теперь можно собрать проект, выбрав в меню Project пункт Make. Проверьте, что в директорииbinariesбыл создан файл с именемlibgeorgeringo.dylib.C++Builder
   В меню File выберите New->Otherи затем выберите DLL Wizard. В диалоге DLL Wizard выберите C++ и Multi Threaded. Теперь у вас должен быть проект, содержащий один исходный файлUnit1.cpp.УдалитеUnit1.cppиз проекта, сделав для этого щелчок правой кнопкой мыши и выбрав Remove From Project (Удалить из проекта). В меню File выберите Save Project As, выберите директорию для сохранения настроечных файлов проекта и в качестве имени проекта введитеlibgeorgeringo.bpr.
   Затем, чтобы отобразить диалог Project Options (Параметры проекта), в меню Project выберите Options…. Затем перейдите в Directories and Conditionals (Директории и условия) и используйте элемент управления рядом с надписью Final output (Окончательный вывод), чтобы указать, что выходные файлы проекта должны создаваться в директорииbinaries.По умолчанию они создаются в той же директории, где находитсяlibjohnpaul.bpr.Если хотите, то также можно использовать элемент управления рядом сIntermediate output (Промежуточный вывод) и указать место создания объектных файлов. По умолчанию они создаются в той же директории, где находятся исходные файлы.
   Далее определите макросGEORGERINGO_DLL,как описано в рецепте 1.19.
   Наконец, чтобы добавить в проект исходные файлы из примера 1.2, используйте Add to Project (Добавить в проект) из меню Project. Теперь можно собрать проект, выбрав в меню Project пункт Make libgeorgeringo. Проверьте, что в директорииlibgeorgeringo.libбыли созданы два файла с именамиlibgeorgeringo.dllиlibgeorgeringo.lib.Dev-C++
   В меню File выберите New->Project.В диалоге New project (Новый проект) выберите DLL и C++ Project, а в качестве имени проекта введитеlibgeorgeringo.После нажатия на OK укажите место для сохранения настроечных файлов проекта.
   Затем, чтобы отобразить диалог Project Options, в меню Project выберите Project Option. Затем перейдите к Build Options и проверьте, что в качестве имени выходного файла проекта указаноlibjohnpaul.dll.В поле Executable output directory (Директория для записи исполняемого файла) введите путь к директорииbinaries.Если хотите, то в поле Object file output directory (Директория для записи объектных файлов) можно указать директорию для создания объектных файлов.
   Теперь определите макросGEORGERINGO_DLL,как описано в рецепте 1.19.
   Наконец удалите из проекта все существующие исходные файлы, сделав щелчок правой кнопкой мыши и выбрав Remove file. Для сохранения настроечного файла проектаlibgeorgeringo.devиспользуйте Save Project as из меню File. Затем, чтобы добавить в проект исходные файлы из примера 1.2, используйте Add to project (Добавить в проект) из меню Project. Соберите проект, в меню Execute выбрав Compile, и проверьте, что в директорииbinariesбыл создан файл с именемlibjohnpaul.a.Смотри также
   Рецепты 1.4, 1.9, 1.17, 1.19 и 1.23.
   1.13.Сборка сложного приложения с помощью IDEПроблема
   Вы хотите использовать IDE для сборки исполняемого файла, зависящего от нескольких статических и динамических библиотек.Решение
   Основная процедура выглядит следующим образом.
   1. При сборке из исходного кода библиотек, от которых зависит исполняемый файл, при том, что они не имеют своих собственных проектов IDE или make-файлов, создайте для нихпроекты, как описано в рецептах 1.11 и 1.12.
   2. Создайте новый проект и укажите, что требуется собрать исполняемый файл, а не библиотеку.
   3. Выберите конфигурацию сборки (т.е. отладочную или окончательную версию и поддержку или отсутствие поддержки многопоточности).
   4. Укажите имя исполняемого файла и директорию, в которой он должен быть создан.
   5. Добавьте в проект исходные файлы.
   6. Скажите компилятору, где искать заголовочные файлы библиотек.
   7. Скажите компоновщику, какие библиотеки требуется использовать и где их искать.
   8. Если IDE поддерживает группы проектов, добавьте все проекты, указанные выше, в единую группу и укажите зависимости между ними.
   9. Если IDE поддерживает группы проектов, соберите группу, созданную на шаге 8. В противном случае соберите проекты по отдельности, обращая внимание на последовательность их сборки с целью соблюдения зависимостей.
   Как и в рецептах 1.11 и 1.12, шаги в этой процедуре будут различаться в зависимости от IDE. Третий шаг подробно описывается в рецептах 1.21, 1.22 и 1.23. А сейчас вы, насколько это возможно, должны использовать параметры по умолчанию.
   Например, вот как надо собирать исполняемый файл из исходных файлов из примера 1.3 с помощью Visual C++ IDE.
   В меню File выберите New->Project,в левой панели выберите Visual С++[4],выберите Win32 Console Application и в качестве имени проекта введитеhellobeatles.В мастере Win32 Application Wizard перейдите к Application Settings, выберите Console Application (Консольное приложение) и Empty Project (Пустой проект) и нажмите на Finish. Теперь у вас должен иметься пустой проектhellobeatles.vcprojс двумя конфигурациями сборки — Debug и Release, и первая будет активной. Также у вас должно быть решениеhellobeatles.sln,содержащее один проектhellobeatles.vcproj.
   Затем, сделав щелчок правой кнопкой мыши на Solution Explorer и выбрав Properties, отобразите страницы свойств проекта. Перейдите в раздел Configuration Properties (Свойства конфигурации)->Linker (Компоновщик)->General (Общие) и в поле с именем Output File (Выходной файл) введите имя и путь выходного файла проекта. Директория этого пути должна указывать на директориюbinaries,созданную в начале этой главы, а имя файла должно бытьhellobeatles.exe.
   Затем, чтобы добавить в проект исходный файлhellobeatles.cppиз примера 1.3, используйте Add Existing Item (Добавить существующий элемент) из меню Project. Теперь страницы свойств проекта должны содержать узел с именем «C/C++». Перейдите к Configuration Properties->C/C++->Code Generation (Генерация кода) и укажите в качестве библиотеки времени выполнения Multi-threaded Debug DLL (многопоточная отладочная динамическая библиотека).
    [Картинка: tip_yellow.png] Вместо использования опции Add Existing Item, добавляющей в проект исходные файлы из примера 1.1, можно использовать Add New Item (Добавить новый элемент), добавляющую в проект пустые исходные файлы. После этого во вновь созданные файлы требуется ввести или вставить через буфер обмена содержимое из примера 1.1. Аналогичные замечания действительны и для других IDE.
   Затем перейдите к Configuration Properties->C/C++->Generalи в поле редактирования с именем Additional Include Directories (Дополнительные директории заголовочных файлов) введите директорию, которая содержит директорииjohnpaulиgeorgeringo,— директорию, являющуюся «дедушкой» по отношению к файламjohn.hpp,ringo.hppи другим. Это позволит корректно разрешить директивыincludeв заголовочном файлеhellobeatles.hpp.
   Далее, используя Add->Existing Project… (Существующий проект…) из меню File добавьте в решениеhellobeatlesфайлы проектовlibjohnpaul.vcprojиlibgeorgeringo.vcproj.Чтобы отобразить диалог Project Dependencies… (Зависимости проектов…), в меню Project выберите Project Dependencies. В раскрывающемся списке выберитеhellobeatlesи щелкните на флажках рядом сlibjohnpaulиlibgeorgeringo.
    [Картинка: tip_yellow.png] Если вы знаете, что будете добавлять несколько проектов в одно решение, нет необходимости создавать для каждого из них отдельное решение. Просто создайте пустое решение, выбрав в меню File пункт New->Blank Solution…, а затем добавив в него новые проекты, выбрав в меню File пункт New->Project….
   Наконец соберите проект, выбрав в меню Build пункт Build Solution. Проверьте, что в директорииbinariesбыли созданы файлы с именамиlibjohnpaul.lib,libgeorgeringo.dll,libgeorgeringo.libиhellobeatles.exe.Теперь, чтобы запустить это приложение, в меню Debug выберите Start Without Debugging (Запустить без отладки).Обсуждение
   В предыдущем примере было достаточно просто указать, чтоhellobeatles.exeзависит от библиотекlibjohnpaul.libиlibgeorgeringo.dll,так как обе эти библиотеки собирались в проектах Visual C++ из исходного кода. При сборке приложения, которое зависит от библиотек, распространяемых в виде готовых бинарных и заголовочных файлов, указать Visual C++, как их найти, можно следующим способом. Во-первых, перейдите к Configuration Properties->C/C++->Generalи в поле редактирования Additional Include Directories введите директории, которые содержат заголовочные файлы библиотек. Затем перейдите в раздел Configuration Properties->Linker->Inputи в поле с именем Additional dependencies (Дополнительные зависимости) введите имена этих библиотек. Наконец перейдите к Configuration Properties->Linker->Generalи в поле редактирования Additional Include Directories введите директории, которые содержат бинарные файлы этих библиотек. Теперь давайте посмотрим на то, как из исходного кода из примера 1.3 собрать исполняемый файл с помощью CodeWarrior, C++Builder и Dev-C++.CodeWarrior
   В меню File выберите New… и в диалоге New выберите вкладку Project. В качестве имени проекта введитеhellobeatles.mcp,выберите место для сохранения настроечных файлов проекта и дважды щелкните мышью на Mac OS C++ Stationery. В диалоге New Project раскройте узел Mac OS X Mach-O and Standard Console, а затем дважды щелкните на C++ Console Mach-O. Теперь у вас должен быть проект с двумя целями — Mach-O C++ Console Debug и Mach-O C++ Console Final, и активной должна быть первая из них.
   Так как при добавлении в проект зависимостей вам придется ссылаться на эти цели по их именам, им следует дать понятные имена. Сейчас переименуйте только отладочную цель. Выберите вкладку Targets окна проекта и дважды щелкните мышью на имени отладочной цели, чтобы отобразить окно Target Settings (Параметры цепи). Затем перейдите к Target->Target Settingsи в первом поле Target Name (Имя цели) введитеhellobeatles Debug.
   Далее выберите вкладку Targets окна проекта и дважды щелкните мышью на имени отладочной цели, чтобы отобразить окно Target Settings, Перейдите к Target->PPC Mac OS X Target,в качестве Project Туре (Тип проекта) укажите Executable (Исполняемый файл), а в поле с именем File Name (Имя файла) введитеhellobeatles.Чтобы в качестве места для создания выходного файла hellobeatles указать директориюbinaries,перейдите к Target->Target Settingsи нажмите на Choose….
   Выберите вкладку Files окна проекта и удалите существующие исходные файлы и файлы библиотек MSL, перетащив их в Trash (корзину). Чтобы добавить в проект исходный файлhellobeatles.cppиз примера 13, используйте Add Files… (Добавить файлы…) из меню Project. Затем используйте Add Files…, чтобы добавить файлыMSL_All_Mach-O_D.dylibиMSL_Shared AppAndDylib_Runtime_D.lib,находящиеся в директорииMetrowerks CodeWarrior/MacOS X Support/Libraries/Runtime/Runtime PPC/Runtime_MacOSX/Libs.Если бы вы вместо отладочной цели настраивали окончательную, то вместо этих библиотек должны были бы добавить библиотекиMSL_All_Mach-О.dylibиMSL_Shared_AppAndDylib_Runtime.lib.В окне Target Settings перейдите к Target->Access Paths (Пути доступа) и щелкните на панели, которая называется User Paths (Пути пользователя). Чтобы добавить директорию, которая содержит директорииjohnpaulиgeorgeringo,— директорию, являющуюся «дедушкой» по отношению к исходным файламringo.hpp,ringo.hppи другим, — используйте элемент управления с именем Add…. Это позволит корректно разрешить директивыincludeв заголовочном файлеhellobeatles.hpp.
   Используя Add Files… из меню Project, добавьте в проектhellobeatles.mcpфайлы проектовlibjohnpaul.mcpиlibgeorgeringo.mcp.Перейдите на вкладку Targets и раскройте узлы, которые называются hellobeatles Debug, libjohnpaul.mcp и libgeorgeringo.mcp. Щелкните на пиктограммах целей, расположенных рядом с дочерними узлами libjohnpaul.mcp и libgeorgeringo.mcp, которые называются libjohnpaul Debug и libgeorgeringo Debug. На обеих пиктограммах должны появиться жирные стрелки. Если требуется, увеличьте окно проекта так, чтобы увидеть небольшую пиктограмму связи у правого края окна. Дважды щелкните в этом столбце — напротив пиктограмм целей со стрелками. В этом столбце должны появиться две черные точки.
   Соберите проект, выбрав в меню Project пункт Make. Компоновщик может отобразить несколько предупреждений о символах, определенных несколько раз, но ими можно пренебречь. Вы можете подавить их, перейдя к Linker->Mac OS X Linkerи установив опцию Suppress Warning Messages (Подавлять предупреждающие сообщения).
   Проверьте, что в директории binaries были созданы файлы с именамиlibjohnpaul.a,libgeorgeringo.dylibиhellobeatles.Теперь запуститеhellobeatles,поместив в директориюbinariesкопию библиотекMSL_All_Mach-O_D.dylib,перейдя в директориюbinariesи введя в командной строке./hellobeatles.C++Builder
   В меню File выберите New и затем выберите Console Wizard. В диалоге Console Wizard выберите C++, Multi Threaded (Многопоточное) и Console Application (Консольное приложение). Теперь у вас должен быть проект, содержащий один исходный файлUnit1.cpp.УдалитеUnit1.cppиз проекта, сделав для этого щелчок правой кнопкой мыши и выбрав Remove From Project (Удалить из проекта). В меню File выберите Save Project As, выберите директорию для сохранения настроечных файлов проекта и в качестве имени проекта введитеhello_beatles.Я добавил в имя проекта знак подчеркивания, потому что C++Builder не позволяет указывать для проекта то же имя, что и для исходного файла.
   Затем, чтобы отобразить диалог Project Options (Параметры проекта), в меню Project выберите Options…. Далее перейдите в Directories and Conditionals (Директории и условия) и используйте элемент управления рядом с надписью Final output (Окончательный вывод), чтобы указать, где должен создаваться выходной файлhello_beatles.exe.По умолчанию этот файл будет создан в той же директории, где находитсяhello_beatles.bpr.Скажите C++Builder, что его требуется создать в директорииbinaries.Если хотите, то также можете использовать элемент управления рядом сIntermediate output (Промежуточный вывод) и указать место создания объектных файлов. По умолчанию они создаются в той же директории, где находятся исходные файлы.
   После этого, чтобы добавить в проект исходный файлhellobeatles.cppиз примера 1.3, используйте Add to Project (Добавить в проект) из меню Project.
   Затем из Project Options перейдите к Directories and Conditionals и, используя элемент управления рядом с Include path (Путь заголовочных файлов), выберите директорию, которая содержит директорииjohnpaulиgeorgeringo,— директорию, являющуюся «дедушкой» по отношению к исходным файламjohn.hpp,ringo.hppи другим. Это позволит корректно разрешить директивыincludeв заголовочном файлеhellobeatles.hpp.
   Далее сделайте щелчок правой кнопкой мыши на ProjectGroup1, выберите Save Project Group As, выберите директорию, содержащую файлhello_beatles.bpr,и введите имя группы проектовhello_beatles.bpg.
   После этого в группу проектов добавьте проектыlibjohnpaul.bprиlibgeorgeringo.bpr,сделав щелчок правой кнопкой мыши на надписи hello_beatles и выбрав Add Existing Project. Соберите эти два проекта, как описано в рецептах 1.11 и 1.12, если этого еще не сделано, а затемс помощью Add to Project из меню Project добавьте выходные файлыlibjohnpaul.libиlibgeorgeringo.libв проект hello_beatles. Используя клавишу со стрелкой при нажатой клавише Ctrl, переместите в Project Manager проектыlibjohnpaulиlibgeorgeringoвыше проектаhello_beatlesтак, чтобы гарантировать, что они будут собираться первыми.
   Наконец соберите решение, выбрав в меню Build пункт Make All Projects. Проверьте, что в директорииbinariesбыл создан файл с именемhellobeatles.exe.Чтобы запустить приложение, выберите Run в меню Run.Dev-C++
   В меню File выберите New->Project.В диалоге New project (Новый проект) выберите Console Application и C++ Project, а в качестве имени проекта введитеhellobeatles.После нажатия на OK укажите место для сохранения настроечных файлов проекта.
   Затем от Project Options перейдите к Build Options и проверьте, что в качестве имени выходного файла проекта указаноhellobeatles.exe.В поле Executable output directory (Директория для записи исполняемого файла) введите путь к директорииbinaries.Если хотите, то в поле Object file output directory (Директория для записи объектных файлов) можно указать директорию для создания объектных файлов.
   Далее удалите из проекта все существующие исходные файлы, сделав щелчок правой кнопкой мыши и выбрав Remove file (Удалить файл). Для сохранения настроечного файла проектаhellobeatles.devиспользуйте Save Project as из меню File. Наконец, чтобы добавить в проект исходный файлhellobeatles.cppиз примера 1.3, используйте Add to project (Добавить в проект) из меню Project
   Затем, чтобы отобразить диалог Project Options, в меню Project выберите Project Options. Затем перейдите к Directories->Include Directories,выберите директорию, которая содержит директорииjohnpaulиgeorgeringo— директорию, являющуюся «дедушкой» по отношению к исходным файламringo.hpp,ringo.hppи другим, — и нажмите на Add. Это позволит корректно разрешить директивы include в заголовочном файлеhellobeatles.hpp.
   Наконец от Project Options перейдите к Directories->Libraries Directoriesи добавьте директорию, которая содержит выходные файлыlibjohnpaul.aиlibgeorgeringo.cпроектовlibjohnpaulиlibgeorgeringo.Затем перейдите к Parameters->Linkerи введите опции-ljohnpaulи-lgeorgeringo.
   Теперь с помощью Compile из меню Execute соберите все три проекта по отдельности, проверив, чтоhellobeatlesсобирается последним. Запуститеhellobeatles.exe,выбрав в меню Execute пункт Run.Смотри также
   Рецепты 1.5, 1.10 и 1.18.
   1.14.Получение GNU makeПроблема
   Вы хотите получить и установить утилиту GNUmake,используемую для сборки библиотек и исполняемых файлов из исходного кода.Решение
   Решение зависит от вашей операционной системы.Windows
   Хотя в некоторых источниках можно получить готовые бинарные файлы GNUmake,чтобы использовать возможности GNUmakeпо максимуму, она должна быть установлена как часть Unix-подобной среды. Я рекомендую использовать либо Cygwin, либо MSYS, являющуюся частью проекта MinGW.
    [Картинка: tip_yellow.png] Cygwinи MinGW описаны в рецепте 1.1.
   Если вы установили Cygwin, как описано в рецепте 1.1, то GNU make у вас уже есть. Чтобы запустить ее из оболочки Cygwin, просто введите командуmake.
   Чтобы установить MSYS, начните с установки MinGW, как описано в рецепте 1.1. Будущие версии инсталлятора MinGW могут предоставить опцию для автоматической установки MSYS. Но пока выполните следующие дополнительные действия.
   Во-первых, на домашней странице MinGWhttp://www.mingw.orgперейдите на страницу закачки MinGW и скачайте самую последнюю стабильную версию программы установки MSYS. Имя этой программы установки должно иметь видMSYS-&lt;версия&gt;.exe.
   Далее запустите программу установки. После этого будет выдан запрос на ввод пути, где находится установка MinGW, и пути, куда следует устанавливать MSYS. Когда программа установки завершит работу, директория установки MSYS должна содержать файлmsys.bat.Запуск этого скрипта приведет к отображению оболочки MSYS — порта оболочкиbash,из которой можно запускать GNUmakeи другие программы MinGW, такие какar,ranlibиdlltool.
    [Картинка: tip_yellow.png] Для использования MSYS не требуется, чтобы поддиректории binустановок MinGW или MSYS были записаны в переменной среды PATH.Unix
   Вначале, введя в командной строкеmake -v,проверьте, установлена ли в вашей системе утилита GNUmake.Если GNUmakeустановлена, она должна вывести сообщение, подобное следующему:
   GNU Make 3.90
   Copyright (С) 2002 Free Software Foundation, Inc.
   This is free software; see the source for copying conditions.
   Если в системе имеется не-GNU-версияmake,то, возможно, GNU-версия установлена под именемgmake.Это можно проверить, введя в командной строкеgmake -v.
   При использовании Mac OS X простейшим способом получения GNUmakeявляется скачивание с web-сайта Apple среды разработки Xcode и следование простым инструкциям ее установки. В настоящий момент Xcode доступен по адресуdeveloper.apple.com/tools.
   В других случаях скачайте самую свежую версию GNUmakeс сайтаftp://ftp.gnu.org/pub/gnu/make,распакуйте ее и следуйте инструкциям по установке.Обсуждение
   Утилитаmakeимеет множество разновидностей. Большая часть инструментариев содержит собственные вариантыmake.Например, Visual C++ поставляется с утилитой, которая называетсяnmake.exe.Обычно эти специфичные версии make содержат встроенные функции, которые облегчают их использование с конкретным инструментарием. В результате обсуждениеmake,которое охватывает множество инструментариев, должно будет описать несколько версийmakeили иметь дело с ситуациями, когда между какой-то отдельной версией make и конкретным инструментарием не будет соответствия.
   Вместо того чтобы описывать несколько утилитmake,я решил сконцентрировать внимание на GNUmake,которая является наиболее мощным и переносимым вариантомmake. GNUmakeв первую очередь предназначена для работы с GCC. В результате использование GNUmakeс другим инструментарием, в частности для Windows, иногда может оказаться нетривиальным. Тем не менее, так как GNU make обладает достаточной гибкостью, гораздо проще использовать GNUmakeс нe-GNU-инструментам и, чем большую часть другихmake,типаnmake.exe,с инструментарием, отличным от того, для которого они были разработаны.
   Основные преимущества GNUmakeпроисходят от ее способности исполнять сложные сценарии оболочки. Если вы работаете одновременно и в Unix, и в Windows, вы знаете, что оболочка Windowscmd.exeоставляет желать много большего; в ней отсутствуют многие полезные команды, она имеет ограниченную способность по выполнению сценариев и накладывает жесткие ограничения на длину командной строки. Следовательно, если заставить GNUmakeиспользоватьcmd.exe,то ее возможности будут сильно ограничены. К счастью, Cygwin и MSYS предоставляют прекрасные среды для использования GNUmakeв Windows.
   MSYSпредоставляет минимальную среду, необходимую для запуска в Windows make-файлов и сценариев configure в стиле Unix. Среди прочих полезных инструментов она предоставляетawk,cat,cp,grep,ls,mkdir,mv,rm,rmdirиsed. MSYSбыла предназначена для работы с GCC и прекрасно с этим справляется. Однако с другими инструментариями для Windows, в частности теми, которые предоставляют .bat-файлы для установки переменных среды и используют для опций командной строки слеши (/) вместо тире (-), она работает несколько менее гладко.
   Так, где MSYS минимальна, Cygwin максимальна. Cygwinmakeможет делать все, что может MSYSmake,и даже много больше. Однако переносимые make-файлы ограничены узким диапазоном утилит GNU, и они все поддерживаются в MSYS.Смотри также
   Рецепт 1.1.
   1.15.Сборка простого приложения «Hello, World» с помощью GNU makeПроблема
   Вы хотите с помощью GNUmakeсобрать простую программу «Hello, World», подобную приведенной в примере 1.4.Решение
   Прежде чем вы напишете свой первый make-файл, вы должны познакомиться с терминологией, make-файл состоит из набора правил, имеющих вид
   цели: пререквизиты
    команда-сценарий
   Здесьцелиипререквизиты— это строки, разделенные пробелами, акоманда-сценарийсостоит из нуля или более строк текста, каждая из которых начинается с символа табуляции (Tab). Цели и пререквизиты обычно являются именами файлов, но иногда они представляют собой просто формальные имена действий, выполняемыхmake.Командный сценарий состоит из последовательности команд, передаваемых в оболочку. Грубо говоря, правило говоритmakeсгенерировать набор целей из набора пререквизитов, выполнив для этого командный сценарий.
    [Картинка: tip_yellow.png] Пробелы в make-файлах значимы. Строки, содержащие командные сценарии, должны начинаться с Tab, а не с пробелов — это источник некоторых наиболее распространенных ошибок новичков. В следующих примерах строки, которые начинаются с Tab, указаны с помощью отступа на четыре символа.
   Теперь вы готовы начать. В директории, содержащей исходные файлы, создайте текстовый файл с именемmakefile.В этом файле объявите четыре цели. Первую цель назовитеallи в качестве ее пререквизита укажите имя собираемого исполняемого файла. Она не должна содержать командного сценария. Второй цели присвойте имя исполняемого файла. В качестве ее пререквизитов укажите имена исходных файлов, а в качестве командного сценария укажите команды, которые требуется выполнить для сборки исполняемого файла из исходных файлов. Третья цель должна называтьсяinstall.У нее не должно быть пререквизитов и должен быть командный сценарий, копирующий исполняемый файл из директории, содержащей make-файл, в директорию, где он должен быть установлен. Последняя цель должна называтьсяclean.Как иinstall,она не должна иметь пререквизитов. Ее командный сценарий должен удалять из текущей директории исполняемый файл и промежуточные объектные файлы. Целиcleanиinstallдолжны быть помечены какphony targets (фиктивные цели), для чего используется атрибутPHONY.
   Например, чтобы с помощью GCC собрать исполняемый файл из исходного кода из примера 1.4, make-файл может иметь вид, показанный в примере 1.14.
   Пример 1.14. make-файл для сборки исполняемого файла с помощью GCC
   #Это цель по умолчанию, которая будет собрана при
   #вызове make
   .PHONY: all
   all: hello

   #Это правило говорит make, как собрать hello из hello.cpp
   hello: hello.cpp
       g++ -o hello hello.cpp

   #Это правило говорит make скопировать hello в поддиректорию binaries,
   #создав ее, если требуется
   .PHONY: install
   install:
       mkdir -p binaries
       cp -p hello binaries

   #Это правило говорит make удалить hello и hello.о
   .PHONY: clean
   clean:
       rm -f hello
   Чтобы собрать исполняемый файл из исходного кода из примера 1.4 с помощью Visual С++, используйте make-файл, показанный в примере 1.15.
   Пример 1.15. make-файл для сборки исполняемого файла с помощью Visual С++.
   #цель по умолчанию
   .PHONY: all
   all: hello.exe

   #правило для сборки hello.exe
   hello.exe: hello.cpp
       cl -nologo -EHsc -GR -Zc:forScope -Zc:wchar_t \
       -Fehello hello.cpp

   .PHONY: install
   install:
       mkdir -о binaries
       cp -p hello.exe binaries

   .PHONY: clean
   clean:
       rm -f hello.exe
    [Картинка: tip_yellow.png] Команды и списки целей или пререквизитов могут занимать несколько строк текста make-файла, для чего используется символ продолжения строки \, как и в исходных файлахС++.
   Чтобы собрать исполняемый файл, установите переменные среды, необходимые для инструментов командной строки, перейдите в директорию, содержащуюmakefile,и введитеmake.Чтобы скопировать исполняемый файл в поддиректориюbinaries,введитеmake install.Чтобы удалить из директории make-файла исполняемый файл и промежуточный объектный файл, введитеmake clean.
    [Картинка: tip_yellow.png] Если вы установили среду Cygwin, описанную в рецепте 1.1, можете выполнить make-файл из примера 1.15 непосредственно из оболочки Windows cmd.exe.
    [Картинка: tip_yellow.png] Также этот make-файл можно выполнить из оболочки Cygwin, как описано далее. Вcmd.exeзапуститеvcvars32.bat,устанавливающий переменные среды Visual С++. Затем запустите cygwin.bat, запускающий оболочку Cygwin. Если директория установки Cygwin добавлена вPATH,то оболочку Cygwin можно запустить изcmd.exe,просто введя cygwin. Наконец, перейдите в директорию, содержащую make-файл, и введитеmake.
   Аналогично можно выполнить make-файл из оболочки MSYS: вcmd.exeзапуститеvcvars32.bat,затем запустите msys.bat, запускающий оболочку MSYS.
   Если ваш инструментарий предоставляет сценарий для установки переменных среды, запуск make-файла из Cygwin или MSYS несколько более трудоемок, чем его запуск из cmd.exe. Однако для некоторых make-файлов это обязательное условие, так как они не будут работать из-подcmd.exe.Обсуждение
   В нескольких последующих рецептах вы увидите, что GNUmakeявляется достаточно мощным инструментом для сборки сложных проектов. Но что же она делает? Вот как она работает. При вызовеmakeбез аргументов она просматривает текущую директорию в поисках файла с именемGNUmakefile,makefileилиMakefileи пытается собрать первую содержащуюся в нем цель, которая называетсяцелью по умолчанию (default target).Если цель по умолчанию не устарела, что означает, что она существует, все ее пререквизиты существуют и ни один из них не был изменен с момента ее сборки, то работаmakeзакончена. В противном случае она пытается сгенерировать цель по умолчанию из ее пререквизитов, выполнив соответствующий командный сценарий. Аналогично определению устаревания этот процесс рекурсивен: для каждого устаревшего пререквизитаmakeищет правило, содержащее этот пререквизит в качестве цели, и начинает весь процесс заново. Так продолжается до тех пор, пока цель по умолчанию не будет обновлена или пока не возникнет ошибка.
   Из приведенного описания следует, что цель, не имеющая пререквизитов, не устаревает только в том случае, если она соответствует файлу в файловой системе. Следовательно, цель, соответствующая несуществующему файлу, всегда будет устаревшей и может использоваться для безусловного выполнения командного сценария. Такие цели называютсяphony targets (фиктивными).
    [Картинка: tip_yellow.png] Пометив цель атрибутом .PHONY, как в примерах 1.14 и 1.15, можно сказать make,что цель не соответствует файлу, и, таким образом, она всегда должна собираться заново.
   И наоборот, пререквизит, соответствующий существующему файлу, никогда не устаревает при условии, что этот файл не указан в качестве цели одного из правил.
   Теперь давайте посмотрим на то, что происходит при выполнении make-файла из примера 1.14. Фиктивная цельallвсегда устаревшая: единственная ее цель — сказать make собратьhello.exe.В таком простом make-файле нет необходимости в целиall,но в более сложных примерах цельallможет иметь несколько пререквизитов, правило с цельюhelloговоритmakeсобрать, если требуется,helloс помощьюg++.Если предположить, что текущая директория не содержит ничего, кроме файловmakefileиhello.cpp,цельhelloбудет устаревшей. Однако пререквизит не устарел, так как файлhello.cppсуществует и так какhello.cppне является целью одного из правил. Следовательно,makeдля компиляции и компоновкиhello.cppвызываетg++,генерируя тем самым файлhello.Пререквизит целиallобновляется, так чтоmakeсобирает цельall — исполняя пустой командный сценарий — и выходит.
   При вызове make с аргументом командной строки, соответствующим цели, make пытается собрать эту цель. Следовательно, выполнениеmake installприводит к выполнению следующих команд:
   mkdir -p binaries
   cp -p hello binaries
   Первая команда создает, если она не существует, директориюbinaries,а вторая команда копирует в эту директорию файлhello.Точно так жеmake cleanвызывает команду
   rm -f hello
   которая удаляетhello.
    [Картинка: tip_yellow.png] При использовании Windows командыmkdir,cpиrm,используемые целямиinstallиclean,указывают на инструменты GNU, поставляющиеся в составе Cygwin или MSYS
   После того как вы поймете, какmakeанализирует зависимости, пример 1.14 покажется очень простым. Однако на самом деле он значительно сложнее, чем требуется. Рассмотрение различных методов его упрощения является хорошим способом узнать некоторые из основ make-файлов.Переменные make
   GNUmakeподдерживает переменные, чьими значениями являются строки. Наиболее часто переменные используются в make-файлах как символьные константы. Вместо того чтобы жестко указывать в нескольких местах make-файла имя файла или команды оболочки, вы можете присвоить имя файла или команды переменной и далее использовать эту переменную. Это дает возможность облегчить сопровождение make-файлов. Например, make-файл из примера 1.14 можно переписать с помощью переменныхmakeтак, как показано в примере 1.16.
   Пример 1.16. make-файл для сборки исполняемого файла hello с помощью GCC, измененный с помощью переменных
   #Указываем целевой файл и директорию установки
   OUTPUTFILE=hello
   INSTALLDIR=binaries

   #Цель по умолчанию
   .PHONY all
   all: $(OUTPUTFILE)

   #Собрать hello из hello.cpp
   $(OUTPUTFILE): hello cpp
       g++ -o hello hello.cpp

   #Скопировать hello в поддиректорию binaries
   .PHONY: install
   install:
       mkdir -p $(INSTALLDIR)
       cd -p $(OUTPUTFILE) $(INSTALLDIR)

   #Удалить hello
   .PHONY: clean
   clean:
       rm -f $(OUTPUTFILE)
   Здесь я ввел две переменные make —OUTPUTFILEиINSTALLDIR.Как вы можете видеть, значения переменным make присваиваются с помощью оператора присвоения =, и они вычисляются с помощью заключения их в круглые скобки с префиксомв виде знака доллара.
   Также установить значение переменной make можно в командной строке с помощью записиmake X=Y.Кроме того, при запуске make все переменные среды используются для инициализации переменныхmakeс такими же именами и значениями. Значения, указанные в командной строке, имеют приоритет перед значениями, унаследованными от переменных среды. Значения, указанные в самом make-файле, имеют приоритет перед значениями, указанными в командной строке.
   Также GNU make поддерживаетавтоматические переменные (automatic variables),имеющие специальные значения при выполнении командного сценария. Наиболее важные из них — это переменная$@,представляющая имя файла цели, переменная$&lt;,представляющая имя файла первого пререквизита, и переменная$^,представляющая последовательность пререквизитов, разделенных пробелами. Используя эти переменные, мы можем еще сильнее упростить make-файл из примера 1.16, как показано в примере 1.17.
   Пример 1.17. make-файл для сборки исполняемого файла hello с помощью GCC, измененный с помощью автоматических переменных
   #Указываем целевой файл и директорию установки
   OUTPUTFILE=hellо
   INSTALLDIR=binaries

   #Цель по умолчанию
   .PHONY all
   all: $(OUTPUTFILE)

   #Собрать hello из hello.cpp
   $(OUTPUTFILE) hello.cpp
       g++ -o $@ $&lt;

   #Цели Install и clean как в примере 1 16
   В командном сценарииg++ -o $@ $&lt;переменная$@раскрывается какhello,а переменная$&lt;раскрывается какhello.cpp.Следовательно, make-файл из примера 1.17 эквивалентен файлу из примера 1.16, но содержит меньше дублирующегося кода.Неявные правила
   make-файл в примере 1.17 может быть еще проще. На самом деле командный сценарий, связанный с цельюhello,избыточен, что демонстрируется выполнением make-файла из примера 1.18.
   Пример 1.18. make-файл для сборки исполняемого файла hello с помощью GCC, измененный с помощью неявных правил
   #Указываем целевой файл и директорию установки
   OUTPUTFILE=hello
   INSTALLDIR=binaries

   #Цель по умолчанию
   .PHONY: all
   all: $(OUTPUTFILE)

   #Говорим make пересобрать hello тогда, когда изменяется hello.cpp
   $(OUTPUTFILE): hello.cpp

   #Цели Install и clean как в примере 1.16
   Откуда make знает, как собирать исполняемый файлhelloиз исходного файлаhello.cpp,без явного указания? Ответ состоит в том, чтоmakeсодержит внутреннюю базу данных неявных правил, представляющих операции, часто выполняемые при сборке приложений, написанных на С и С++. Например, неявное правило для генерации исполняемого файла из файла.cppвыглядит так, как в примере 1.19.
   Пример 1.19. Шаблон правила из внутренней базы данных make
   %: %.cpp
   #исполняемые команды (встроенные):
       $(LINK.cpp) $(LOADLIBS) $(LDLIBS) -о $@
   Правила, первые строки которых имеют вид%xxx:%yyy,известны какшаблонные правила (pattern rules),а символ%действует какподстановочный знак (wildcard).Когда устаревшему пререквизиту не соответствует ни одно из обычных правил,makeищет доступные шаблонные правила. Для каждого шаблонного правилаmakeпытается найти строку, которая при подстановке подстановочного знака в целевую часть правила даст искомый устаревший пререквизит. Еслиmakeнаходит такую строку,makeзаменяет подстановочные знаки для цели и пререквизитов шаблонного правила и создает новое правило. Затемmakeпытается собрать устаревший пререквизит с помощью этого нового правила.
    [Картинка: tip_yellow.png] Чтобы напечатать базу данных неявных правил GNUmake,используйте make -p.
   Например, при первом выполнении make-файла из примера 1.18 пререквизитhelloцели по умолчаниюallявляется устаревшим. Хотяhelloфигурирует как цель правила$(OUTPUTFILE): hello.cpp,это правило не содержит командного сценария, и, таким образом, оно бесполезно для сборки файла hello. Следовательно, make выполняет поиск в своей внутренней базе данныхи находит правило, показанное в примере 1.19. Подставляя в правило из примера 1.19 вместо подстановочного знака строкуhello,makeгенерирует следующее правило сhelloв качестве цели.
   hello: hello.cpp
       $(LINK.cpp) $(LOADLIBS) $(LDLIBS) -o $@
   Пока все хорошо, но есть еще кое-что. Повторный взгляд на внутреннюю базу данныхmakeпоказывает, что переменнаяLINK.cppпо умолчанию раскрывается как$(LINK.cc).В свою очередьLINK.ccпо умолчанию раскрывается как
   $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)
   Наконец, переменнаяCXXпо умолчанию раскрывается какg++,а четыре другие переменные —$(CXXFLAGS),$(CPPFLAGS),$(LDFLAGS)и$(TARGET_ARCH)— раскрываются как пустые строки. После выполнения всех этих подстановок получается следующее правило, которое теперь выглядит более знакомо.
   hello: hello.cpp
       g++ $^ -o $@
    [Картинка: tip_yellow.png] Запутались? Это не страшно. Если вы изучите приведенное объяснение и потратите некоторое время на изучение внутренней базы данных make,неявные правила приобретут смысл.Возможности для настройки
   Теперь, когда вы увидели, как шаблонное правило из примера 1.19 приводит к тому, чтоmakeсобирает исполняемый файлhelloиз исходного файлаhello.cpp,вы можете спросить, почему было необходимо использовать столько промежуточных шагов. Почему вместо сложного правила из примера 1.19 во внутреннюю базу данныхmakeпросто не добавить правило
   %: %.cpp
       g++ $^ -о $@
   Ответ состоит в том, что промежуточные переменные, такие как$(CXX),$(CXXFLAGS),$(CPPFLAGS)и$(LDFLAGS),служат как точки настройки (customization points). Например, указав значениеLDFLAGSв командной строке, в make-файле или установив значение переменной среды, можно указать дополнительные флаги, передаваемые компоновщику. ПеременныеCPPFLAGSиCXXFLAGSиграют схожую роль для опций препроцессора и компилятора C++ соответственно. А установив значение переменнойCXX,можно указать компилятор, отличный от GCC. Например, чтобы собратьhelloс помощью Intel для Linux и используя make-файл из примера 1.18, вы должны в командной строке ввестиmake CXX=icpc,предполагая, что переменные среды, необходимые для компилятора Intel, уже установлены.VPATHи директива vpath
   В примере 1.18makeможет применить правильное шаблонное правило, потому что файл.cppнаходится в той же директории, в которой создается выходной файл. Если исходные файлы находятся в другой директории, то для указанияmake,где искать цели или пререквизиты, используется переменнаяVPATH.
   VPATH =&lt;путь-к-файлам-cpp&gt;
   Чтобы сказатьmake,что выполнять поиск определенных типов файлов требуется в определенном месте, используйте директивуvpath.
   #искать файлы .exp в ../lib
   vpath %. exp../libСмотри также
   Рецепты 1.2 и 1.7.
   1.16.Сборка статической библиотеки с помощью GNU MakeПроблема
   Вы хотите использовать GNUmakeдля сборки статической библиотеки из набора исходных файлов C++, таких как перечисленные в примере 1.1.Решение
   Вначале в директории, где должна быть создана статическая библиотека, создайте make-файл и объявите фиктивную цельall,единственным пререквизитом которой будет статическая библиотека. Затем объявите цель статической библиотеки. Ее пререквизитами должны быть объектные файлы, входящие в состав библиотеки, а ее командный сценарий должен представлять собой командную строку для сборки библиотеки из набора объектных файлов, аналогично показанному в рецепте 1.3. При использовании GCC или компилятора с похожим синтаксисом командной строки настройте, если требуется, неявные правила шаблонов, изменив одну или более переменныхCXX,CXXFLAGSи т.п., используемых в базе данных неявных правилmake,как показано в рецепте 1.15. В противном случае, используя синтаксис шаблонных правил, описанный в рецепте 1.16, напишите шаблонное правило, говорящееmake,как с помощью командной строки из табл. 1.8 компилировать.cpp-файлы в объектные. Далее явно или неявно объявите цели, указывающие, как каждый из исходных файлов библиотеки зависит от включаемых в него заголовков. Эти зависимости можно описать вручную или сгенерировать их автоматически. Наконец, добавьте целиinstallиclean,как показано в рецепте 1.15.
   Например, чтобы с помощью GCC в Unix собрать из исходных файлов, перечисленных в примере 1.2, статическую библиотеку, создайте в директорииjohnpaul make-файл, показанный в примере 1.20.
   Пример 1 20. make-файл для создания libjohnpaul.a с помощью GCC в Unix
   #Укажите расширения файлов, удаляемых при очистке
   CLEANEXTS -о а

   #Укажите целевой файл и директорию установки
   OUTPUTFILE = libjohnpaul.a
   INSTALLDIR = ../binaries

   #Цель по умолчанию
   .PHONY: all
   all: $(OUTPUTFILE)
   #Соберите libjohnpaul.a из john.o. paul.o и johnpaul.с
   $(OUTPUTFILE): john.o paul.o johnpaul.о
       ar ru $@ $^
       ranlib $@

   #Для сборки john.o, paul.o и johnpaul.о из файлов .cpp
   #правила не требуются; этот процесс обрабатывается базой данных
   #неявных правил make
   .PHONY: install
   install:
       mkdir -p $(INSTALLDIR)
       cp -p $(OUTPUTFILE) $(INSTALLDIR)

   .PHONY: clean
   clean:
       for file in $(CLEANEXTS); do rm -f *.$$file; done

   #Укажите зависимости файлов cpp от файлов .hpp
   john.o: john.hpp
   paul.o: paul.hpp
   johnpaul.o: john.hpp paul.hpp johnpaul.hpp
   Аналогично, чтобы собрать статическую библиотеку с помощью Visual С++, ваш make-файл должен выглядеть, как показано в примере 1.21.
   Пример 1.21. make-файл для создания libjohnpaul.lib с помощью Visual C++
   #Укажите расширения файлов, удаляемых при очистке
   CLEANEXTS = obj lib

   # Specify the target file and the install directory
   OUTPUTFILE = libjohnpaul.lib
   INSTALLDIR = ./binaries
   #Шаблонное правило для сборки объектного файла из файла .cpp
   %.obj: %.cpp
       "$(MSVCDIR)/bin/cl" -с -nologo -EHsc -GP -Zc:forScope -Zc:wchar_t \
       $(CXXFLAGS) S(CPPFLAGS) -Fo"$@" $&lt;

   #Фиктивная цель
   .PHONY: all
   all: $(OUTPUTFILE)

   #Соберите libjohnpaul.lib из john.obj, paul.obj и johnpaul.obj
   $(OUTPUTFILE): john.obj paul.obj johnpaul.obj
       "$(MSVCDIR)/bin/link" -lib -nologo -out:"$@" $^

   .PHONY: install
   install:
       mkdir -p $(INSTALLDIR)
       cp -p $(OUTPUTFILE) $(INSTALLDIR)

   .PHONY: clean
   clean:
       for file in $(CLEANEXTS); do rm -f *.$$file; done

   #Укажите зависимости файлов .cpp от файлов .hpp
   john.obj: john.hpp
   paul.obj: paul.hpp
   johnpaul.obj: john.hpp paul.hpp johnpaul.hpp
    [Картинка: tip_yellow.png] В примере 1.21 я с помощью переменной среды MSVCDIR, устанавливаемой в vcvars32.bat,показал команду Visual C++ link.exeкак"$(MSVCDIR)/bin/link".Это позволяет избежать путаницы между компоновщиком Visual C++ и командой Unix link,поддерживаемой Cygwin и MSYS. Для полноты картины я также использовал MSVCDIR для команды компиляции Visual С++.Обсуждение
   Давайте подробно рассмотрим пример 1.20. Вначале я определяю переменные, представляющие выходной файл, директорию установки и расширения файлов, которые должны удаляться при сборке целиclean.Затем я объявляю цель по умолчаниюall,как в примере 1.14.
   Правило для сборки статической библиотеки выглядит так.
   $(OUTPUTFILE): john.o paul.o johnpaul.о
       ar ru $@ $^
       ranlib $@
   Это непосредственная адаптация записи для GCC из табл. 1.10. Здесь$(OUTPUTFILE)и$@раскрываются какlibjohnpaul.a,а$^раскрывается в виде списка пререквизитовjohn.o paul.o johnpaul.о.
   Следующие два правила объявляют целиinstallиclean,как в рецепте 1.15. Единственное отличие состоит в том, что в примере 1.20 для удаления всех файлов, чьи расширения имеются в спискео а— т. е. все объектные файлы и файлы статической библиотеки, - я использую цикл оболочки.
   for file in $(CLEANEXTS); do rm -f *.$$file; done
   Двойной знак доллара я использовал для того, чтобы запретитьmakeраскрывать переменную$$fileпри передаче ее оболочке.
   Три последних правила указывают отношения зависимостей между файлами.cppбиблиотеки и включаемыми в них заголовочными файлами. Здесь указано по одному правилу для каждого.cpp-файла. Целью такого правила является объектный файл, собираемый из.cpp-файла, а пререквизитами являются заголовочные файлы, явно или неявно включаемые.cpp-файлом.
   john.o: john.hpp
   paul.o: paul.hpp
   johnpaul.o. john.hpp paul.hpp johnpaul.hpp
   Это можно понять следующим образом. Если.cpp-файл явно или косвенно включает заголовочный файл, то он должен быть пересобран при каждом изменении этого заголовочного файла. Однако, так как.cpp-файл существует и не является целью какого-либо правила, он никогда не устаревает, как описано в рецепте 1.15. Следовательно, при изменении заголовочного файла перекомпиляции не происходит. Чтобы исправить эту ситуацию, требуется объявить правило, сделав эти зависимости явными; когда один из используемых заголовочных файлов изменяется, объектный файл, соответствующий.cpp-файлу, устаревает, что приводит к перекомпиляции.cpp-файла.
   Это решение удобно только для очень небольших проектов, так как очень сложно постоянно отслеживать зависимости целей, представляющих собой исходные файлы, входящие в большую базу кода. К счастью, имеется несколько способов автоматической генерации этих зависимостей. Например, три последних правила примера 1.20 можно заменитьна следующие.
   #Генерируем зависимости .cpp-файлов от .hpp-файлов
   include john.o paul.o johnpaul.о

   %.d: %.cpp
       $(CC) -M $(CPPFLAGS) $&lt;&gt; $@.$$$$; \
       sed 's.\($*\)\.o[ :]*.\1.o $@ : ,g'&lt; $@.$$$$&gt; $@, \
       rm -f $@.$$$$
   Этот фрагмент кода основан на опции компилятора-M,которая заставляет GCC вывести в make-файл информацию о зависимостях. За подробным описанием того, как это работает, и почему иногда не подходит, обратитесь к книгеManaging Projects with GNU make, Third Edition,написанной Робертом Мекленбургом (Robert Mecklenburg) (O'Reilly).
    [Картинка: tip_yellow.png] Код для генерации зависимостей помещайте в конец make-файла.
   Так как большинство компиляторов имеет опцию, аналогичную опции-М GCC,этот метод может быть адаптирован для работы с большинством инструментов. На самом деле обычно эта опция называется-Мили-m.Однако Visual C++ не имеет опции для генерации зависимостей в make-файле. При использовании Visual C++ есть две возможности. Можно использовать опцию-Gmсовместно с опциями-Ziили-ZI,обсуждаемыми в рецепте 1.21. Опция-Gmговорит компилятору создать базу данных, сохраняемую в файле с расширениемidb,содержащую информацию о зависимостях между исходными файлами. Файл .idbсоздается при первоначальной компиляции файла или набора файлов.cpp.При последующих компиляциях перекомпилируются только те исходные файлы, которые были изменены или зависят от изменившихся заголовочных файлов.
   Кроме того, можно использовать опцию-showIncludesсовместно с опцией-E.Опция-showIncludesприводит к тому, что компилятор при каждом обнаружении директивы include выводит в стандартный поток ошибок сообщение. Опция-Eговорит компилятору запустить препроцессор и выйти, не создавая никаких двоичных файлов. С помощью небольшого сценария оболочки можно использовать вывод, сгенерированный-showIncludes;для создания зависимостей в make-файле.
   include john.d paul.d johnpaul.d

   %d: %.cpp
       "$(MSVCDIR)/bin/cl" -E -showIncludes $&lt; 2&gt; $@.$$$$&gt; /dev/null; \
       sed -n 's/^Note: including file: *\(.*\)/$*.obj•$*.d:\1/gp' \
      &lt; $@.$$$$ | sed "s:\\:/:g:s: :\\ :gp"&gt; $@; \
       rm -f $@.$$$$
   В этом примере символ • обозначает Tab.
   Давайте сделаем еще одно последнее усовершенствование примера 1.20. В настоящий момент последовательностьjohn paul johnpaulсодержится в двух местах — в пререквизитах правила для сборки статической библиотеки и в директивеinclude,используемой для генерации зависимостей. Если список исходных файлов изменится, вам придется вносить изменения в двух местах make-файла. Гораздо лучше определить переменнуюSOURCESи заменить оба использования последовательностиjohn paul johnpaulна выражения, использующиеSOURCES.
   SOURCES = john.cpp paul.cpp johnpaul.cpp
   ...
   #Собираем libjohnpaul.a из john.о, paul.o и johnpaul.о
   $(OUTPUTFILE): $(subst .cpp, .o,$(SOURCES))
       ar ru $@ $^
       ranlib $@
   ...
   #Генерируем зависимости .cpp-файлов от .hpp-файлов
   include $(subst .cpp,.d,$(SOURCES))
   %d: %.cpp
       $(CC) -M $(CPPFLAGS) $&lt;&gt; $@.$$$$; \
       sed 's,\($*\)\.o[ :]*.\1.o $@ : .g'&lt; $@ $$$$&gt; $@; \
       rm -f $@.$$$$
   Здесь я использую функциюmake$(substx,y,str),которая заменяет в строкеstrвсе вхожденияxнаy.
    [Картинка: tip_yellow.png] GNU makeподдерживает большое количество функций обработки строк и имен файлов, а также много других. Также она поддерживает определение пользовательских функций. Как обычно, за подробным описанием обратитесь к Managing Projects with GNU make, Third EditionРоберта Мекленбурга (O'Reilly).Смотри также
   Рецепты 1.2 и 1.7.
   1.17.Сборка динамической библиотеки с помощью GNU MakeПроблема
   Вы хотите использовать GNUmakeдля сборки динамической библиотеки из набора исходных файлов С++, таких как перечисленные в примере 1.2.Решение
   Вначале в директории, где должна быть создана динамическая библиотека, создайте make-файл и объявите фиктивнуюцель all,единственным пререквизитом которой будет эта динамическая библиотека. Затем объявите цель динамической библиотеки. Ее пререквизитами должны быть объектные файлы, из которых она собирается, а ее командный сценарий должен представлять собой командную строку для сборки библиотеки из набора объектных файлов, аналогично показанному в рецепте 1.4. При использовании GCC или компилятора с похожим синтаксисом командной строки настройте, если требуется, неявные правила шаблонов, изменив одну или более переменныхCXX,CXXFLAGSи т.п., используемых в базе данных неявных правилmake,как показано в рецепте 1.15. В противном случае, используя синтаксис шаблонных правил, описанный в рецепте 1.16, напишите шаблонное правило, говорящееmake,как с помощью командной строки из табл. 1.8 скомпилировать.cpp-файлы в объектные. Наконец добавьте целиinstallиclean,как показано в рецепте 1.15, и механизм для автоматической генерации зависимостей исходных файлов, как показано в рецепте 1.16.
   Например, чтобы из исходных файлов, перечисленных в примере 1.2, собрать динамическую библиотеку с помощью GCC в Unix, в директорииgeorgeringoсоздайте make-файл, показанный в примере 1.22.
   Пример 1.22. make-файл для libgeorgeringo.so с использованием GCC
   #Укажите расширения файлов, удаляемых при очистке
   CLEANEXTS = o so

   #Укажите исходные файлы, целевой файл и директорию установки
   SOURCES = george.cpp ringo.cpp georgeringo.cpp
   OUTPUTFILE = libgeorgeringo.so
   INSTALLDIR = ../binaries

   .PHONY: all
   all: $(OUTPUTFILE)

   #Соберите libgeorgeringo.so из george.o, ringo.о
   #и georgeringo.o; subst - это функция поиска и замены.
   #показанная в рецепте 1.16
   $(OUTPUTFILE): $(subst .cpp,.o,$(SOURCES))
       $(CXX) -shared -fPIC $(LDFLAGS) -о

   .PHONY: install
   install:
       mkdir -p $(INSTALLDIR)
       cp -p $(OUTPUTFILE) $(INSTALLDIR)

   .PHONY: clean
   clean:
       for file in $(CLEANEXTS); do rm -f *.$$file; done

   #Сгенерируйте зависимости файлов .cpp от файлов .hpp
       include $(subst .cpp,.d,$(SOURCES))

   %.d: %.cpp
       $(CC) -M $(CPPFLAGS) $&lt;&gt; $@.$$$$; \
       sed 's. \($*\)\.o[ :]*.\1.o $@ : ,g'&lt; $@.$$$$&gt; $@; \
       rm -f $@.$$$$Обсуждение
   make-файл из примера 1.22 — это прямое применение идей из рецептов 1.4, 1.15 и 1.16. Главным отличием между примерами 1.22 и 1.20 является правило для сборкиlibgeorgeringo.soиз объектных файловgeorge.o,ringo.oиgeorgeringo.о.
   $(OUTPUTFILE): $(subst .cpp,.o,$(SOURCES))
   $(CXX) -shared -fPIC $(LDFLAGS) -о $@ $^
   Здесь$(OUTPUTFILE)раскрывается какlibgeorgeringo.so,а выражение$(subst.cpp, .o, $(SOURCES))раскрывается какgeorge.о,ringo.оиgeorgeringo.o,как показано в рецепте 1.16. Командный сценарий$(CXX) -shared -fPIC $(LDFLAGS) -о— это адаптация командной строки GCC, показанной в табл. 1.11.Смотри также
   Рецепты 1.4, 1.9, 1.12, 1.19 и 1.23.
   1.18.Сборка сложного приложения с помощью GNU makeПроблема
   Вы хотите использовать GNUmakeдля сборки исполняемого файла, зависящего от нескольких статических и динамических библиотек.Решение
   Выполните следующие действия.
   1. Создайте make-файлы для библиотек, используемых приложением, как описано в рецептах 1.16 и 1.17. Эти make-файлы должны находиться в отдельных директориях.
   2. Создайте make-файл в еще одной директории. Этот make-файл будет использоваться для сборки приложения, но только после того, как будут выполнены make-файлы из шага 1. Укажите в этом make-файле фиктивную цельall,чьим пререквизитом будет являться исполняемый файл. Объявите цель исполняемого файла с пререквизитами, состоящими из библиотек, используемых приложением, а также объектных файлов, которые собираются из.cpp-файлов приложения. Напишите командный сценарий для сборки исполняемого файла из набора библиотек и объектных файлов, как описано в рецепте 1.5. Если необходимо, напишите шаблонное правило для генерации объектных файлов из.cpp-файлов, как показано в рецепте 1.16. Добавьте цели install и clean, как показано в рецепте 1.15, и механизм для автоматической генерации зависимостей исходных файлов, как показано в рецепте 1.16.
   3. В директории, родительской по отношению к директориям, содержащим все остальные make-файлы, создайте новый make-файл — давайте называть егоглавным (top-level) make-файлом, а все остальные —подчиненными.Объявите цель по умолчанию all с пререквизитами в виде директории, содержащей make файл, созданный на шаге 2. Объявите правило, чьи цели состоят из директорий, содержащих подчиненные make-файлы, а командный сценарий вызываетmakeв каждой целевой директории для цели, указанной в виде значения переменнойTARGET.Наконец, объявите цели, указывающие зависимости между целями по умолчанию подчиненных make-файлов.
   Например, чтобы из исходных файлов из примера 1.3 собрать исполняемый файл с помощью GCC в Unix, создайте такой make-файл, как показанный в примере 1.23.
   Пример 1.23. make файл для hellobeatles.exe с использованием GCC
   #Укажите исходные файлы, целевой файл, директории сборки
   #и директорию установки
   SOURCES = hellobeatles.cpp
   OUTPUTFILE = hellobeatles
   LIBJOHNPAUL = libjohnpaul.a
   LIBGEORGERINGO = libgeorgeringo.so
   JOHNPAULDIR = ../johnpaul
   GEORGERINGODIR = ../georgeringo
   INSTALLDIR = ../binaries

   #
   #Добавьте в путь поиска заголовочных файлов родительскую директорию
   #
   CPPFLAGS += -I..

   #
   #Цель по умолчанию
   #
   .PHONY: all
   all: $(HELLOBEATLES)

   #
   #Цель для сборки исполняемого файла.
   #
   $(OUTPUTFILE): $(subst .cpp,.о,$(SOURCES)) \
    $(JOHNPAULDIR)/$(LIBJOHNPAUL) \
    $(GEORGERINGODIR)/$(LIBGEORGERINGO)
       $(CXX) $(LDFLAGS) -o $@ $^

   .PHONY: install
   install:
       mkdir -p $(INSTALLDIR)
       cp -p $(OUTPUTFILE) $(INSTALLDIR)

   .PHONY: clean
   clean:
       rm -f *.o
       rm -f $(OUTPUTFILE)

   #Сгенерируйте зависимости .cpp-файлов от .hpp-файлов
   include $(subst .cpp,.d,$(SOURCES))

   %.d: %.cpp
       $(CC) -M $(CPPFLAGS) $&lt;&gt; $@.$$$$; \
       sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g'&lt; $@..$$$$&gt; $@; \
       rm -f $@.$$$$
   Далее в директории, содержащейjohnpaul,georgeringo,hellobeatlesиbinaries,создайте главный make-файл, как показано в примере 1.24.
   Пример 1.24. Главный make-файл для исходного кода из примеров 1.1, 1.2 и 1.3
   #Все цели в этом make-файле — фиктивные
   PHONY: all johnpaul georgeringo hellobeatles

   #Цель по умолчанию
   all: hellobeatles

   #Цели johnpaul, georgeringo и hellobeatles представляют
   #директории, командный сценарий вызывает make в каждой из них
   johnpaul georgeringo hellobeatles
   $(MAKE) --directory=$@ $(TARGET)

   #Это правило указывает что цель по умолчанию make-файла
   #в директории hellobeatles зависит от целей по умолчанию
   # make-файлов из директорий johnpaul и georgeringo
   .PHONY: hellobeatles
   hellobeatles: johnpaul georgeringo
   Чтобы собратьhellobeatles,перейдите в директорию, содержащую главный make-файл, и введитеmake.Чтобы скопировать файлыlibjohnpaul.a,libgeorgeringo.soиhellobeatlesв директориюbinaries,введитеmake TARGET=install.Чтобы очистить проект, введитеmake TARGET=clean.Обсуждение
   Подход к управлению сложными проектами, продемонстрированный в этом рецепте, известен какрекурсивный make (recursive make).Он позволяет организовать проект в виде набора модулей, каждый со своим собственным make-файлом, и указать зависимости между этими модулями. Он не ограничен одним главным make-файлом с набором дочерних make-файлов: эта методика может применяться для обработки многоуровневых древовидных структур. В то время, пока рекурсивныйmakeбыл стандартной методикой управления большими проектами с помощьюmake,появились другие методы, которые теперь рассматриваются как более качественные. За подробностями снова обратитесь кManaging Projects with GNU make, Third EditionРоберта Мекленбурга (O'Reilly).
   Пример 1.23 — это прямое применение методик, продемонстрированных в рецептах 1.15, 1,16 и 1.17. В нем есть один очень интересный момент. Как показано в рецепте 1.15, при компиляцииhellobeatles.cppиз командной строки необходимо использовать опцию-I..,говорящую компилятору, где искать заголовочные файлыjohnpaul.hppиgeorgeringo.hpp.Одним из возможных решений является написание явного правила сборкиhellobeatles.oс помощью командного сценария, содержащего опцию-I..подобно этому.
   hellobeatles.o: hellobeatles.cpp
   g++ -с -I.. -о hellobeatles.o hellobeatles.cpp
   Вместо этого я использовал точку настройкиCPPFLAGS,описанную в рецепте 1.15, и указал, что всегда, когда происходит компиляция объектного файла из файла.cpp,в командную строку должна быть добавлена опция-I..:
   CPPFLAGS += -I..
   Вместо оператора присвоения=я использовал+=,так что новое значение будет добавляться к тому значениюCPPFLAGS,которое могло быть указано в командной строке или в переменной среды.
   Теперь давайте посмотрим на то, как работает пример 1.24. Наиболее важным правилом является то, которое заставляетmakeвызываться для каждой из директорийjohnpaul,georgeringoиhellobeatles.
   johnpaul georgeringo hellobeatles:
   $(MAKE) --directory=$@ $(TARGET)
   Чтобы понять это правило, вы должны знать три вещи. Во-первых, переменнаяMAKEраскрывается как имя запущенного в данный момент экземпляраmake.Обычно это будетmake,но на некоторых системах это может бытьgmake.Во-вторых, опция командной строки--directory=&lt;path&gt;заставляетmakeвызваться с&lt;path&gt;в качестве текущей директории. В-третьих, правило с несколькими целями эквивалентно набору правил, каждое из которых имеет по одной цели и которые содержат одинаковые командные сценарии. Так что приведенное выше правило эквивалентно следующим.
   johnpaul:
       $(MAKE) --directory=$@ $(TARGET)

   georgeringo:
       $(MAKE) --directory=$@ $(TARGET)

   hellobeatles:
       $(MAKE) --directory=$@ $(TARGET)
   В свою очередь это эквивалентно:
   johnpaul:
       $(MAKE) --directory=johnpaul $(TARGET)

   georgeringo:
       $(MAKE) --directory=georgeringo $(TARGET)

   hellobeatles:
       $(MAKE) -directory=hellobeatles $(TARGET)
   Следовательно, эффект от этого правила состоит в вызове make-файлов в каждой из директорийjohnpaul,georgeringoиhellobeatles,а в командной строке передаётся значение переменнойTARGET.В результате для сборки целиxxxв каждом из подчиненных make-файлов требуется выполнить главный make-файл с опциейTARGET=xxx.
   Последнее правило make-файла гарантирует, что подчиненные make-файлы вызываются в правильном порядке; оно просто объявляет цельhellobeatles,зависящую от целейjohnpaulиgeorgeringo.
   hellobeatles: johnpaul georgeringo
   В более сложном приложении может иметься большое количество зависимостей между исполняемым файлом и входящими в него библиотеками. Для каждой такой компоненты требуется объявить правило, указывающее другие компоненты, от которых она явно зависит.Смотри также
   Рецепты 1.5, 1.10 и 1.13.
   1.19.Определение макросаПроблема
   Вы хотите определить символ препроцессораname,присвоив ему либо неопределенное значение, либо значениеvalue.Решение
   Опции компилятора для определения макросов в командной строке показаны в табл. 1.16. Инструкции для определения макросов в IDE приведены в табл. 1.17. Чтобы определить макрос с помощью Boost.Build, просто добавьте в требования цели свойство вида&lt;define&gt;name[=value],как показано в табл. 1.15 и примере 1.12.

   Табл. 1.16. Определение макроса из командной строкиИнструментарийОпцииВсе-Dname[-value]

   Табл. 1.17. Определение макроса из IDEIDEКонфигурацияVisual C++На страницах свойств проекта перейдите к Configuration Properties->C/C++->Preprocessorи в Preprocessor Definitions (определения препроцессора) введитеname[=value],для разделения нескольких записей используя точку с запятойCodeWarriorВ окне Target Settings перейдите к Language Settings->C/C++ Preprocessorи введите:#define name[=value]в поле с именем Prefix TextC++BuilderВ Project Options перейдите к Directories/Conditionals и в Preprocessor Definitions введитеname[=value],для разделения нескольких записей используя точку с запятойDev-C++В Project Options выберите Parameters и введите:-Dname[=value]в области C++ CompilerОбсуждение
   Символы препроцессора часто используются в коде C++ для того, чтобы один набор исходных файлов мог быть использован в нескольких конфигурациях сборки или операционных системах. Например, предположим, что вы хотите написать функцию, проверяющую, является ли имя объекта именем файла или директории. Сейчас стандартная библиотека C++ не предоставляет функциональности, необходимой для выполнения этой задачи. Следовательно, эта функция должна использовать функции, специфичные для платформы. Если вы хотите, чтобы этот код работал и в Windows, и в Unix, вы должны убедиться, что код, использующий специфичные для Windows функции, невидим для компилятора при компиляции под Unix, и наоборот. Обычным способом достижения этого эффекта является использование условной компиляции, иллюстрируемой в примере 1.25.
   Пример 1.25. Условная компиляция с помощью предопределенных макросов
   #ifdef _WIN32
   # include&lt;windows.h&gt;
   #else // He Windows -предположим, что мы в Unix
   # include&lt;sys/stat.h&gt;
   #endif

   bool is_directory(const char* path) {
   #ifdef _WIN32
    // реализация для Windows
   #else
    // реализация для Unix
   #endif
   }
   В Windows все наборы инструментов, за исключением порта GCC Cygwin, определяют макрос_WIN32.Макрос, определяемый автоматически, называется предопределенным макросом. Пример 1.25 использует предопределенный макросWIN32для определения, под какой операционной системой он компилируется, и для включения соответствующего специфичного для платформы кода.
   Однако часто настроечная информация, необходимая для выполнения подобного рода условной компиляции, в виде предопределенных макросов недоступна. В таких случаях необходимо создать собственные макросы и с помощью методов, показанных в табл. 1.15, 1.16 и 1.17, присвоить им соответствующие значения. Хорошим примером является пример 1.2. В Windows при сборке DLLgeorgeringo.dllфункцияgeorgeringo()должна быть объявлена с атрибутом__declspec(dllexport),а в остальных случаях — с атрибутом__declspec(dllimport).Как описано в рецепте 1.4, этого эффекта можно достичь, определив в командной строке сборки DLL символ препроцессораGEORGERINGO_DLLи не определяя его при компиляции кода, использующего эту DLL.
    [Картинка: tip_yellow.png] Если вы не указали значение макроса, то большинство компиляторов присваивают ему значение 1, но некоторые присваивают ему пустое значение. При использовании макросов для включения условной компиляции, как в примере 1.25, эта разница не имеет значения. Однако, если требуется, чтобы макрос раскрывался как определенное значение, вы должны указать это значение явно, использовав запись вида-D&lt;name&gt;=&lt;value&gt;.Смотри также
   Рецепты 1.4, 1.9, 1.12 и 1.17.
   1.20.Указание опций командной строки из IDEПроблема
   Вы хотите передать компилятору или компоновщику опцию командной строки, но она не соответствует ни одному из параметров, доступных в IDE.Решение
   Многие IDE предоставляют способ передачи опций командной строки непосредственно компилятору или компоновщику. Эти способы приведены в табл. 1.18 и 1.19.

   Табл. 1.18. Указание опций компилятора из IDEIDEКонфигурацияVisual C++На страницах свойств проекта перейдите к Configuration Properties->С/С++->Command Line (командная строка) и введите опцию в поле Additional options (дополнительные опции)CodeWarriorНеприменимоC++BuilderНеприменимоDev-C++В Project Options выберите Parameters и введите опцию в поле C++ Compiler

   Табл. 1.19. Указание опций компоновщика из IDEIDEКонфигурацияVisual C++На страницах свойств проекта перейдите к Configuration Properties->Linker->Command Lineи введите опцию в поле Additions optionsMetrowerksНеприменимоC++BuilderНеприменимоDev-C++В Project Options выберите Parameters и введите опцию в поле LinkerОбсуждение
   Visual C++предоставляет опции расширенной настройки через свой графический интерфейс, но также позволяет указать опции командной строки явно. CodeWarrior и C++Builder не позволяют явно устанавливать опции командной строки, но обычно это не является проблемой, так как аналогично Visual C++ они предоставляют опции расширенной настройки через свои графические интерфейсы. С другой стороны, некоторые IDE предоставляют для настройки инструментов командной строки только самый минимум, за исключением возможности явного ввода в текстовое поле опций командной строки. Dev-C++ занимает положение где-то посередине: хотя Dev-C++ предлагает больше графических опций настройки, чем некоторые IDE, предназначенные для работы с инструментарием GCC, при его использовании обычно бывает необходимо явно ввести опции командной строки.
   1.21.Создание отладочной сборкиПроблема
   Вы хотите собрать версию проекта, которую можно будет легко отлаживать.Решение
   В основном для получения отладочной сборки требуется:
   • отключить оптимизации;
   • отключить расширение встраиваемых (inline) функций;
   • включить генерацию отладочной информации.
   Таблица 1.20 представляет опции компилятора и компоновщика, предназначенные для отключения оптимизаций и встраивания функций, а табл. 1.21 представляет опции компилятора и компоновщика для включения отладочной информации.

   Табл. 1.20. Отключение оптимизаций и встраивания из командной строкиИнструментарииОптимизацияВстраиваниеGCC-O0-fno-inline?Visual C++ Intel (Windows)-Od-Ob0Intel (Linux)-O0-Ob0-opt off-inline offComeau (Unix)-O0--no_inliningComeau (Windows)Toже, что и у основного компилятора, но вместо тире (-) используется слеш (/)Borland-Od-vi-Digital Mars-o+none -S-C
   ?Эту опцию указывать не требуется, если не была указана опция-O3.

   Табл. 1.21. Опции командной строки для включения отладочной информацииИнструментарииОпции компилятораОпции компоновщикаComeau (Unix) GCC-g-gIntel (Linux) MetrowerksVisual C++ Intel (Windows)См. табл. 1.22См. табл. 1 22Comeau (Windows)Toже, что и у основного компилятора, но вместо тире (-) используется слеш (/)То же, что и у основного компилятора, но вместо тире (-) используется слеш (/)Borland-v-vDigital Mars-g-co

   Табл. 1.22. Включение отладочной информации при использовании Visual C++ или Intel для WindowsОпции компилятораОпции компоновщикаIDE options?Описание-Z7-debugC7 Compatible (совместимость с C7)Отладочная информация сохраняется в файлах.objи.exe-Zi [-Fd&lt;pdb-file-for-obj&gt;].-debug[-pdb:&lt;pdb-file-for-exe&gt;]Program Database (база данных программы)Отладочная информация сохраняется в файлах.pdb;опция в квадратных скобках используется для указания файлов.pdb-Zi [-Fd&lt;pdbfile-for-obj&gt;]-debug [-pdb:&lt;pdb-file-for-exe&gt;]Program Database for Edit& Continue (база данных программы для редактирования и продолжения)Отладочная информация сохраняется в файлах .pdb;опция в квадратных скобках используется для указания файлов.pdb.Программа может быть перекомпилирована во время сессии отладки
   ?Чтобы получить доступ к этим опциям, перейдите к Configuration Properties->С/С++-> General->Debug Information Format (формат отладочной информации).

   BoostBuildпредоставляет похожий механизм создания отладочной сборки: просто добавьте к требованиям цели&lt;variant&gt;debugили используйте опцию командной строкиvariant=debug,которую можно сократить до простоdebug.
   Некоторые IDE также предоставляют простой способ создания отладочной сборки. Например, при создании нового проекта в Visual C++ IDE автоматически генерирует конфигурации для отладочной и окончательной сборок. Чтобы запросить отладочную сборку, просто выберите в меню Build опцию Configuration Manager и в качестве активной выберите конфигурацию Debug. Также можно выбрать Debug в раскрывающемся списке конфигураций на стандартной панели инструментов. При следующей сборке проекта будет создана отладочная сборка.
   Аналогично при создании проекта в CodeWarrior с помощью одного из шаблонов проектов Metrowerks, называемых «принадлежности» (stationery), IDEавтоматически генерирует отладочную и окончательную цели. Имя отладочной цели может быть разным, но оно всегда должно включать слово «debug». Чтобы запросить отладочную сборку, в меню Project выберите пункт Set Default Target (установить цель по умолчанию), а затем выберите элемент меню, соответствующий отладочной цели. Также можно выбратьотладочную цель в раскрывающемся списке целей в окне проекта.
   C++Builderне поддерживает множественных конфигураций для одного проекта, но он предоставляет простой способ создания отладочной сборки. Чтобы запросить отладочную сборку,перейдите в Project Options->Compilerи нажмите на Full debug (полная отладка). Это отключит все оптимизации и встраивание и включит отладочную информацию.
   При использовании IDE, которая не предоставляет готовых отладочной и окончательной конфигураций, такой как Dev-C++, или если вам требуется получить дополнительный контроль над параметрами проекта, обратитесь к таблицам с 1.23 до 1.25.

   Табл. 1.23. Отключение оптимизаций из IDEIDEКонфигурацияVisual C++На страницах свойств проекта перейдите к Configuration Properties->C/C++->Optimizationи установите опцию Optimization в значение Disabled (отключено). Для остальных опций на этой странице оставьте значения по умолчаниюCodeWarriorВ окне Target Settings перейдите к Code Generation->Global Optimizations (генерация кода->глобальная оптимизация) и выберите Off (выкл)C++BuilderВ Project Options перейдите к Compiler, в разделе Code optimization (оптимизация кода) выберите NoneDev-C++В Project Options перейдите к Compiler->Optimizationи установите опцию Perform a number of minor optimizations (выполнить несколько незначительных оптимизаций) в значение No (нет), затем перейдите к Compiler->Optimization->Further optimizations (дополнительные оптимизации) и установите опции Optimize (оптимизировать), Optimize more (дополнительно оптимизировать) и Best Optimization (наилучшая оптимизация) в значение No

   Табл. 1.24. Отключение встраивания из IDEIDEКонфигурацияVisual C++На страницах свойств проекта перейдите к Configuration Properties->C/C++->Optimizationи установите опцию Inline Function Expansion (расширение встраиваемых функций) в значение Default (по умолчанию)CodeWarriorВ окне Target Settings перейдите к Language Settings->C/C++ Languageи установите Inline Depth (глубина встраивания) в значение Don't Inline (не встраивать)C++BuilderВ Project Options перейдите к Compiler и в разделе Debugging установите флажок Disable inline expansions (отключить встраивание функций)Dev-C++См. запись для GCC в табл. 1.20 и обратитесь к рецепту 1.20

   Табл. 1.25. Включение отладочной информации в IDEIDEКонфигурацияVisual C++См. табл. 1.22CodeWarriorВ окне Target Settings перейдите к Language Settings->Linker->PPC Mac OS X Linkerи установите флажки Generate SYM File (генерировать SYM-файл) и Full Path in SYM Files (полные пути в SYM-файлах)C++BuilderВ Project Options перейдите к Compiler и установите флажки Debug information и Line Number Information (информация о номерах строк)Dev-C++См. запись для GCC в табл. 1.21 и обратитесь к рецепту 1.20Обсуждение
   Все наборы инструментов предоставляют опции для генерации в объектных и исполняемых файлах информации, которая позволяет отладчикам сообщать полезные данные при пошаговом выполнении программы. Эта информация обычно включает имена исходных файлов и номера строк, соответствующих определенному объекту или инструкциям машинного кода, а также информацию об объектах С++, занимающих определенные области памяти, включая их имена и типы.
   Большинство наборов инструментов сохраняют отладочную информацию непосредственно в объектных и исполняемых файлах, но некоторые также предоставляют опцию для генерации отладочной информации в отдельных файлах базы данных. Например, в Visual C++ опция компилятора-Z7указывает, что отладочная информация должна быть помещена в объектные и исполняемые файлы, а опции-Ziи-ZIуказывают, что она должна быть сохранена в файлах базы данных программы, имеющих расширение.pdb.Опция-ZIвключает функцию, которая называетсяEdit and Continue (отредактировать и продолжить), которая позволяет пользователям IDE изменять и перекомпилировать код, не прерывая сессии отладки. Аналогично CodeWarrior для Mac OS X по умолчанию генерирует отладочную информацию в файлах.SYM.
   Большая часть наборов инструментов может генерировать отладочную информацию даже с включенными оптимизациями и встраиванием, хотя в некоторых случаях отладочная информация может оказаться несовместимой с некоторыми видами оптимизации. Однако при включении оптимизаций компилятор может увеличить эффективность кода, изменив порядок следования операторов или полностью реорганизовав фрагменты кода, в то время как внешне его поведение останется неизменным. Это делает отладку более сложной, так как при этом теряется строгое соответствие между частями исходного кода и местами расположения объектов и машинным кодом. Это же верно и для встраивания: когда компилятор раскрывает встраиваемую функцию, объектный код, соответствующий этой функции, генерируется в теле вызывающей функции. При выполнении этого кода для встроенной функции не создается стекового фрейма. Помимо всего прочего это означает, что отладчик не сможет отобразить значения аргументов функции и ее локальных переменных. Обычно отладчики даже не пытаются сообщать о местах в исходном коде, соответствующих телам встроенных функций.
   По этим причинам обычно при создании отладочной сборки принято отключать оптимизации и встраивание.Смотри также
   Рецепт 1.22.
   1.22.Создание окончательной сборкиПроблема
   Вы хотите создать небольшой быстрый исполняемый файл или динамическую библиотеку, предназначенные для распространения среди покупателей.Решение
   В основном для получения окончательной сборки требуется:
   • включить оптимизации;
   • включить расширение встраиваемых (inline) функций;
   • отключить генерацию отладочной информации.
   В табл 1.26 представлены опции компилятора и компоновщика, включающие оптимизацию и встраивание. Опций командной строки для отключения отладочной информации не существует: при сборке из командной строки отладочная информация по умолчанию отключена. Однако при использовании инструментария GCC размер исполняемых файлов и динамических библиотек можно уменьшить, указав компоновщику опцию-s.

   Табл. 1.26. Опции компилятора, включающие оптимизации и встраиваниеИнструментарийОптимизацияВстраиваниеGCC-O3-finline-functions?Visual C++ Intel-O2-Оb1Metrowerks-opt full-inline auto -inline level=8Comeau (Unix)-O3Comeau (Windows)Toже, что и у основного компилятора, но вместо тире (-) используется слеш (/)-inliningBorland-O2-viDigital Mars-o+timeВключено по умолчанию
   ?Эта опция автоматически включается при указании-O3.

   Boost.Buildпредоставляет похожий механизм создания окончательной сборки: просто добавьте к требованиям цели&lt;variant&gt;releaseили используйте опцию командной строкиvariant=release,которую можно сократить до простоrelease.
   Некоторые IDE также предоставляют простой способ создания окончательной сборки. Например, как я говорил в рецепте 1.21, при создании нового проекта в Visual C++ IDE автоматически генерирует отладочную и окончательную конфигурации. Чтобы запросить окончательную сборку, просто выберите в меню Build опцию Configuration Manager и в качестве активной выберите конфигурацию Release. Также можно выбрать Release в раскрывающемся списке конфигураций на стандартной панели инструментов. При следующей сборке проекта будет создана окончательная сборка.
   Аналогично при создании проекта в CodeWarrior с помощью одного из шаблонов проектов Metrowerks, называемых «принадлежности» (stationery), IDEавтоматически генерирует отладочную и окончательную цели. Имя окончательной цели может быть разным, но оно всегда должно включать слово «release» или «final». Чтобы запросить окончательную сборку, в меню Project выберите пункт Set Default Target (установить цель по умолчанию), а затем выберите элемент меню, соответствующий окончательной цели.Также можно выбрать окончательную цель в раскрывающемся списке целей в окне проекта.
   C++Builderне поддерживает множественных конфигураций для одного проекта, но он предоставляет простой способ создания окончательной сборки. Чтобы запросить окончательную сборку, перейдите в Project Options->Compilerи нажмите на Release. Это включит все оптимизации и встраивание и отключит отладочную информацию.
   При использовании IDE, которая не предоставляет готовых отладочной и окончательной конфигураций, такой как Dev-C++, или если требуется получить дополнительный контроль над параметрами проекта, обратитесь к таблицам с 1.27 до 1.29.

   Табл. 1.27. Включение оптимизаций из IDEIDEКонфигурацияVisual C++На странице свойств проекта перейдите к Configuration Properties->C/C++->Optimizationи установите параметр Optimization в значение Maximize Speed (Максимизировать быстродействие), Favor Size or Speed (Отдавать предпочтение размеру или скорости) в значение Favor Fast Code (Отдавать предпочтение быстроте кода), а параметры Global Optimizations (Глобальная оптимизация). Enable Intrinsic Functions (Включить встроенные функции) и Omit Frame Pointers (Не включать указатели фрейма) в значение Yes (Да). Для остальных опций на этой странице оставьте значения по умолчаниюCodeWarriorВ окне Target Settings перейдите к Code Generation->Global Optimizations (Генерация кода->Глобальная оптимизация) и выберите Level 4 (Уровень 4)C++BuilderВ Project Options перейдите к Compiler, в разделе Code optimization (оптимизация кода) выберите Speed (Скорость)Dev-C++См запись для GCC в табл. 1 26 и обратитесь к рецепту 1.20

   Табл. 1.28. Включение встраивания из IDEIDEКонфигурацияVisual C++На страницах свойств проекта перейдите к Configuration Properties->C/C++->Optimizationи установите опцию Inline Function Expansion (расширение встраиваемых функций) в значение Any Suitable (Все подходящие)CodeWarriorВ окне Target Settings перейдите к Language Settings->C/C++ Language.Установите параметр Inline Depth (Глубина встраивания) в значение 8, а остальные опции встраивания оставьте неотмеченнымиC++BuilderВ Project Options перейдите к Compiler и в разделе Debugging снимите флажок Disable inline expansions (Отключить встраивание функций)Dev-C++См. запись для GCC в табл. 1.26 и обратитесь к рецепту 1.20

   Табл. 1.29. Отключение отладочной информации в IDEIDEКонфигурацияVisual C++На страницах свойств проекта перейдите к Configuration Properties->С/С++->Generalи для опции Debug Information Formal (Формат отладочной информации) выберите значение DisabledMetrowerksВ окне Target Settings перейдите к Language Settings->Linker->х86 Linker и снимите флажки Store full paths (Сохранять полные пути). Link debug info (Компоновать с отладочной информацией), и Debug inline functions (Отлаживать встраиваемые функции)C++BuilderВ Project Options перейдите к Compiler и снимите флажки Debug Information и Line Number Information (информация о номерах строк)Dev-C++Убедитесь, что. как описано в рецепте 1.20 не указана опция командной строки-gОбсуждение
   Большинство наборов инструментов предлагает несколько опций оптимизации, а некоторые даже десятки. Какие оптимизации следует выбрать, зависит от требований к проекту. Например, во встраиваемых системах может потребоваться выбрать оптимизации, которые ценой некоторого уменьшения скорости приводят к созданию меньших по размеру исполняемых файлов. В других случаях приоритет может отдаваться скорости. Некоторые оптимизации сделают программу быстрее на одной платформе, но медленнее на другой. Вы можете даже столкнуться с тем, что некоторые опции сделают отдельные части программы быстрее, а другие части — медленнее.
   Таблицы 1.26 и 1.27 показывают опции обобщенных оптимизаций, но для достижения наилучших результатов следует тщательно рассмотреть все требования, изучить документацию по инструментарию и провести всестороннее тестирование.
   Эта ситуация аналогична встраиванию, хотя обычно инструментарии предоставляют значительно меньше опций для встраивания, чем для других оптимизацийСмотри также
   Рецепт 1.21.
   1.23.Указание варианта библиотеки времени выполненияПроблема
   Ваш инструментарий поставляется с несколькими вариантами базовых библиотек времени выполнения, и вы хотите указать компилятору и компоновщику тот вариант, который должен использоваться.Решение
   Библиотеки времени выполнения, поставляемые с данным инструментарием, могут различаться по тому, являются ли они одно- или многопоточными, статическими или динамическими и содержат ли они отладочную информацию или нет.
   При использовании Boost.Build эти три выбора можно сделать, использовав функцииthreading,runtime-linkиvariant,описанные в табл. 1.15. Например, чтобы указать статическую библиотеку времени выполнения, добавьте к требованиям цели&lt;runtime-link&gt;staticили используйте опцию командной строкиruntime-link=static.Чтобы указать многопоточную библиотеку времени выполнения, добавьте к требованиям цели&lt;threading&gt;multiили используйте опцию командной строкиthreading=multi.
   При сборке из командной строки используйте опции компилятора и компоновщика, представленные в таблицах с 1.30 до 1.36. Опции командной строки и имена библиотек для отладочной и окончательной конфигураций обычно очень похожи. В следующих таблицах буквы в квадратных скобках добавляются только для отладочных конфигураций. Имена динамических вариантов библиотек времени выполнения показаны в круглых скобках. При выборе динамической компоновки эти библиотеки должны быть доступны при выполнении программы.

   Табл. 1.30. Опции компилятора для выбора библиотеки времени выполнения при использовании Visual C++ или Intel (Windows)Статическая компоновкаДинамическая компоновкаОднопоточная-ML[d]?НеприменимоМногопоточная-MT[d]-MD[d](msvcrt[d].dll, msvcr80[d].dll)?
   ?Начиная с Visual Studio 2005, в момент написания книги, находящейся в стадии бета-тестирования, опции-MLи-MLdсчитаются устаревшими, а однопоточные статические библиотеки времени выполнения больше не поставляются.
   ?Предыдущие версии Visual C++ использовали DLLmsvcr71.dll,msvcr71d.dll,msvcr70.dll,msvcr70d.dllи т.д.

   Табл. 1.31. Опции компилятора для выбора библиотеки времени выполнения при использовании Metrowerks (Windows)Статическая компоновкаДинамическая компоновкаОднопоточная-runtime ss[d]НеприменимоМногопоточная-runtime sm[d]-runtime dm[d](MSL_All-DLL90_x86[_D].dll)

   Табл. 1.32. Опции командной строки для выбора библиотеки времени выполнения при использовании CodeWarrior 10 для Max OS XСтатическая компоновкаДинамическая компоновкаОпции не требуетсяОбратитесь к документации Metrowerks по опциям командной строки (MSL_All_Mach-O[_D].dylib)

   Табл. 1.33. Опции компилятора для выбора библиотеки времени выполнения при использовании BorlandСтатическая компоновкаДинамическая компоновкаОднопоточная-WM-WM- -WR -WC? (cc3260.dll)Многопоточная-WM-WM -WR -WC (cc3260mt.dll)
   ?Опция-WCтребуется только при сборке консольного приложения.

   Табл. 1.34. Опции компилятора для выбора библиотеки времени выполнения при использовании Digital Mars (все библиотеки времени выполнения многопоточны)Статическая компоновкаДинамическая компоновкаОпций не требуется-ND -D_STLP_USE_DYNAMIC_LIB(sccrt70.dll, stlp45dm.dll)

   Табл. 1.35. Опции компилятора для выбора библиотеки времени выполнения при использовании GCCСтатическая компоновкаДинамическая компоновка-static?Опций не требуется
   ?Эта опция отключает всю динамическую компоновку, а не только динамические библиотеки времени выполнения.

   Например, чтобы указать динамическую окончательную сборку библиотеки времени выполнения Visual С++, используйте опцию компилятора-MD.Чтобы указать статическую однопоточную отладочную сборку библиотеки времени выполнения Metrowerks для Windows, используйте опцию компилятора-runtime ssd.Чтобы указать однопоточную динамическую сборку библиотеки времени выполнения Borland, передайте компилятору и компоновщику опции-WM- -WR -WC.
   Инструкции для указания варианта библиотеки времени выполнения в IDE приведены в табл. 1.36.

   Табл. 1.36. Указание варианта библиотеки времени выполнения из IDEIDEКонфигурацияVisual C++На страницах свойств проекта перейдите к Configuration Properties->C/C++->Code Generation (Генерация кода) и используйте раскрывающийся список Runtime Library (библиотека времени выполнения)CodeWarriorДля проектов динамических библиотек добавьте в проект объектный файл/usr/lib/dylib1.oи библиотекиMSL_Shared_AppAndDylib_Runtime[_D].libиMSL_All_Mach-O[_D].dylibи удалите все библиотеки видаMSL_&lt;XXX&gt;_Mach-O[_D].lib.Для проектов исполняемых файлов добавьте в проект объектный файл/usr/lib/crtl.си библиотекиMSL_Shared_AppAndDylib_Runtime[_D].libиMSL_All_Mach-O[_D].dylibи удалите все библиотеки видаMSL_&lt;XXX&gt;_Mach-O[_D].libC++BuilderБудет ли проект одно- или многопоточным, должно быть указано при его создании. Чтобы выбрать статическую или динамическую библиотеку времени выполнения, в окне Project Options перейдите к Linker и установите или снимите флажок Use dynamic RTL (Использовать динамические библиотеки времени выполнения)Dev-C++Чтобы выбрать статическую библиотеку времени выполнения, укажите опцию командной строки-static,как описано в рецепте 1.20Обсуждение
   Библиотека времени выполнения содержит реализации вспомогательных функций, необходимых при выполнении программы. Обычно библиотека времени выполнения содержитреализации функций стандартной библиотеки С, функций, используемых для доступа к сервисам операционной системы, таким как потоки и файловые системы, и специфичных для платформы, и функций, предоставляющих инфраструктуру для функций языка С++, таких как информация о типах во время выполнения (RTTI) и обработка исключений.
   В большинстве случаев, чем больше у вас выбор, тем лучше. Однако слишком большое количество библиотек времени выполнения приводит к различным проблемам. Главной проблемой является гарантия того, что все компоненты приложения — статические библиотеки, динамические библиотеки и исполняемые файлы — используют один и тот же вариант библиотеки времени выполнения, Если это не так, то приложение может не скомпоноваться или в нем могут появиться сложные с точки зрения диагностики сбои.
    [Картинка: tip_yellow.png] При использовании библиотек, разработанных другими, у вас не будет возможности выбрать библиотеки времени выполнения. В таких случаях вы будете вынуждены использовать в одном приложении несколько вариантов библиотек времени выполнения.
   Итак, как же решить, какую библиотеку времени выполнения использовать? Два выбора — одно- или многопоточную и отладочную или окончательную — вполне очевидны.
   Если проект использует несколько потоков или зависит от многопоточных библиотек, выдолжнывыбрать многопоточный вариант библиотеки времени выполнения (если такой имеется в поставке инструментария). Если библиотека времени выполнения была собрана без поддержки многопоточности, то вызов ее функций из нескольких потоков может привести к непредсказуемому поведению программы. Аналогично при создании отладочной сборки следует использовать отладочный вариант библиотеки времени выполнения (если он имеется).
   Последний выбор — следует использовать статическую или динамическую библиотеку времени выполнения — более сложен. Использование статической библиотеки имеет несколько преимуществ. Во-первых, благодаря тому, что в приложение включаются только функции, реально используемые приложением, она может уменьшить суммарный размер дистрибутива программы, исключив необходимость распространять динамическую библиотеку времени выполнения. (Однако если известно, что динамическая библиотека в целевой системе уже имеется, компоновка со статической библиотекой сделает дистрибутив больше по размеру.) Во-вторых, при компоновке со статической библиотекой устраняется проблема версий библиотек, которая возникает, когда в системе присутствует несколько версий одной и той же динамической библиотеки.
   Однако компоновка с динамической библиотекой времени выполнения также имеет свои преимущества. В первую очередь благодаря тому, что очень эффективным средством организации приложения является создание набора динамических библиотек. Во-первых, это позволяет обновлять части приложения, не требуя переустановки всего приложения. Далее, в некоторых случаях, благодаря использованию возможности отложеннойзагрузки DLLв Windows, значительно увеличивается производительность приложения. Но так как все компоненты приложения должны использовать один и тот же вариант библиотеки времени выполнения, то если приложение использует хотя бы одну динамическую библиотеку, все компоненты этого приложения должны использовать динамическую библиотеку времени выполнения. В результате использование динамической библиотеки времени выполнения облегчает разбиение приложения на модули.
   Я рекомендую в большинстве случаев выбирать динамическую компоновку. Однако, как я упоминал выше, иногда предпочтительнее статическая компоновка. Иногда, когда неизвестно, как будет использоваться написанная библиотека, невозможно узнать заранее, какой тип компоновки предпочтительнее. В этом случае общим решением является создание нескольких вариантов библиотеки, скомпонованных с использованием различных вариантов библиотеки времени выполнения.Смотри также
   Рецепты 1.4, 1.5, 1.21 и 1.25.
   1.24.Включение строгого соответствия стандарту C++Проблема
   Вы хотите, чтобы компилятор принимал только программы, которые соответствуют стандарту языка С++.Решение
   Опции командной строки для указания строгого соответствия стандарту C++ приведены в табл. 1.37. Инструкции для включения строгого соответствия в IDE приведены в табл. 1.38
    [Картинка: tip_yellow.png] Некоторые из показанных в табл. 1.6 опций компиляторов могут рассматриваться как опции соответствия. Примерами являются опции для включения основных языковых функций, таких как поддержка «широких» символов, исключений и информации о типе во время выполнения. В табл. 1.37 они не приведены.

   Табл. 1.37. Включение строгого соответствия из командной строкиИнструментарийОпции командной строки компилятораGCC-ansi -pedantic-errorsVisual C++-ZaIntel (Windows)-Za -Qms0Intel (Linux)-strict-ansi?Metrowerks-ansi strict -iso_templates on -msext offComeau (Windows)-AComeau (Unix)-strict or -ABorland-A?Digital Mars-A
   ?Версии компилятора Intel для Linux до 9.0 использовали опцию-strict_ansi.При использовании-strict-ansiили-strict_ansiможет потребоваться с помощью опции-cxxlib-iccвключить стандартную библиотеку Intel
   ?С опцией-Анекоторые стандартные заголовочные файлы библиотеки STLPort могут не компилироваться.

   Табл. 1.38. Включение строгого соответствия в IDEIDEКонфигурацияVisual C++На страницах свойств проекта перейдите к Configuration Properties->C/C++->Languageи установите в значение Yes (Да) опции Disable Language Extensions (Отключить расширения языка), Treat wchar_t as Built-in Type (Рассматривать wchar_t как встроенный тип) и Force Conformance in For Loop Scopes (Включить соответствие стандарту в циклах For)MetrowerksВ окне Target Settings перейдите к Language Settings->C/C++ Languageи установите ISO Template Parser (Синтаксический анализ шаблонов ISO), ANSI Strict (Строгий ANSI) и ANSI Keywords Only (Только ключевые слева ANSI). Убедитесь, что выбраны опции Enable C++ Exceptions (Включить исключений С++). Enable RTTI support (Включить поддержку RTTI). Enable bool Support (Включить поддержку bool) и Enable wchar_t Support (Включить поддержку wchar_t)C++BuilderВ Project Options перейдите к Advanced Compiler и в разделе Language Compliance (Соответствие языка) установите ANSIDev-C++См запись для GCC в табл. 1 37 и обратитесь к рецепту 1.20Обсуждение
   Язык C++ был стандартизирован Международной организацией по стандартизации (International Standards Organization — ISO) в 1998 году. В том же году стандарт ISO был одобрен и принят Национальным институтом стандартизации США (American National Standards Institute — ANSI). В 2003 году была одобрена вторая редакция стандарта, которая содержит исправления и пояснения, но также вводит несколько новых языковых возможностей. В настоящее время ведется работа над обновленной версией стандарта С++, которая будет включать несколько важных языковых функций и расширенную стандартную библиотеку.
   В момент принятия стандарта в 1998 году ни один из компиляторов не достигал полного соответствия его требованиям, хотя многие были представлены как «ANSI-совместимые». Однако в течение нескольких прошедших лет поставщики много работали над тем, чтобы сделать свои инструменты более точно и строго соответствующими стандарту. По состоянию на сентябрь 2005 года последние версии компиляторов GNU, Microsoft, Intel, Metrowerks и Comeau обладают высокой степенью соответствия. Comeau и Intel с их поддержкой экспорта шаблонов могут рассматриваться как соответствующие стандартупочтина 100%[5].
   Ни один из компиляторов не может обеспечить полного соответствия стандарту с точки зрения отказа компилировать любую неверную программу. И не только из-за того, что ни один из них не соответствует стандарту на 100%: более важной причиной является то, что стандарт C++ не требует от компилятора отвергать неверные программы. Имеется четкий перечень обстоятельств, в которых компилятор должен выдаватьдиагностическое сообщение,указывающее на неправильно написанную программу, однако для многих некорректных программ диагностики не требуется. Это программы, которые приводят к тому, что стандарт называетнеопределенным поведением программы при ее выполнении.И даже тогда, когда диагностика обязательна, компилятор волен выдать сообщение и продолжить компиляцию, в результате которой возможно успешное создание исполняемого файла или библиотеки.
   Главной причиной, по которой от компиляторов не требуется отвергать все некорректно написанные программы, является то, что во многих случаях эту некорректность сложно, а иногда и невозможно обнаружить. Еще одной причиной, которая обсуждается далее, является то, что некорректные с точки зрения стандарта программы иногда очень полезны.
   Я советую вам использовать опции строгого соответствия компилятора как можно чаще. Однако имеются ситуации, когда это невозможно. Чтобы лучше это понять, давайте посмотрим на несколько вариантов не соответствующего стандарту кода.
   Для начала вот код, который полностью попустим в ранних диалектах С++, существовавших до стандартизации языка. Например, в ранних версиях C++ область видимости переменной, объявленной при инициализации циклаfor,простиралась до конца блока, в котором находился этот цикл.
   //ВНИМАНИЕ: некорректный код!
   int main() {
    for (int i = 0; i&lt; 10; ++i)
     ;
    int j = i; // j == 10
   }
   Стандартом это не допускается и не имеет никаких преимуществ по сравнению со стандартными правилами областей видимости. Требование компилировать код, подобный этому, возникает только при сопровождении устаревших приложений.
   Другой категорией некорректного кода является код, который использует экспериментальные расширения языка, которые по какой-либо причине не вошли в конечный стандарт C++. Например, многие компиляторы предоставляют встроенный типlong long,длина которого гарантированно имеет не менее 64 бит. Как еще один пример, некоторые компиляторы предоставляют встроенный операторtypeof,имеющий такой же синтаксис, как и операторsizeof,и возвращающий тип выражения. Обе эти функции, скорее всего, появятся в следующей версии стандарта C++, хотя ожидается, что написаниеtypeofизменится на, возможно,decltype.
   Будьте осторожны при использовании подобного рода расширений: вы можете столкнуться с тем, что вам потребуется портировать код на платформу, не реализующую какого-либо расширения или реализующую его по-другому.
   Третья категория некорректного кода — это код, который использует платформенно-зависимые расширения языка, необходимые для использования функций операционной системы. В эту категорию попадают атрибуты__declspec(dllexport)и__declspec(dllimport),используемые для сборки динамических библиотек в Windows, и атрибуты__stdcall,__fastcallи__cdecl,представляющие соглашения о вызовах в Windows. Хотя это и расширения языка, большая часть компиляторов для Windows принимает код, содержащий эти расширения, даже если используется опция строгого соответствия стандарту.
   Последней категорией некорректного кода является код, нарушающий стандарт С++, но полностью соответствующий некоторым другим стандартам. Главным примером такого стандарта является C++/CLI, который сейчас проходит последние стадии стандартизации в ECMA. C++/CLI — это расширение С++, которое состоит из интерфейса C++ к Command Language Infrastructure — ядру Microsoft .NET Framework. При компиляции приложения, использующего определенные расширения C++/CLI, соответствующий стандарту компилятор C++ должен выдавать диагностику, но при поддержке стандарта C++/CLI он может свободно генерировать работоспособное приложение.
   Если вам требуется скомпилировать код, не соответствующий стандарту, вначале проверьте, будет ли он компилироваться при использовании опций, приведенных в табл. 1.37 и 138. Если нет, то некоторые компиляторы предлагают набор «дробных» опций совместимости, позволяющих использовать некоторые несовместимые конструкции, но запрещающих другие. Например, Comeau предоставляет опцию--long_long,указывающую на необходимость распознавания типаlong long.Наконец, некоторые компиляторы предоставляют опции, заставляющие их сообщать о большинстве нарушений стандарта как о предупреждениях, а не ошибках. Например, GCC для этой цели предоставляет опцию-pedantic, a Comeauдля Windows предоставляет опцию--a,а для других платформ — опции--strict_warningsили-a.Смотри также
   Рецепт 1.2.
   1.25.Указание определенной библиотеки для автоматической компоновки с исходным файломПроблема
   Вы написали библиотеку, которую хотите распространять в виде набора заголовочных файлов и готовых статических или динамических библиотек, но не хотите, чтобы пользователи вашей библиотеки должны были сами указывать имена библиотек при компоновке приложений.Решение
   При программировании для Windows с использованием инструментария Visual C++, Intel, Metrowerks, Borland или Digital Mars для указания имен и (при необходимости) путей готовых библиотек, с которыми должен компоноваться код, включающий заголовочные файлы вашей библиотеки, используйте в этих заголовочных файлахpragma comment.
   Например, предположим, что вы хотите распространить библиотеку из примера 1.1, состоящую из статической библиотекиlibjohnpaul.libи заголовочного файлаjohnpaul.hpp.Измените этот заголовочный файл так, как показано в примере 1.26.
   Пример 1.26. Использование pragma comment
   #ifndef JОНNPAUL_HPP_INCLUDED
   #define JOHNPAUL_HPP_INCLUDED
   #pragma comment(lib, "libjohnpaul")
   void johnpaul();
   #endif // JOHNPAUL_HPP_INCLUDED
   После этого изменения компоновщики Visual С++, Intel, Metrowerks, Borland и Digital Mars при компоновке кода, включающего заголовочный файлjohnpaul.hpp,будут автоматически находить библиотекуlibjohnpaul.lib.Обсуждение
   В некоторых ситуациях компоновка может оказаться более сложным этапом процесса сборки, чем компиляция. Одна из наиболее часто возникающих проблем компоновки создается тогда, когда компоновщик находит неверную версию какой-либо библиотеки. Это в основном проблема Windows, где библиотеки времени выполнения и зависящие ar них библиотеки часто имеют множество вариантов. По этой причине библиотеки для Windows часто поставляются с именами, измененными так, чтобы они отражали различные конфигурации сборки. Хотя это и помогает снизить число конфликтов версий, это также затрудняет процесс компоновки, так как теперь вы должны указывать компоновщику правильноеизмененное имя.
   По этой причинеpragma commentочень полезна. Среди прочего она позволяет указать правильное имя библиотеки в заголовочном файле и избавить пользователя от необходимости разбираться в ваших соглашениях об изменении имен файлов. Если в дополнение к этому вы разработаете процесс установки, копирующий двоичные файлы в папку, автоматически используемую компоновщиком, — такую как поддиректорияlibкорневых директорий Visual С++, CodeWarrior или C++Builder, — то программисты смогут использовать вашу библиотеку, просто включив ее заголовочные файлы.
   До сих пор все было хорошо. Но есть одна проблема:pragma commentраспознается не всеми компиляторами. Если вы хотите писать портируемый код, вы должны вызывать pragma только после того, как проверите, что она поддерживается используемым инструментарием. Например, вы можете изменитьjohnpaul.cppвот так.
   #ifndef JOHNPAUL_HPP_INCLUDED
   #define JOHNPAUL_HPP_INCLUDED

   #if defined(_MSC_VER) || \
    defined(__ICL) || \
    defined(__MWERKS__)&& defined(_WIN32) || \
    defined(__BORLANDC__) \
    defined(__DMC__) \
   /**/
   #pragma comment (lib, "libjohnpaul")
   #endif

   void johnpaul();

   #endif // JOHNPAUL_HPP_INCLUDED
   Этот пример уже стал достаточно сложным, и, к сожалению, он все еще не полностью корректен: некоторые компиляторы, не поддерживающиеpragma comment,для совместимости в Visual C++ определяют макрос_MSC_VER.К счастью, Boost предоставляет простое решение.
   #ifndef johnpaul_hpp_included
   #define JOHNPAUL_HPP_INCLUDED

   #define BOOST_LIB_NAME libjohnpaul
   #define BOOSTAUTO_LINK_NOMANGLE

   #include&lt;boost/config/auto_link.hpp&gt;

   void johnpaul();

   #endif // JOHNPAUL_HPP_INCLUDED
   Здесь строка
   #define BOOST_LIB_NAME libjohnpaul
   определяет имя библиотеки, строка
   #define BOOST_AUTO_LINK_NOMANGLE
   указывает, что вы не хотите использовать соглашение об именах Boost, а строка
   #include&lt;boost/config/auto_link.hpp&gt;
   вызываетpragma commentдля поддерживающих ее компиляторов.Смотри также
   Рецепт 1.23.
   1.26.Использование экспортируемых шаблоновПроблема
   Вы хотите собрать программу, использующую экспортируемые шаблоны, что означает, что она объявляет шаблоны в заголовочных файлах с использованием ключевого словаexport,а реализация шаблонов находится в файлах.cpp.Решение
   Во-первых, скомпилируйте в объектные файлы файлы.cpp,содержащие реализации шаблонов, передав компилятору опцию командной строки, необходимую для включения экспортируемых шаблонов. Затем скомпилируйте и скомпонуйте файлы.cpp,использующие экспортируемые шаблоны, передав компилятору и компоновщику опции командной строки, необходимые для включения экспортируемых шаблонов, а также опции, указывающие директории, содержащие реализации шаблонов.
   Опции для включения экспортируемых шаблонов приведены в табл 1.39. Опции для указания расположения реализаций шаблонов приведены в табл. 1.40. Если ваш инструментарий в этой таблице не указан, то он, скорее всего, не поддерживает экспортируемых шаблонов.

   Табл. 1.39. Опции для включения экспортируемых шаблоновИнструментарийСценарийComeau (Unix)-export,-Aили-strictComeau (Windows)-exportили-AIntel (Linux)-exportили-strict-ansi?
   ?Версии компилятора Intel для Linux до 9.0 использовали опцию-strict_ansi

   Табл. 1.40. Опции, указывающие расположение реализаций шаблоновИнструментарийСценарийComeau-template_directory=&lt;path&gt;Intel (Linux)-export_dir&lt;path&gt;
   Например, предположим, что вы хотите скомпилировать программу, показанную в примере 1.27. Она содержит три файла.
   • Файлplus.hppсодержит объявление экспортируемого шаблона функцииplus().
   • Файлplus.cppсодержит определениеplus().
   • Файлtest.cppвключает объявление — но не определение —plus()и определяет функциюmain(),использующуюplus().
   Пример 1.27. Простая программа, использующая экспортируемые шаблоны

   plus.hpp:
   #ifndef PLUS_HPP_INCLUDED
   #define PLUS_HPP_INCLUDED

   export template&lt;typename T&gt;
   T plus(const T& lhs, const T& rhs);

   #endif // #ifndef PLUS_HPP_INCLUDED

   plus.cpp:
   #include "plus.hpp"

   template&lt;typename T&gt;
   T plus(const T& lhs, const T& rhs) {
    return rhs + lhs;
   }

   test.cpp:
   #include&lt;iostream&gt;
   #include "plus.hpp"

   int main() {
    std::cout&lt;&lt; "2 + 2 = "&lt;&lt; plus(2, 2)&lt;&lt; "\n";
   }
   Чтобы скомпилироватьplus.cppв объектный файлplus.objс помощью Comeau в Unix, перейдите в директорию, содержащуюplus.cpp,plus.hppиtest.cpp,и введите следующую команду.
   $como -c --export plus.cpp
   Эта команда также генерирует файлplus.et,описывающий реализацию шаблона, содержащегося в plus.cpp.
    [Картинка: tip_yellow.png] Для развлечения откройтеplus.etв текстовом редакторе.
   Затем скомпилируйтеtest.cppв объектный файлtest.objс помощью команды:
   $como -c --export test.cpp
   Наконец, скомпонуйте исполняемый файлtest.exe.
   $como --export -о test test.obj
   Две последние команды также можно объединить в одну.
   $como --export -o test test.cpp
   Теперь можно запуститьtest.exe.
   $./test
   2 + 2 = 4
   Теперь предположите, что файлыplus.hppиplus.cppнаходятся в директории с именемplus, atest.cppнаходится в дочерней директорииtest.Чтобы скомпилировать и скомпоноватьtest.cpp,перейдите в директориюtestи введите:
   $como --export --template_directory=../plus -I../plus -o test
   test.cppОбсуждение
   C++поддерживает две модели обеспечения определений шаблонов функций и статических данных-членов шаблонов классов:включающую (inclusion model)ираздельную (separation model)модели. Включающая модель знакома всем программистам, регулярно использующим шаблоны С++, но часто оказывается непонятной программистам, привыкшим писать код без шаблонов. Во включающей моделиопределениешаблона функции — или статических данных-членов шаблона класса — должно включаться в каждый исходный файл, ее использующий. В противоположность этому при использовании нешаблонных функций и данных достаточно включить в исходный файл толькообъявление;определение может быть помещено в отдельный файл.cpp.
   Раздельная модель ближе к традиционной манере организации исходного кода C++. Для шаблонов, объявленных с ключевым словомexport,не требуется включать определения во все исходные файлы, их использующие. Вместо этого определения помещаются в отдельные файлы.cpp.Однако параллель с традиционной организацией кода не полная, так как даже несмотря на то, что код, использующий экспортируемый шаблон, не требуетвключенияего определения, онзависитот определения.
   Раздельная модель предлагает несколько потенциальных преимуществ.
   Уменьшение времени компиляции
   Время компиляции при использовании раздельной модели может сократиться благодаря тому, что сканирование определений шаблонов производится реже, и потому, что раздельная модель уменьшает зависимости между модулями.
   Снижение «загрязнения» символов
   Имена функций, классов и данных, используемых в файле реализации шаблона, могут быть полностью скрыты от кода, использующего этот шаблон, что снижает возможность случайного совпадения имен. Кроме того, автор реализации шаблона может уделять меньше внимания случайным совпадениям с именами из исходных файлов, использующих шаблон
   Возможность поставлять скомпилированные реализации шаблонов.
   Теоретически при использовании раздельной модели поставщик может распространять реализации шаблонов в скомпилированном двоичном виде, находящемся где-то посередине между исходным кодом C++ и обычными объектными файлами.
   Все три потенциальных преимущества раздельной модели спорны. Во-первых, хотя некоторые пользователи сообщали о сокращении времени компиляции, раздельная модель также может в некоторых случаях привести к его увеличению. В настоящее время данных для окончательных выводов недостаточно. Во-вторых, хотя раздельная модель снижает некоторые виды загрязнения символов, правила языка, необходимые для поддержки раздельной модели, и особенно идея двухэтапного поиска, усложняют способ написания кода шаблона — даже по сравнению с включающей моделью - и имеют несколько нежелательных последствий. В-третьих, все существующие реализации раздельной модели основаны на оболочке EDG, a EDG пока еще не предоставляет никаких возможностей для компиляции исходных файлов, содержащих реализации экспортируемых шаблонов, в двоичные файлы, которые могут поставляться вместо исходников.
   В 2003 году имела место попытка удалить экспортируемые шаблоны из будущих версий стандарта С++, но она провалилась. Следовательно, экспортируемые шаблоны являются постоянной частью языка С++, и вы должны научиться использовать их.Смотри также
   Рецепт 1.25.
   Глава 2
   Организация кода
   2.0.Введение
   Возможно, что одной из причин популярности C++ является его способность одинаково хорошо подходить для маленьких, средних и больших проектов. Для небольшого прототипа или исследовательского проекта можно написать всего несколько классов, а при росте проекта и увеличении числа сотрудников C++ позволяет масштабировать приложение, разбив его на модули, различающиеся по степени своей независимости. Недостатком здесь является то, что вы должны потратить время на то, чтобы вручную выполнить реорганизацию (добавить пространства имен, реорганизовать физическое расположение заголовочных файлов и т.д.). Обычно это стоит того, так как при этом приложение становится модульным и позволяет отдельным людям сосредоточиться только на их локальной функциональной области.
   Количество необходимого ручного труда обратно пропорционально количеству времени, потраченному на первоначальную разработку модульности. Начните с нескольких хороших методик достижения модульности, и ваш код будет масштабируемым.
   Если вы еще не используете пространства имен, вы, возможно, по крайней мере, слышали о них и уже используете одно из них: пространство именstd,которое является пространством имен, содержащим стандартную библиотеку. Исходя из моего опыта, пространства имен используются не настолько часто, насколько следовало бы но это не потому, что они очень сложны или их использование требует больших усилии. Рецепт 2.3 объясняет, как с помощью пространств имен сделать код модульным.
   Многие рецепты этой главы описывают методики, применяемые в заголовочных файлах. Так как здесь обсуждается несколько возможностей, каждая из которых относится к отдельной части заголовочного файла, я поместил во введение пример 2.1, который показывает, как выглядит типичный заголовочный файл, который использует все методики, описанные в этой главе.
   Пример 2.1. Заголовочный файл
   #ifndef MYCLASS_H__ //защита #include, рецепт 2.0
   #define MYCLASS_H__

   #include&lt;string&gt;

   namespace mylib { //пространства имен, рецепт 2.3
    class AnotherClass; // предварительное объявление класса, рецепт 2.2
    class Logger;
    extern Logger* gpLogger; // объявление внешнего хранилища, рецепт 2.1
    class MyClass {
    public:
     std::string getVal() const;
     // ...
    private:
     static int refCount_;
     std::string val_;
    };
   }

   //Встраиваемые определения, рецепт 2.4
   inline std::string MyClass::getVal() const {
    return(val_);
   }

   #include "myclass.inl"
   } // namespace

   #endif // MYCLASS_H__
   После написания заголовочного файла также вам будет нужен файлреализации,под которым я понимаю файл.cpp,содержащий не только объявления, но и определения. Файл реализации оказывается менее сложным, чем заголовочный файл, но ради полноты пример 2.2 содержит пример реализации файла, идущего в комплекте с заголовочным файлом из примера 2.1.
   Пример 2.2. Файл реализации
   #include "myclass.h"

   namespace mylib {
    MyClass::refCount_ = 0; // статическое определение, рецепт 8.4
    MyClass::foo() { // реализация метода
     // ...
    };
   }
   Конечно, файлы реализации будут полны обдуманных, хорошо написанных комментариев, но ради простоты я оставляю этот вопрос за скобками.
   2.1.Обеспечение единственности подключения заголовочного файлаПроблема
   У вас есть заголовочный файл, который подключается несколькими другими файлами. Вы хотите убедиться, что препроцессор сканирует объявления в заголовочном файле не более одного раза.Решение
   В заголовочном файле с помощью#defineопределите макрос и содержимое заголовочного файла подключайте только тогда, когда макрос еще не был определен. Используйте такую комбинацию директив препроцессора#ifndef,#defineи#endif,как я делаю в примере 2.1:
   #ifndef MYCLASS_H__ //защита #include
   #define MYCLASS_H__
   //Здесь поместите все. что требуется...
   #endif // MYCLASS_H__
   Когда препроцессор сканирует такой заголовочный файл, одной из первых встреченных им вещей будет директива#ifndefи следующий за ней символ,#ifndefговорит препроцессору перейти на следующую строку только в том случае, если символMYCLASS_H__еще не определен. Если он уже определен, препроцессор должен пропустить код до закрывающей директивы#endif.Строка, следующая за#ifndef,определяетMYCLASS_H__,так что если этот файл при одной и той же компиляции сканируется препроцессором дважды, то второй разMYCLASS_H__будет уже определен. Поместив весь код между#ifndefи#endif,вы гарантируете, что в процессе компиляции он будет прочитан только один раз.Обсуждение
   Если вы не используете эту методику, которая называетсязащитой заголовка,то вы, вероятно, уже видели ошибки компиляции «symbol already defined» (символ уже определен), которые являются следствием отсутствия защитных мер против множественных определений. C++ не позволяет определять один и тот же символ несколько раз, и если вы это сделаете (целенаправленно или случайно), то получите ошибку компилятора. Включение защиты предотвращает такие ошибки, и она стала стандартной методикой.
   Определяемый с помощью#defineмакрос не обязан следовать какому-либо формату, но использованный мной синтаксис имеет широкое распространение. Его идея состоит в том, чтобы использовать символ,который не будет конфликтовать с другим макросом, в результате чего файл будет непреднамеренно пропускаться препроцессором. На практике вы можете столкнуться и сдругими методиками, такими как включение в макрос версии заголовочного файла или модуля, т.е.MYCLASS_H_V301__,или, возможно, имени автора. Не имеет значения, как вы его назвали, до тех пор, пока вы придерживаетесь единой схемы. Эти макросы должны использоваться только в заголовочном файле, который они защищают, и больше нигде.
   В некоторых фрагментах кода можно увидетьвнешнюю защиту заголовков,которая аналогична описанной ранеевнутренней защите заголовков,за исключением того, что она используется в файле, включающем заголовочный файл, а не в самом заголовочном файле.
   #ifndef MYCLASS_H__
   #include "myclass.h"

   #endif
   Это сокращает процесс включения, поскольку, если макросMYCLASS_H__уже определен, файлmyclass.hдаже не подключается. Несколько лет назад утверждалось, что внешняя защита заголовков в больших проектах снижает время компиляции, но компиляторы совершенствуются и внешняя защита больше не требуется. Не используйте ее.
   Даже если вы работаете над небольшим проектом, всегда следует помещать в заголовочный файл защиту заголовка. Если заголовочный файл включается в более чем одном файле, имеется вероятность, что в один прекрасный момент вы увидите ошибку переопределения. Более того, небольшие проекты стремятся за очень короткое время превратиться в большие, и хотя проект мог начинаться с единственного исполняемого файла и набора заголовочных файлов, включаемых только один раз, рано или поздно проект вырастет, и начнут появляться ошибки компиляции. Если вы с самого начала добавите защиту заголовков, вам не придется в будущем возвращаться и добавлять их сразу в большое количество файлов.
   2.2.Обеспечение единственности экземпляра переменной при большом количестве исходных файловПроблема
   Требуется, чтобы одна и та же переменная использовалась различными модулями программы, а копия переменной должна быть только одна. Другими словами, это должна бытьглобальная переменная.Решение
   Объявите и определите как обычно переменную в одном файле реализации, а в других файлах реализации, где требуется доступ к этой переменной, используйте ключевое словоextern.Часто это означает включение объявленийexternв заголовочные файлы, используемые файлами реализаций, которым требуется доступ к глобальной переменной. Пример 2.3 содержит несколько файлов, которые показывают,как используется ключевое словоexternдля доступа к переменным, определенным в другом файле реализации.
   Пример 2.3. Использование ключевого слова extern

   // global.h
   #ifndef GLOBAL_H__ //см. рецепт 2.0
   #define GLOBAL_H__

   #include&lt;string&gt;

   extern int x;
   extern std::string s;
   #endif

   // global.cpp
   #include&lt;string&gt;

   int x = 7;
   std::string s = "Kangaroo";

   // main.cpp
   #include&lt;iostream&gt;
   #include "global.h"

   using namespace std;
   int main() {
    cout&lt;&lt; "x = "&lt;&lt; x&lt;&lt; endl;
    cout&lt;&lt; "s = "&lt;&lt; s&lt;&lt; endl;
   }Обсуждение
   Ключевое словоextern— это способ сказать компилятору, что реальная область памяти для переменной выделяется в другом месте,externговорит компоновщику, что переменная описана где-то в другом объектном файле и что компоновщик должен найти ее при создании конечного исполняемого файла или библиотеки. Если компоновщик не находит переменной, объявленной какextern,или если он находит более одного ее определения, он генерирует ошибку компоновки.
   Пример 2.3 не слишком впечатляет, но он хорошо иллюстрирует вопрос. Две мои глобальные переменные объявляются вglobal.cpp:
   int x = 7;
   std::string s = "Kangaroo";
   Мне требуется доступ к ним из других файлов реализации, так что я поместил в заголовочный файлglobal.hобъявлениеexternдля них:
   extern int x;
   extern std::string s;
   Разница между объявлением и определением очень важна. В C++ можно объявить что-либо несколько раз, при условии совпадения объявлений, но определить что-либо можно только один раз. Это называетсяправилом одного определения (на самом деле в некоторых случаях определить объект можно несколько раз, но только если определения абсолютно идентичны — обычно это бессмысленно). Ключевое словоextern— это механизм, позволяющий сказать компилятору и компоновщику, что определение находится где-то еще и что оно должно быть разрешено при компоновке.
   Нельзя сказать, что использованиеexternдолжно быть постоянным. Его следует использовать обдуманно и только тогда, когда это необходимо, так как оно позволяет создавать переменные, глобальные для всего приложения. Иногда оно может потребоваться для поистине глобальных объектов или данных — объекта журналирования, оборудования, большого объекта общих данных, но вбольшинстве случаев имеются более адекватные альтернативы.
   2.3.Снижение числа #include с помощью предварительного объявления классовПроблема
   Имеется заголовочный файл, который ссылается на классы из других заголовочных файлов, и требуется снизить зависимости компиляции (и, возможно, время).Решение
   Чтобы избежать ненужных зависимостей при компиляции, везде, где только возможно, используйте предварительное объявление классов. Пример 2.4. является коротким примером предварительного объявления класса.
   Пример 2.4. Предварительное объявление класса

   // myheader.h
   #ifndef MYHEADER_H__
   #define MYHEADER_H__

   class A; //заголовок для А включать не требуется

   classВ {
   public:
    void f(const A& a);
    // ...
   private:
    A* a_;
   };
   #endif
   Где-то в другом месте имеется заголовочный файл и, вероятно, файл реализации, который объявляет и определяет классА,но в файлеmyheader.hподробности классаАменя не волнуют: все, что мне требуется знать, — это то, чтоА— это класс.Обсуждение
   Предварительное объявление класса — это способ игнорировать подробности, о которых не требуется беспокоиться. В примере 2.4myheader.hне должен знать о классеАничего, кроме того, что он существует и что это класс.
   Рассмотрим, что случится, если с помощью#includeвключить заголовочный файл дляА,или, что более реально, заголовочный файл для полудюжины или более классов, присутствующих в реальном заголовочном файле. Тогда файл реализации (myheader.cpp)будет включать заголовочный файлmyheader.h,так как он содержит все объявления. До сих пор все было хорошо. Но если вы измените один из заголовочных файлов, включаемых вmyheader.h (или один из заголовочных файлов, включаемых одним из этих файлов), то потребуется перекомпилировать все файлы реализации, включающиеmyheader.h.
   Создайте предварительное объявление класса, и эти зависимости компиляции исчезнут. Использование предварительного объявления просто создает имя, на которое можно ссылаться далее в заголовочном файле. Компоновщик должен будет сам найти в файлах реализаций подходящее определение.
   К несчастью, использовать предварительное объявление можно не всегда. КлассВв примере 2.4 использует только указатели или ссылки наA,так что ему достаточно только предварительного объявления. Однако если бы в определении классаВя использовал функцию-член (метод) или переменнуюАили если бы создавал объект типаА,а не только указатель или ссылку на него, то предварительного объявления окажется недостаточно. Причиной этого является то, что файлы, включающиеmyheader.h,должны знать размерВ,и еслиAявляется членомВ,то компилятор, чтобы определить размерВ,должен знать размерА.Указатель или ссылка на что-либо всегда имеют один и тот же размер, так что в случае использования указателей или ссылок подробности обАкомпилятор не интересуют, и, следовательно, заголовочный файл не требуется
   Неудивительно, что если включить вmyheader.hкакое-либо определение, использующее членовA,то потребуется включить через#includeзаголовок дляА.Это требуется для того, чтобы компилятор мог проверить сигнатуру используемой функции-членаАили тип переменной-членаА.Вот иллюстрация кода, требующего#include.
   #include "a.h"

   class B {
   public:
    void f(const A& a) {
     foo_ = a.getVal(); // требуется знать, допустимо ли a.getVal
    }
   }
   // ...
   В общем случае используйте предварительное объявление тогда, когда это позволяет снизить количество#include,что отражается на времени компиляции.
   2.4.Предотвращение конфликта имен с помощью пространств именПроблема
   В несвязанных между собой модулях обнаружены конфликтующие имена или требуется заранее избежать возможности таких конфликтов, создав логические группы кода.Решение
   Для структурирования кода используйте пространства имен. С помощью пространств имен можно объединять большие группы кода, находящиеся в разных файлах, в единое пространство имен. Для разбиения больших модулей на подмодули можно использовать вложенные пространства имен, и потребители вашего модуля смогут выборочно открывать элементы вашего пространства имен, которые им требуются. Пример 2.5 показывает несколько способов использования пространства имен.
   Пример 2.5. Использование пространств имен

   // Devices.h
   #ifndef DEVICES_H__
   #define DEVICES_H__

   #include&lt;string&gt;
   #include&lt;list&gt;

   namespace hardware {
    class Device {
    public:
     Device(): uptime_(0), status_("unknown") {}
     unsigned long getUptime() const;
     std::string getStatus() const;
     void reset();
    private:
     unsigned long uptime_;
     std::string status_;
    };

    class DeviceMgr {
    public:
     void getDeviceIds(std::list&lt;std::string&gt;& ids) const;
     Device getDevice(const std::string& id) const;
     // Other stuff...
    };
   }

   #endif // DEVICES_H__

   // Devices.cpp
   #include "Devices.h"
   #include&lt;string&gt;
   #include&lt;list&gt;

   namespace hardware {
    using std::string;
    using std::list;

    unsigned long Device::getUptime() const {
     return(uptime__);
    }

    string Device::getStatus() const {
     return(status_);
    }

    void DeviceMgr::getDeviceIds(list&lt;string&gt;& ids) const {}

    Device DeviceMgr::getDevice(const string& id) const {
     Device d;
     return(d);
    }
   }

   // DeviceWidget.h
   #ifndef DEVICEWIDGET_H__ #define DEVICEWIDGET_H__
   #include "Devices.h"

   namespace ui {
    class Widget {/*... */ };

    class DeviceWidget : public Widget {
    public:
     DeviceWidget(const hardware::Device& dev) : device_(dev) {}
     // Some other stuff
    protected:
     hardware::Device device_;
    };
   }
   #endif // DEVICEWIDGET_H__

   // main.cpp
   #include&lt;iostream&gt;
   #include "DeviceWidget.h"
   #include "Devices.h"

   int main( ) {
    hardware::Device d;
    ui::DeviceWidget myWidget(d);
    // ...
   }Обсуждение
   Пример 2.5 более сложен, но давайте разберем его по частям, так как он иллюстрирует несколько ключевых моментов, связанных с пространствами имен. Представьте, что выпишете управляющее приложение, которое должно взаимодействовать с различным оборудованием. С целью устранения конфликтов имен вы можете разбить это приложение на два или более пространств имен или просто разделить его логически на две части.
   Вначале рассмотрим файлDevices.h.Он содержит пару классов, которые управляют элементами оборудования, —DeviceиDeviceMgr.Однако они не должны находиться в глобальном пространстве имен (что означало бы, что их имена видны в любом месте программы), так что я поместил их в пространство именhardware.
   #ifndef DEVICES_H__ //см. рецепт 2.0
   #define DEVICES_H__

   #include&lt;string&gt;
   #include&lt;list&gt;

   namespace hardware {
    class Device {
     // ...
    };

    class DeviceMgr {
     // ...
    };

   }
   #endif // DEVICES_H__
   Этот механизм прост: «оберните» все, что требуется поместить в пространство имен, в блокnamespace.
   Приведенный выше фрагмент — это объявлениеDeviceиDeviceMgr,но нам также требуется подумать об их реализациях, которые находятся в файлеDevices.cpp.И снова оберните все в блокnamespace— он будет добавлен к уже имеющемуся содержимому этого пространства имен.
   #include "Devices.h"
   #include&lt;string&gt;
   #include&lt;list&gt;

   namespace hardware {
    using std::string;
    using std::list;
    // Реализация Device и DeviceMgr
   }
   В данный момент пространство именhardwareсодержит все, что требуется. Все, что осталось, — это где-то его использовать. Для этого имеется несколько способов. Способ, который был использован в примере 2.5, состоит в указании полного имени классаDevice,включая пространство имен, как здесь.
   #ifndef DEVICEWIDGET_H_
   #define DEVICEWIDGET_H_

   #include "Devices.h"

   namespace ui {
    class Widget { /* ... */ };
    class DeviceWidget : public Widget {
    public:
     DeviceWidget(consthardware::Device& dev) : device_(dev) {}
     // Other stuff...
    protected:
    hardware::Device device_;
    };
   }
   #endif // DEVICEWIDGET_H__
   Также я использую этот способ вmainвmain.cpp.
   int main() {
    hardware::Device d;
    ui::DeviceWidget myWidget(d);
   }
   Чтобы добавить к одному из пространств имен типы, объявите заголовочный файл и файл реализации так, как показано в примере 2.5. При каждом использовании блока пространства имен, обрамляющего код, этот код добавляется в это пространство имен, так что в пространстве имен может находиться код, который ничего не знает о другом кодеэтого же пространства имен.
   При использовании подхода с указанием полных имен классов, включающих пространство имен, вы быстро устанете вводить код. Имеется пара способов устранить эту проблему. Для полного имени типа с помощью ключевого словаusingможно создать псевдоним.
   using hardware::Device;

   int main() {
    Device d; // Пространство имен не требуется
    ui::DeviceWidget myWidget(d);
   }
   В последующем коде вместо ввода полного имени можно просто сослаться на этот псевдоним. Или можно с помощьюusingимпортировать все содержимое пространства имен, а не только один содержащийся в нем тип.
   using namespace hardware;

   int main() {
    Device d:
    ui::DeviceWidget myWidget(d);
   }
   Этот вариант вы, вероятно, уже использовали, или, по крайней мере, видели в примерах, при использовании стандартной библиотеки (эту методику используют многие примеры в этой книге). Вся стандартная библиотека находится в пространстве именstd,так что очень часто вы увидите такое:
   using namespace std;
   Импорт всего пространства имен часто является плохой идеей и обычно рассматривается как плохой стиль. В примерах в этой книге мы импортируем полное содержимое пространства именstdтолько с целью повышения ясности кода и обычно рекомендуем не делать этого в реальных программах.
   При импорте всего пространства имен или даже нескольких пространств имен их полезность значительно снижается. Одной из причин существования пространств имен является снижение конфликтов имен. При импорте нескольких различных пространств имен вероятность конфликтов имен увеличивается. В данный момент код может прекрасно компилироваться, но в будущем в одно из пространств имен может быть что-то добавлено, и при последующей сборке кода возникнет конфликт.
   Чтобы разделить содержимое пространства имен на более мелкие группы, можно использовать вложенные пространства имен. Например, пространство именhardware,определенное в примере 2.5, может на самом деле содержать большое количество сетевых классов и еще больше классов устройств, так что его можно было бы разделить, вложив еще несколько описательных имен.
   namespace hardware {
    namespace net {
     // сетевые классы
    }
    namespace devices {
     // классы устройств
    }
   }
   Теперь доступ к элементам, содержащимся в пространстве имен, стал несколько более сложным.
   //В каком-либо другом файле...
   using hardware::devices::Device;
   Пространства имен довольно удобны. Есть несколько интересных вещей, связанных с пространствами имен, облегчающих жизнь: псевдонимы пространств имен, автоматический поиск имен в пространствах имен параметров функций и подстановка имен перегрузок функций в объявленияхusing.Последние два длинны по названиям, но просты.
   Псевдоним пространства имен — это то, что означает его название: имя (возможно, короткое), которое используется для замены имени (возможно, длинного) пространства имен. Если вы не хотите использовать выражениеusing,но также не хотите вводить при каждом использовании класса огромное полное имя, создайте для него псевдоним.
   using dev = hardware::devices;
   // ...
   dev::Device d;
   Затем этот псевдоним используется при ссылке на элементы соответствующего пространства имен.
   C++также предоставляет автоматический поиск в пространствах имен, к которым относятся параметры функций. Так, например, следующий код описывает аргументы в пространстве имен (dev— это пространство имен, в котором объявленDevice):
   void f(dev::Device& d) {
    register(d); // на самом деле это dev::register
   }
   При передаче функции параметра, принадлежащего пространству имен, компилятор включает это пространство имен при поиске имен функций, вызываемых в теле этой функции. Это, может быть, не самая часто используемая особенность, но когда она используется, то экономит значительное время набора кода и позволяет избежать лишних директивusing.В основе этого лежит идея о том, что функции, которые оперируют с каким-либо типом, часто определяются в том же пространстве имен, что и этот тип. Кстати, вообще всегда, когда возможно, следует помещать функции, оперирующие определенными типами, в то же пространство имен, в котором находятся эти типы.
   Последним интересным моментом, связанным с пространствами имен, является подстановка имен перегрузок в объявленияхusing.Рассмотрим такой пример.
   namespace mylib {
    void foo(mt);
    void foo(double);
    void foo(std::string);
    // Другие перегрузки foo( )...
   }

   //В каком-то другом файле...
   using mylib::foo; //Какой вариант используется?
   Объявлениеusingсоответствует всем перегрузкамfoo,так что писать отдельную директиву для каждой перегрузки не требуется. Другим преимуществом этой записи является то, что если добавляется еще одна перегрузкаfoo,то весь код, содержащий объявление видаmylib::foo,видит ее автоматически (конечно, при компиляции кода, содержащего это объявление), так как объявлениеusingвключает и ее.
   Конечно, использовать пространства имен следует обдуманно, а иначе у вас или тех, кто будет их использовать, появятся неожиданные ошибки компиляции. Вот несколько популярных советов по использованию пространств имен.
   Как можно реже используйтеusing namespacexxx
   Как я объяснял ранее, импорт всего пространства имен увеличивает вероятность конфликта имен — либо сразу, либо в будущем (в используемое вами пространство имен может быть добавлено что-то, что приведет к конфликту). Это также снижает степень модульности, предоставляемую пространствами имен.
   Не используйте операторusingв заголовочных файлах
   Заголовочные файлы включаются большим количеством других файлов, так что использование пространства имен или чего-либо из пространства имен в заголовочном файлеоткрывает его файлам, включающим этот заголовочный файл. Решение этой проблемы заключается в указании в заголовочных файлах полных имен.
   Не помещайте объявленияusingили определения перед директивами#include
   Если это сделать, тогда то, что указано в директивеusing,будет открыто для кода заголовочного файла, что, вероятно, не входило в намерения автора этого заголовочного файла.
   При выполнении этих правил использование пространств имен в новом проекте или добавление их в существующий проект должно быть относительно просто.
   2.5.Включение встраиваемого файлаПроблема
   Имеется несколько функций-членов или самостоятельных функций, которые требуется сделать встраиваемыми (inline), но вы не хотите определять их все в определении класса (или даже после него) в заголовочном файле. Это позволит хранить объявление и реализацию по отдельности.Решение
   Создайте файл.inlи с помощью#includeвключите его в конец своего заголовочного файла. Это эквивалентно помещению определения функции в конец заголовочного файла, но позволяет хранить объявление и определение раздельно. Пример 2.6 показывает, как это делается.
   Пример 2.6. Использование встраиваемого файла

   // Value.h
   #ifndef VALUE_H__
   #define VALUE_H__

   #include&lt;string&gt;

   class Value {
   public:
    Value (const std::string& val) : val_(val) {}
    std::string getVal() const;
   private:
    std::string val_;
   };

   #include "Value.inl"

   #endif VALUE_H__

   // Value.inl
   inline std::string Value::getVal() const {
    return(val_);
   }
   Это решение не требует пояснений,#includeзаменяется на содержимое ее аргумента, так что здесь в заголовочный файл включается содержимоеValue.inl.Следовательно, любой файл, включающий этот заголовочный файл, содержит определения встраиваемых функций, но вам не требуется загромождать объявление класса.
   Глава 3
   Числа
   3.0.Введение
   Даже если вы не занимаетесь написанием научных или инженерных приложений, вам все равно придется работать с числами. Эта глава содержит решения проблем, часто возникающих при работе с числовыми типами С++.
   Некоторые из рецептов содержат методики преобразования из числовых типов в типstringи обратно чисел, представленных в различных форматах (шестнадцатеричном, с плавающей точкой или экспоненциальном). Самостоятельное написание кода для таких преобразований утомительно и требует времени, так что я показываю возможности стандартной библиотеки или одной из библиотек Boost, облегчающие выполнение этих задач. Также имеется несколько рецептов по работе исключительно с числовыми типами: безопасное преобразование между ними, сравнение чисел с плавающей точкой с граничными значениями и поиск минимального и максимального значений.
   Рецепты в этой главе предоставляют решения некоторых общих проблем, с которыми обычно сталкиваются при работе с числами в С++, но они не пытаются решать проблем, специфичных для конкретных приложений. При написании научного или инженерного приложения вам также следует взглянуть на главу 11, которая содержит рецепты ко многим общим научным и инженерным алгоритмам.
   3.1.Преобразование строки в числовой типПроблема
   Имеются числа в строковом формате, и вам требуется преобразовать их в числовой тип, такой какintилиfloat.Решение
   Это можно сделать двумя способами — с помощью функций стандартной библиотеки или с помощью классаlexical_castиз Boost (написанного Кевлином Хенни (Kevlin Henney) Функции стандартной библиотеки неуклюжи и небезопасны, но они стандартны, и в некоторых случаях потребуются именно они,так что в первом решении я представлю именно их.lexical_castболее безопасен, проще в использовании и интереснее, так что я представляю его в обсуждении.
   Функцииstrtol,strtodиstrtoul,определенные в&lt;cstdlib&gt;,преобразуют символьные строки, ограниченные нулем, вlong int,doubleилиunsigned long.Они могут использоваться для преобразования чисел, представленных в виде строк с любым основанием, в числовые типы. Код примера 3.1 демонстрирует функциюhex2int,которая предназначена для преобразования шестнадцатиричной строки вlong.
   Пример 3.1. Преобразование числовых строк в числа
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;cstdlib&gt;

   using namespace std;

   long hex2int(const string& hexStr) {
    char *offset;
    if (hexStr.length( )&gt; 2) {
     if (hexStr[0] == '0'&& hexStr[1] == 'x') {
      return strtol(hexStr.c_str(),&offset, 0);
     }
    }
    return strtol(hexStr.c_str( ),&offset, 16);
   }

   int main() {
    string str1 = "0x12AB";
    cout&lt;&lt; hex2int(str1)&lt;&lt; endl;
    string str2 = "12AB";
    cout&lt;&lt; hex2int(str2)&lt;&lt; endl;
    string str3 = "0AFG";
    cout&lt;&lt; hex2int(str3)&lt;&lt; endl;
   }
   Вот вывод этой программы.
   4779
   4779
   0
   Первые две строки содержат шестнадцатеричное число 12AB. Первая из них содержит префикс0x,а вторая — нет. Третья строка не содержит правильного шестнадцатеричного числа. В этом случае функция просто возвращает 0.Обсуждение
   Некоторые люди склонны писать свои собственные функции для преобразования шестнадцатеричных чисел в целочисленные форматы. Но зачем изобретать колесо? Стандартная библиотека уже предоставляет эту функциональность. Пример 3.1 представляет собой функцию-оболочку, упрощающую вызовstrtol.Функцияstrtol— это старая функция библиотеки С, и она требует от вас передачи указателя на завершающуюся нулем строку, а так же адрес еще одного указателя на строку. Этот второйуказатель получает адрес, на котором обработка строки завершилась. Однако в C++ большинство людей предпочитает работать с более мощным классомstring,а не со старыми указателями на символьные строки. Поэтому функцияhex2intпринимает параметр типаstring.
   Функцияstrtolнесколько странна в том, что она позволяет использовать два разных метода указания основания 16: 16 можно передать как третий параметр функции, а можно в качестве основания передать 0, но предварить строку символами0x (точно также, как это делается для обозначения шестнадцатеричных чисел в коде, но только помните, что в случае сstrtolпередается строка).
   Пример 3.1 позволяет использовать оба метода. При передаче строки вида0x12ABфункция обнаружит0xи передаст ее непосредственно вstrtol,в качестве третьего параметра передав 0. В противном случае функция передаст строку, в качестве третьего параметра передав 16.
   strtolиstrtoulработают одинаково, за исключением типа возвращаемого значения.strtodаналогична им, но не позволяет указывать основание.
   Эти старые функции С не являются единственным способом преобразования строк в числа. Проект Boost предоставляет класс преобразованияlexical_cast,который выполняет то же самое для числовых строк, записанных с основанием 10. Пример 3.2 показывает как он используется.
   Пример 3.2. Использование lexical_cast
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;boost/lexical_cast.hpp&gt;

   using namespace std;

   int main() {
    string str1 = "750" ;
    string str2 = "2.71";
    string str3 = "0x7FFF";
    try {
     cout&lt;&lt; boost::lexical_cast&lt;int&gt;(str1)&lt;&lt; endl;
     cout&lt;&lt; boost::lexical_cast&lt;double&gt;(str2)&lt;&lt; endl;
     cout&lt;&lt; boost::lexical_cast&lt;int&gt;(str3)&lt;&lt; endl;
    } catch (boost::bad_lexical_cast& e) {
     cerr&lt;&lt; "Bad cast: "&lt;&lt; e.what()&lt;&lt; endl;
    }
   }
   Вывод примера 3.2 таков.
   750
   2.71
   Bad cast: bad lexical cast: source type value could not be
   interpreted as target
   (Неверное преобразование: неверное лексическое преобразование: значение исходного типа не может быть преобразовано в целевой.)
   Вы ведите, что для последнего значения, представляющего собой шестнадцатеричное число, он выбрасывает исключение. При преобразовании чисел с основанием, отличнымот 10, требуется использовать функцииstrtol.
   Также имеются версии функцийstrtolдля работы с «широкими» символами. Эквивалентstrtolдля работы с широкими символами — этоwcstol,которая объявлена в&lt;cwchar&gt;.Эквивалентами функцийstrtodиstrtoulявляютсяwcstodиwcstoul.Каждая из этих функций точно такая же, за исключением того, что те параметры, которые в функциях для узких символов имеют типchar*,в функциях для широких символов имеют типwchar_t*.Смотри также
   Рецепт 3.2.
   3.2.Преобразование чисел в строкиПроблема
   Имеются числовые типы (int,float),и вам требуется поместить их содержимое вstring,возможно, предварительно отформатировав.Решение
   Для выполнения этого имеется множество способов, каждый из которых имеет свои достоинства и недостатки. Первая представляемая мной методика использует для хранения строковых данных классstringstream,который является частью стандартной библиотеки и прост в использовании. Этот подход показан в примере 3.3. Смотри обсуждение альтернативных методик.
   Пример 3.3. Форматирование числа как строки
   #include&lt;iostream&gt;
   #include&lt;iomanip&gt;
   #include&lt;string&gt;
   #include&lt;sstream&gt;

   using namespace std;

   int main() {
    stringstream ss;
    ss&lt;&lt; "В моей корзине "&lt;&lt; 9&lt;&lt; "яблок.";
    cout&lt;&lt;ss.str()&lt;&lt;endl; //stringstream::str()возвращает string
                           // с содержимым
    ss.str(""); // Очистка строки
    ss&lt;&lt; showbase&lt;&lt; hex&lt;&lt; 16; //Показать основание в шестнадцатеричном формате
    cout&lt;&lt; "ss = "&lt;&lt; ss.str()&lt;&lt; endl;
    ss.str("");
    ss&lt;&lt; 3.14;
    cout&lt;&lt; "ss = "&lt;&lt; ss.str()&lt;&lt; endl;
   }
   Вывод примера 3.3 выглядит так.
   В моей корзине 9 яблок.
   ss = 0x10
   ss = 3.14Обсуждение
   stringstream— это удобный способ поместить данные вstring,поскольку он позволяет использовать все возможности форматирования, предоставляемые классами стандартного ввода и вывода. В простейшем случае в примере 3.3 я для записи комбинации текста и числовых данных в строковый поток просто использую оператор сдвига влево (&lt;&lt;).
   ss&lt;&lt; "В моей корзине "&lt;&lt; 9&lt;&lt; "яблок.";
   Оператор&lt;&lt;перегружен для встроенных типов и соответственно форматирует вывод. Когда требуется получить данные, хранящиеся вstring,используйте функцию-членstr.
   cout&lt;&lt; ss.str()&lt;&lt; endl;
   В&lt;iomanip&gt;имеется большое количество манипуляторов потоками, и их использование при выводе числовых данных в строку позволяет выполнить все виды форматирования. В примере 3.3 для форматирования числа как шестнадцатеричного я использовалshowbaseиhex,но есть еще и другие возможности форматирования. Например, можно установить точность отображения, отличную от числа десятичных знаков по умолчанию.
   ss&lt;&lt; setprecision(6)&lt;&lt; 3.14285;
   Однако использование манипуляторов является не самой интуитивно понятной вещью, и именно поэтому создан рецепт, посвященный им. За дополнительной информацией о форматировании числовых данных с помощью манипуляторов потоками обратитесь к рецепту 10.2.
   Конечно, как часто бывает в С++, имеется и другой способ. Библиотека Boost Format (написанная Сэмюэлем Кремппом (Samuel Krempp) содержит классformat,который делает форматирование и преобразование очень простыми. Пример 3.4 показывает, как выполнить подобное преобразование.
   Пример 3.4. Форматирование целых в шестнадцатеричное представление
   #include&lt;iostream&gt;
   #include&lt;boost/format.hpp&gt;

   using namespace std;
   using boost::format;
   using boost.:io::str;
   using boost::io::format_error;

   int main() {
    try {
     format f("Имеется %1% способа. %2% %3% %4%");
     f % 3;
     f % "чтобы" % "это" % "сделать.";
     cout&lt;&lt; f&lt;&lt; endl;
     f.clear(); // Счистка буферов для форматирования чего-либо еще
     f.parse("Это стоит $%d.");
     f % 50;
     cout&lt;&lt; f&lt;&lt; endl;
     int x = 11256099;
     string strx = str(format("%x") % x);
     cout&lt;&lt; strx&lt;&lt; endl;
    } catch (format_error&e) {
     cout&lt;&lt; e.what()&lt;&lt; endl;
    }
   }
   Вот что вы увидите при запуске этой программы.
   Имеется 3 способа, чтобы это сделать.
   Это стоит $50.
   abc123
   Использование классаformatтребует двух шагов, включая создание объектаformatи передачу ему содержимого. Для простейшего случая в примере 3.4 я создал объект format с помощью простейшей версии его синтаксиса.
   format f("Имеется %1% способа, %2% %3% %4%");
   В строке формата заполнители — это числа, обрамленные с обеих сторон символами %. Затем я начинаю передавать в объект содержимое указанного формата.
   f % 3;
   f % "чтобы" % "это" % "сделать;
   Оператор%в библиотеке форматирования был переопределен так, чтобы добавлять указанные в нем переменные в левую часть объектаformat.Его можно использовать как один раз на строку, так и несколько раз в одной строке. Он аналогичен оператору&lt;&lt;для строк. Что же касается оператора&lt;&lt;,он также был переопределен так, что объектыformatможно непосредственно записать в выходной поток. Кроме того, если требуется поместить результаты в строку, используйте функцию-членstr.
   string s = f.str();
   Если же вам нравитсяprintf,то можно использовать форматную строкуprintf.
   f.parse("Это стоит $%d.*");
   f % 50;
   Если будет записано слишком много или слишком мало переменных для указанного формата, то при попытке записать строку в поток или извлечь отформатированную строкубудет выброшено исключениеformat_error (или подклассthereof).
   Классformatдостаточно мощен и содержит слишком много возможностей форматирования, чтобы их можно было описать здесь, и его стоит изучить. Чтобы скачать Boost или почитать документацию, посетите web-сайт Boost по адресуwww.boost.org.
   Также для преобразования чисел из числовых типов в строки можно использоватьsprintfили аналогичные ей функции. Обычно этого следует избегать, так как это небезопасно и для этого имеются лучшие альтернативы.Смотри также
   Глава 10.
   3.3.Проверка, содержит ли строка допустимое числоПроблема
   Имеется строкаstringи требуется определить, содержит ли она допустимое число.Решение
   Для проверки допустимости числа можно использовать шаблон функцииlexical_castбиблиотеки Boost. При таком подходе допустимое число может включать предшествующий знак минус, предшествующий знак плюс, но не пробел. В примере 3.5 приводятся несколько образцов типов форматов, с которыми работаетlexical_cast.
   Пример 3.5. Проверка числовой строки
   #include&lt;iostream&gt;
   #include&lt;boost/lexical_cast.hpp&gt;

   using namespace std;
   using boost::lexical_cast;
   using boost::bad_lexical_cast;

   template&lt;typename T&gt;
   bool isValid(const string& num) {
    bool res = true;
    try {
     T tmp = lexical_cast&lt;T&gt;(num);
    } catch (bad_lexical_cast&e) {
     res = false;
    }
    return(res);
   }

   void test(const string& s) {
    if (isValid&lt;int&gt;(s))
     cout&lt;&lt; s&lt;&lt; " -допустимое целое число."&lt;&lt; endl;
    else
     cout&lt;&lt; s&lt;&lt; " - HEдопустимое целое число."&lt;&lt; endl;
    if (isValid&lt;double&gt;(s))
     cout&lt;&lt; s&lt;&lt; " -допустимое число двойной точности."&lt;&lt; endl;
    else
     cout&lt;&lt; s&lt;&lt; " - HEдопустимое число двойной точности."&lt;&lt; endl;
    if (isValid&lt;float&gt;(s))
     cout&lt;&lt; s&lt;&lt; " -допустимое число одинарной точности."&lt;&lt; endl;
    else
     cout&lt;&lt; s&lt;&lt; " - HEдопустимое число одинарной точности "&lt;&lt; endl;
   }

   int main() {
    test("12345");
    test("1.23456");
    test("-1.23456");
    test(" - 1.23456");
    test("+1.23456");
    test(" 1.23456 ");
    test("asdf");
   }
   Вот вывод этого примера.
   12345 -допустимое целое число.
   12345 -допустимое число двойной точности.
   12345 -допустимое число одинарной точности.
   1.23456 -НЕ допустимое целое число.
   1.23456 -допустимое число двойной точности.
   1.23456 -допустимое число одинарной точности.
   -1.23456 -НЕ допустимое целое число.
   -1.23456 -допустимое число двойной точности.
   -1.23456 -допустимое число одинарной точности.
   - 1.23456 -НЕ допустимое целое число.
   - 1 23466 -НЕ допустимое число двойной точности.
   - 1.23456 -НЕ допустимое число одинарной точности.
   +1.23456 -НЕ допустимое целое число.
   +1.23456 -допустимое число двойной точности.
   +1.23456 -допустимое число одинарной точности.
    1.23456 - НЕ допустимое целое число.
    1.23456 - НЕ допустимое число двойной точности.
    1.23456 - НЕ допустимое число одинарной точности.
   asdf -НЕ допустимое целое число.
   asdf -НЕ допустимое число двойной точности.
   asdf -НЕ допустимое число одинарной точности.Обсуждение
   Шаблон функцииlexical_castпреобразует значение из одного типа в другой. Он объявлен следующим образом.
   template&lt;typename Target, typename Source&gt;
   Target lexical_cast(Source arg)
   Source— это тип оригинальной переменной, aTarget — это тип переменной, в которую значение преобразуется. Таким образом, например, чтобы преобразовать изstringвint,вызовlexical_castимеет вид:
   int i = lexical_cast&lt;int&gt;(str); // str -это строка
   lexical_castпроводит анализ и пытается выполнить преобразование. Если преобразование невозможно, он выбрасывает исключениеbad_lexical_cast.В примере 3.5 я только хочу проверить допустимость, и мне не требуется сохранять целевую переменную, так что если исключение не выбрасывается, я возвращаюtrue,а в противном случае —false.
   Вlexical_castтребуется передать только первый аргумент, поскольку это шаблон, что означает, что компилятор может догадаться, какой тип имеет аргумент функции, и использовать его в качестве второго аргумента. Пояснение этой ситуации более сложно, чем простая демонстрация, так что позвольте мне использовать фрагмент кода примера. Вместо того чтобы вызыватьlexical_cast,как в предыдущем фрагменте кода, можно сделать так.
   int i = lexical_cast&lt;int, string&gt;(str);
   Это означает то же самое, но указывать аргументstringне требуется, так как компилятор видит, чтоstr— этоstring,и понимает, что от него требуется дальше.
   Если вы собираетесь написать аналогичную функцию-обертку для проверки допустимости, возвращающуюtrueиfalse,ее также можно написать как шаблон функции. В этом случае ее потребуется написать только один раз с использованием параметризованного типа, а различные версии будут генерироваться при каждом ее использовании с различными типами.
   lexical_castтакже удобен для преобразования из одного числового типа в другой. Более подробно это обсуждается в рецепте 3.6.Смотри также
   Рецепт 3.6.
   3.4.Сравнение чисел с плавающей точкой с ограниченной точностьюПроблема
   Требуется сравнить значения с плавающей точкой, но при этом выполнить сравнение на равенство, больше чем или меньше чем с ограниченным количеством десятичных знаков. Например, требуется, чтобы 3.33333 и 3.33333333 считались при сравнении с точностью 0.0001 равными.Решение
   Напишите свои функции сравнения, которые принимают в качестве параметра ограничение точности сравнения. Пример 3.6 показывает основную методику, используемую в такой функции сравнения.
   Пример 3.6. Сравнение чисел с плавающей точкой
   #include&lt;iostream&gt;
   #include&lt;cmath&gt; //для fabs()

   using namespace std;

   bool doubleEquals(double left, double right, double epsilon) {
    return (fabs(left - right)&lt; epsilon);
   }

   bool doubleLess(double left, double right, double epsilon,
    bool orequal = false) {
    if (fabs(left - right)&lt; epsilon) {
     // В рамках epsilon, так что считаются равными
     return (orequal);
    }
    return (left&lt; right);
   }

   bool doubleGreater(double left, double right, double epsilon,
    bool orequal = false) {
    if (fabs(left - right)&lt; epsilon) {
     // В рамках epsilon, так что считаются равными
    return (orequal);
    }
    return (left&gt; right);
   }

   int main() {
    double first = 0.33333333;
    double second = 1.0 / 3.0;
    cout&lt;&lt; first&lt;&lt; endl;
    cout&lt;&lt; second&lt;&lt; endl;
    // Тест на прямое равенство. Не проходит тогда, когда должно проходить.
    // (boolalpha печатает булевы значения как "true" или "false")
    cout&lt;&lt; boolalpha&lt;&lt; (first == second)&lt;&lt; endl;
    // Новое равенство. Проходит так, как требуется в научном приложении.
    cout&lt;&lt; doubleEquals(first, second, .0001)&lt;&lt; endl;
    // Новое меньше чем
    cout&lt;&lt; doubleLess(first, second, .0001)&lt;&lt; endl;
    // Новое больше чем
    cout&lt;&lt; doubleGreater(first, second, .0001)&lt;&lt; endl;
    // Новое меньше чем или равно
    cout&lt;&lt; doubleLess(first, second, .0001, true)&lt;&lt; endl;
    // Новое больше чем или равно
    cout&lt;&lt; doubleGreater(first, second, .0001, true)&lt;&lt; endl;
   }
   Далее показан вывод этого примера.
   0.333333
   0.333333
   false
   true
   false
   false
   true
   trueОбсуждение
   Код примера 3.6 начинается с двух значений — 0.33333333 и того, что компьютер получает в результате деления 1.0 / 3.0. Он с помощью форматирования по умолчаниюcoutпечатает эти два значения. Они кажутся одинаковыми и равными 0.333333. Однако при сравнении этих двух значений они оказываются различными. Значение 1.0 / 3.0 имеет больше значащих цифр, чем 0.33333333, и, следовательно, как полагает машина, эти два числа не равны. Однако в некоторых приложениях может потребоваться, чтобы они считались равными.
   Чтобы добиться этого, надо написать собственные функции сравнения чисел с двойной точностью:doubleLess,doubleEqualsиdoubleGreater,каждая из которых принимает в качестве параметров два значения типаdouble.Кроме того,doubleLessиdoubleGreaterимеют дополнительный параметр, который при его равенствеtrueприводит к тому, что эти функции ведут себя как «меньше или равно» и «больше или равно» соответственно.
   Чтобы заставить эти функции учитывать точность, рассмотрим функциюdoubleEquals.Вместо того чтобы проверять на равенство, эта функция проверяет, находится ли разность двух чисел в указанном пользователем диапазонеepsilon. (В качествеepsilonпример использует значение 0.0001.) Если это так, то функция возвращает значение true, что означает, что значения одинаковы. Таким образом, равными окажутся значения 0.3333, 0.33333, 0.333333, 0.33333333333 и 0.33333323438.
   Чтобы выполнить операцию «меньше чем» и «больше чем», вначале проверьте, не равны ли значения, как это делается в функцииdoubleEquals.Если так, то при наличии теста на равенство вернитеtrue,а в противном случае —false.В противном случае выполните прямое сравнение.
   3.5.Лексический анализ строки, содержащей число в экспоненциальной формеПроблема
   Имеется строка, содержащая число в экспоненциальной форме, и требуется сохранить значение числа в переменной типаdouble.Решение
   Наиболее простым способом анализа числа в экспоненциальной форме является использование встроенного в библиотеку C++ классаstringstream,объявленного в&lt;sstream&gt;,как показано в примере 3.7.
   Пример 3.7. Лексический анализ числа в экспоненциальной форме
   #include&lt;iostream&gt;
   #include&lt;sstream&gt;
   #include&lt;string&gt;

   using namespace std;

   double sciToDub(const strings str) {
    stringstream ss(str);
    double d = 0;
    ss&gt;&gt; d;
    if (ss.fail()) {
     string s = "Невозможно отформатировать ";
     s += str;
     s += " как число!";
     throw (s);
    }
    return (d);
   }

   int main() {
    try {
     cout&lt;&lt; sciToDub("1.234e5")&lt;&lt; endl;
     cout&lt;&lt; sciToDub("6.02e-2")&lt;&lt; endl;
     cout&lt;&lt; sciToDub("asdf")&lt;&lt; endl;
    } catch (string& e) {
     cerr&lt;&lt; "Ошибка: "&lt;&lt; e&lt;&lt; endl;
    }
   }
   Далее показан вывод этого кода.
   123400
   0.0602
   Ошибка: невозможно отформатировать asd как число!Обсуждение
   Классstringstream— этоstring,который ведет себя как поток (что неудивительно). Он объявлен в&lt;sstring&gt;.Если требуется выполнить анализstring,содержащей число в экспоненциальной форме (см. также рецепт 3.2), то с этой работой прекрасно справитсяstringstream.Стандартные классы потоков уже «знают», как анализировать числа, так что не тратьте без острой необходимости время на повторную реализацию этой логики.
   В примере 3.7 я написал простую функциюsciToDub,принимающую параметр типаstringи возвращающую содержащийся в нейdouble,если он допустим. ВsciToDubя используюstringstreamследующим образом.
   stringstream ss(str); //Конструирование из строки типа string
   double d = 0;
   ss&gt;&gt; d;
   if (ss.fail()) {
    string s = "Невозможно отформатировать ";
    s += str;
    s += " как число!";
    throw (s);
   }
   return (d);
   Наиболее важной частью здесь является то, что все, что требуется сделать, — это использовать для чтения из строкового потока вdoubleоператор сдвига вправо (&gt;&gt;),как это делается при чтении изcin.
   Ну, это не совсемвсе,что требуется сделать. Если вstringstreamзаписано значение, которое не может быть записано в переменную в правой части оператора&gt;&gt;,то для потока будет выставлен битfail.Этот бит можно проверить с помощью функции-членаfail (на самом деле это функция-членbasic_ios,который является родительским классом дляstringstream).Кроме того, переменная справа от оператора&gt;&gt;в случае ошибки значения не меняет.
   Однако с целью обобщения можно избежать написания отдельных версийsciToDubдля типовint,float,doubleи чего-либо еще, что может потребоваться преобразовать, если написать шаблон функции. Рассмотрим такую новую версию.
   template&lt;typename T&gt;
   T strToNum(const string& str) {
    stringstream ss(str);
    T tmp;
    ss&gt;&gt; tmp;
    if (ss.fail()) {
     string s = "Невозможно отформатировать ";
     s += str;
     s += " как число!";
     throw (s);
    }
    return (tmp);
   }
   Теперь, чтобы преобразоватьstringв числовой тип, можно сделать так.
   double d = strToNum&lt;double&gt;("7.0");
   float f = strToNum&lt;float&gt;("7.0");
   int i = strToNum&lt;int&gt;("7.0");
   Также параметром шаблона можно сделать тип символов, но это очень просто сделать, так что я оставляю это в качестве вашего упражнения.Смотри также
   Рецепт 3.2.
   3.6.Преобразования между числовыми типамиПроблема
   Имеется число одного типа и требуется преобразовать его в другой, какintвshortили наоборот, но при этом необходимо перехватывать все ошибки переполнения (overflow) или потери значимости (underflow), возникающие при работе программы.Решение
   Используйте шаблон классаnumeric_cast Boost.Он выполняет проверки, которые при переполнениях переменной, принимающей значение, или других ошибках выбрасывают исключение типаbad_numeric_cast.Пример 3.8 показывает, как это выполняется.
   Пример 3.8. Безопасное преобразование чисел
   #include&lt;iostream&gt;
   #include&lt;boost/cast.hpp&gt;

   using namespace std;
   using boost::numeric_cast;
   using boost::bad_numeric_cast;

   int main() {
    // Целые типы
    try {
     int i = 32767;
     short s = numeric_cast&lt;short&gt;(i);
     cout&lt;&lt; "s = "&lt;&lt; s&lt;&lt; endl;
     i++; // Теперь i выходит за диапазон (если sizeof(short) равен 2)
     s = numeric__cast&lt;short&gt;(i);
    } catch (bad_numeric_cast& e) {
     cerr&lt;&lt; e.what()&lt;&lt; endl;
    }
    try {
     int i = 300;
     unsigned int ui = numeric_cast&lt;unsigned int&gt;(i);
     cout&lt;&lt; ui&lt;&lt; endl; //Прекрасно
     i *= -1;
     ui = numeric_cast&lt;unsigned int&gt;(i); // iотрицателен!
    } catch (bad_numeric_cast& e) {
     cerr&lt;&lt; e.what()&lt;&lt; endl;
    }
    try {
     double d = 3.14.
     int i = numeric_cast&lt;int&gt;(d);
     i = numeric_cast&lt;int&gt;(d); //Это отрезает 0.14!
     cout&lt;&lt; i&lt;&lt; endl; // i = 3
    } catch (bad_numeric_cast& e) {
     cerr&lt;&lt; e.what( )&lt;&lt; endl;
    }
   }Обсуждение
   Вы, вероятно, знаете, что базовые типы C++ имеют различные размеры. Стандарт C++ содержит жесткие указания по относительному размеру типов:intвсегда не короче, чемshort int,но он не указывает абсолютных размеров. Это означает, что если взятьlong intи попытаться записать его значение вshortили попытаться поместитьintвunsigned int,то информация о значении переменной-источника, такая как знак или даже часть числового значения, может быть потеряна.
   Только знания, что это может привести к проблемам, не достаточно. Вы можете быть ограничены жесткими требованиями по объему и не захотите использовать четыре байта дляlong,когда можно обойтись двумя байтами дляshort (если ваша платформа на самом деле использует такие размеры, что очень распространено, но не гарантируется). Из-за ограничений по объему может возникнуть желание попробовать хранить значения в наименьших возможных типах. Если вы любите приключения, но вам нужна страховка, для перехвата потерь данных при работе программы используйтеnumeric_castиз Boost.
   Синтаксисnumeric_castочень прост. Это шаблон функции, объявленный следующим образом.
   template&lt;typename Target, typename Source&gt;
   inline Target numeric_cast(Source arg)
   Если вы уже прочли рецепты 3.1 и 3.3, он аналогиченlexical_cast.У него имеется два параметра шаблона —TargetиSource,— которые представляют типы оригинального и результирующего значений. Так как это шаблон функции, компилятор может догадаться о типе аргументаSource,так что требуется указать толькоTarget,как здесь.
   int i = 32767;
   short s = numeric_cast&lt;short&gt;(i);
   short— это аргумент, передаваемый в шаблон как параметрTarget.Компилятор догадывается, чтоSourceимеет типintпотому, чтоiимеет типint.
   В этом случае я впихиваюintвshort.В моей системе (Windows XP) int имеет длину четыре байта, ashort— два.shortимеет знак, это означает, что для представления числа в нем используется 15 бит и, следовательно, максимальным допустимым положительным значением для него является32 767. Приведенный выше фрагмент кода работает молча, но когда я увеличиваюiна единицу, она выходит за диапазонshort.
   s = numeric_cast&lt;short&gt;(i); //Ох!
   Вы уже догадались, что выбрасывается исключениеbad_numeric_cast.Смотри остальную часть примера 3.8:numeric_castтакже перехватывает потери знака, возникающие при присвоении отрицательного значения со знаком типу без знака.
   Ноnumeric_castне решает всех проблем. Если попытаться поместить значение с плавающей точкой в тип без плавающей точки, то будет потеряно все, что находится справа от десятичной точки, так?numeric_castв этой ситуации не спасает, так что не думайте, что он сможет уберечь вас от всех рискованных предприятий. Например, рассмотрим такой фрагмент кода из примера 3.8:
   double a = 3.14;
   int i = numeric_cast&lt;int&gt;(d); //Ох!
   Здесь не будет выброшено никаких исключений. Но это произойдет, если попробовать такое:
   double d = -3.14;
   unsigned int ui = numeric_cast&lt;unsigned int&gt;(d);
   Потому что, несмотря на то что происходит потеря всего, что находится справа от десятичной точки, происходит потеря знака, а это очень плохо.Смотри также
   Рецепты 3.1 и 3.3.
   3.7.Получение минимального и максимального значений числового типаПроблема
   Требуется узнать наибольшее и наименьшее значения, представляемые на данной платформе числовым типом, таким какintилиdouble.Решение
   Чтобы среди прочего получить максимальное и минимальное допустимые значения числового типа, используйте шаблон классаnumeric_limitsиз заголовочного файла&lt;limits&gt; (см. пример 3.9).
   Пример 3.9. Получение числовых ограничений
   #include&lt;iostream&gt;
   #include&lt;limits&gt;

   using namespace std;

   template&lt;typename T&gt;
   void showMinMax() {
    cout&lt;&lt; "min: "&lt;&lt; numeric_limits&lt;T&gt;::min()&lt;&lt; endl;
    cout&lt;&lt; "max: "&lt;&lt; numeric_limits&lt;T&gt;::max()&lt;&lt; endl;
    cout&lt;&lt; endl;
   }

   int main() {
    cout&lt;&lt; "short:"&lt;&lt; endl;
    showMinMax&lt;short&gt;();
    cout&lt;&lt; "int:"&lt;&lt; endl;
    showMinMax&lt;int&gt;();
    cout&lt;&lt; "long:"&lt;&lt; endl;
    showMinMax&lt;long&gt;();
    cout&lt;&lt; "float:"&lt;&lt; endl;
    showMinMax&lt;float&gt;();
    cout&lt;&lt; "double:"&lt;&lt; endl;
    showMinMax&lt;double&gt;();
    cout&lt;&lt; "long double:"&lt;&lt; endl;
    showMinMax&lt;long double&gt;();
    cout&lt;&lt; "unsigned short:"&lt;&lt; endl;
    showMinMax&lt;unsigned short&gt;();
    cout&lt;&lt; "unsigned int:"&lt;&lt; endl;
    showMinMax&lt;unsigned int&gt;();
    cout&lt;&lt; "unsigned long:"&lt;&lt; endl;
    showMinMax&lt;unsigned long&gt;();
   }
   Вот что я получил в Windows XP, используя Visual C++ 7.1.
   short:
   min: -32768
   max: 32767

   int:
   min: -2147483648
   max: 2147483647

   long:
   min -2147483648
   max 2147483647

   float:
   min: 1.17549e-038
   max: 3.40282e-038

   double:
   min: 2.22507e-308
   max: 1.79769e+308

   long double:
   min: 2.22507e-308
   max: 1.79769e+308

   unsigned short:
   min: 0
   max: 65535

   unsigned int:
   min: 0
   max: 4294967295

   unsigned long:
   min: 0
   max: 4294967295Обсуждение
   Пример 3.9 показывает простой пример получения минимального и максимального значений встроенных числовых типов. Шаблон классаnumeric_limitsимеет специализации для всех встроенных типов, включая как числовые, так и нечисловые типы. Стандарт требует, чтобы все типы, которые я использовал в примере 3.9, а также перечисленные далее, имели свою специализациюnumeric_limits.
   bool
   char
   signed char
   unsigned char
   wchar_t
   minиmax— это функции-членыnumeric_limitsтипаstatic,которые возвращают наименьшее и наибольшее значения для типа переданного им параметра.
   Глава 4
   Строки и текст
   4.0.Введение
   Эта глава содержит рецепты работы со строками и текстовыми файлами. Большая часть программ на C++ независимо от сферы их применения в той или иной степени работает со строками и текстовыми файлами. Однако, несмотря на различия в сферах применения, требования к ним часто одни и те же: для строк — обрезка, дополнение, поиск, разбиение и т.п.; для текстовых файлов — перенос строк, переформатирование, чтение файлов с разделителями и др. Следующие рецепты предоставляют решения многих из часто встречающихся задач, не имеющих готовых решений в стандартной библиотеке С++.
   Стандартная библиотека переносима, стандартизована и в общем случае не менее эффективна, чем самодельное решение, так что в следующих примерах я предпочитаю ее коду, написанному с нуля. Она содержит богатый раздел для работы со строками и текстом, большая часть которого заключена в шаблоне классовbasic_string (для строк),basic_istreamиbasic_ostream (для входных и выходных текстовых потоков). Почти все методики, описанные в этой главе, используют или расширяют эти шаблоны классов. В тех случаях, когда они не делают того, что требуется, я использую другую часть стандартной библиотеки, содержащей общие готовые решения: алгоритмы и контейнеры.
   Строки используют все, так что если что-то, что вам требуется, отсутствует в стандартной библиотеке, то велика вероятность, что это уже написано кем-то другим. Библиотека Boost String Algorithms (алгоритмы для работы со строками), написанная Паволом Дробой (Pavol Droba), заполняет большинство пробелов стандартной библиотеки, реализуя большую часть алгоритмов, которые могут понадобиться в различных ситуациях, и делает это переносимым и эффективным способом. Для получения дополнительной информации и документации по библиотеке String Algorithms обратитесь к проекту Boost по адресуwww.boost.org.Библиотека String Algorithms и решения, приводимые в этой главе, в некоторых частях дублируют друг друга. В большинстве случаев я привожу примеры или, по крайней мере, упоминаю алгоритмы Boost связанные с приводимым решением.
   Для большинства примеров приводится как версия с использованием шаблонов, так и без них. Это сделано по двум причинам. Во-первых, большая часть областей стандартной библиотеки, использующих символьные данные, — это шаблоны классов, параметризованных по типу символов — узкие (char)или широкие (wchar_t).Следуя этой модели, можно повысить совместимость программного обеспечения со стандартной библиотекой. Во-вторых, работаете ли вы со стандартной библиотекой или нет, шаблоны классов и функций предоставляют прекрасную возможность написания программного обеспечения, не привязанного к конкретной ситуации. Однако, если шаблоны не нужны, используйте нешаблонные версии, хотя, если вы новичок в шаблонах, я рекомендую вам поэкспериментировать с ними.
   Стандартная библиотека очень активно использует шаблоны, а для того, чтобы оградить программистов от многословного синтаксиса шаблонов, используетtypedef.В результате терминыbasic_string,stringиwstringиспользуются как взаимозаменяемые, поскольку то, что верно для одного из них, обычно верно и для двух других,stringиwstringявляютсяtypedefдляbasic_string&lt;char&gt;иbasic_string&lt;wchar_t&gt;.
   Наконец, вы, вероятно, заметите, что ни один из рецептов этой главы не использует строк в стиле С, т.е. заканчивающихся нулем символьных массивов. Стандартная библиотека предоставляет такую богатую, эффективную и расширяемую поддержку строк С++, что использование строковых функций в стиле С (которые поддерживаются с целью обратной совместимости) — это уход от гибкости, безопасности и общей природы того, что дается бесплатно компилятором: классов строк С++.
   4.1.Дополнение строкПроблема
   Требуется «дополнить» — или заполнить - строку некоторым количеством символов до определенной длины. Например, может потребоваться дополнить строку"Chapter 1"точками до 20 символов в длину так, чтобы она выглядела как"Chapter 1...........".Решение
   Для дополнения строк начальными или концевыми символами используйте функции-члены (методы)insertиappendклассаstring.Например, чтобы дополнить конец строки 20 символамиX:
   std::string s = "foo";
   s.append(20 - s.length(), 'X');
   Чтобы дополнить начало строки:
   s.insert(s.begin(), 20 - s.length(), 'X');Обсуждение
   Разница в использовании двух функций заключается в первом параметреinsert.Это итератор, который указывает на символ, справа от которого требуется вставить новые символы. Методbeginвозвращает итератор, указывающий на первый элемент строки, так что в этом примере последовательность символов добавляется слева от него. Параметры, общие для всехфункций, — это количество раз, которое требуется повторить символ, и сам символ.
   insertиappend— это методы шаблона классаbasic_string,описанного в заголовочном файле&lt;string&gt; (string— этоtypedefдляbasic_string&lt;char&gt;, awstring — этоtypedefдляbasic_string&lt;wchar_t&gt;),так что они работают как для строк из узких, так и широких символов. Их использование по мере необходимости, как в предыдущем примере, прекрасно работает, но при использовании методовbasic_stringв собственных вспомогательных функциях общего назначения эти функции следует создавать, используя общий существующий дизайн стандартной библиотеки и шаблоны функций. Рассмотрим код примера 4.1, который определяет общий шаблон функции pad, который работает для строк типа basic_string.
   Пример 4.1. Общий шаблон функции pad
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   using namespace std;

   //Общий подход
   template&lt;typename&gt;
   void pad(basic_string&lt;T&gt;& s,
    typename basic_string&lt;T&gt;::size_type n, T c) {
    if (n&gt; s.length())
     s.append(n - s.length(), c);
   }

   int main() {
    string s = "Appendix A";
    wstring ws = L"Acknowledgments"; // "L" указывает, что
                                     // этот литерал состоит из
    pad(s, 20. "*");                 // широких символов
    pad(ws, 20, L'*');
    // cout&lt;&lt; s&lt;&lt; std::endl; // Heследует пытаться выполнить это
    wcout&lt;&lt; ws&lt;&lt; std::endl;  // одновременно
   }
   padв примере 4.1 дополняет данную строкуsдо длины n, используя символc.Так как шаблон функции использует параметризованный тип элементов строки (T),он будет работать дляbasic_stringиз любых символов:char,wchar_tили любых других, определенных пользователем.
   4.2.Обрезка строкПроблема
   Требуется обрезать несколько символов в конце или начале строки, обычно пробелов.Решение
   Для определения позиции строки, которую требуется удалить, используйте итераторы, а для ее удаления — методerase.Пример 4.2 показывает функциюrtrim,которая удаляет символ в конце строки.
   Пример 4.2. Обрезка символов строки
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   //Подход для строк из узких символов
   void rtrim(std::string& s, charс) {
    if (s.empty()) return;
    std::string::iterator p;
    for (p = s.end(); p != s.begin()&& *--p == c;);
    if (*p != c) p++;
    s.erase(p, s.end());
   }

   int main() {
    std::string s = "zoo";
    rtrim(s, 'o');
    std::cout&lt;&lt; s&lt;&lt; '\n';
   }Обсуждение
   Пример 4.2 выполняет все необходимое для строк длиныchar,но работаеттолькодля них. Аналогично тому, что показано в примере 4.1, можно использовать общий дизайнbasic_stringи шаблон функции. Пример 4.3 использует для удаления символов в конце строки любого типа шаблон функции.
   Пример 4.3. Обобщенная версия rtrim
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   using namespace std;

   //Общий подход к обрезке отдельных
   //символов строки
   template&lt;typename T&gt;
   void rtrim(basic_string&lt;T&gt;& s, Tс) {
    if (s.empty()) return;
    typename basic_string&lt;T&gt;::iterator p;
    for (p = s.end(); p != s.begin()&& *--p == c;);
    if (*p != c) p++;
    s.erase(p, s.end());
   }

   int main() {
    string s = "Great!!!!";
    wstring ws = L"Super!!!!";
    rtrim(s, '!');
    rtrim(ws, L'!');
    cout&lt;&lt; s&lt;&lt; '\n';
    wcout&lt;&lt; ws&lt;&lt; L'\n';
   }
   Эта функция работает точно так же, как и предыдущая, необобщенная версия из примера 4.2, но так как она параметризована по типу символов, она будет работать дляbasic_stringлюбого типа.
   Примеры 4.2 и 4.3 удаляют из строки последовательность одного символа. Однако обрезка пробелов выглядит по-другому, так как пробельный символ может быть представлен одним из нескольких символов. Для удобства стандартная библиотека предоставляет простейший способ справиться с этим: функциюisspaceиз заголовочного файла&lt;cctype&gt; (и ееwchar_t-эквивалентiswspaceиз&lt;cwctype&gt;).Пример 4.4 определяет общую функцию, которая обрезает концевые пробелы.
   Пример 4.4. Удаление концевых пробелов
   #include&lt;string&gt;
   #include&lt;iostream&gt;
   #include&lt;cctype&gt;
   #include&lt;cwctype&gt;

   using namespace std;

   template&lt;typename T, typename F&gt;
   void rtrimws(basic_string&lt;T&gt;& s, F f) {
    if (s.empty()) return;
    typename basic_string&lt;T&gt;::iterator p;
    for (p = s.end(); p ! = s.begin()&& f(*--p););
    if (!f(*p))
     p++;
    s.erase(p, s.end());
   }

   //Перегрузка для облегчения вызовов в клиентском коде
   void rtrimws(string& s) {
    rtrimws(s, isspace);
   }

   void rtrimws(wstring& ws) {
    rtrimws(ws, iswspace);
   }

   int main() {
    string s = "zing ";
    wstring ws = L"zong ";
    rtrimws(s) rtrimws(ws);
    cout&lt;&lt; s&lt;&lt; "|\n";
    wcout&lt;&lt; ws&lt;&lt; L"|\n";
   }
   Шаблон функцииrtrimwsв примере 4 4 — это шаблон обобщённой функции, аналогичной предыдущим примерам, которая принимаетbasic_stringи удаляет пробелы в ее конце. Но в отличие от других примеров, она для проверки элемента строки и определения того, должен ли он быть удален, принимает не символ, а объект функции.
   Перегружатьrtrimws,как это сделано в предыдущем примере, необязательно, но это упрощает синтаксис использования функции, так как вызывающий код при ее использовании может опустить аргумент логической функции.
   Но, увы, это решение требует, чтобы вы писали код сами. Если же вы предпочитаете использовать библиотеку — и именно это и следует делать, — то библиотека Boost String Algorithms предоставляет огромное количество функций для обрезки строки, и в ней на верняка есть то, что вам надо. На самом деле, в библиотеке String Algorithms имеется огромное количество удобных функций обрезки, и при возможности использования Boost на них следует посмотреть. Таблица 4.1 приводит шаблоны функций этой библиотеки, используемые для обрезки строк, включая некоторые вспомогательные функции. Так как это шаблоны функций, они имеют параметры шаблонов, представляющие различные используемые типы. Вот что они означают.
   Seq
   Это тип, удовлетворяющий требованиям к последовательностям стандарта C++.
   Coll
   Это тип, удовлетворяющий менее строгим требованиям, чем стандартная последовательность. Для того чтобы узнать, каким требованиям удовлетворяет коллекция, обратитесь к определениям Boost String Algorithms.
   Pred
   Это объект функции или указатель на функцию, которая принимает один аргумент и возвращает логическое значение — другими словами, унарный предикат. В некоторые функции обрезки для обрезки элементов, удовлетворяющих некоторому критерию, можно передать собственный унарный предикат.
   OutIt
   Это тип, который удовлетворяет требованиям выходного итератора, как определено в стандарте С++. В частности, он должен поддерживать инкрементирование и присвоениенового положения для добавления элементов в конец последовательности, на которую он указывает.

   Табл. 4.1. Шаблоны функций обрезки строк BoostОбъявлениеОписаниеtemplate&lt;typename Seq&gt; void trim(Seq& s, const locale& loc = locale());Обрезает пробелы с обоих концов строки, используя для классификации пробельных символов функцию классификации локалиtemplate&lt;typename Seq, typename Pred&gt; void trim_if(Seq& s, Pred p);Обрезает с обоих концов последовательности s элементы для которыхp(*it)равноtrue,гдеit— это итератор, указывающий на элемент последовательности. Обрезка прекращается, когдаp(*it) = falsetemplate&lt;typename Seq&gt; Seq trim_copy(const Seq& s, const locale& loc = locale());Делает то же самое, что иtrim,но вместо измененияsвозвращает новую последовательность, содержащую обрезанные результатыtemplate&lt;typename Seq, typename Pred&gt; Seq trim_copy_if(const Seq& s, Pred p);Делает то же самое, что иtrim_if,но вместо измененияsвозвращает новую последовательность, содержащую обрезанные результатыtemplate&lt;typename OutIt, typename Coll, typename Pred&gt; OutIt trim_copy_if(OutIt out, const Coll& c, Pred p);Делает то же, что и предыдущая версияtrim_copy_if,но с некоторыми отличиями. Во-первых, она дает гарантию строгой безопасности исключений. Во-вторых, она в качестве первого аргумента принимает выходной итератор и возвращает выходной итератор, указывающий на одну позицию после конца результирующей последовательности. Наконец, она принимает тип коллекции, а не последовательности. За дополнительной информацией обратитесь к списку перед этой таблицейtrim_left trim_rightРаботает какtrim,но только для левого или правого конца строкиtrim_left_if trim_right_ifРаботает какtrim_if,но только для левого или правого конца строкиtrim_left_copy trim_right_copyРаботает какtrim_сору,но только для левого или правого конца строкиtrim_left_copy_if trim_right_copy_ifРаботает как trim_copy_if,но только для левого или правого конца строки. Обе функции имеют две версии — одна работает с последовательностью, а другая — с коллекцией
   Первые четыре шаблона функции, описанные в табл. 4.1, — это базовая функциональность функций обрезки библиотеки String Algorithms. Остальные являются вариациями на их тему. Чтобы увидеть некоторые из них в действии, посмотрите на пример 4.5. Он показывает некоторые преимущества от использования этих функций перед методамиstring.
   Пример 4.5. Использование функций обрезки строк Boost
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;boost/algorithm/string.hpp&gt;

   using namespace std;
   using namespace boost;

   int main() {
    string s1 = " ведущие пробелы?";
    trim_left(s1); // Обрезка оригинальной строки
    string s2 = trim_left_copy(s1); // Обрезка, но оригинал остается без изменений
    cout&lt;&lt; "s1 = "&lt;&lt; s1&lt;&lt; endl;
    cout&lt;&lt; "s2 = "&lt;&lt; s2&lt;&lt; endl;

    s1 = "YYYYboostXXX";
    s2 = trim_copy_if(s1, is_any_of("XY")); // Используется предикат
    trim_if(s1, is_any_of("XY"));
    cout&lt;&lt; "s1 = "&lt;&lt; s1&lt;&lt; endl;
    cout&lt;&lt; "s2 = "&lt;&lt; s2&lt;&lt; endl;

    s1 = "1234 числа 9876";
    s2 = trim_copy_if(s1, is_digit());
    cout&lt;&lt; "s1 = "&lt;&lt; s1&lt;&lt; endl;
    cout&lt;&lt; "s2 = "&lt;&lt; s2&lt;&lt; endl;

    // Вложенные вызовы функций обрезки
    s1 = " ****Обрезка!*** ";
    s2 = trim_copy_if(trim_copy(s1), is_any_of("*"));
    cout&lt;&lt; "s1 = "&lt;&lt; s1&lt;&lt; endl;
    cout&lt;&lt; "s2 = "&lt;&lt; s2&lt;&lt; endl;
   }
   Пример 4.5 демонстрирует, как использовать функции обрезки строк Boost. Обычно способ их использования понятен из их названия, так что я не буду вдаваться в описания более подробные, чем даны в табл. 4.1. Единственная функция, имеющаяся в этом примере и отсутствующая в таблице, — этоis_any_of.Это шаблон функции, который возвращает объект функции-предиката, используемый функциями серииtrim_if.Она используется, когда требуется обрезать набор символов. Также есть аналогичная функция классификации, которая называетсяis_from_rangeи принимает два аргумента и возвращает унарный предикат, который возвращает истину, когда символ находится в заданном диапазоне. Например, чтобы обрезать в строкесимволы садоd,требуется сделать что-то, похожее на следующее.
   s1 = "abcdXXXabcd";
   trim_if(s1, is_from_range('a', 'd'));
   cout&lt;&lt; "s1 = "&lt;&lt; s1&lt;&lt; endl; //Теперь s1 = XXX
   Заметьте, что эта конструкция чувствительна к регистру, так как диапазон отадоdне включает заглавных версий этих букв.
   4.3.Хранение строк в последовательностиПроблема
   Требуется сохранить набор строк в виде последовательности, которая ведет себя как массив.Решение
   Для хранения строк в виде массива используйтеvector.Пример 4.6 показывает простой образец.
   Пример 4 6. Хранение строк в векторе
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include&lt;iostream&gt;

   using namespace std;

   int main() {
    vector&lt;string&gt; v;
    string s = "one";
    v.push_back(s);
    s = "two";
    v.push_back(s);
    s = "three";
    v.push_back(s);
    for (int i = 0; i&lt; v.size(); ++i) {
     cout&lt;&lt; v[i]&lt;&lt; "\n";
    }
   }
   vectorиспользует для произвольного доступа семантику массива (а также делает много другого), так что он прост и понятен в использовании. Однакоvector— это только одна из многих последовательностей стандартной библиотеки. Чтобы узнать об этом побольше, читайте дальше.Обсуждение
   vector— это динамическая последовательность объектов, которая предоставляет произвольный доступ с помощью оператора в стиле массивовoperator[].Методpush_backпри помощи копирующего конструктора копирует свой аргумент, добавляет копию в последний элемент вектора и увеличивает его размер на единицу.pop_backвыполняет обратную операцию, удаляя последний элемент. Вставка и удаление элементов в конце вектора занимает постоянное время, а время вставки и удаления элементов в середине вектора линейно зависит от его размера. Это основы векторов. Кроме этого, они умеют еще много чего.
   В большинстве случаевvectorдолжен быть первым выбором вместо массива в стиле С. Во-первых, их размеры изменяются динамически, что означает, что эти размеры увеличиваются по мере необходимости. Не требуется проводить каких-либо исследований для выбора оптимального размера статического массива, как в случае с массивами С, — vector растет по мере надобности,а при необходимости может быть увеличен или уменьшен вручную. Во-вторых,vectorпри использовании методаat (но не при использованииoperator[])предлагает проверку границ, так что при ссылке на несуществующий индекс программа не обрушится и не продолжит выполнение с неверными данными. Посмотрите на пример 4.7, Он показывает, как работать с индексами, выходящими за границы массива.
   Пример 4.7. Проверка границ для векторов
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;exception&gt;

   using namespace std;

   int main() {
    char carr[] = {'a', 'b', 'c', 'd', 'e'};
    cout&lt;&lt; carr[100000]&lt;&lt; '\n'; //Оп, кто знает, что дальше
                                  // произойдет
    vector&lt;char&gt; v;
    v.push_back('a');
    v.push_back('b');
    v.push_back('c');
    v.push_back('d');
    v push_back('e');
    try {
     cout&lt;&lt; v.at(10000)&lt;&lt; "\n"; // atпроверяет границы и выбрасывает
    } catch(out_of_range&е) {    // out_of_range, если произошел выход за них
     cerr&lt;&lt; e.what()&lt;&lt; '\n';
    }
   }
   Перехватout_of_range,определенного в&lt;stdexcept&gt;,позволяет грамотно справиться с неправильными индексами. А также можно вызвать методwhat,позволяющий в зависимости от используемой реализации получить осмысленное сообщение об ошибке, как возвращаемая в коде примера 4.7:
   invalid vector&lt;T&gt; subscript
   Однакоvectorне является единственной возможностью. В C++ имеется большое количество способов хранить последовательности. Кромеvectorимеютсяlist,setи двунаправленные очереди (deque— double-ended queue). Все они поддерживают множество одинаковых операций, и каждый поддерживает свои собственные. Кроме того, каждый имеет различную алгоритмическую сложность, требования по хранению и семантику. Так что имеется богатый выбор.
   Посмотрите внимательно на пример 4.6. Вы, вероятно, обратите внимание, что я изменяю значение строкиsдо того, как добавляю ее в конец контейнера с помощьюpush_back.Логично ожидать такого вывода этого примера
   three
   three
   three
   Я поместил в вектор одну и ту же строку три раза, так что каждый раз, когда я переприсваиваю строку, разве не должны все элементы вектора указывать на одну и ту же строку? Нет. Это важный момент, касающийся контейнеров STL.
   Контейнеры STL сохраняют копии объектов, помещаемых в них, а не сами объекты. Так что после помещения в контейнер всех трех строк в памяти остается четыре строки: трикопии, созданные и хранящиеся в контейнере, и одна копия, которой присваиваются значения.
   Ну и что? Было создано несколько новых копий: большое дело. Но это действительно большое дело, так как если используется большое количество строк, за каждую копию приходится платить процессорным временем, памятью или и тем и другим. Копирование элементов в контейнерах — это намеренное поведение STL, и все контейнеры организованы именно так.
   Одним из решений (определеннонеединственным) является хранение в контейнере указателей. Но помните, что контейнер не удаляет с помощьюdeleteуказатели при его уничтожении. Память для указателей выделяет ваш код, так что он и должен ее очищать. Это относится и к ситуации, когда происходит полное удаление контейнера и когда удаляется только один его элемент.
   В целях создания альтернативного решения давайте рассмотрим еще одну возможность. Рассмотрим шаблон классаlist,определенный в&lt;list&gt;,который является двусвязным списком (doubly linked list). Если планируется большое количество вставок и удалений элементов в середине последовательности или если требуется гарантировать, что итераторы, указывающие на элементы последовательности, не станут недействительными при ее изменении, используйтеlist.Пример 4.8 вместоvectorдля хранения нескольких строк типаstringиспользуетlist.Также он для перебора этих строк и печати вместо оператора индекса, как это делается в случае с простыми массивами, используетfor_each.
   Пример 4.8. Хранение строк в списке
   #include&lt;string&gt;
   #include&lt;list&gt;
   #include&lt;algorithm&gt;
   #include&lt;iostream&gt;

   using namespace std;

   void write(const string& s) {
    cout&lt;&lt; s&lt;&lt; '\n';
   }

   int main() {
    list&lt;string&gt; lst;
    string s = "нож";
    lst.push_front(s);
    s = "вилка";
    lst.push_back(s);
    s = "ложка";
    lst.push_back(s);
    // У списка нет произвольного доступа, так что
    // требуется использовать for_each()
    for_each(lst.begin(), lst.end(), write);
   }
   Целью этого отступления от первоначальной проблемы (хранения строк в виде последовательностей) является краткое введение в последовательности STL. Здесь невозможно дать полноценное описание этого вопроса. За обзором STL обратитесь к главе 10 книгиC++ in a NutshellРэя Лишнера (Ray Lischner) (O'Reilly).
   4.4.Получение длины строкиПроблема
   Требуется узнать длину строки.Решение
   Используйте методlengthклассаstring.
   std::string s = "Raising Arizona";
   int i = s.length();Обсуждение
   Получение длины строки — это тривиальная задача, но она является хорошей возможностью обсудить схему размещенияstring (как узких, так и широких символов).string,в отличие от массивов строк, завершаемых нулем, в С являются динамическими и увеличиваются по мере надобности. Большая часть реализаций стандартной библиотеки начинают с относительно низкой емкости и увеличивают ее в два раза каждый раз, когда достигается предел. Знание того, как анализировать этот рост, если и не точного алгоритма, помогает диагностировать проблемы производительности, связанные со строками.
   Символы вbasic_stringхранятся в буфере, который является единым фрагментом памяти статического размера. Этот буфер, используемый строкой, изначально имеет некий размер, и по мере добавления в строку символов он заполняется до тех пор, пока не будет достигнут предел его емкости. Когда это происходит, буфер увеличивается. В частности, выделяется новый буфер большего размера, символы копируются из старого буфера в новый, и старый буфер удаляется.
   Определить размер буфера (не число символов, в нем содержащихся, а его максимальный размер) можно с помощью методаcapacity.Если требуется вручную установить емкость и избежать ненужных копирований буфера, используйте метод reserve и передайте ему числовой аргумент, указывающий требуемый размер буфера. Также имеется максимально возможный размер буфера, получить который можно с помощью вызоваmax_size.Это все можно использовать, чтобы посмотреть на расходование памяти в данной реализации стандартной библиотеки. Посмотрите на пример 4.9, показывающий, как это сделать.
   Пример 4.9. Длина строки и ее емкость
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   using namespace std;

   int main() {
    string s = "";
    string sr = "";
    sr.reserve(9000);
    cout&lt;&lt; "s.length = "&lt;&lt; s.length( )&lt;&lt; '\n';
    cout&lt;&lt; "s.capacity = "&lt;&lt; s.capacity( )&lt;&lt; '\n';
    cout&lt;&lt; "s.max.size = "&lt;&lt; s.max_size()&lt;&lt; '\n';
    cout&lt;&lt; "sr.length = "&lt;&lt; sr.length()&lt;&lt; '\n';
    cout&lt;&lt; "sr.capacity = "&lt;&lt; sr.capacity()&lt;&lt; '\n';
    cout&lt;&lt; "sr.max_size = "&lt;&lt; sr.max_size()&lt;&lt; '\n';
    for (int i = 0; i&lt; 10000; ++i) {
     if (s.length() == s.capacity()) {
      cout&lt;&lt; "sдостигла емкости "&lt;&lt; s.length()&lt;&lt;увеличение... \n";
     }
     if (sr.length() == sr.capacity()) {
      cout&lt;&lt; "srдостигла емкости "&lt;&lt; sr.length()&lt;&lt; ",увеличение...\n";
     }
     s += 'x';
     sr += 'x';
    }
   }
   При использовании Visual C++ 7.1 вывод выглядит так.
   s.length = 0
   s.capacity = 15
   s.max_size = 4294967294
   sr.length = 0
   sr.capacity = 9007
   sr.max_size = 4294967294
   sдостигла емкости 15, увеличение...
   sдостигла емкости 31, увеличение...
   sдостигла емкости 47, увеличение...
   sдостигла емкости 70, увеличение...
   sдостигла емкости 105, увеличение...
   sдостигла емкости 157, увеличение...
   sдостигла емкости 235, увеличение...
   sдостигла емкости 352, увеличение...
   sдостигла емкости 528, увеличение...
   sдостигла емкости 792, увеличение...
   sдостигла емкости 1188, увеличение...
   sдостигла емкости 1782, увеличение...
   sдостигла емкости 2673, увеличение...
   sдостигла емкости 4009, увеличение...
   sдостигла емкости 6013, увеличение...
   srдостигла емкости 9007, увеличение...
   sдостигла емкости 9019, увеличение...
   Здесь происходит то, что буфер строки заполняется по мере добавления в него символов. Если буфер оказывается полон (т.е. длина = емкость), выделяется новый буфер, и символы оригинальной строки и новый добавляемый символ (или символы) копируются в этот новый буфер,sначинает заполняться с емкости 15 (зависит от компилятора), а затем увеличивается каждый раз примерно на 50%.
   Если ожидается значительное увеличение строки или имеется большое количество строк, которые будут увеличиваться хотя бы немного, для минимизации числа перераспределений буфера используйтеreserve.Также следует провести эксперименты с имеющейся реализацией стандартной библиотеки и посмотреть, как она выполняет увеличение строк.
   Кстати, когда потребуется узнать, пуста ли строка, не сравнивайте ее размер с нулем, а просто вызовите методempty.Это метод, который возвращает истину, если длина строки равна нулю.
   4.5.Обращение строкПроблема
   Требуется обратить (реверсировать) строку.Решение
   Чтобы обратить строку «на месте», не используя временной строки, используйте шаблон функции reverse из заголовочного файла&lt;algorithm&gt;:
   std::reverse(s.begin(), s.end());Обсуждение
   reverseработает очень просто: она изменяет диапазон, переданный ей, так, что его порядок меняется на обратный оригинальному. Время, необходимое для этого, линейно зависит от длины диапазона.
   В случае, если требуетсяскопироватьстроку в другую строку, но в обратном порядке символов, используйте реверсивные итераторы, как здесь:
   std::string s = "Los Angeles";
   std::string rs;
   rs.assign(s.rbegin(), s.rend());
   rbeginиrendвозвращают реверсивные итераторы. Реверсивные итераторы ведут себя так, как будто они просматривают последовательность в обратном порядке.rbeginвозвращает итератор, который указывает на последний элемент, arendвозвращает итератор, указывающий на позицию перед первым элементом. Это в точности обратно тому, что делаютbeginиend.
   Нодолжныли вы обращать строку? С помощьюrbeginиrendдля обратной строки можно использовать все методы или алгоритмы, работающие с диапазонами итераторов. А если требуется выполнить поиск в строке, то можно использоватьrfind,которая делает то же, что иfind,но начинает с конца строки и движется к ее началу. Для больших строк или большого количества строк обращение может оказаться очень дорогостоящим, так что при возможности избегайте его.
   4.6.Разделение строкиПроблема
   Требуется разделить строку с разделителями на несколько строк. Например, может потребоваться разделить строку"Name|Address|Phone"на три отдельных строки —"Name","Address"и"Phone",удалив при этом разделитель.Решение
   Для перехода от одного вхождения разделителя к следующему используйте методfindклассаbasic_string,а для копирования каждой подстроки используйтеsubstr.Для хранения результатов используйте любую стандартную последовательность. Пример 4.10 используетvector.
   Пример 4.10. Разделение строки с разделителями
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include&lt;functional&gt;
   #include&lt;iostream&gt;

   using namespace std;

   void split(const string& s, char c, vector&lt;string&gt;& v) {
    string::size_type i = 0;
    string::size_type j = s.find(c);
    while (j != string::npos) {
     v.push_back(s.substr(i, j-i));
     i = ++j;
     j = s.find(c, j);
     if (j == string::npos)
      v.push_back(s.substr(i, s.length()));
    }
   }

   int main() {
    vector&lt;string&gt; v;
    string s = "Account Name|Address 1|Address 2 |City";
    split(s, '|', v);
    for (int i = 0; i&lt; v.size(); ++i) {
     cout&lt;&lt; v[i]&lt;&lt; '\n';
    }
   }Обсуждение
   Превращение приведенного выше примера в шаблон функции, принимающий любой тип символов, тривиально — просто параметризуйте тип символов и замените случаи использованияstringнаbasic_string&lt;T&gt;.
   template&lt;typename T&gt;
   void split(const basic_string&lt;T&gt;& s, T c,
    vector&lt;basic_string&lt;T&gt;&gt;& v) {
    basic_string&lt;T&gt;::size_type i = 0;
    basic_string&lt;T&gt;::size_type j = s.find(c);
    while (j != basic_string&lt;T&gt;::npos) {
     v.push_back(s.substr(i, j-i));
     i = ++j;
     j = s.find(c, j);
     if (j == basic_string&lt;T&gt;::npos)
      v.push back(s.substr(i, s.length()));
    }
   }
   Логика при этом не меняется.
    [Картинка: tip_yellow.png] Однако обратите внимание, что между двумя последними угловыми скобками в последней строке заголовка функции добавлен один пробел. Это требуется для того, чтобы сказать компилятору, что это не оператор сдвига вправо.
   Пример 4.10 разбивает строку с помощью простого алгоритма. Начиная с начала строки, он ищет первое вхождение разделителя с, а затем считает, что все, что стоит после начала строки или предыдущего найденного вхождения и до этого вхождения, является очередным фрагментом текста. Для поиска первого вхождения символа в оригинальной строкеstringпример использует методfind,а для копирования символов диапазона в новуюstring,помещаемую вvector,— методsubstr.Это тот же самый принцип, который используется в функциях разбиения строк большинства скриптовых языков и является специальным случаемразделения строки текста на лексемы (tokenizing),описываемого в рецепте 4.7.
   Разделение строки, использующей единственный символ-разделитель, является очень распространенной задачей, и неудивительно, что ее решение есть в библиотеке Boost String Algorithms. Оно просто в использовании. Чтобы увидеть, как разделить строку с помощью функцииsplitиз Boost, посмотрите на пример 4.11.
   Пример 4.11. Разделение строки с помощью Boost
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;list&gt;
   #include&lt;boost/algorithm/string.hpp&gt;

   using namespace std;
   using namespace boost;

   int main() {
    string s = "one,two,three,four";
    list&lt;string&gt; results;
    split(results, s, is_any_of(",")); // Обратите внимание - это boost::split
    for (list&lt;string&gt;::const_iterator p = results.begin();
     p != results.end(); ++p) {
     cout&lt;&lt; *p&lt;&lt; endl;
    }
   }
   split— это шаблон функции, принимающий три аргумента. Он объявлен вот так.
   template&lt;typename Seq, typename Coll, typename Pred&gt;
   Seq& split(Seq& s, Coll& c, Pred p,
    token_compress_mode_type e = token_compress_off);
   Seq,CollиPredпредставляют типы результирующей последовательности, входной коллекции и предиката, используемого для определения, является ли очередной объект разделителем. Аргумент последовательности — это последовательность, определенная по стандарту C++, содержащая нечто, что может хранить части того, что находится во входной коллекции. Так, например, в примере 4.11 был использованlist&lt;string&gt;,но вместо него можно было бы использовать иvector&lt;string&gt;.Аргумент коллекции — это тип входной последовательности. Коллекция — это нестандартная концепция, которая похожа на последовательность, но с несколько меньшими требованиями (за подробностями обратитесь к документации по Boost по адресуwww.boost.org).Аргумент предиката — это объект унарной функции или указатель на функцию, которая возвращаетbool,указывающий, является ли ее аргумент разделителем или нет. Она вызывается для каждого элемента последовательности в видеf(*it),гдеit— это итератор, указывающий на элемент последовательности.
   is_any_of— это удобный шаблон функции, поставляющийся в составе String Algorithms, которая облегчает жизнь при использовании нескольких разделителей. Он конструирует объект унарной функции, которая возвращаетtrue,если переданный ей аргумент является членом набора. Другими словами:
   bool b = is_any_of("abc")('a'); // b = true
   Это облегчает проверку нескольких разделителей, не требуя самостоятельного написания объекта функции.
   4.7.Разбиение строки на лексемыПроблема
   Требуется разбить строку на части, используя набор разделителей.Решение
   Для перебора элементов строки и поиска места нахождения следующих лексем и не-лексем используйте методыfind_first_ofиfirst_first_not_of.Пример 4.12 представляет простой классStringTokenizer,выполняющий эту задачу.
   Пример 4.12. Разбиение строки на лексемы
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   using namespace std;

   //Класс, разбивающий строку на лексемы.
   class StringTokenizer {
   public:
    StringTokenizer(const string& s, const char* delim = NULL) :
     str_(s), count(-1), begin_(0), end_(0) {
     if (!delim)
      delim_ = " \f\n\r\t\v"; //по умолчанию пробельные символы
     else
      delim_ = delim;
     // Указывает на первую лексему
     begin_ = str_.find_first_not_of(delim);
     end_ = str.find_first_of(delim_, begin_);
    }

    size_t countTokens() {
     if (count_&gt;= 0) //если уже посчитали, то выход
      return(count_);
     string::size_type n = 0;
     string::size_type i = 0;
     for (;;) {
      // переход на первую лексему
      if ((i = str_.find_first_not_of(delim_, i)) == string::npos)
       break;
      // переход на следующий разделитель
      i = str_.find_first_of(delim_, i+1);
      n++;
      if (i == string::npos) break;
     }
     return (count_ = n);
    }

    bool hasMoreTokens() { return(begin_ != end_); }

    void nextToken(string& s) {
     if (begin_ != string::npos&& end_ != string::npos) {
      s = str_.substr(begin_, end_-begin_);
      begin_ = str_.find_first_not_of(delim_, end_);
      end_ = str_.find_first_of(delim_, begin_);
     } else if (begin_ != string::npos&& end_ == string::npos) {
      s = str_.substr(begin_, str_.length()-begin_);
      begin_ = str_.find_first_not_of(delim_, end_);
     }
    }

   private:
    StringTokenizer() {}
    string delim_;
    string str_;
    int count_;
    int begin_;
    int end_;
   };

   int main() {
    string s = " razzle dazzle giddyup ";
    string tmp;
    StringTokenizer st(s);
    cout&lt;&lt; "Здесь содержится"&lt;&lt; st.countTokens()&lt;&lt; "лексемы.\n";
    while (st.hasMoreTokens()) {
     st.nextToken(tmp);
     cout&lt;&lt; "token = "&lt;&lt; trap&lt;&lt; '\n';
    }
   }Обсуждение
   Разбиение строки с четко определенной структурой, как в примере 4.10, конечно, хорошо, но не все так просто. Предположим, что, вместо того чтобы просто разделить строку на основе единственного разделителя, требуетсяразбить строку на лексемы.Наиболее частым вариантом этой задачи является разделение на лексемы с игнорированием пробелов. Пример 4.12 дает реализацию классаStringTokenizer (аналогичного стандартному классу Java™ с таким же именем) для C++, который принимает символы-разделители, но по умолчанию использует пробелы.
   Наиболее важные строки вStringTokenizerиспользуют методыfind_first_ofиfind_first_not_ofшаблона классаbasic_string.Их описание и примеры использования даны в рецепте 4.9. Пример 4.12 дает такой вывод.
   Здесь содержится 3 лексемы.
   token = razzle
   token = dazzle
   token = giddyup
   StringTokenizer— это более гибкая форма функцииsplitиз примера 4.10. Он поддерживает свое состояние, так что можно просто последовательно переходить с одной лексемы на другую, не разбивая вначале всю строку на части. Также есть возможность подсчитать число лексем.
   ВStringTokenizerможно внести пару усовершенствований. Во-первых, для простотыStringTokenizerнаписан так, что он работает только с простыми строками — другими словами, строками из узких символов. Если требуется, чтобы один и тот же класс работал как с узкими, так и с широкими символами, параметризуйте тип символов, как это сделано в предыдущих рецептах. Другим улучшением является расширениеStringTokenizerтак, чтобы он обеспечивал более дружественное взаимодействие с последовательностями и был более гибок. Вы всегда можете сделать это сами, а можете использовать имеющийся класс разбиения на лексемы. Проект Boost содержит классtokenizer,делающий все это. За подробностями обратитесь кwww.boost.org.Смотри также
   Рецепт 4.24.
   4.8.Объединение нескольких строкПроблема
   Имея последовательность строк, такую как вывод примера 4.10, вам требуется объединить их в одну длинную строку, возможно, с разделителями.Решение
   В цикле переберите всю последовательность строк и добавьте каждую из них в выходную строку. В качестве входа можно обрабатывать любую стандартную последовательность. Пример 4.13 используетvectorиз элементов типаstring.
   Пример 4.13. Объединение последовательности строк
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include&lt;iostream&gt;

   using namespace std;

   void join(const vector&lt;string&gt;& v, char c, string& s) {
    s.clear();
    for (vector&lt;string&gt;::const_iterator p = v.begin();
     p ! = v.end(); ++p) {
     s += *p;
     if (p != v.end() - 1) s += c;
    }
   }

   int main() {
    vector&lt;string&gt; v;
    vector&lt;string&gt; v2;
    string s;
    v.push_back(string("fее"));
    v.push_back(string("fi"));
    v.push_back(string("foe"));
    v.push_back(string("fum"));
    join(v, '/', s);
    cout&lt;&lt; s&lt;&lt; '\n';
   }Обсуждение
   Пример 4.13 содержит одну методику, которая несколько отличается от предыдущие примеров. Посмотрите на эту строку.
   for (vector&lt;string&gt;::const_iterator p = v.begin();
   Предыдущие примеры работы со строками использовалиiterator'ы без части «const», но здесь без этого не обойтись, так какvобъявлен как ссылка на объектconst.Если имеется объект контейнераconst,то для доступа к его элементам можно использовать толькоconst_iterator.Это так потому, что простойiteratorпозволяет записывать в объект, на который он указывает, что, конечно, нельзя делать в случае с объектами контейнера типаconst.
   vобъявлен какconstпо двум причинам. Во-первых, я знаю, что я не собираюсь изменять его содержимое, так что я хочу, чтобы компилятор выдал сообщение об ошибке, если это произойдет. Компилятор гораздо лучше меня в деле поиска таких вещей, особенно когда к такому присвоению приводит тонкая семантическая или синтаксическая ошибка. Во-вторых, я хочу показать пользователям этой функции, что я ничего не делаю с их контейнером, иconst— это великолепный способ сделать это. Теперь я просто должен создать обобщенную версию, которая работает с различными типами символов.
   Как и в рецепте 4.6, превращениеjoinв общий шаблон функции очень просто. Все, что требуется сделать, — это изменить заголовок, параметризовав тип символов, как здесь:
   template&lt;typename T&gt;
   void join(const std::vector&lt;std::basic_string&lt;T&gt;&gt;& v, T c,
    std::basic_string&lt;T&gt;& s)
   Ноvectorможет оказаться не единственным возможным входом функции. Вам может потребоваться объединить строки в стиле С. Классstring C++предпочтительнее строк в стиле С, так что если возникает такая задача, объединяйте их в C++string.После этого всегда можно получить версию С, вызвав методstring c_str,который возвращает указательconstна завершающийся нулем массив символов.
   Пример 4.14 предлагает общую версиюjoin,которая объединяет массив символов вstring.Так как новая общая версия параметризована по типу символов, она будет работать как для массивов узких, так и для массивов широких символов.
   Пример 4.14 Объединение строк в стиле C
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   const static int MAGIC_NUMBER = 4;

   template&lt;typename T&gt;
   void join(T* arr[], size_t n, T c, std::basic_string&lt;T&gt;& s) {
    s.clear();
    for (int i = 0; i&lt; n; ++i) {
     if (arr[i] != NULL)
      s += arr[i];
     if (i&lt; n-1) s += c;
    }
   }

   int main() {
    std::wstring ws;
    wchar_t* arr[MAGIC_NUMBER];
    arr[0] = L"you";
    arr[1] = L"ate";
    arr[2] = L"my";
    arr[3] = L"breakfast";
    join(arr, MAGIC_NUMBER, L'/', ws);
   }
   4.9.Поиск в строкахПроблема
   Требуется выполнить поиск в строке. Это может быть поиск одного символа, другой строки или одного из (или одногонеиз) неупорядоченного набора символов. И по каким-либо причинам требуется выполнять поиск в определенном порядке, например первое или последнее вхождение или первое или последнее вхождения относительно какого- либо положения в строке.Решение
   Используйте один из методов «find» изbasic_string.Почти все методы поиска начинаются со слова «find», и их имена говорят достаточно о том, что они делают. Пример 4.15 показывает, как работают некоторые из этих методов поиска.
   Пример 4.15. Поиск строк
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   int main() {
    std::string s = "Charles Darwin";
    std::cout&lt;&lt; s.find("ar")&lt;&lt; '\n'; //Поиск от
                                       // начала
    std::cout&lt;&lt; s.rfind("ar")&lt;&lt; "\n"; //Поиск с конца
    std::cout&lt;&lt; s.find_first_of("swi") //Найти первое вхождение одного
    &lt;&lt; '\n'; //из этих символов
    std::cout&lt;&lt; s.find_first_not_of("Charles") //Найти первое,
    &lt;&lt; '\n';                                   // что не входит в этот
                                                // набор
    std::cout&lt;&lt; s.find_last_of("abg")&lt;&lt; '\n'; //Найти первое вхождение любого
                                                // из этих символов,
                                                // начиная с конца
    std::cout&lt;&lt; s.find_last_not_of("aDinrw") //Найти первое,
     &lt;&lt; '\n';                                 // что не входит в этот
                                              // набор, начиная с конца
   }
   Все эти методы поиска обсуждаются более подробно в разделе «Обсуждение».Обсуждение
   Имеется шесть различных методов для поиска в строках, каждый из которых предоставляет четыре перегруженных варианта. Эти перегрузки позволяют использовать либо параметрbasic_string,либоcharT* (charT— это символьный тип). Каждый имеет параметрposтипаbasic_string::size_type,который позволяет указать индекс, с которого следует начать поиск, и есть перегрузка с параметромnтипаsize_type,который позволяет выполнить поиск только n символов из набора.
   Запомнить все эти методы довольно сложно, так что в табл. 4.2 дается краткая справка по каждому из них и их параметрам.

   Табл. 4.2. Методы для поиска строкМетодОписаниеsize_type find(const basic_string& str, size_type pos = 0) const;Возвращает индекс первого вхождения символа или подстроки начиная с начала или индекса, указанного в параметреpos.size_type find (const charT* s, size_type pos, size_type n) const; size_type find (const charT* s, size_type pos = 0) const; size_type find(charT c, size_type pos = 0) const;Если указанn,то при поиске используются первыеnсимволов целевой строкиsize_type rfind(...)Находит первое вхождение символа или подстроки, начиная с конца строки и двигаясь к ее началу. Другими словами делает то же, что иfind,но начинает поиск с конца строкиsize_type find_first_of(...)Находит первое вхождение любого символа из набора, переданного какbasic_stringили указатель на символы. Если указанn,то ищутся только первыеnсимволов используемого набораsize_type find_last_of(...)Находит последнее вхождение любого символа из набора, переданного какbasic_stringили указатель на символы. Если указанn,то ищутся только первыеnсимволов используемого набораsize_type find_first_not_of(...)Находит первое вхождение любого символа, не входящего в набор, переданный какbasic_stringили указатель на символы. Если указанn,то принимаются во внимание только первые n символов используемого набораsize_type find_last_not_of(...)Находит последнее вхождение любого символа, не входящего в набор, переданный какbasic_stringили указатель на символы. Если указанn,то принимаются во внимание только первыеnсимволов используемого набора
   Все эти методы возвращают индекс вхождения искомого элемента, который имеет типbasic_string&lt;T&gt;::size_type.Если поиск заканчивается неудачей, возвращаетсяbasic_string&lt;T&gt;::npos,которое является специальным значением (обычно -1), указывающим, что поиск был неудачен. Даже хотя обычно это значение -1, сравнивать возвращаемое значение следует именно сnpos,что обеспечит переносимость. Также это сделает код более понятным, так как сравнение сnposявляется явной проверкой, не содержащей магических чисел.
   Имея такое многообразие алгоритмов поиска, у вас должна быть возможность найти то, что вы ищете, а если такой возможности нет, используйте свои собственные алгоритмы. Однако еслиbasic_stringне предоставляет то, что требуется, то перед написанием своего кода посмотрите на&lt;algorithm&gt;.Стандартные алгоритмы работают с последовательностями, используя итераторы и почти также часто — объекты функций. Для удобства и простоты переносаbasic_stringпредоставляет итераторы, так что подключение итераторовstringк стандартным алгоритмам является тривиальным. Скажем, вам требуется найти первое вхождение двух одинаковых символов подряд. Для поиска двух одинаковых расположенных рядом («расположенных рядом» означает, что их позиции отличаются на один шаг итератора, т.е.*iter == *(iter + 1))символов в строке используйте шаблон функцииadjacent_find.
   std::string s = "There was a group named Kiss in the 70s";
   std::string::iterator p =
    std::adjacent_find(s.begin(), s.end());
   Результатом будет итератор, указывающий на первый из двух смежных элементов.
   Если вам требуется написать собственный алгоритм работы со строками, не используйтеbasic_stringтак, как это делается со строками в стиле С, используя для доступа к элементамoperator[].Используйте существующие методы. Каждая функция поиска принимает параметрsize_type,указывающий индекс, с которого должен начаться поиск. Последовательно используя функции поиска, можно пройти по всей строке. Рассмотрим пример 4.16, который подсчитывает число уникальных символов в строке.
   Пример 4.16. Подсчет уникальных символов
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   template&lt;typename T&gt;
   int countUnique(const std::basic_string&lt;T&gt;& s) {
    using std::basic_string;
    basic_string&lt;T&gt; chars;
    for (typename basic_string&lt;T&gt;::const_iterator p = s.begin();
     p != s.end(); ++p) {
     if (chars.find(*p) == basic.string&lt;T&gt;::npos)
     chars += *p;
    }
    return(chars.length());
   }

   int main() {
    std: :string s = "Abracadabra'";
    std::cout&lt;&lt; countUnique(s)&lt;&lt; '\n';
   }
   Функции поиска очень часто оказываются полезными. Когда требуется найти что- либо в строке типаstring,они должны быть первым, что следует использовать.
   4.10.Поиск n-го вхождения подстрокиПроблема
   Имея источникsourceи шаблонpatternтипаstring,требуется найтиn-е вхождениеpatternвsource.Решение
   Для поиска последовательных вхождений искомой подстроки используйте методfind.Пример 4.17 содержит простую функциюnthSubstr.
   Пример 4.17. Поиск n-го вхождения подстроки
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   using namespace std;

   int nthSubstr(int n, const strings s,
    const strings p) {
    string::size_type i = s.find(p); // Найти первое вхождение
    int j;
    for (j = 1; j&lt; n&& i != string::npos; ++j)
     i = s.find(p, i+1); // Найти следующее вхождение
    if (j == n) return(i);
    else return(-1);
   }

   int main() (
    string s = "the wind, the sea, the sky, the trees";
    string p = "the";
    cout&lt;&lt; nthSubstr(1, s, p)&lt;&lt; '\n';
    cout&lt;&lt; nthSubstr(2, s, p)&lt;&lt; '\n';
    cout&lt;&lt; nthSubstr(5, s, p)&lt;&lt; '\n';
   }Обсуждение
   В функциюnthSubstr,имеющую вид, показанный в примере 4.17, можно внести пару улучшений. Во-первых, ее можно сделать общей, сделав из нее вместо обычной функции шаблон функции. Во-вторых,можно добавить параметр, позволяющий учитывать подстроки, которые перекрываются друг с другом. Под перекрывающимися подстроками я понимаю такие, у которых началостроки соответствует части конца такой же строки, как в строке «abracadabra», где последние четыре символа такие же, как и первые четыре. Это демонстрируется в примере 4.18.
   Пример 4.18. Улучшенная версия nthSubstr
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   using namespace std;

   template&lt;typename T&gt;
   int nthSubstrg(int n, const basic_string&lt;T&gt;& s,
    const basic_string&lt;T&gt;& p, bool repeats = false) {
    string::size_type i = s.find(p);
    string::size_type adv = (repeats) ? 1 : p.length();
    int j;
    for (j = 1; j&lt; n&& i != basic_string&lt;T&gt;::npos; ++j)
     i = s.find(p, i+adv);
    if (j == n)
     return(i);
    else
     return(-1);
   }

   int main() {
    string s = AGATGCCATATATATACGATATCCTTA";
    string p = "ATAT";
    cout&lt;&lt; p&lt;&lt; "без повторений встречается в позиции "
    &lt;&lt; nthSubstrg(3, s, p)&lt;&lt; '\n';
    cout&lt;&lt; p&lt;&lt; "с повторениями встречается в позиции "
    &lt;&lt; nthSubstrg(3, s, p, true)&lt;&lt; '\n';
   }
   Вывод для строк, использованных в примере 4.18, выглядит так.
   ATATбез повторений встречается в позиции 18
   ATATс повторениями встречается в позиции 11Смотри также
   Рецепт 4.9.
   4.11.Удаление подстроки из строкиПроблема
   Требуется удалить из строки подстроку.Решение
   Используйте методыbasic_string find,eraseиlength:
   std::string t = "Banana Republic";
   std::string s = "nana";
   std::string::size_type i = t.find(s);
   if (i != std::string::npos) t.erase(i, s.length());
   Этот код удаляетs.length()элементов, начиная с индекса, по которомуfindнаходит первое вхождение подстроки.Обсуждение
   На практике встречается огромное количество вариаций на тему поиска и удаления подстрок. Например, может потребоваться удалить все вхождения подстроки, а не одно из них. Или только последнее. Или седьмое. Каждый раз действия будут одни и те же: найдите индекс начала шаблона, который требуется удалить, затем вызовитеeraseдля этого индекса иnпоследующих символов, гдеn— это длина строки шаблона. За описанием различных методов поиска подстрок обратитесь к рецепту 4.9.
   Также велика вероятность, что вам потребуется сделать функцию удаления обобщенной, так чтобы ее можно было использовать с любыми типами символов. Пример 4.19 предлагает общую версию, которая удаляет все вхождения шаблона в строке.
   Пример 4.19. Удаление всех подстрок из строки (обобщенная версия)
   #include&lt;string&gt;
   #include&lt;iostream&gt;

   using namespace std;

   template&lt;typename T&gt;
   void removeSubstrs(basic_string&lt;T&gt;& s,
    const basic_string&lt;T&gt;& p) {
    basic_string&lt;T&gt;::size_type n = p.length();
    for (basic_string&lt;T&gt;::size_type i = s.find(p);
     i != basic_string&lt;T&gt;::npos; i = s.find(p))
     s.erase(i, n);
   }

   int main() {
    string s = "One fish, two fish, red fish, blue fish";
    string p = "fish";
    removeSubstrs(s, p);
    cout&lt;&lt; s&lt;&lt; '\n';
   }
   Здесь всю важную работу выполняет методerase basic_string.В&lt;string&gt;он перегружен три раза. Использованная в примере 4.19 версия принимает индекс, с которого требуется начать удаление, и число удаляемых символов. Другая версия принимает в качестве аргументов начальный и конечный итераторы, а также есть версия, которая принимает единственный итератор и удаляет элемент, на который он указывает. Чтобы обеспечить оптимальную производительность при планировании удаления нескольких последовательных элементов, используйте первые две версии и не вызывайтеs.erase(iter)несколько раз для удаления каждого из идущих подряд элементов. Другими словами, используйте методы, работающие с диапазонами, а не с одним элементом, особенно в случае тех методов, которые изменяют содержимое строки (или последовательности). В этом случае вы избежите дополнительных вызовов функцииeraseдля каждого элемента последовательности и позволите реализацииstringболее грамотно управлять ее содержимым.
   4.12.Преобразование строки к нижнему или верхнему региструПроблема
   Имеется строка, которую требуется преобразовать к нижнему или верхнему регистру.Решение
   Для преобразования символов к нижнему или верхнему регистру используйте функцииtoupperиtolowerиз заголовочного файла&lt;cctype&gt;.Пример 4.20 показывает, как использовать эти функции. Смотри также обсуждение альтернативных методик.
   Пример 4.20. Преобразование регистра строки
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;cctype&gt;
   #include&lt;cwctype&gt;
   #include&lt;stdexcept&gt;

   using namespace std;

   void toUpper(basic_string&lt;char&gt;& s) {
    for (basic_string&lt;char&gt;::iterator p = s.begin();
    p != s.end(); ++p) {
     *p = toupper(*p); // toupper is for char
    }
   }

   void toUpper&lt;basic_string&lt;wchar_t&gt;& s) {
    for (basic_string&lt;wchar_t&gt;::iterator p = s.begin();
     p != s.end(); ++p) {
     *p = towupper(*p); // towupper is for wchar_t
    }
   }

   void toLower(basic_string&lt;char&gt;& s) {
    for (basic_string&lt;char&gt;::iterator p = s.begin();
     p != s.end(); ++p) {
     *p = tolower(*p);
    }
   }

   void toLower(basic_string&lt;wchar_t&gt;& s) {
    for (basic_string&lt;wchar_t&gt;::iterator p = s.begin();
     p != s.end(); ++p) {
     *p = towlower(*p);
   }

   int main() {
    string s = "shazam";
    wstring ws = L"wham";
    toUpper(s); toUpper(ws);
    cout&lt;&lt; "s = "&lt;&lt; s&lt;&lt; endl;
    wcout&lt;&lt; "ws = "&lt;&lt; ws&lt;&lt; endl;
    toLower(s);
    toLower(ws);
    cout&lt;&lt; "s = "&lt;&lt; s&lt;&lt; endl;
    wcout&lt;&lt; "ws = "&lt;&lt; ws&lt;&lt; endl;
   }
   Этот код производит следующий вывод.
   s = SHAZAM
   ws = WHAM
   s = shazam
   ws = whamОбсуждение
   Кто-то может подумать, что стандартный классstringсодержит метод, преобразующий всю строку к верхнему или нижнему регистру, но на самом деле это не так. Если требуется преобразовать строку символов к верхнему или нижнему регистру, это требуется делать самостоятельно.
   Неудивительно, что имеется несколько способов преобразования регистра строки (и когда я говорю «строки», то имею в виду последовательность символов как узких, таки широких). Простейшим способом сделать это является использование одной из четырех функций преобразования символовtoupper,towupper,tolowerиtowlower.Первая форма этих функций работает с узкими символами, а вторая форма (с дополнительной буквойw)является ее эквивалентом для широких символов.
   Каждая из этих функций преобразует регистр символа, используя текущие правила локали для преобразования регистра. Верхний и нижний регистры зависят от символов, используемых в текущей локали. Некоторые символы не имеют верхнего или нижнего регистра, и в этом случае указанные функции возвращают переданный им символ. За дополнительной информацией о локалях обратитесь к главе 13. Возможности C++ по работе с различными локалями довольно сложны, и я не могут уделить им сейчас достаточно места.
   Выполнение собственно преобразования символов просто. Рассмотрим функциюtoUpperиз примера 4.20.
   void toUpper(basic_string&lt;char&gt;& s) {
    for (basic_string&lt;char&gt;::iterator p = s.begin();
    p != s.end(); ++p) {
     *p = toupper(*p);
    }
   }
   Строка, выделенная жирным, выполняет всю работу. Версия для широких символов почти идентична.
   void toUpper(basic_string&lt;wchar_t&gt;& s) {
    for (basic_string&lt;wchar_t&gt;::iterator p = s.begin();
     p != s.end(); ++p) {
     *p = towupper(*p);
    }
   }
   Я перегрузилtoupperдля различных типов символов потому, что не существует общей функцииtoupper,преобразующей регистр символов (при условии, что не используются возможности заголовочного файла&lt;locale&gt;,который я описываю ниже). Две простые функции, как приведенные выше, выполняют всю работу.
   Однако есть и другой способ выполнить эту задачу, и фактором, оказывающим влияние на выбор этого способа, является необходимость использовать явные локали. Следующие версииtoUpperиtoLowerпреобразуют регистр строк независимо от типа их символов, но при условии, что указанная локаль (а по умолчанию текущая) поддерживает преобразование регистра для данного типа символов.
   template&lt;typenameС&gt;
   void toUpper2(basic_string&lt;C&gt;& s, const locale& loc = locale()) {
    typename basic_string&lt;C&gt;::iterator p;
    for (p = s.begin(); p ! = s.end(); ++p) {
     *p = use_facet&lt;ctype&lt;C&gt;&gt;(loc).toupper(*p);
    }
   }

   template&lt;typename C&gt;
   void tolower2(basic_string&lt;C&gt;& s, const locale& loc = locale()) {
    typename basic_string&lt;C&gt;::iterator p;
    for (p = s.begin(), p ! = s.end(++p) {
     *p = use_facet&lt;ctype&lt;C&gt;&gt;(loc).tolower(*p);
    }
   }
   Строки, выделенные жирным, выполняют всю работу. Функционально они работают точно так же, как и функции для верхнего и нижнего регистров, использованные в примере 4.20, за исключением того, что они используют для этого возможности интернационализации из заголовочного файла&lt;locale&gt;.За более подробным обсуждением локалей и возможностей интернационализации обратитесь к главе 13.
   4.13.Выполнение сравнения строк без учета регистраПроблема
   Имеются две строки и требуется узнать, не равны ли они, не учитывая регистр их символов. Например, «cat» не равно «dog», но «Cat» должна быть равна «cat», «CAT» или «caT».Решение
   Сравните строки, используя стандартный алгоритмequal (определенный в&lt;algorithm&gt;),и создайте свою собственную функцию сравнения, которая использует для сравнения версий с верхним регистром символов функциюtoupperиз&lt;cctype&gt; (илиtowupperиз&lt;cwctype&gt;для широких символов). Пример 4.21 показывает обобщенное решение. Также он демонстрирует использование и гибкость STL. За полным объяснением обратитесь к обсуждению ниже.
   Пример 4.21. Сравнение строк без учета регистра
   1  #include&lt;string&gt;
   2  #include&lt;iostream&gt;
   3  #include&lt;algorithm&gt;
   4  #include&lt;cctype&gt;
   5 #include&lt;cwctype&gt;
   6
   7  using namespace std;
   8
   9  inline bool caseInsCharCompareN(char a, char b) {
   10 return(toupper(a) == toupper(b));
   11 }
   12
   13 inline bool caseInsCharCompareW(wchar_t a, wchar_t b) {
   14  return(towupper(a) == towupper(b));
   15 }
   16
   17 bool caseInsCompare(const string& s1, const string& s2) {
   18  return((s1.size() == s2.size())&&
   19   equal(s1.begin(), s1.end(), s2.begin(), caseInsCharCompareN));
   20 }
   21
   22 bool caseInsCompare(const wstring& s1, const wstring& s2) {
   23  return((s1.size() == s2.size())
   24  equal(s1.begin(), s1.end(), s2.begin(), caseInsCharCompareW));
   25 }
   26
   27 int main() {
   28  string s1 = "In the BEGINNING...";
   29  string s2 = "In the beginning...";
   30  wstring ws1 = L"The END";
   31  wstring ws2 = L"the end";
   32
   33  if (caseInsCompare(s1, s2))
   34   cout&lt;&lt; "Equal!\n";
   35
   36  if (caseInsCompare(ws1, ws2))
   37   cout&lt;&lt; "Equal!\n";
   38 }Обсуждение
   Критической частью сравнения строк без учета регистра является проверка равенства каждой соответствующей пары символов, так что давайте начнем обсуждение с него. Так как я в этом подходе использую стандартный алгоритмequal,но хочу использовать свой особый критерий сравнения, я должен создать отдельную функцию, выполняющую это сравнение.
   Строки 9-15 примера 4.21 определяют функции, которые выполняют сравнение —caseInsCharCompareNиcaseInsCharCompareW.Они для преобразования символов к верхнему регистру используютtoupperиtowupper,а затем сообщают, равны ли они.
   После написания этих функций сравнения настает время использовать стандартный алгоритм, выполняющий применение этих функций сравнения к произвольной последовательности символов. Именно это делают функцииcaseInsCompare,определенные в строках 17-25 и использующиеequal.Здесь сделано две перегрузки — по одной для каждого типа интересующих нас символов. Они обе делают одно и то же, но каждая использует для своего типа символов соответствующую функцию сравнения. Для этого примера я перегрузил две обычные функции, но этот же эффект может быть достигнут и с помощью шаблонов. Для пояснений обратитесь к врезке «Следует ли использовать шаблон?».
   equalсравнивает две последовательности на равенство. Имеется две версии: одна используетoperator==,а другая использует переданный ей функциональный объект двоичного предиката (т.е. такой, который принимает два аргумента и возвращаетbool).В примере 4.21caseInsCharCompareNиW— это функции двоичного предиката.
   Но это не всё, что требуется сделать; также требуется сравнить размеры. Рассмотрим объявлениеequal.
   template&lt;typename InputIterator1, typename InputIterator2,
    typename BinaryPredicate&gt;
   bool equal(InputIterator1 first, InputIterator1 last1,
    InputIterator2 first2, BinaryPredicate pred);
   Пустьn— это расстояние междуfirst1иlast1,или, другими словами, длина первого диапазона.equalвозвращаетtrue,если первыеnэлементов обеих последовательностей равны. Это означает, что если есть две последовательности, где первыеnэлементов равны, но вторая содержит больше чемnэлементов, тоequalвернетtrue.Чтобы избежать такой ошибки требуется проверять размер.
   Эту логику не обязательно инкапсулировать в функцию. Ваш или клиентский код может просто вызвать алгоритм напрямую, но проще запомнить и написать такое:
   if (caseInsCompare(s1, s2)) { //они равны, делаем что-нибудь
   чем такое:
   if ((s1.size() == s2.size())&&
   std::equal(s1.begin(), s1.end(s2.begin(), caseInsCharCompare&lt;char&gt;)) {
    // они равны, делаем что-нибудь
   когда требуется выполнить сравнение строк без учета регистра.
   4.14.Выполнение поиска строк без учета регистраПроблема
   Требуется найти в строке подстроку, не учитывая разницу в регистре.Решение
   Используйте стандартные алгоритмыtransformиsearch,определенные в&lt;algorithm&gt;,а также свои собственные функции сравнения символов, аналогичные уже показанным. Пример 4.22 показывает, как это делается.
   Пример 4.22. Поиск строк без учета регистра
   #include&lt;string&gt;
   #include&lt;iostream&gt;
   #include&lt;algorithm&gt;
   #include&lt;iterator&gt;
   #include&lt;cctype&gt;

   using namespace std;

   inline bool caseInsCharCompSingle(char a. char b) {
    return(toupper(a) == b);
   }

   string::const_iterator caseInsFind(string& s, const string& p) {
    string tmp;
    transform(p.begin( ), p.end(), // Преобразуем шаблон
     back_inserter(tmp),           // к верхнему регистру
     toupper);
    return(search(s.begin(), s.end(), // Возвращаем итератор.
     tmp.begin(), tmp.end(),          // возвращаемый из
     caseInsCharCompSingle));         // search
   }

   int main() {
    string s = "row, row, row, your boat";
    string p = "YOUR";
    string::const_iterator ir = caseInsFind(s, p);
    if (it != s.end()) {
     cout&lt;&lt; "Нашли!\n;
    }
   }
   Возвращая итератор, который указывает на элемент целевой строки, где начинается шаблонная строка, мы обеспечиваем совместимость с другими стандартными алгоритмами, так как большинство из них принимают в качестве аргумента итератор.Обсуждение
   Пример 4.22 демонстрирует обычный ход действий при работе со стандартными алгоритмами. Создайте функцию, которая выполняет работу, а затем подключите ее как объект функции к наиболее подходящему алгоритму. Здесь работу выполняет функцияcharInsCharCompSingle,но в отличие от примера 4.21 эта функция сравнения символов переводит к верхнему регистру толькопервыйаргумент. Это сделано потому, что немного далее вcaseInsFindя перед использованием строки шаблона в поиске преобразую ее к верхнему регистру полностью и тем самым избегаю многократного преобразования символов строки шаблона к верхнему регистру.
   После того как функция сравнения будет готова, используйте для поиска стандартные алгоритмыtransformиsearch.transformиспользуется для преобразования к верхнему регистру всего шаблона (но не целевой строки). После этого используйте для поиска места вхождения подстроки search совместно с функцией сравнения.
   Помните, что стандартные алгоритмы работают споследовательностями,а не со строками. Это общие алгоритмы, которые в основном (но не только) работают со стандартными контейнерами, но не делают никаких предположений о содержимом этихконтейнеров. Все стандартные алгоритмы требуют передачи им функции сравнения (а в случае их отсутствия используют операторы по умолчанию), которые тем или иным способом сравнивают два элемента и возвращаютbool,указывающий, дало ли сравнение истину или ложь.
   В примере 4.22 есть одна вещь, которая выглядит странно. Вы видите, чтоcaseInsCompareвозвращаетconst_iterator,как в
   string::const_iterator caseInsFind(const string& s,
    const string& p)
   Что, если требуется изменить элемент, на который указывает возвращенный итератор? Тому есть причина. Она состоит в том, что константный итератор используется потому, что строки, которые передаются вcaseInsFind,также передаются какconst,и, следовательно, невозможно получить не-constитератор наconst-строку. Если требуется итератор, который можно использовать для изменения строки, удалитеconstиз параметров и измените объявление функции так, чтобы она возвращалаstring::iterator.
   4.15.Преобразование между табуляциями и пробелами в текстовых файлахПроблема
   Имеется текстовый файл, содержащий табуляции или пробелы, и требуется преобразовать одни в другие. Например, может потребоваться заменить все табуляции на последовательности из трех пробелов или сделать наоборот и заменить все вхождения некоторого числа пробелов на табуляции.Решение
   Независимо от того, производится ли замена табуляций на пробелы или пробелов на табуляции, используйте классыifstreamиofstreamиз&lt;fstream&gt;.В первом (более простом) случае прочтите данные по одному символу с помощью входного потока, изучите их и, если очередной символ — это табуляция, запишите в выходной поток некоторое количество пробелов. Пример 4.23 демонстрирует, как это делается.
   Пример 4.23. Замена табуляций на пробелы
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;cstdlib&gt;

   using namespace std;

   int main(int argc, char** argv) {
    if (argc&lt; 3)
     return(EXIT_FAILURE);
    ifstream in(argv[1]);
    ofstream out(argv[2]);
    if (!in || !out) return(EXIT_FAILURE);
    char c;
    while (in.get(c)) {
     if (c == '\t')
      out&lt;&lt; " "; // 3пробела
     else
      out&lt;&lt; c;
    }
    out.close();
    if (out)
     return(EXIT_SUCCESS);
    else
     return(EXIT_FAILURE);
   }
   Если же требуется заменить пробелы на табуляции, обратитесь к примеру 4.24. Он содержит функциюspacesToTabs,которая читает из входного потока по одному символу, ища три последовательных пробела. Когда они найдены, она записывает в выходной поток табуляцию. Для всех остальных символов или меньшего количества пробелов в выходной поток записывается то, что было прочитано во входном.
   Пример 4.24. Замена пробелов на табуляции
   #include&lt;iostream&gt;
   #include&lt;istream&gt;
   #include&lt;ostream&gt;
   #include&lt;fstream&gt;
   #include&lt;cstdlib&gt;

   using namespace std;

   void spacesToTabs(istream& in, ostream& out, int spaceLimit) {
    int consecSpaces = 0;
    char c;
    while (in.get(c)) {
     if (c != ' ') {
      if (consecSpaces&gt; 0) {
       for (int i = 0; i&lt; consecSpaces; i++) {
        out.put(' ');
       }
       consecSpaces = 0;
      }
      out.put(c);
     } else {
      if (++consecSpaces == spaceLimit) {
       out.put('\t');
       consecSpaces = 0;
      }
     }
    }
   }

   int main(int argc, char** argv) {
    if (argc&lt; 3)
     return(EXIT_FAILURE);
    ifstream in(argv[1]);
    ofstream out(argv[2]);
    if (!in || !out)
     return(EXIT_FAILURE);
    spacesToTabs(in, out, 3);
    out.сlose();
    if (out)
     return(EXIT_SUCCESS);
    else
     return(EXIT_FAILURE);
   }Обсуждение
   Механизм обоих этих решений один и тот же, отличаются только алгоритмы. Символы читаются из входного потока с помощьюget,а в выходной поток помещаются с помощьюput.Логика, выполняющая преобразования, помещается между этими двумя функциями.
   Вы, вероятно, заметили в примере 4.24, что в функцииmain inиoutобъявлены как переменные типовifstreamиofstreamсоответственно и что параметрыspacesToTabs — этоistreamиostream.Это сделано для того, чтобы позволитьspacesToTabsработать с любыми типами входных и выходных потоков (ну, нелюбымитипами потоков, а теми, которые наследуются отbasic_istreamилиbasic_ostream),а не только с файловыми потоками. Например, текст, который требуется переформатировать, может находиться в строковом потоке (istringstreamиostringstreamиз&lt;sstream&gt;).В этом случае сделайте что-то похожее на следующее.
   istringstream istr;
   ostringstream ostr;
   //заполняем istr текстом...
   spacesToTabs(istr, ostr);
   Как и в случае со строками, потоки — это на самом деле шаблоны классов, параметризованные по типу символов, с которыми работает поток. Например,ifstream— этоtypedefдляbasic_ifstream&lt;char&gt;, awifstream— этоtypedefдляbasic_ifstream&lt;wchar_t&gt;.Таким образом, если требуется, чтобыspacesToTabsиз примеров 4.23 или 4.24 работала с потоками любых символов, то вместоtypedefиспользуйте эти шаблоны классов.
   template&lt;typename T&gt;
   void spacesToTabs(std::basic_istream&lt;T&gt;& in,
    std::basic_ostream&lt;T&gt;& out, int spaceLimit) { //...
   4.16.Перенос строк в текстовом файлеПроблема
   Требуется сделать перенос текста файла после определенного количества символов. Например, если требуется сделать перенос текста после 72 символов, то после каждого 72 символа файла требуется вставить символ новой строки. Если файл содержит текст, читаемый человеком, то, вероятно, потребуется избежать разделения слов.Решение
   Напишите функцию, которая использует входной и выходной потоки, читает символы с помощьюistream::get(char),выполняет какие-либо действия и записывает символы с помощьюostream::put(char).Пример 4.25 показывает, как это делается с файлом, который содержит обычный текст, с учетом сохранения целостности слов.
   Пример 4.25. Перенос текста
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;cstdlib&gt;
   #include&lt;string&gt;
   #include&lt;cctype&gt;
   #include&lt;functional&gt;

   using namespace std;

   void textWrap(istream& in, ostream& out, size_t width) {
    string tmp;
    char cur = '\0';
    char last = '\0';
    size_t i = 0;
    while (in.get(cur)) {
     if (++i == width) {
      ltrimws(tmp);       // ltrim как в рецепте
      out&lt;&lt; '\n'&lt;&lt; tmp; // 4.1
      i = tmp.length();
      tmp.clear();
     } else if (isspace(cur)&& //Это конец
      !isspace(last)) {         // слова
      out&lt;&lt; tmp;
      tmp.clear();
     }
     tmp += cur;
     last = cur;
    }
   }

   int main(int argc, char** argv) {
    if (argc&lt; 3)
     return(EXIT_FAILURE);
    int w = 72;
    ifstream in(argv[1]);
    ofstream out(argv[2]);
    if (!in || !out)
     return(EXIT_FAILURE);
    if (argc == 4) w = atoi(argv[3]);
    textWrap(in, out, w);
    out.close();
    if (out)
     return(EXIT_SUCCESS);
    else
     return(EXIT_FAILURE);
   }Обсуждение
   textWrapчитает по одному символы из входного потока. Каждый символ добавляется к временной строкеtmpдо тех пор, пока не будет достигнут конец слов или максимальная длина строки. Если достигнут конец слова, а максимальная длина строки еще не достигнута, то временная строка записывается в выходной поток. В противном случае, если максимальная длина строки была превышена, в выходной поток записывается новая строка, пробел в начале временной строки удаляется, и строка записывается в выходной поток. Таким образом,textWrapзаписывает в выходной поток столько, сколько можно, но не превышая максимальной длины строки. Вместо разделения слов она переносит все слово на новую строку.
   Пример 4.25 использует потоки почти так же, как и рецепт 4.15. За дополнительной информацией о потоках и их использовании обратитесь к этому рецепту.Смотри также
   Рецепт 4.15.
   4.17.Подсчет числа символов, слов и строк в текстовом файлеПроблема
   Требуется подсчитать число символов, слов и строк — или каких-либо других элементов текста — в текстовом файле.Решение
   Для чтения символов по одному используйте входной поток и по мере чтения символов, слов и строк увеличивайте счетчики. Пример 4.26 содержит функциюcountStuff,которая именно это и делает.
   Пример 4.26. Подсчет статистики по текстовому файлу
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;cstdlib&gt;
   #include&lt;cctype&gt;

   using namespace std;

   void countStuff(istream& in,
    int& chars, int& words, int& lines) {
    char cur = '\0';
    char last = '\0';
    chars = words = lines = 0;
    while (in.get(cur)) {
     if (cur == '\n' ||
      (cur == '\f'&& last == '\r'))
      lines++;
     else chars++;
     if (!std::isalnum(cur)&& //Это конец
      std::isalnum(last))      // слова
      words++;
     last = cur;
    }
    if (chars&gt; 0) {         // Изменить значения слов
     if (std::isalnum(last)) // и строк для специального
      words++;               // случая
     lines++;
    }
   }

   int main(int argc, char** argv) {
    if (argc&lt; 2)
     return(EXIT _FAILURE);
    ifstream in(argv[1]);
    if (!in)
     exit(EXIT_FAILURE);
    int c, w, l;
    countStuff(in, c, w, l);
    cout&lt;&lt; "символов: "&lt;&lt; c&lt;&lt; '\n';
    cout&lt;&lt; "слов: "&lt;&lt; w&lt;&lt; '\n';
    cout&lt;&lt; "строк: "&lt;&lt; l&lt;&lt; '\n';
   }Обсуждение
   Этот алгоритм очень прост. С символами все просто: увеличивайте счетчик символов при каждом вызовеgetдля входного потока. Со строками все не намного сложнее, так как способ представления концов строк зависит от операционной системы. К счастью, обычно это либо символ новой строки (\n),либо последовательность из символов возврата каретки и перевода строки (\r\n).Отслеживая текущий и предыдущий символы, можно легко обнаружить вхождения этой последовательности. Со словами все проще или сложнее, в зависимости от определениятого, что такое «слово».
   Для примера 4.26 я предположил, что слово это неразрывная последовательность буквенно-цифровых символов. В процессе просмотра каждого символа входного потока при обнаружении неалфавитно-цифрового символа я проверяю предыдущий символ — был ли он буквенно-цифровым или нет. Если был то это конец слова, и я увеличиваю счетчик слов. Определить, является ли символ буквенно-цифровым, можно с помощью функцииisalnumиз&lt;cctype&gt;.Но это еще не все — с помощью аналогичных функций можно проверять символы на целый ряд других качеств. Функции, которые предназначены для проверки характеристик символов, приведены в табл. 4.3. Для широких символов используйте функции с такими же именами, но с буквой «w» после «is», напримерiswSpace.Версии для широких символов объявлены в заголовочном файле&lt;cwctype&gt;.

   Табл. 4.3. Функции для проверки символов из&lt;cctype&gt;и&lt;cwctype&gt;ФункцияОписаниеisalpha iswalphaБуквенные символы: a-z, A-Z (верхний или нижний регистр)isupper iswupperБуквенные символы верхнего регистра: A-Zislower iswlowerБуквенные символы нижнего регистра: a-zisdigit iswdigitЧисловые символы: 0-9isxdigit iswxdigitШестнадцатеричные числовые символы: 0-9, a-f, A-Fisspace iswspaceПробельные символы. ' ', \n, \t, \v, \r, \liscntrl iswcntrlУправляющие символы: ASCII 0-31 и 127ispunct iswpunctСимволы пунктуации, не принадлежащие предыдущим группамisalnum iswalnumisalphaилиisdigitравны trueisprint iswprintПечатаемые символы ASCIIisgraph iswgraphisalpha,isdigitилиispunctравны true
   После того как были прочтены все символы и достигнут конец файла, требуется сделать еще кое-что. Во-первых, строго говоря, цикл подсчитывает только переносы строк, а не сами строки. Следовательно, это значение будет на одну меньше, чем реальное число строк. Чтобы решить эту проблему, я, если файл содержит ненулевое число символов, просто увеличиваю счетчик строк на единицу. Во-вторых, если поток заканчивается на буквенно-цифровой символ, то поиск конца последнего слова не сработает, так какне будет следующего символа. Чтобы учесть это, я проверяю, является ли последний символ потока буквенно-цифровым (также только в том случае, если в файле содержитсяненулевое число символов), и увеличиваю счетчик слов на единицу.
   Методика использования потоков в примере 4.26 почти идентична той, которая описана в рецептах 4.14 и 4.15, но несколько проще, так как он только исследует файл, не внося никаких изменений.Смотри также
   Рецепты 4.14 и 4.15.
   4.18.Подсчет вхождений каждого слова в текстовом файлеПроблема
   Требуется подсчитать количество вхождений в текстовом файле каждого слова.Решение
   Для чтения из текстового файла непрерывных фрагментов текста используйтеoperator&gt;&gt;,определенный в&lt;string&gt;,а для сохранения каждого слова и его частоты в файле используйтеmap,определенный в&lt;map&gt;.Пример 4.27 демонстрирует, как это делается.
   Пример 4.27. Подсчет частоты слов
   1  #include&lt;iostream&gt;
   2  #include&lt;fstream&gt;
   3  #include&lt;map&gt;
   4  #include&lt;string&gt;
   5
   6  typedef std::map&lt;std::string, int&gt; StrIntMap;
   7
   8  void countWords(std::istream& in, StrIntMap& words) {
   9
   10  std::string s;
   11
   12  while (in&gt;&gt; s) {
   13   ++words[s];
   14  }
   15 }
   16
   17 int main(int argc, char** argv) {
   18
   19  if (argc&lt; 2)
   20   return(EXIT_FAILURE);
   21
   22  std::ifstream in(argv[1]);
   23
   24  if (!in)
   25   exit(EXIT_FAILURE);
   26
   27  StrIntMap w;
   28  countWords(in, w);
   29
   30  for (StrIntMap::iterator p = w.begin();
   31   p != w.end(); ++p) {
   32   std::cout&lt;&lt; p-&gt;first&lt;&lt; "присутствует "
   33   &lt;&lt; p-&gt;second&lt;&lt; "раз.\n";
   34  }
   35 }Обсуждение
   Пример 4.27 кажется вполне простым, но в нем делается больше, чем кажется. Большая часть тонкостей связана сmap,так что вначале давайте обсудим его.
   Если вы не знакомы сmap,то вам стоит узнать про него,map — это шаблон класса контейнера, который является частью STL. Он хранит пары ключ-значение в порядке, определяемомstd::lessили вашей собственной функцией сравнения. Типы ключей и значений, которые можно хранить в нем, зависят только от вашего воображения. В этом примере мы просто сохраняемstringиint.
   В строке 6 я для упрощения читаемости кода использовалtypedef.
   typedef map&lt;string, int&gt; StrIntMap;
   Таким образом,StrIntMap— этоmap,который хранит пары string/int. Каждаяstring— это уникальное слово именно по этой причине я использую ее как ключ, — которое было прочитано из входного потока, а связанное с нейint— это число раз, которое это слово встретилось. Все, что осталось, — это прочитать все слова по одному, добавить их в map, если их там еще нет, и увеличить значение счетчика, если они там уже есть.
   Это делаетcountWords.Основная логика кратка.
   while (in&gt;&gt; s) {
    ++words[s];
   }
   operator&gt;&gt;читает из левого операнда (istream)непрерывные отрезки, не содержащие пробелов, и помещает их в правый операнд (string).После прочтения слова все, что требуется сделать, — это обновить статистику вmap,и это делается в следующей строке.
   ++words[s];
   mapопределяетoperator[],позволяющий получить значение данного ключа (на самом деле он возвращает ссылку на само значение), так что для его инкремента просто инкрементируется значение, индексируемое с помощью заданного ключа. Но здесь могут возникнуть небольшие осложнения. Что, если ключа в map еще нет? Разве мы не попытаемся увеличить несуществующий элемент, и не обрушится ли программа, как в случае с обычным массивом? Нет,mapопределяетoperator[]не так, как другие контейнеры STL или обычные массивы.
   Вmap operator[]делает две вещи: если ключ еще не существует, он создает значение, используя конструктор типа значения по умолчанию, и добавляет вmapэту новую пару ключ/значение, а если ключ уже существует, то никаких изменений не вносится. В обоих случаях возвращается ссылка на значение, определяемое ключом, даже если это значение было только что создано конструктором по умолчанию. Это удобная возможность (если вы знаете о ее существовании), так как он устраняет необходимость проверки в клиентском коде существования ключа перед его добавлением.
   Теперь посмотрите на строки 32 и 33. Итератор указывает на члены, которые называютсяfirstиsecond— что это такое?mapобманывает вас, используя для хранения пар имя/значение другой шаблон класса: шаблон классаpair,определенный в&lt;utility&gt; (уже включенный в&lt;map&gt;).При переборе элементов, хранящихся вmap,вы получите ссылки на объектыpair.Работа сpairпроста. Первый элемент пары хранится в элементеfirst,а второй хранится, естественно, вsecond.
   В примере 4.27 я для чтения из входного потока непрерывных фрагментов текста используюoperator&gt;&gt;,что отличается от некоторых других примеров. Я делаю это для демонстрации того, как это делается, но вам почти наверняка потребуется изменить его поведение в зависимости от определения «слова» текстового файла. Например, рассмотрим фрагмент вывода, генерируемого примером 4.27.
   withприсутствует 5 раз.
   workприсутствует 3 раз.
   workersприсутствует 3 раз.
   workers,присутствует 1 раз.
   yearsприсутствует 2 раз.
   years,присутствует 1 раз.
   Обратите внимание, что точки в конце слов рассматриваются как части слов. Скорее всего, вам потребуется с помощью функций проверки символов из&lt;cctype&gt;и&lt;cwctype&gt;изменить определение слова так, чтобы оно означало только буквенно-цифровые символы, как это сделано в рецепте 4.17.Смотри также
   Рецепт 4.17 и табл. 4.3.
   4.19.Добавление полей в текстовый файлПроблема
   Имеется текстовый файл, и в нем требуется сделать поля. Другими словами, требуется сдвинуть обе стороны каждой строки, содержащей какие-либо символы, так, чтобы длина всех строк стала одинаковой.Решение
   Пример 4.28 показывает, как добавить в файл поля с помощью потоков,stringи шаблона функцииgetline.
   Пример 4.28. Добавление полей в текстовый файл
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;string&gt;
   #include&lt;cstdlib&gt;

   using namespace std;

   const static char PAD_CHAR = '.';

   // addMarginsпринимает два потока и два числа. Потоки используются для
   //ввода и вывода. Первое из двух чисел представляет
   //ширину левого поля (т.е. число пробелов, вставляемых в
   //начале каждой строки файла). Второе число представляет
   //общую ширину строки.
   void addMargins(istream& in, ostream& out,
    int left, int right) {
    string tmp;
    while (!in.eof()) {
     getline(in, tmp, '\n'); // getline определена
                             // в&lt;string&gt;
     tmp.insert(tmp.begin(), left, PAD_CHAR);
     rpad(tmp, right, PAD_CHAR); // rpad из рецепта
                                 // 4.2
     out&lt;&lt; tmp&lt;&lt; '\n';
    }
   }

   int main(int argc, char** argv) {
    if (argc&lt; 3)
     return(EXIT_FAILURE);
    ifstream in(argv[1]);
    ofstream out(argv[2]);
    if (!in || !out)
     return(EXIT_FAILURE);
    int left = 8;
    int right = 72;
    if (argc == 5) {
     left = atoi(argv[3]);
     right = atoi(argv[4]);
    }
    addMargins(in, out, left, right);
    out.close();
    if (out)
     return(EXIT_SUCCESS);
    else
     return(EXIT_FAILURE);
   }
   Этот пример делает несколько предположений о формате входного текста, так что внимательно прочтите следующий раздел.Обсуждение
   addMarginsпредполагает, что ввод выглядит примерно так.
   The data is still inconclusive. But the weakness
   in job creation and the apparent weakness in
   high-paying jobs may be opposite sides of a coin.
   Companies still seem cautious, relying on
   temporary workers and anxious about rising health
   care costs associated with full-time workers
   Этот текст содержит переносы в позиции 50 символов (см. рецепт 4.16) и выровнен по левому краю (см. рецепт 4.20).addMarginsтакже предполагает, что требуется, чтобы вывод выглядел подобно следующему, который использует для обозначения полей вместо пробелов точки.
   .......The data is still inconclusive. But the weakness..............
   .......in job creation and the apparent weakness in..................
   .......high-paying jobs may be opposite sides of a coin..............
   .......Companies still seem cautious, relying on.....................
   .......temporary workers and anxious about rising health.............
   .......care costs associated with full-time workers..................
   По умолчанию левое поле содержит восемь символов, а общая длина строки составляет 72 символа. Конечно, если известно, что входной текст будет всегда выровнен по левому или правому краю, то можно просто дополнить оба конца каждой строки таким количеством символов, которое требуется. В любом случае логика очень проста. Многие методики, используемые в этом рецепте, уже описывались (потоки, дополнениеstring),так что я не буду здесь на них останавливаться. Единственная новая функция здесь — этоgetline.
   Если требуется прочитать сразу целую строку текста или, более точно, прочитать текст до определенного разделителя, используйте шаблон функцииgetline,определенный в&lt;string&gt;,как это сделано в примере 4.28.
   getline(in, tmp, '\n');
   getlineчитает символы из входного потока и добавляет их вtmpдо тех пор, пока не встретится разделитель'\n',который вtmpне добавляется.basic_istreamсодержит метод с таким же именем, но с другим поведением. Он сохраняет свой вывод в символьном буфере, а не вstring.В данном случае я решил использовать преимущества метода изstring,так как мне не хотелось читать строку в символьный буфер, а затем копировать ее вstring.Таким образом, я использовалgetlineв версииstring.Смотри также
   Рецепты 4.16 и 4.20.
   4.20.Выравнивание текста в текстовом файлеПроблема
   Требуется выровнять текст по правому или левому краю.Решение
   Используйте потоки и стандартные флаги форматирования потоковrightиleft,являющиеся частьюios_base,определенного в&lt;ios&gt;.Пример 4.29 показывает, как они работают.
   Пример 4.29. Выравнивание текста
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;string&gt;
   #include&lt;cstdlib&gt;

   using namespace std;

   int main(int argc, char** argv) {
    if (argc&lt; 3)
     return(EXIT_FAILURE);
    ifstream in(argv[1]);
    ofstream out(argv[2]);
    int w = 72;
    if (argc == 4)
     w = atoi(argv[3]);
    string tmp;
    out.setf(ios_base::right); // Указать потоку на
                               // выравнивание по правому краю
    while (!in.eof()) {
     out.width(w);           // Сбросить ширину после
     getline(in, tmp, "\n"); // каждой записи
     out&lt;&lt; tmp&lt;&lt; '\n';
    }
    out.close();
   }
   Этот пример принимает три аргумента: входной файл, выходной файл и ширину выровненного по правому краю текста. Входной файл может иметь следующий вид.
   With automatic download of Microsoft's (Nasdaq:
   MSFT) enormous SP2 security patch to the Windows
   XP operating system set to begin the industry
   still waits to understand its ramifications. Home
   users that have their preferences set to receive
   operating system updates as they are made
   available by Microsoft may be surprised to learn
   that some of the software they already run on
   their systems could be disabled by SP2 or may run
   very differently.
   Вывод будет иметь следующий вид.
      With automatic download of Microsoft's (Nasdaq:
     MSFT) enormous SP2 security patch to the Windows
        XP operating system set to begin the industry
    still waits to understand its ramifications. Home
     users that have their preferences set to receive
            operating system updates as they are made
     available by Microsoft may be surprised to learn
        that some of the software they already run on
    their systems could be disabled by SP2 or may run
                                    very differently.
   Второй пример текста выровнен по правому краю и имеет в ширину 50 символов.Обсуждение
   Шаблон классаios_baseсодержит большое количество флагов форматирования числовых и текстовых данных, читаемых из потоков или записываемых в них. Два флага, управляющих выравниванием текста, — этоrightиleft.Они являютсяstatic const-членамиios_baseи имеют типfmtflags (который зависит от реализации). Все это хозяйство определено в&lt;ios&gt;.
   Чтобы установить флаги форматирования, используйтеios_base::setf.Она объединяет переданные в нее и уже установленные ранее флаги потока с помощью операции OR (ИЛИ). Например, эта строка включает выравнивание по правому краю:
   out.setf(std::ios_base::right);
   Но выравнивание по правому краю не имеет смысла без установки правого поля, по которому требуется выравнивать. Чтобы установить это поле, используйтеios_base::width,как здесь.
   out.width(w);
   Этот код устанавливает ширину выходного поля для передаваемого значения, что означает, что при выравнивании текста по правому краю начало строки будет дополняться пробелами так, чтобы ее правый край достиг правого поля. Заметьте, что ширину я задаю в цикле, в то время как флагrightя выставляю перед ним. Это требуется делать потому, что после каждой записи в поток ширина сбрасывается в ноль. Флаги форматирования после записи не сбрасываются, так что их можно указать только один раз.
   Однако всегда следует быть аккуратным и точным, так что при использовании флагов форматирования требуется сделать еще одну вещь: убрать их за собой.
   Часто потоки, в которые производится запись, не принадлежат записывающему коду, особенно при написании библиотеки или API общего назначения. Например, если написать функцию журналирования, которая принимает выходной поток иstring,изменяетstring,устанавливает флаги форматирования и записываетstringв поток, то могут возникнуть нежелательные побочные эффекты. После того как клиентский код вызывает эту функцию журналирования, его поток содержит другой набор флагов форматирования. Решением является копирование старых флагов и восстановление их по окончании работы.
   Например, функция журналирования ошибок может выглядеть вот так.
   using namespace std;

   void logFrror(ostream& out, const string& s) {
    string tmp(s);
    tmp.insert(0, "ERROR: ");
    ios_base::fmtflags figs =  // setf возвращает
     out.setf(ios_base::left); // флаги, которые уже
                               // были установлены
    out.width(72);
    out&lt;&lt; tmp&lt;&lt; '\n';
    out.flags(flgs); // вернуть оригинальные
   }
   Методflagsработает аналогичноsetf,но не объединяет с помощью OR переданные ему флаги с уже установленными, а заменяет их. Таким образом, при вызовеflagsи передаче ему оригинальных флагов форматирования можно быть уверенным, что флаги будут восстановлены.
   4.21.Замена в текстовом файле последовательностей пробелов на один пробелПроблема
   Имеется текстовый файл с последовательностями пробелов различной длины и требуется заменить каждое вхождение такой последовательности на единственный пробел.Решение
   Для чтения непрерывной последовательности непробельных символов из потока в строку используйте шаблон функцииoperator&gt;&gt;,определенный в&lt;string&gt;.Затем используйте его двойникаoperator&lt;&lt;,который записывает каждую из этих последовательностей в выходной поток, и после каждой из них добавьте по одному пробелу. Пример 4.30 дает краткий пример этой методики.
   Пример 4 30. Замена последовательностей пробелов на один пробел
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;string&gt;

   using namespace std;

   int main(int argc, char** argv) {
    if (argc&lt; 3)
     return(EXIT_FAILURE);
    ifstream in(argv[1]);
    ofstream out(argv[2]);
    if (!in || !out)
     return(EXIT_FAILURE);
    string tmp;
    in&gt;&gt; tmp;  // Прочитать первое слове
    out&lt;&lt; tmp; //Записать его в выходной поток
    while (in&gt;&gt; tmp) { // operator&gt;&gt;игнорирует пробелы, так что все, что
     out&lt;&lt; ' ';        // я должен сделать, - это записать пробел и каждую
     out&lt;&lt; tmp;        // последовательность «непробелов»
    }
    out.close();
   }Обсуждение
   Это просто сделать, если использовать потоки и строки. Даже если требуется реализовать другой вариант этого — например, чтобы сохранить переходы на новую строку, — эта методика будет работать. Если требуется добавить переходы на новые строки, для их расстановки в нужных местах используйте решение, представленное в рецепте 4.16.Смотри также
   Рецепты 4.15 и 4.16.
   4.22.Автозамена текста при изменении буфераПроблема
   Имеется класс, который представляет некий тип текстового поля или документа, и по мере добавления в него текста требуется автоматически корректировать неправильно написанные слова, как это делает функция Autocorrect (Автозамена) в Microsoft Word.Решение
   Это можно реализовать в относительно небольшом коде, если использоватьmap,который определен в&lt;map&gt;,stringи различные возможности стандартной библиотеки. Пример 4.31 показывает, как это делается.
   Пример 4.31. Автозамена текста
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;cctype&gt;
   #include&lt;map&gt;

   using namespace std;

   typedef map&lt;string, string&gt; StrStrMap;

   //Класс для хранения текстовых полей
   class TextAutoField {
   public:
    TextAutoField(StrStrMap* const p) : pDict_(p) {}
    ~TextAutoField() {}
    void append(char c);
    void getText(string& s) {s = buf_;}
   private:
    TextAutoField();
    string buf_;
    StrStrMap* const pDict ;
   };

   //Добавление с автозаменой
   void TextAutoField::append(char c) {
    if ((isspace(c) || ispunct(c))&&     // Выполнять автоза-
     buf_.length()&gt; 0&&                 // мену, только когда вводятся
     !isspace(buf_[buf_.length() - 1])) { // ws или punct
     string::size_type i = buf_.find_last_of(" \f\n\r\t\v");
     i = (i == string::npos) ? 0 : ++i;
     string tmp = buf_.substr(i, buf_.length() - i);
     StrStrMap::const_iterator p = DDict_-&gt;find(tmp);
     if (p != pDict_-&gt;end()) {          // Нашли, так что стираем
      buf_.erase(i, buf_.length() - i); // и заменяем
      buf_ += p-&gt;second;
     }
    }
    buf_ += с;
   }

   int main() {
    // Создаем map
    StrStrMap dict;
    TextAutoField txt(&dict);
    dict["taht"] = "that";
    dict["right"] = "wrong";
    dict["bug"] = "feature";
    string tmp = "He's right, taht's a bug.";
    cout&lt;&lt; "Оригинальная версия: "&lt;&lt; tmp&lt;&lt; '\n';
    for (string::iterator p = tmp.begin(); p != tmp.end(); ++p) {
     txt.append(*p);
    }
    txt.getText(tmp);
    cout&lt;&lt; "Исправленная версия. "&lt;&lt; tmp&lt;&lt; '\n';
   }
   Вывод примера 3.2 таков.
   Оригинальная версия: He's right, taht's a bug.
   Исправленная версия: He's wrong, that's a feature.Обсуждение
   stringиmapудобны в ситуациях, когда требуется отслеживать ассоциацииstring.TextAutoField— это простой текстовый буфер, использующийstringдля хранения данных. ИнтереснойTextAutoFieldделает ее методappend,который «слушает» пробелы или знаки пунктуации и при их появлении выполняет обработку.
   Чтобы сделать автозамену работающей, требуется две вещи. Во-первых, требуется некий словарь, который содержит неправильно написанные варианты слов и связанные с ними правильные написания, map хранит пары ключ/значение, где ключ и значение могут быть любого типа, так что он является идеальным кандидатом на эту роль. В начале примера 4.31 имеетсяtypedefдля парstring:
   typedef map&lt;string, string&gt; StrStrMap;
   За более подробным описанием map обратитесь к рецепту 4.18.TextAutoFieldхранит указатель наmap,так как, вероятнее всего, для всех полей потребуется только один общий словарь.
   Предполагая, что клиентский код помещает вmapчто-то осмысленное,appendпросто должен периодически проверятьtrap.В примере 4.31appendждет появления пробела или знака пунктуации. Для проверки на пробел можно использоватьisspace,а для поиска знаков пунктуации можно использовать ispunct. Обе эти функции для узких символов определены в&lt;cctype&gt; (см. табл. 4.3).
   Если вы не знакомы с использованием итераторов и методов поиска в контейнерах STL, то код, который выполняет проверку, требует некоторых пояснений,string tmpсодержит последний фрагмент текста, который был добавлен вTextAutoField.Чтобы увидеть, был ли он написан с ошибками, поищите его в словаре вот так.
   StrStrMap::iterator p = pDict-&gt;find(tmp);
   if (p != pDict_-&gt;end()) {
   Здесь важно то, чтоmap::findв случае успеха поиска возвращает итератор, который указывает на пару, содержащую соответствующий ключ. Если поиск не дал результатов, то возвращается итератор, указывающий на область памяти после последнего элементаmap,на который указываетmap::end (именно так работают контейнеры STL, поддерживающиеfind).Если слово вmapнайдено, стираем из буфера старое слово и заменяем его правильной версией.
   buf_.erase(i, buf_.length() - i);
   buf_ += p-&gt;second;
   Добавьте символ, который инициировал весь процесс (либо пробел, либо знак пунктуации), и все.Смотри также
   Рецепты 4.17, 4.18 и табл. 4.3.
   4.23.Чтение текстового файла с разделителями-запятымиПроблема
   Требуется прочитать текстовый файл, чье содержимое разделено запятыми и новыми строками (или любой другой парой разделителей). Записи разделяются одним символом, а поля записи разделяются другим символом. Например, текстовый файл с разделителями-запятыми, содержащий информацию о сотрудниках, может выглядеть вот так.
   Smith, Bill, 5/1/2002, Active
   Stanford, John, 4/5/1999, Inactive
   Такие файлы обычно временно хранят наборы данных, экспортируемые из электронных таблиц, баз данных или других форматов файлов.Решение
   Пример 4.32 демонстрирует, как это делается. Если читать текст вstringнепрерывными кусками с помощьюgetline (шаблон функции определен в&lt;string&gt;),то для анализа текста и создания структуры данных можно использовать функциюsplit,которая была представлена в рецепте 4.6.
   Пример 4.32. Чтение файла с разделителями
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;

   using namespace std;

   void split(const string& s, char c, vector&lt;string&gt;& v) {
    int i = 0;
    int j = s.find(c);
    while (j&gt;= 0) {
     v.push_back(s.substr(i, j-i));
     i = ++j;
     j = s.find(c, j);
     if (j&lt; 0) {
      v.push_back(s.substr(i, s.length()));
     }
    }
   }

   void loadCSV(istream& in, vector&lt;vector&lt;string&gt;*&gt;& data) {
    vector&lt;string&gt;* p = NULL;
    string tmp;
    while (!in.eof()) {
     getline(in, tmp, '\n'); // Получить следующую строку
     p = new vector&lt;string&gt;();
     split(tmp, '.', *p); // Использовать split из
                          // Рецепта 4.7
     data.push_back(p);
     cout&lt;&lt; tmp&lt;&lt; '\n';
     tmp.clear();
    }
   }

   int main(int argc, char** argv) {
    if (argc&lt; 2)
     return(EXIT_FAILURE);
    ifstream in(argv[1]);
    if (!in)
     return(EXIT_FAILURE);
    vector&lt;vector&lt;string&gt;*&gt; data;
    loadCSV(in, data);
    // Выполнить с данными какие-либо действия...
    for (vector&lt;vector&lt;string&gt;*&gt;::iterator p = data.begin();
     p != data end(); ++p) {
     delete *p; // Убедитесь, что p
    }           // разыменован!
   }Обсуждение
   В примере 4.32 почти нет ничего, что еще не было бы описано,getlineобсуждается в рецепте 4.19, avector— в рецепте 4.3. Единственный фрагмент, заслуживающий упоминания, — это выделение памяти.
   loadCSVсоздает новыйvectorдля каждой прочитанной строки данных и сохраняет его в другом vector, состоящем из указателей наvector.Так как память для каждого из этих векторов выделяется из кучи, кто-то должен удалить ее, и этот кто-то — это вы (а не реализацияvector).
   vectorничего не знает о том, содержит ли он значение или указатель на значение или что-либо еще. Все, что он знает, — это то, что при его удалении он должен вызвать деструктор для каждого содержащегося в нем элемента. Еслиvectorхранит объекты, то все нормально, объект будет удален правильно. Но еслиvectorсодержит указатели, то удалены будут указатели, а не объекты, на которые они указывают.
   Есть два способа гарантировать освобождение памяти. Первый заключается в том, что сделано в примере 4.32 вручную, как здесь.
   for (vector&lt;vector&lt;string&gt;*&gt;::iterator p = data.begin();
    p != data.end(); ++p) {
    delete *p;
   }
   Либо можно использовать указатель со счетчиком ссылок, такой какsmart_ptrиз проекта Boost, который станет частью будущего стандарта C++0x. Но реализация этого нетривиальна, так что я рекомендую почитать, что такоеsmart_ptrи как он работает. Для получения дополнительной информации по Boost посетите его домашнюю страницу по адресуwww.boost.org.
   4.24.Использование регулярных выражений для разделения строкиПроблема
   Требуется разделить строку на лексемы, но необходимо выполнить более сложный поиск, чем показано в рецепте 4.7. Например, могут потребоваться лексемы, разделенные более чем одним символом или имеющие несколько различных форм. Это часто приводит к большому коду и путанице среди пользователей вашего класса или функции.Решение
   Используйте шаблон классаregex Boost.regexпозволяет использовать для строк и текстовых данных регулярные выражения. Пример 4.33 показывает, как использоватьregexдля разделения строк.
   Пример 4.33. Использование регулярных выражений Boost
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;boost/regex.hpp&gt;

   int main() {
    std::string s = "who,lives-in-a,pineapple under the sea?";
    boost::regex re(',|:|-|\\s+"); // Создаем регулярное выражение
    boost::sregex_token_iterator   // Создаем итератор, используя
    p(s.begin(), s.end(), re, -1), // последовательность и это выражение
     boost::sregex_token_iterator end; // Создаем маркер
                                       // «конец-рег-выражения»
    while (p != end)
     std::cout&lt;&lt; *p++&lt;&lt; '\n';
   }Обсуждение
   Пример 4.33 показывает, как использоватьregexдля перебора соответствий регулярному выражению. Следующая строка создает регулярное выражение.
   boost::regex re(' ,|:| -|\\s+");
   Она гласит, что каждое соответствие регулярному выражению — это либо запятая, либо двоеточие, либо тире, либо один или несколько пробелов. Символ канала — это логический оператор OR, используемый для объединения разделителей. Следующие две строки создают итератор.
   boost::sregex_token_iterator
   p(s.begin(), s.end(), re, -1);
   boost::sregex_token_iterator end;
   Итераторpсоздается с помощью регулярного выражения и входной строки. После его созданияpможно рассматривать как итератор для последовательности из стандартной библиотеки,sregex_token_iteratorсоздается без аргументов и является специальным значением, представляющим конец последовательности лексем регулярного выражения, и, следовательно, может использоваться для проверки достижения конца.
   Глава 5
   Даты и время
   5.0.Введение
   Даты и время являются удивительно обширным и сложным вопросом. Как отражение этого факта, стандартная библиотека C++ не предоставляет подходящего типа данных для дат. C++ наследует структуры и функции для работы с датами и временем, а также пару функций ввода и вывода дат/времени с учетом локализации, от С. Однако решение можно найти в библиотеке date_time Library из состава Boost, написанной Джеффом Гарландом (Jeff Garland), которая является, по всей видимости, наиболее полной и всеобъемлющей из имеющихся библиотек для работы с датами и временем в С++. В некоторых рецептах я буду использовать именно ее. Сообщество C++ ожидает, что будущие расширения стандартной библиотеки в части работы с датами/временем будут основаны на библиотеке Boost date_time.
   Библиотека Boost date_time включает две отдельные системы для работы с датами и временем: одна для работы со временем, и вторая для работы с датами, относящимися к григорианскому календарю. Рецепты описывают обе эти системы.
   За дополнительной информацией о датах и времени, в частности об их чтении и записи, обратитесь к главе 13.
   5.1.Получение текущей даты и времениПроблема
   Требуется получить от пользователя компьютера текущую дату и время — либо в формате локального времени, либо в формате универсального глобального времени (CoordinatedUniversal Time (UTC).Григорианский календарь и високосные годы
   Григорианский календарь — это наиболее широко используемый сегодня в западном мире календарь. Григорианской календарь создавался с целью исправить ошибку в юлианском календаре. Медленный процесс адаптации григорианского календаря начался в 1582 году.
   Юлианский календарь говорит, что каждый четвертый год — это високосный год, но каждый сотый год — не високосный. Григорианской календарь ввел еще одно исключение— каждый 400-й год должен быть високосным.
   Високосные годы предназначены для компенсации несинхронности вращения Земли вокруг Солнца и продолжительности дня. Другими словами, частное отделения продолжительности солнечного года на длительность дня — это не целое число. В результате если календарь не корректировать, то мы получим смещение сезонов, когда равноденствия и солнцестояния (которые определяют сезоны) будут все более и более рассинхронизированы с каждым новым годом.Решение
   Вызовите функциюtimeиз заголовочного файла&lt;ctime&gt;,передав в качестве параметра значение 0. Результатом будет значение типаtime_t.Для преобразования значенияtime_tв структуруtm,представляющую текущее время UTC (также известное как Greenwich Mean Time (время по Гринвичу), или GMT), используется функцияgmtime,а для преобразования значенияtime_tв структуруtm,представляющую локальное время, используется функцияlocaltime.Программа в примере 5.1 получает текущие дату/время, а затем преобразует их в локальное время и выводит на экран. Затем программа преобразует текущие дату/время во время/дату UTC и также выводит результат на экран.
   Пример 5.1. Получение локального времени и времени UTC
   #include&lt;iostream&gt;
   #include&lt;ctime&gt;
   #include&lt;cstdlib&gt;

   using namespace std;

   int main() {
    // Текущие дата/время используемой системы
    time_t now = time(0);
    // Преобразуем в структуру tm для локальной временной зоны
    tm* localtm = localtime(&now);
    cout&lt;&lt; "Локальные дата и время. "&lt;&lt; asctime(localtm)&lt;&lt; endl;
    // Преобразуем в структуру tm для UTC
    tm* gmtm = gmtime(&now);
    if (gmtm ! = NULL) {
     cout&lt;&lt; "Дата и время UTC: "&lt;&lt; asctime(gmtm)&lt;&lt; endl;
    } else {
     cerr&lt;&lt; "Невозможно получить дату и время UTC"&lt;&lt; endl;
     return EXIT_FAILURE;
    }
   }Обсуждение
   Функцияtimeвозвращает типtime_t,который является зависящим от реализации арифметическим типом, представляющим временной период (интервал времени) с точностью до одной секунды. Наибольший интервал времени, который можно представить с помощьюtime_t,сохранив совместимость и переносимость кода, — это 2 147 483 648 секунд, или примерно 68 лет.
   Вызовtime(0)возвращаетtime_t,представляющее временной интервал от зависящего от реализации начала отсчета (обычно 0:00:00 1 января 1970 года) до текущего момента.Ошибка 2038 года
   Так какtime_tможет представлять интервалы времени длиной в 68 лет, а многие реализации для представления текущего времени в качестве начала отсчета используют 1970 год, в большинстве популярных реализаций C++ невозможно представлять даты и времена после 2038 года. Это означает, что если программисты не предпримут мер предосторожности, то в 2038году большая часть программного обеспечения перестанет работать.
   Наиболее удобное представление текущих даты и времени можно получить, преобразовав их с помощью функцийlocaltimeилиgmtimeв структуруtm.Структураtmсодержит целочисленные поля, показанные в примере 5.2.
   Пример 5.2. Содержимое структуры tm
   struct tm {
    int tm_sec;   // секунды в минуте от 0 до 61 (60 и 61 для секунд координации)
    int tm_min;   // минуты в часе от 0 до 59
    int tm_hour;  // часы в сутках от 0 до 23
    int tm_mday;  // день месяца от 0 до 31
    int tm_mon;   // месяц года от 0 до 11
    int tm_year;  // год после 1900
    int tm_wday;  // дней после воскресенья
    int tm_yday;  // дней после 1-го января
    int tm_isdst; // часы летнего времени
   };
   При использовании функцииgmtimeне забудьте проверить ее возвращаемое значение. Если компьютер, на котором выполняется код, не имеет определенной локальной временной зоны (часового пояса), функцияgmtimeне сможет вычислить время UTC и вернет 0. Если передать 0 в функциюasctime,то результатом будет неопределенное поведение.
   Функцииlocaltime,gmtimeиasctimeвозвращают указатели на статически размещенные в памяти объекты. Это более эффективно для библиотеки, не означает, что последующие вызовы будут изменять значениеэтих объектов. Код в примере 5.3 показывает, как это может привести к неожиданным эффектам.
   Пример 5.3. Подводные камни использования asctime
   void f() {
    char* x = asctime(localtime(time(0)));
    wait_for_15_seconds(); // выполняет длительную задачу обработки
    asctime(localtime(time(0)));
    cout&lt;&lt; x&lt;&lt; endl; //печатает текущее время, а не то что 15 секунд назад.
   }
   5.2.Форматирование даты/времени в виде строкиПроблема
   Требуется преобразовать дату и/или время в строковый форматРешение
   Используйте шаблон классаtime_putиз заголовочного файла&lt;locale&gt;,как показано в примере 5.4.
   Пример 5.4. Форматирование строки даты/времени
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;cstring&gt;
   #include&lt;string&gt;
   #include&lt;stdexcept&gt;
   #include&lt;iterator&gt;
   #include&lt;sstream&gt;

   using namespace std;

   ostream& formatDateTime(ostream& out, const tm& t, const char* fmt) {
    const time_put&lt;char&gt;& dateWriter = use_facet&lt;time_put&lt;char&gt;&gt;(out.getloc());
    int n = strlen(fmt);
    if (dateWriter.put(out, out, ' ',&t, fmt, fmt + n).failed()) {
     throw runtime_error("невозможно отформатировать дату и время");
    }
    return out;
   }

   string dateTimeToString(const tm& t, const char* format) {
    stringstream s;
    formatDateTime(s, t.format);
    return s.str();
   }

   tm now() {
    time_t now = time(0);
    return *localtime(&now);
   }

   int main() {
    try {
     string s = dateTimeToString(now(), "%A %B, %d %Y %I:%M%p");
     cout&lt;&lt; s&lt;&lt; endl;
     s = dateTimeToString(now(), "%Y-%m-%d %H:%M:%S);
     cout&lt;&lt; s&lt;&lt; endl;
    } catch(...) {
     cerr&lt;&lt; "невозможно отформатировать дату и время"&lt;&lt; endl;
     return EXIT FAILURE.
    }
    return EXIT_SUCCESS;
   }
   Вывод программы из примера 5.4 будет содержать нечто подобное следующему, в зависимости от локальных настроек.
   Sunday July, 24 2005 05:48PM 2005-07-24 17:48:11Обсуждение
   Методputизtime_putиспользует спецификатор форматирования строки, аналогичный строке формата функции Сprintf.Символы строки формата выводятся в выходной буфер по мере их появления при условии, что им не предшествует символ%.Символ, перед которым стоит%,— это спецификатор формата, который имеет специальное значение, приведенное в табл. 5.1. Спецификаторы формата также поддерживают модификаторы, такие как целое число, указывающее длину поля, как в%4B.

   Tабл. 5.1. Спецификаторы формата даты/времениСпецификаторОписаниеaСокращенное название дня недели (например, Mon (пн))AПолное название дня недели (например, Monday (понедельник))bСокращенное название месяца (например, Dec (дек))BПолное название месяца (например, May (май))cПолные дата и времяdДень месяца (01-31)HЧас (00-23)IЧас (01-12)jДень года (001-366)mМесяц (01-12)MМинуты (00-59)pПризнак AM/PMSСекунды, включая до двух секунд координацииUНомер недели (00-53), причем неделя 1 начинается в первое воскресеньеwДень недели (0-6), где 0 — это воскресеньеWНомер недели (00-53), причем неделя 1 начинается в первый понедельникxДата в формате MM/DD/YYXВремя в формате HH/MM/SS и 24-часовыми часамиyГод текущего столетия (00-99)YГодZСокращение временной зоны (часового пояса), или пустая строка, если зона неизвестна
   Библиотека Boost date_time, обсуждаемая в дальнейших рецептах, не содержит возможностей форматирования, предлагаемыхtime_put.Для удобства пример 5.5 содержит несколько процедур, преобразующих классы даты/времени Boost в формат структурыtm,так что вы можете использовать процедурыtime_put.
   Пример 5.5. Преобразование из классов даты/времени Boost в структуру tm
   using boost::gregorian;
   using boost::posix_time;

   void dateToTmAux(const date& src, tm& dest) {
    dest.tm_mday = src.day();
    dest tm_year = src.year() - 1900;
    dest.tm_mon = src.month() - 1;
   }

   void ptimeToTmAux(const ptime& src, tm& dest) {
    dest.tm_sec = src.seconds();
    dest.tm_min = st.minutes();
    dest.tm_hour = src.hours();
    dateToTmAux(src.date(), dest);
   }

   tm ptimeToTm(const ptime& t) {
    tm ret = tm();
    ptimeToTmAux(t.ret);
    return ret;
   }Смотри также
   Рецепт 13.3.
   5.3.Выполнение вычислений с датами и временемПроблема
   Требуется узнать количество времени, прошедшего между двумя точками даты/времени.Решение
   Если обе временные точки находятся между 1970 и 2038 годами, то используйте типtime_tи функциюdifftime,определенную в заголовочном файле&lt;ctime&gt;.Пример 5.6 показывает, как вычислить число дней, прошедших между двумя датами.
   Пример 5.6. Вычисление даты и времени в формате time_t
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;

   using namespace std;

   time_t dateToTimeT(int month, int day, int year) {
    // 5 января 2000 года передается как (1, 5, 2000)
    tm tmp = tm();
    tmp.tm_mday = day;
    tmp.tm_mon = month - 1;
    tmp.tm_year = year - 1900;
    return mktime(&tmp);
   }

   time_t badTime() {
    return time_t(-1);
   }

   time_t now() {
    return time(0);
   }

   int main() {
    time_t date1 = dateToTimeT(1,1,2000);
    time_t date2 = dateToTimeT(1,1,2001);
    if ((date1 == badTime()) || (date2 == badTime())) {
     cerr&lt;&lt; "невозможно создать структуру time_t"&lt;&lt; endl;
     return EXIT_FAILURE;
    }
    double sec = difftime(date2, date1);
    long days = static_cast&lt;long&gt;(sec / (60 * 60— 24));
    cout&lt;&lt;число дней между 1 января 2000 г. и 1 января 2001 г. составляет ";
    cout&lt;&lt; days&lt;&lt; endl;
    return EXIT_SUCCESS;
   }
   Программа из примера 5.6 должна вывести:
   число дней между 1 января 2000 г. и 1 января 2001 г. составляет 366
   Обратите внимание, что 2000 год високосный, так как, несмотря на то что он делится на 100, он также делится и на 400 и, следовательно, состоит из 366 дней.Обсуждение
   Типtime_t— это зависящий от реализации арифметический тип. Это означает, что это либо целый тип, либо тип с плавающей точкой, и, таким образом, он поддерживает основные арифметические операции. Его можно складывать, вычитать, делить, умножать и т.д. Чтобы вычислить интервал между двумя значениямиtime_tв секундах, используйте функциюdifftime.Не думайте, что самtime_tсодержит секунды, даже если это и так. Многие реализации C++ могут в ближайшем будущем молча изменить его так, чтобы он содержал доли секунд (это одна из причин, по которымdifftimeвозвращаетdouble).
   Если ограниченияtime_tслишком жестки, то вместо него для вычисления временных интервалов потребуется использовать различные классы из библиотеки Boostdate_time.Пример 5.7 показывает, как использовать классы Boost для вычисления числа дней в 20-м и 21-м столетиях.
   Пример 5.7. Вычисление даты и времени с помощью date_duration
   #include&lt;iostream&gt;
   #include&lt;boost/date_time/gregorian/gregorian.hpp&gt;

   using namespace std;
   using namespace boost::gregorian;

   int main() {
    date_duration dd = date(2000, 1, 1) - date(1900, 1, 1);
    cout&lt;&lt; "Двадцатый век содержал "&lt;&lt; dd.days()&lt;&lt; "дней"&lt;&lt; endl;
    dd = date(2100, 1, 1) - date(2000, 1, 1);
    cout&lt;&lt; "Двадцать первый век будет содержать "&lt;&lt;
     dd.days()&lt;&lt; "дней"&lt;&lt; endl;
   }
   Программа из примера 5.7 должна вывести:
   Двадцатый век содержал 36 524 дней
   Двадцать первый век будет содержать 36 525 дней
   5.4.Преобразование между часовыми поясамиПроблема
   Требуется преобразовать текущее время из одного часового пояса в другой.Решение
   Чтобы выполнить преобразование между часовыми поясами, используйте процедуры преобразования часовых поясов из библиотеки Boost date_time. Пример 5.8 показывает, как, зная время в Нью-Йорке, определить время в Туксоне, Аризона.
   Пример 5.8. Преобразование между часовыми поясами
   #include&lt;iostream&gt;
   #include&lt;boost/date_time/gregorian/gregorian.hpp&gt;
   #include&lt;boost/date_time/posix_time/posix_time.hpp&gt;
   #include&lt;boost/date_time/local_time_adjustor.hpp&gt;

   using namespace std;
   using namespace boost::gregorian;
   using namespace boost::date_time;
   using namespace boost::posix_time;

   typedef local_adjustor&lt;ptime, -5, us_dst&gt; EasternTZ;
   typedef local_adjustor&lt;ptime, -7, no_dst&gt; ArizonaTZ;

   ptime NYtoAZ(prime nytime) {
    ptime utctime = EasternTZ::local_to_utc(nytime);
    return ArizonaTZ::utc_to_local(utctime);
   }

   int main() {
    // May 1st 2004.
    boost::gregorian::date thedate(2004, 6, 1);
    ptime nytime(thedate, hours(19)); // 7 pm
    ptime aztime = NYtoAZ(nytime);
    cout&lt;&lt; "1мая 2004 г. когда было "&lt;&lt; nytime.time_of_day().hours();
    cout&lt;&lt; ":00часов в Нью-Йорке, было "&lt;&lt; aztime.time_of_day().hours();
    cout&lt;&lt; ":00часов в Аризоне"&lt;&lt; endl;
   }
   Программа из примера 5.8 выводит следующее.
   1мая 2004 г., когда было 19:00 часов в Нью-Йорке, было 16:00 часов в АризонеОбсуждение
   Преобразование часовых поясов в примере 5.8 выполняется в два шага. Вначале время преобразуется в UTC, а затем время в UTC преобразуется во второй часовой пояс. Заметьте, что часовые пояса в библиотеке Boostdate_timeпредставлены как типы, использующие шаблон классаlocal_adjustor.Каждый тип содержит функции преобразования, которые преобразуют из данного часового пояса в UTC (функцияlocal_tc_utс)и из UTC в данный часовой пояс (функцияutc_to_local).
   5.5.Определение номера дня в годуПроблема
   Требуется определить номер дня в году. Например, 1 января — это первый день в году, 5 февраля это 36-й день в году, и так далее. Но так как некоторые годы — високосные, то после 28 февраля указанный день может иметь не такой же номер, как и в другие годы.Решение
   Решение этой проблемы требует одновременного решения сразу нескольких проблем. Во-первых, требуется знать, сколько дней в каждом месяце, что в свою очередь требует определить, является ли год високосным. Пример 5.9 содержит процедуры, выполняющие эти вычисления.
   Пример 5.9. Процедуры, определяющие номер дня в году
   #include&lt;iostream&gt;

   using namespace std;

   enum MonthEnum {
    jan = 0, feb = 1, mar = 2, apr = 3, may = 4, jun = 5,
    jul = 6, aug = 7, sep = 8, oct = 9, nov = 10, dec = 11
   };

   bool isLeapYear(int y) {
    return (y % 4 == 0)&& ((y % 100 != 0) || (y % 400 == 0));
   }

   const int arrayDaysInMonth[] = {
    31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
   };

   int n;
   int arrayFirstOfMonth[] = {
    n = 0,
    n += arrayDaysInMonth[jan],
    n += arrayDaysInMonth[feb],
    n += arrayDaysInMonth[mar],
    n += arrayDaysInMonth[apr],
    n += arrayDaysInMonth[may],
    n += arrayDaysInMonth[jun],
    n += arrayDaysInMonth[jul],
    n += arrayDaysInMonth[aug],
    n += arrayDaysInMonth[sep],
    n += arrayDaysInMonth[::oct],
    n += arrayDaysInMonth[nov]
   };

   int daysInMonth(MonthEnum month, int year) {
    if (month == feb) {
     return isLeapYear(year) ? 29 : 28;
    } else {
     return arrayDaysInMonth[month];
    }
   }

   int firstOfMonth(MonthEnum month, int year) {
    return arrayFirstOfMonth[month] + isLeapYear(year);
   }

   int dayOfYear(MonthEnum month, int monthDay, int year) {
    return firstOfMonth(month, year) + monthDay - 1;
   }

   int main() {
    cout&lt;&lt; "1июля 1971 г. был "&lt;&lt; dayOfYear(jul, 1, 1971);
    cout&lt;&lt;днем года"&lt;&lt; endl;
   }
   Программа из примера 5.9 выводит следующее.
   1июля 1971 г. был 181 днем годаОбсуждение
   Код примера 5.9 довольно прост, но содержит набор полезных функций для работы с датами в високосных годах. Обратите внимание, что я отбросил подход, который я называю «задокументируй и молись», использованный в предыдущих рецептах. Под этим я подразумеваю, что месяцы больше не представляются индексами, вместо которых используются перечисления. Это значительно снижает вероятность программистской ошибки при передаче месяца в функцию в качестве ее аргумента.
   Вычисление високосного года, показанное в примере 5.9, выполняется в соответствии с современным григорианским календарем. Каждый четвертый год — високосный, за исключением каждого сотого, если он не делится на 400 (т.е. 1896 год был високосным, 1900 не был, 2000 был, 2004 был, 2100 год не будет).
   5.6.Определение ограниченных типов значенийПроблема
   Требуются самопроверяющиеся типы числовых данных, представляющие числа в ограниченном диапазоне допустимых значений, гаком как часы в сутках или минуты в часе.Решение
   При работе с датами и временем часто возникает необходимость ограничить целые значения диапазоном допустимых значений (т.е для секунд в минуте — от 0 до 59, для часов в сутках от 0 до 23, для дней в году — от 0 до 365). Вместо того чтобы каждый раз проверять эти значения при их передаче в функцию, предпочтительной является их автоматическая проверка с помощью перегруженного оператора присвоения. Так как имеется очень большое количество таких типов, следует реализовать один тип, который сможет работать с подобной проверкой для различных числовых диапазонов. Пример 5.10 представляет реализацию шаблона классаConstrаinedValue,который облегчает задание диапазона целых чисел и определение других ограниченных типов.
   Пример 5.10. constrained_value.hpp
   #ifndef CONSTRAINED_VALUE_HPP
   #define CONSTRAINED_VALUE_HPP

   #include&lt;cstdlib&gt;
   #include&lt;iostream&gt;

   using namespace std;

   template&lt;class Policy_T&gt;
   struct ConstrainedValue {
   public:
    // открытые typedef
    typedef typename Policy_T policy_type;
    typedef typename Policy_T::value_type value_type;
    typedef ConstrainedValue self;

    // конструктор по умолчанию
    ConstrainedValue() : m(Policy_T::default_value) {}
    ConstrainedValue(const self& x) : m(x.m) {}
    ConstrainedValue(const value_type& x) { Policy_T::assign(m, x); }
    operator value_type() const { return m; }

    // использует функцию присвоения, определенную политикой
    void assign(const value_type& x) {
     Policy_T::assign(m, x);
    }

    // операции присвоения
    self& operator=(const value_type& x) { assign(x); return *this; }
    self& operator+=(const value_type& x) { assign(m + x) return *this; }
    self& operator-=(const value_type& x) { assign(m - x) return *this; }
    self& operator*=(const value_type& x) { assign(m * x); return *this; }
    self& operator/=(const value_type& x) { assign(m / x); return *this; }
    self& operator%=(const value_type& x) { assign(m % x); return *this; }
    self& operator&gt;&gt;=(int x) { assign(m&gt;&gt; x); return *this; }
    self& operator&lt;&lt;=(int x) { assign(m&lt;&lt; x); return *this; }

    // унарные операторы
    self operator-() { return self(-m); }
    self operator+() { return self(-m); }
    self operator!() { return self(!m); }
    self operator~() { return self(~m); }

    // бинарные операторы
    friend self operator+(self x, const value_type& y) { return x += y; }
    friend self operator-(self x, const value_type& y) { return x -= y; }
    friend self operator*(self x, const value_type& y) { return x *= y; }
    friend self operator/{self x, const value_type& y) { return x /= y; }
    friend self operator%(self x, const value_type& y) { return x %= y; }
    friend self operator+(const value_type& y, self x) { return x += y; }
    friend self operator-(const value_type& y, self x) { return x -= y; }
    friend self operator*(const value_type& y, self x) { return x *= y; }
    friend self operator/(const value_type& y, self x) { return x /= y; }
    friend self operator%(const value_type& y, self x) { return x %= y; }
    friend self operator&gt;&gt;(self x, int y) { return x&gt;&gt;= y; }
    friend self operator&lt;&lt;(self x, int y) { return x&lt;&lt;= y; }

    // потоковые операторы
    friend ostream& operator&lt;&lt;(ostream& o, self x) {о&lt;&lt; x.m; return o; }
    friend istream& operator&gt;&gt;(istream& i, self x) {
     value_type tmp; i&gt;&gt; tmp; x.assign(tmp); return i;
    }

    // операторы сравнения
    friend bool operator&lt;(const self& x, const self& y) { return x.m&lt; y.m; }
    friend bool operator&gt;(const self& x, const self& y) { return x.m&gt; y.m; }
    friend bool operator&lt;=(const self& x, const self& y) { return x.m&lt;= y.m; }
    friend bool operator&gt;=(const self& x, const self& y) { return x.m&gt;= y.m; }
    friend bool operator==(const self& x, const self& y) { return x.m == y.m; }
    friend bool operator!=(const self& x, const self& y) { return x.m != y.m; }
   private:
    value_type m;
   };

   template&lt;int Min_N, int Max_N&gt;
   struct RangedIntPolicy {
    typedef int value_type;
    const static value_type default_value = Min_N;

    static void assign(value_type& lvalue, const value_type& rvalue) {
     if ((rvalue&lt; Min_N) || (rvalue&gt; Max_N) {
      throw range_error("out of valid range");
     }
     lvalue = rvalue;
    }
   };
   #endif
   Программа в примере 5.11 показывает, как использовать типConstrainedValue.
   Пример 5.11. Использование constrained_value.hpp
   #include "constrained_value.hpp"

   typedef ConstrainedValue&lt; RangedIntPolicy&lt;1582, 4000&gt;&gt; GregYear;
   typedef ConstrainedValue&lt; RangedIntPolicy&lt;1, 12&gt;&gt; GregMonth;
   typedef ConstrainedValue&lt; RangedIntPolicy&lt;1, 31&gt;&gt; GregDayOfMonth;

   using namespace std;

   void gregOutputDate(GregDayOfMonth d, GregMonth m, GregYear y) {
    cout&lt;&lt; m&lt;&lt; "/"&lt;&lt; d&lt;&lt; "/"&lt;&lt; y&lt;&lt; endl;
   }

   int main() {
    try {
     gregOutputDate(14, 7, 2005);
    } catch(...) {
     cerr&lt;&lt; "Оп, не должны сюда попасть&lt;&lt; endl;
    }
    try {
     gregOutputDate(1, 5, 1148);
     cerr&lt;&lt; "Оп, не должны сюда попасть"&lt;&lt; endl;
    } catch(...) {
     cerr&lt;&lt; "Уверены, что надо использовать григорианский календарь?"&lt;&lt; endl;
    }
   }
   Вывод программы из примера 5.11 имеет вид:
   7/14/2005
   Уверены, что надо использовать григорианский календарь?Обсуждение
   Ограниченные типы значений обычно используются при работе с датами и временем, так как многие значения, связанные с датами/временем, — это целые числа, которые должны находиться в определенных диапазонах (например, месяц должен быть в интервале [0,11], а день месяца должен быть в интервале [0,30]). Проверять вручную параметр каждой функции на допустимый диапазон очень долго и чревато ошибками. Просто представьте, что требуется внести глобальное изменение в то, как программа, содержащая миллион строк кода, обрабатывает ошибки диапазона дат!
   Шаблон классаConstrainedValue,используемый вместе с шаблономRangedIntPolicy,может использоваться для простого определения различных типов, выбрасывающих при присвоении значений, выходящих за диапазон, исключения. Пример 5.12 показывает некоторые примеры использованияConstrainedValueдля определения новых самопроверяющихся целочисленных типов.
   Пример 5.12. Использование ConstrainedValue
   typedef ConstrainedValue&lt; RangedIntPolicy&lt;0, 59&gt;&gt; Seconds;
   typedef ConstrainedValue&lt; RangedIntPolicy&lt;0, 59&gt;&gt; Minutes;
   typedef ConstrainedValue&lt; RangedIntPolicy&lt;0, 23&gt;&gt; Hours;
   typedef ConstrainedValue&lt; RangedIntPolicy&lt;0, 30&gt;&gt; MonthDays;
   typedef ConstrainedValue&lt; RangedIntPolicy&lt;0, 6&gt;&gt; WeekDays;
   typedef ConstrainedValue&lt; RangedIntPolicy&lt;0, 365&gt;&gt; YearDays;
   typedef ConstrainedValue&lt; RangedIntPolicy&lt;0, 51&gt;&gt; Weeks.
   Шаблон классаConstrainedValueявляется примером основанного на политике дизайна. Политика — это класс, передаваемый в шаблон как параметр, который указывает аспекты реализации или поведения параметризованного класса. Политика, передаваемая вConstrainedValue,должна предоставлять реализацию того, как выполнять присвоение между одними и теми же специализациями типа.
   Использование политик может повысить гибкость классов, перенеся часть решений относительно типа на его пользователя. Политики обычно используются тогда, когда группа типов имеет общий интерфейс, но различается по реализациям. Также политики частично полезны при невозможности предугадать и удовлетворить все возможные сценарии использования данного типа.
   Имеется множество других политик, которые можно использовать с типомConstrainedValue.Например, вместо того чтобы выбрасывать исключение, можно присваивать значение по умолчанию или ближайшее допустимое значение. Более того, ограничения не обязательно должны иметь вид диапазонов: можно задать такое ограничение, когда значение всегда должно быть четным.
   Глава 6
   Управление данными с помощью контейнеров
   6.0.Введение
   Эта глава описывает структуры данных стандартной библиотеки, используемые для хранения данных. Часто они также называются контейнерами (containers), так как они содержат («contain») хранящиеся в них объекты. Также эта глава описывает другой тип контейнеров, который не является частью стандартной библиотеки, хотя и поставляется с большинством ее реализаций —хеш-контейнер.
   Часть библиотеки, которая содержит контейнеры, часто называется Standard Template Library, или STL (стандартная библиотека шаблонов), именно так она называлась до ее включения в стандарт С++. STL включает не только контейнеры, обсуждаемые в этой главе, но и итераторы и алгоритмы, которые являются еще двумя строительными блоками STL, делающими STL гибкой библиотекой общего назначения. Так как эта глава в основном посвящена стандартным контейнерам, а не STL во всем ее многообразии, я буду называть контейнеры «стандартными контейнерами», а не «контейнерами STL», как это делается во многих книгах по С++. Хотя я по мере необходимости описываю итераторы и алгоритмы, более подробно они обсуждаются в главе 7.
   Стандарт C++ использует для описания набора контейнеров точную терминологию. «Контейнер» в стандартной библиотеке C++ — это структура данных, имеющая четкий интерфейс, описанный в стандарте. Например, любой класс стандартной библиотеки С++, который называет себя контейнером, должен поддерживать методbegin,который не имеет параметров и возвращаетiterator,указывающий на первый элемент в этом контейнере. Имеется большое количество обязательных конструкторов и функций-членов, определяющих, что такое контейнер в терминах С++. Также имеются необязательные методы, реализуемые только некоторыми контейнерами обычно теми, которые могут их эффективно реализовать.
   Общий набор контейнеров подразделяется на два различных типа контейнеров:последовательныеконтейнеры иассоциативныеконтейнеры. Последовательный контейнер (обычно называемый просто последовательностью) хранит объекты в порядке, указанном пользователем, и предоставляет необходимый для доступа и обработки элементов интерфейс (в дополнение к обязательному для контейнеров). Ассоциативные контейнеры хранят элементы в упорядоченном виде и, таким образом, не позволяют вставлять элементы в определенное место, хотя для увеличения эффективности при вставке можно указать дополнительные параметры. Как последовательности, так и ассоциативные контейнеры содержат обязательный интерфейс, но только последовательности имеют дополнительный набор операций, который поддерживается только теми последовательностями, для которых он эффективно реализуем. Эти дополнительные операции с последовательностями предоставляют большую гибкость и удобство, чем стандартный интерфейс.
   Это выглядит очень похоже на наследование. Последовательность — это контейнер, ассоциативный контейнер — это контейнер, но контейнер — это не последовательность и не ассоциативный контейнер. Однако это не наследование в смысле С++, а наследование с точки зрения концепции,vector— это последовательность, но это самостоятельный класс. Он не наследует от классаcontainerили подобного ему (реализации стандартной библиотеки имеют свободу в реализацииvectorи других контейнеров, но стандарт не предписывает реализации стандартной библиотеки включать базовый классcontainer).При разработке контейнеров было приложено большое количество усилий, и если вы хотите поподробнее узнать о них, обратитесь к книге Мэтта Остерна (Matt Austern)Generic Programming and the STL (Addison Wesley).
   Эта глава содержит две части. Несколько первых рецептов рассказывают, как использоватьvector,который является стандартной последовательностью и одной из наиболее популярных структурой данных. Они описывают, как эффективно и рационально использоватьvector.Остальные рецепты описывают большую часть остальных широко применяемых стандартных контейнеров, включая два нестандартных хеш-контейнера, о которых я упоминал ранее.
   6.1.Использование vector вместо массивовПроблема
   Требуется сохранить элементы (встроенные типы, объекты, указатели и т.п.) в виде последовательности, обеспечить произвольный доступ к ним, и не ограничивать место хранения массивом статического размера.Решение
   Используйте шаблон классаvectorстандартной библиотеки, определенный в&lt;vector&gt;,и не используйте массивы.vectorвыглядит и ведет себя, как массив, но имеет перед ним большое количество преимуществ в части безопасности и удобства. Пример 6.1 показывает несколько обычных операций сvector.
   Пример 6.1. Использование некоторых методов vector
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;string&gt;

   using namespace std;

   int main() {
    vector&lt;int&gt; intVec;
    vector&lt;string&gt; strVec;
    // Добавление элементов в "конец" вектора с помощью push_back
    intVec.push_back(3);
    intVec.push_back(9);
    intVec.push_back(6);
    string s = "Army";
    strVec.push_back(s);
    s = "Navy";
    strVec.push_back(s);
    s = "Air Force";
    strVec.push_back(s);
    // Для доступа к элементам используется operator[], как и для массивов
    for (vector&lt;string&gt;::size_type i = 0; i&lt; intVec.size(); ++i) {
     cout&lt;&lt; "intVec["&lt;&lt; i&lt;&lt; "] = "&lt;&lt; intVec[i]&lt;&lt; '\n';
    }
    // Или можно использовать итераторы
    for (vector&lt;string&gt;::iterator p = strVec.begin();
     p != strVec.end(); ++p) {
     cout&lt;&lt; *p&lt;&lt; '\n';
    }
    // Если требуется безопасность, вместо operator[] используйте at(). Она
    // при использовании индекса&gt; size()выбрасывает исключение out_of_range.
    try {
     intVec.at(300) = 2;
    } catch(out_of_range& e) {
     cerr&lt;&lt; "out_of_range: "&lt;&lt; e.what()&lt;&lt; endl;
    }
   }Обсуждение
   В целом, если требуется использовать массив, вместо него следует использоватьvector.vectorпредлагает большую безопасность и гибкость, чем массив, а накладные расходы на производительность в большинстве случаев пренебрежимо малы, и если окажется, что они больше, чем можно себе позволить, производительностьvectorможно увеличить, использовав некоторые его методы.
   Если вы не знакомы с контейнерами, поставляющимися в составе стандартной библиотеки, или не сталкивались с использованием шаблонов классов (и их написанием), то объявлениеvectorв примере 6.1 требует некоторых пояснений. Объявлениеvectorимеет следующий вид.
   vector&lt;typename Value, //Тип элемента, который будет храниться в этом векторе
    typename Allocator = allocator&lt;Value&gt;&gt; //используемый распределитель (allocator)
                                            // памяти
   Стандартные контейнеры параметризованы по типу объектов, которые будут в них храниться. Также есть параметр шаблона для используемого распределителя памяти, но по умолчанию он имеет стандартное значение и обычно не указывается, так что я его здесь обсуждать не буду.
   Если вы хотите, чтобыvectorхранил элементы типаint,объявите его, как в этом примере.
   vector&lt;int&gt; intVec;
   А если вам требуется, чтобы он хранил строки, просто измените тип аргументаvector.
   vector&lt;string&gt; strVec;
   vectorможет содержать любой тип С++, который поддерживает конструктор копирования и присвоение.
   Следующее, что логически требуется сделать после создания экземпляраvector,— это что-либо поместить в него. В конец вектора элементы добавляются с помощьюpush_back.
   intVec.push_back(3);
   intVec.push_back(9);
   intVec.push_back(6);
   Это примерно эквивалентно добавлению элементов 0, 1 и 2 в массив. Это «примерно» эквивалентно потому, что, конечно,push_back— это метод, который возвращаетvoidи помещает свой аргумент в конец вектора.operator[]возвращает ссылку на область памяти, на которую указывает индекс массива,push_backгарантирует, что во внутреннем буфереvectorокажется достаточно места для добавления аргумента. Если место есть, то он добавляется в следующий неиспользуемый индекс, а если нет, то буфер увеличивается с помощью зависящего от реализации алгоритма, азатемв него добавляется аргумент
   Также с помощью методаinsertможно вставить элементы в середину вектора, хотя этого следует избегать из-за линейно возрастающей сложности этой операции. За более подробным обсуждением проблем производительности и их решения при использованииvectorобратитесь к рецепту 6.2. Чтобы вставить элемент, получите итератор на точку, куда требуется его вставить (обсуждение итераторов приводится в рецепте 7.1).
   string s = "Marines";
   vector&lt;string&gt;::iterator p = find(strVec.begin()
   strVec.end(), s);
   if (s != strVec.end()) //Вставляет s непосредственно перед элементом,
    strVec.insert(p, s);  // на который указывает p
   Перегруженные версииinsertпозволяют вставлять в вектор n копий объекта, а также вставлять целый диапазон другой последовательности (эта последовательность может быть другимvector,массивом,listи т.п.).
   Вместо вставки можно просто присвоить вектору уже существующую другую последовательность, стерев при этом то, что в нем содержалось до этого. Это выполняет методassign.Вектору можно присвоить диапазон значений илиnкопий одного и того же объекта, как здесь.
   string sarr[3] = {"Ernie", "Bert", "Elmo"};
   string s = "Oscar";
   strVec.assign(&sarr[0],&sarr[3]); //Присвоить эту последовательность
   strVec.assign(50, s);              // Присвоить 50 копий s
   Если новая последовательность окажется больше, чем имеющийся размер буфераvector,тоassignизменит размер буфера так, чтобы разместить в нем всю новую последовательность.
   После того как данные помещены вvector,имеется несколько способов получения их назад. Вероятно, наиболее интуитивным являетсяoperator[],который возвращает ссылку илиconst-ссылку в зависимости от того, является ли векторconstили нет, на элемент по указанному индексу. В этом отношении он ведет себя почти как массив:
   for (int i = 0; i&lt; intVec.size(); ++i) {
    std::cout&lt;&lt; "intVec["&lt;&lt; i&lt;&lt; "] = "
    &lt;&lt; intVec[i]&lt;&lt; '\n'; // rvalue
   }
   intVec[2] = 32; // lvalue
   operator[]также ведет себя как массив в том, что при использовании индекса, который больше, чем индекс последнего элементаvector,результат не определен, что обычно означает, что будут повреждены данные программы или она обрушится. Избежать этого можно, запросив число элементов, содержащихсявvector,с помощьюsize().Однако использованиюoperator[]следует предпочитать итераторы, так как их использование является стандартным для перебора элементов любого стандартного контейнера.
   for (vector&lt;string&gt;::iterator p = strVec.begin();
    p != strVec.end(); ++p) {
    std::cout&lt;&lt; *p&lt;&lt; '\n';
   }
   Итераторы являются наиболее мощным подходом, так как они позволяют обращаться с контейнерами одинаковым образом. Например, при написании алгоритма, который работает с последовательностями элементов, расположенными между двумя итераторами, он сможет работать с любым стандартным контейнером. Это общий подход. При использовании произвольного доступа с помощьюoperator[]вы ограничиваете себя использованием только тех контейнеров, которые поддерживают произвольный доступ. Первый подход позволяет алгоритмам стандартной библиотеки из&lt;algorithm&gt;одинаково работать со стандартными контейнерами (и другими типами, ведущими себя, как они).
   Такжеvectorпредоставляет безопасность, которой просто невозможно достичь в случае обычных массивов. В отличие от массивовvectorс помощью методаatпредлагает проверку диапазонов. Если вatпередается неправильный индекс, он выбрасывает исключениеout_of_range,которое затем можно перехватить с помощьюcatchи адекватно на него отреагировать. Например:
   try {
    intVec.at(300) = 2;
   } catch(std::out_of_range& e) {
    std::cerr&lt;&lt; "out_of_range: "&lt;&lt; e.what()&lt;&lt; std::endl;
   }
   Как вы знаете, если обратиться к элементу за пределами массива с помощьюoperator[],оператор сделает то, что ему сказано сделать, и вернет то, что находится в указанной области памяти. Это плохо, так как либо программа обрушится в результате попытки доступа к области памяти, к которой она доступа не имеет, либо она молча изменит содержимое области памяти, принадлежащей другому объекту кучи, что обычно еще хуже.operator[]для vector работает точно так же, но когда требуется обезопасить код, используйтеat.
   Итак, вот краткий курс поvector.Но чтотакоеvector?Если вы используете С++, то вас, вероятно, волнуют проблемы производительности, и вам не понравится, если вам просто дадут что-то и скажут, что это работает. Вполне справедливо. За обсуждением работыvectorи советами по его эффективному использованию обратитесь к рецепту 6.2.Смотри также
   Рецепт 6.2.
   6.2.Эффективное использование vectorПроблема
   Вы используетеvector,и при этом имеются жесткие требования по объему или времени выполнения кода и требуется снизить или устранить все накладные расходы.Решение
   Поймите, как реализованvector,узнайте о сложности методов вставки и удаления и минимизируйте ненужные операции с памятью с помощью методаreserve.Пример 6.2 показывает некоторые из этих методик в действии.
   Пример 6.2. Эффективное использование vector
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;string&gt;

   using std::vector;
   using std::string;

   void f(vector&lt;string&gt;& vec) {
    // Передача vec по ссылке (или,
    // если требуется, через указатель)
    // ...
   }

   int main() {
    vector&lt;string&gt; vec(500); //При создании vector говорим, что в него
                             // планируется поместить определенное количество
                             // объектов
    vector&lt;string&gt; vec2;
    // Заполняем vec...
    f(vec);
    vec2 reserve(500); // Или постфактум говорим vector,
                       // что требуется буфер достаточно большого
                       // размера для хранения объектов
                       // Заполняем vec2...
   }Обсуждение
   Ключ к эффективному использованиюvectorлежит в знании его работы. Когда у вас есть четкое представление реализацииvector,вопросы производительности становятся очевидными.Как работает vector
   vector— это по сути управляемый массив. Более конкретно,vector&lt;T&gt;— это непрерывный фрагмент памяти (т.е. массив), который достаточно велик для храненияnобъектов типаT,гдеnбольше или равно нулю и меньше или равно зависящему от реализации максимальному размеру. Обычноnувеличивается в процессе жизни контейнера при добавлении или удалении элементов, но оно никогда не уменьшается. Что отличаетvectorот массива — это автоматическое управление памятью массива, методы для вставки и получения элементов и методы, которые предоставляют метаданные о контейнере, такие как размер (число элементов) и емкость (размер буфера), а также информацию о типе:vector&lt;T&gt;::value_type— это типT,vector&lt;T&gt;::pointer— это тип указатель-на-Tи т.д. Два последних и некоторые другие являются частью любого стандартного контейнера, и они позволяют писать обобщенный код, который работает независимо от типаT.Рисунок 6.1 показывает графическое представление того, что предоставляют некоторые из методовvector,еслиvectorимеет размер 7 и емкость 10. [Картинка: img_2.jpg] 
   Рис. 6.1. Внутренности vector
   Если вам любопытно, как поставщик вашей стандартной библиотеки реализовалvector,скомпилируйте пример 6.1 и пройдите в отладчике все вызовы методов vector или откройте заголовочный файл&lt;vector&gt;реализации стандартной библиотеки и изучите его. Код, который вы там увидите, по большей части не является дружественным к читателю, но он должен осветить некоторые моменты. Во-первых, если вы еще не видели кода библиотеки, он даст вам представление о методиках реализации, используемых для написания эффективного, переносимогообобщенного кода. Во-вторых, он даст точное представление о том, что представляют собой используемые вами контейнеры. При написании кода, который должен работать сразличными реализациями стандартной библиотеки, это следует сделать в любом случае.
   Однако независимо от поставщика библиотеки почти все реализации векторов похожи. В них есть переменная экземпляра, которая указывает на массив изT,и элементы, добавляемые или присваиваемые вами, с помощью конструктора копирования или операции присвоения помешаются в элементы этого массива.
   Обычно добавление объектаTв следующий доступный слот буфера выполняется с помощью копирующего конструктора и new, которому передается тип создаваемого объекта, а также адрес, по которому он должен быть создан. Если вместо этого явно присвоить значение слоту, используя его индекс (с помощьюoperator[]илиat),то будет использован оператор присвоенияT.Заметьте, что в обоих случаях объект клонируется либо с помощью конструктора копирования, либоT::operator=.vectorне просто хранит адрес добавляемого объекта. Именно по этой причине любой тип, сохраняемый в векторе, должен поддерживать копирующий конструктор и присвоение. Этисвойства означают, что эквивалентный объект типаTможет быть создан с помощью вызова конструктора копированияTили оператора присвоения. Это очень важно из-за семантики копированияvector— если конструктор копирования или присвоение объектов не работает, то результаты, получаемые из vector, могут отличаться от того, что в него помещалось. А это плохо.
   После добавления некоторого набора объектов в vector его буфер заполняется, и для добавления новых объектов его требуется увеличить. Алгоритм увеличения размера зависит от реализации, но обычно буфер размераnувеличивается до 2n+1.Важным здесь является то, как vector увеличивает свой буфер. Вы не можете просто сказать операционной системе неопределенно увеличить свой фрагмент памяти кучи. Требуется запросить новый фрагмент, который больше уже имеющегося. В результате процесс увеличения размера буфера выглядит следующим образом.
   1. Выделить память для нового буфера.
   2. Скопировать старые данные в новый буфер.
   3. Удалить старый буфер.
   Это позволяетvectorхранить все его объекты в одном непрерывном фрагменте памяти.Оптимизация производительности vector
   Предыдущий раздел должен дать вам представление о том, как объекты хранятся в векторе. Из этого обзора вам должны стать понятны главные моменты, связанные с производительностью, но в том случае, если вы еще не поняли, я расскажу о них.
   Для начала,vector (или любой другой контейнер из стандартной библиотеки) не хранит объекты. Он храниткопииобъектов. Это значит, что каждый раз, когда вvectorзаносится новый объект, он туда не «кладется». С помощью конструктора копирования или оператора присвоения он копируется в другое место. Аналогично при получении значения изvectorпроисходит копирование того, что находится в векторе по указанному индексу, в локальную переменную. Рассмотрим простое присвоение элементаvectorлокальной переменной.
   vector&lt;MyObj&gt; myVec;
   //Поместить несколько объектов MyObj в myVec
   MyObj obj = myVec[10]; //Скопировать объект с индексом 10
   Это присвоение вызывает оператор присвоенияobj,в качестве правого операнда которого используется объект, возвращенныйmyVec[10].Накладные расходы на производительность при работе с большим количеством объектов резко возрастают, так что их лучше всего избегать.
   Для снижения накладных расходов на копирование вместо помещения вvectorсамих объектов поместите в него указатели. Сохранение указателей потребует меньшего количества циклов ЦП на добавление и получение данных, так как указатели проще скопировать, чем объекты, и, кроме того, это снизит объем памяти, необходимый для буфераvector.Но помните, что при добавлении в контейнер стандартной библиотеки указателей контейнер не удаляет их при своем уничтожении. Контейнеры удаляют только содержащиеся в них объекты, т.е. переменные, которые хранят адреса объектов, но контейнер ничего не знает, хранится ли в нем указатель или объект. Все, что он знает, — это то, что это объект типаT.
   Изменение размера буфера тоже не дешево. Копирование каждого элемента буфера требует много работы, и этого лучше всего избегать. Чтобы защититься от этого, явно укажите размер буфера. Имеется пара способов сделать это. Простейшим способом сделать это является указание размера при создании вектора.
   vector&lt;string&gt; vec(1000);
   Здесь резервируется место для 1000 строк, и при этом производится инициализация каждого слота буфера с помощью конструктораstringпо умолчанию. При этом подходе приходится платить за создание каждой из этих строк, но добавляются определенные меры безопасности в виде инициализации каждого элемента буфера пустой строкой. Это означает, что при ссылке на элемент, значение которого еще не было присвоено, будет просто получена пустая строка.
   Если требуется проинициализировать буфер каким-то определенным значением, можно передать объект, который требуется скопировать в каждый слот буфера.
   string defString = "uninitialized";
   vector&lt;string&gt; vec(100, defString);
   string s = vec[50]; // s = "uninitialized"
   В этом вариантеvecс помощью конструктора копирования создаст 100 элементов, содержащих значение изdefString.
   Другим способом резервирования пространства буфера является вызов методаreserve,расположенный после созданияvector.
   vector&lt;string&gt; vec;
   vec reserve(1000);
   Главным различием между вызовомreserveи указанием размера в конструкторе является то, чтоreserveне инициализирует слоты буфера каким-либо значением. В частности, это означает, что не следует ссылаться на индексы, в которые еще ничего не записано.
   vector&lt;string&gt; vec(100);
   string s = vec[50]; //без проблем: s содержит пустую строку
   vector&lt;string&gt; vec2;
   vec2.reserve(100);
   s = vec2[50];      // Не определено
   Использование резервирования или указание числа объектов по умолчанию в конструкторе помогает избежать ненужных перераспределений буфера, Это приводит к увеличению производительности, но также позволяет избежать и еще одной проблемы: каждый раз, когда происходит перераспределение буфера, все итераторы, имевшиеся на этот момент и указывающие на элементы, становятся недействительными.
   Наконец, плохой идеей является вставка элементов в любое место, кроме конца вектора. Посмотрите на рис. 6.1. Так какvector— это просто массив с дополнительными прибамбасами, становится очевидно, почему следует добавлять элементы только в конец вектора. Объекты вvectorхранятся последовательно, так что при вставке элемента в любое место, кроме конца, скажем, по индексуn,объекты сn+1до конца должны быть сдвинуты на один (в сторону конца) и освободить место для нового элемента. Сложность этой операции линейна, что означает, что она оказывается дорогостоящей даже для векторов скромного размера. Удаление элемента вектора имеет такой же эффект: оно означает, что все индексы больше n должны быть сдвинуты на один слот вверх. Если требуется возможность вставки и удаления в произвольном месте контейнера, вместо вектора следует использоватьlist.
   6.3.Копирование вектораПроблема
   Требуется скопировать содержимое одногоvectorв другой.Решение
   Имеется пара способов сделать это. Можно при созданииvectorиспользовать конструктор копирования, а можно использовать методassign.Пример 6.3 показывает оба этих способа.
   Пример 6.3. Копирование содержимого vector
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;string&gt;
   #include&lt;algorithm&gt;

   using namespace std;

   //Вспомогательная функция для печати содержимого вектора
   template&lt;typename T&gt;
   void vecPrint (const vector&lt;T&gt;& vec) {
    cout&lt;&lt; "{";
    for (typename vector&lt;T&gt;::const_iterator p = vec.begin();
     p != vec.end(); ++p) {
     cout&lt;&lt; "{"&lt;&lt; *p&lt;&lt; "} ";
    }
    cout&lt;&lt; "}"&lt;&lt; endl;
   }

   int main() {
    vector&lt;string&gt; vec(5);
    string foo[] = {"My", "way", "or", "the", "highway"};
    vec[0] = "Today";
    vec[1] = "is";
    vec[2] = "a";
    vec[3] = "new";
    vec[4] = "day";
    vector&lt;string&gt; vec2(vec);
    vecPrint(vec2);
    vec.at(0) = "Tomorrow";
    vec2.assign(vec.begin(), vec.end()); // Копирование каждого элемента
    vecPrint(vec2);                      // с помощью присвоения
    vec2.assign(&foo[0],&foo[5]); //Присвоение работает для всего, что
    vecPrint(vec2);                // ведет себя как итератор
    vector&lt;string&gt;::iterator p;
    p = find(vec.begin(), vec.end(), "new");
    vec2.assign(vec.begin(), p); // Копирование подмножества полного диапазона
    vecPrint(vec2);              // vec
   }Обсуждение
   Копированиеvectorпросто. Имеется два способа сделать это. Можно скопировать одинvectorв другой с помощью конструктора копирования, как и любой другой объект, а можно использовать методassign.О конструкторе копирования сказать почти нечего. Просто передайте в негоvector,который требуется скопировать, и все.
   vector&lt;string&gt; vec2(vec);
   В этом случаеvec2будет содержать такое же число элементов, что иvec,и каждый из этих элементов будет копией элементаvecс таким же индексом. Каждый элемент копируется с помощью конструктора копированияstring.Так как здесь используется конструктор, буферvec2имеет размер, достаточный для хранения всего, что есть вvec.
   assignработает аналогично, за исключением того, что за кулисами выполняется дополнительная работа, связанная с тем, что теперь дело касается целевого vector который уже может содержать данные. Во-первых, требуется удалить элементы, которые оказались, так сказать, под ногами. Вначалеassignдля каждого из объектов, уже содержащихся вvec2,вызывает деструктор. После этого он проверяет размер буфераvec2,чтобы убедиться, что он достаточно большой, чтобы вместить то, что находится вvec.Если он не достаточен,assignизменяет размер буфера под размещение новых данных. Наконец, он копирует каждый элемент.
   Кроме того,assignможно использовать для копирования подмножества последовательности. Например, если требуется скопировать подмножество элементовvec,просто укажите при вызовеassignнеобходимый диапазон.
   vector&lt;string&gt;::iterator p;
   p = std::find(vec.begin(), vec.end(), "new");
   vec2.assign(vec.begin(), p);
   vecPrint(vec2);
   В этом случаеassignскопирует все до, но не включая,p.Причиной этого является соглашение, по которому во всех контейнерах и алгоритмах стандартной библиотекиassign(first, last)копирует элементы, на которые указываетfirst,до, но не включая, элемент, на который указываетlast.Такой диапазон, который включает первый элемент, но не включает последний, часто обозначается как(first, last).
   Используйтеassignили конструктор копирования вместо самостоятельного циклического перебора. Это значит, не копируйте каждый элемент, перебираяvecи помещая элементы в конецvec2в цикле. Это потребует от вас большой избыточности кода и отключит все оптимизации, которые могут присутствовать в реализацииassignи конструктора копирования стандартной библиотеки.
   6.4.Хранение указателей в вектореПроблема
   С целью повышения эффективности или по другим причинам невозможно хранить копии объектов вvector,но их требуется как-то разместить.Решение
   Сохраните вvectorуказатели на объекты, а не копии самих объектов. Но при этом не забудьте удалить объекты с помощьюdelete,так какvectorэтого за вас не сделает. Пример 6.4 показывает, как объявитьvectorуказателей и работать с ним.
   Пример 6.4. Использование векторов указателей
   #include&lt;iostream&gt;
   #include&lt;vector&gt;

   using namespace std;

   static const int NUM_OBJECTS = 10;

   class MyClass { /*...*/ };

   int main() {
    vector&lt;MyClass*&gt; vec;
    MyClass* p = NULL;
    // Загрузить в vector объекты MyClass
    for (int i = 0; i&lt; NUM_OBJECTS; i++) {
     p = new MyClass();
     vec.push_back(p);
    }
    // Выполнить обработку данных, затем удалить объекты, когда
    // они уже не нужны
    for (vector&lt;MyClass*&gt;::iterator pObj = vec.begin();
     pObj != vec.end(); ++pObj) {
     delete *pObj; // заметьте, что здесь удаляется то на что указывает pObj,
                   // который является указателем
    }
    vec.clear(); // Очистить содержимое, чтобы больше никто не попытался
                 // удалить его еще раз
   }Обсуждение
   Сохранить указатели вvectorможно точно так же, как и все остальное. Объявите vector указателей таким образом:
   vector&lt;MyClass*&gt; vec;
   Здесь важно запомнить, чтоvectorхранитзначения,не обращая внимания на то, что они означают. Следовательно, он не знает, что для указателей перед их удалением следует использоватьdelete.Если выделить память, затем поместить указатели в памятьvector,то по окончании работы следует самостоятельно удалить память. Не дайте ввести себя в заблуждение термину «контейнер», думая, что если вvectorсохранить указатель, то это подразумевает владение им.
   После удаления указателей следует явно очиститьvector— по той же причине, по которой следует присваивать переменным-указателям по окончании работы с ними значение NULL. Это предотвратит ошибочное повторное удаление.
   6.5.Хранение объектов в спискеПроблема
   Требуется хранить элементы в виде последовательности, но vector не соответствует всем требованиям. В частности, требуется иметь возможность эффективно добавлять и удалять элементы в середине последовательности, а не только в ее конце.Решение
   Для хранения данных используйтеlist,объявленный в&lt;list&gt;.listпредлагает более высокую производительность и большую гибкость при изменении последовательности в произвольных местах. Пример 6.5 показывает, как использоватьlist,а также демонстрирует некоторые из его уникальных операций.
   Пример 6.5. Использование list
   #include&lt;iostream&gt;
   #include&lt;list&gt;
   #include&lt;string&gt;
   #include&lt;algorithm&gt;

   using namespace std;

   //Простая функция для печати
   template&lt;typename T&gt;
   struct printer {
    void operator()(const T& s) {
     cout&lt;&lt; s&lt;&lt; '\n';
    }
   };

   bool inline even(int n) {
    return(n % 2 == 0);
   }

   printer&lt;string&gt; strPrinter;
   printer&lt;int&gt; intPrinter;

   int main() {
    list&lt;string&gt; lstOne;
    list&lt;string&gt; lstTwo;
    lstOne.push_back("Red");
    lstOne.push_back("Green");
    lstOne.push_back("Blue");
    lstTwo.push_front("Orange");
    lstTwo.push_front("Yellow");
    lstTwo.push_front("Fuschia");
    for_each(lstOne.begin(), // Напечатать каждый элемент списка,
     lstOne.end(),           // используя пользовательскую функцию печати
     strPrinter);
    lstOne.sort(); // list содержит методы для сортировки
    lstTwo.sort();
    lstOne.merge(lstTwo);    // Объединить два списка и напечатать
    for_each(lstOne.begin(), // результаты (перед объединением списки должны
     lstOne.end(),           // быть отсортированы)
     strPrinter);
    list&lt;int&gt; intLst;
    intLst.push_back(0);
    intLst.push_back(1);
    intLst.push_back(2);
    intLst.push_back(3);
    intLst.push_back(4);
    // Удалить все значения больше 2
    intLst.remove_if(bind2nd(greater&lt;int&gt;(), 2));
    for_each(intLst.begin(), intLst.end(), intPrinter);
    // Или удалить все четные значения
    intLst.remove_if(even);
   }Обсуждение
   list— это последовательность, обеспечивающая постоянную сложность операций вставки и удаления элементов в произвольную позицию, но обладающая линейной сложностью их поиска. Обычноlistреализуется как двухсвязный список, что означает, что каждый элемент хранится в узле, содержащем указатели на предыдущий и следующий элементы последовательности.Он обеспечивает все требования к контейнеру стандартной последовательности, полюс предоставляет несколько уникальных методов.
   Объявлениеlistне вызывает сложностей — просто укажите тип элементов, которые в нем будут храниться, и, опционально, класс распределителя памяти.
   list&lt;typename Value, //Тип элементов, хранящихся в списке
    typename Allocator = allocator&lt;Value&gt;&gt; //Используемый распределитель
                                            // памяти
   Параметр шаблонаValue— это тип элементов, которые будут храниться вlist.Это должен быть тип, который поддерживает конструктор копирования и присвоение.Allocator— это используемый класс распределителя памяти. По умолчанию используется стандартный распределитель (и в большинстве случаев его вполне достаточно).
   Далее приведено типичное объявлениеlist (см. пример 6.5).
   list&lt;string&gt; lstOne;
   После объявления списка поместите в него что-нибудь с помощьюpush_frontилиpush_back,как здесь.
   lstOne.push_back("Red"); // Добавление элементов в конец списка
   lstOne.push_back("Green");
   lstOne.push_back("Blue");

   lstTwo.push_front("Orange"); //Добавление элементов в начало
   lstTwo.push_front("Yellow");
   lstTwo.push_front("Fuschia");
   Помещение элементов вlistзанимает постоянное время, а неамортизированное постоянное время,как в случае сvector.Реализацииlistне требуется периодически изменять размер буфера, так что в них не будет возникать периодических падений производительности, как при использованииvector.listпросто должен обновить набор указателей, и больше ничего.
   Для удаления элементов из начала или концаlistиспользуйтеpop_frontилиpop_back (без аргументов). Несмотря на их имя, методы «pop» не возвращают извлекаемый элемент, как это можно ожидать, исходя из обычной семантики стеков.
   Обычноlistвыглядит так, как показано на рис. 6.2. Каждый узел содержит (по меньшей мере) три части: объект, в нем содержащийся, указатель на предыдущий узел и указатель на следующий узел. В оставшейся части рецепта я буду ссылаться на указатели на следующий и предыдущий узлы какnext_иprev_. [Картинка: img_3.jpg] 
   Рис. 6.2. Список с двунаправленными связями
   Когда вы увидите, как реализованlist,станет очевидно, почему некоторые операции имеют сложность, отличную от их сложности дляvector.Добавление элемента в любое местоlistтребует только изменения указателейnext_иprev_предыдущего и следующего элементов. Приятным моментом вlistявляется то, что при вставке и удалении элементов в помощьюinsertиeraseустаревают значения только тех итераторов, которые указывают на затрагиваемый(е) объект(ы). Итераторы для других элементов не теряют актуальности.
   Методы вставки и удаления — этоinsertиerase,insertв качестве первого аргумента принимает итератор, а в качестве второго — либо объект типаT,либо количество и затем объект типаT,либо начальный и конечный итераторы. Первый аргумент-итератор указывает на элемент, непосредственно перед которым должна произойти вставка. Перегрузкиinsertиспользуются вот так.
   list&lt;string&gt; strlst;
   list&lt;string&gt;::iterator p;
   // ...
   string s = "Scion";
   p = find(strLst.begin(), strLst.end(), // std::findиз&lt;algorithm&gt;
    "Toyota");
   strLst.insert(p, s);     // Вставить s сразу перед p
   strLst.insert(p, 16, s); //Вставить 16 копий s непосредственно перед p
   strLst insert(p, myOtherStrLst.begin(), //Вставить все, что содержится
    myOtherStrLst.end());                  // в myOtherStrLst, перед p
   Удаление элементов аналогично.
   p = find(strLst.begin(), strLst.end(), // std::findиз&lt;algorithm&gt;
    "Toyota");
   strLst1.erase(p); //Удаляем этот элемент
   strLst2.erase(p, strLst.end()); //Удаляем от p до конца
   strLst3.clear(); //Удаляем все элементы
   В дополнение к методам стандартных контейнеровlistпредоставляет несколько своих. Первый — этоsplice.
   spliceделает то, что означает его имя: он объединяет дваlistв один. Вот как можно объединитьlstTwoсlstOneиз примера 6.5.
   list&lt;string&gt;::iterator p = //Находим, куда вставить второй
    std::find(lstOne.begin(), // список
     lstOne.end(), "Green");
   lstOne.splice(p, lstTwo); //Вставляем lstTwo непосредственно перед "Green"
   p— это итератор, который указывает на элемент вlstOne.lstTwoвставляется вlstTwoнепосредственно передp.Как и в случае со вставкой, все, что здесь требуется сделать, — это изменить указателиnext_иprev_соответствующих узлов, так что эта операция занимает постоянное время. После объединенияlstTwoсlstOneпервый очищается, и именно поэтому этот параметр не объявлен какconst.Также можно вставить вlstOneодин элемент или диапазон элементов изlstTwo.В обоих случаях элементы, объединяемые с другим списком, удаляются из первоначального.
   Если списки отсортированы (listсодержит свой собственный методsort,std::sortсlistне работает) и требуется объединить их в один, сохранив их порядок, то вместоspliceиспользуйтеmerge.mergeобъединяет два списка в один, и если два элемента оказываются одинаковыми, то в конечную версию попадает элемент изlstOne.Как и в случае соsplice,список, переданный в качестве аргумента, по окончании объединения очищается.
   Такжеlistсодержит несколько удобных операций для удаления элементов. Представьте, что вам требуется удалить все вхождения какого-либо элемента. Все, что для этого требуется сделать, это вызватьremove,передав такой аргумент, который при сравнении с элементамиlistбудет давать(*p == item) != false,гдеp— это итераторlist.removeвызывается вот так.
   strLst.remove("Harry");
   В результате изstrLstбудут удалены все элементы, у которыхel == "Harry".Если требуется удалить элементы, которые удовлетворяют какому-либо предикату, такому как больше какого-либо значения, используйтеremove_if.
   bool inline even(int n) {
    return(n % 2 == 0);
   }

   list&lt;int&gt; intLst;

   // Fill up intLst...
   intLst.remove_if(even); //Удаляет все элементы, для которых even(*p)
                           // != false
   Если предикаты более сложные, то попробуйте использовать какие-то из функторов из&lt;functional&gt;.Например, если требуется удалить элементы, которые больше определенного значения, используйте вremove_ifобъединение изgreater (из&lt;algorithm&gt;)иbind2nd.
   intLst.remove_if(std::bind2nd(std::greater&lt;int&gt;(), 2));
   В результате этого изintLstбудут удалены все значения, которые больше 2. Эта запись несколько необычна, но ничего сложного в ней нет.bind2ndпринимает два аргумента — объект функции (назовем ееf)и значение (v)— и возвращает объект функции, который принимает один аргумент (arg)и вызываетf(arg, v).bind2nd— это простой способ делать подобные вещи без необходимости писать набор небольших функций.
   list— это хорошая альтернатива вектору, когда требуется стандартный последовательный контейнер. Другое внутреннее представлениеlistпозволяет ему обеспечить другой уровень сложности многих стандартных операций с последовательностями и несколько дополнительных операций.Смотри также
   Рецепт 6.1.
   6.6.Отображение строк на другие объектыПроблема
   Имеются объекты, которые требуется сохранить в памяти, и вы хотите хранить их по ключам типаstring.Требуется иметь возможность быстро добавлять, удалять и получать элементы (с, как максимум, логарифмической сложностью).Решение
   Для отображения ключей (string)на значения (любой тип, который подчиняется семантике значений) используйте стандартный контейнерmap,объявленный в&lt;map&gt;.Пример 6.6 показывает, как это делается.
   Пример 6.6. Создание отображения строк
   #include&lt;iostream&gt;
   #include&lt;map&gt;
   #include&lt;string&gt;

   using namespace std;

   int main() {
    map&lt;string, string&gt; strMap;
    strMap["Monday"] = "Montag";
    strMap["Tuesday"] = "Dienstag";
    strMap["Wednesday"] = "Mittwoch";
    strMap["Thursday"] = "Donnerstag";
    strMap["Friday"] = "Freitag";
    strMap["Saturday"] = "Samstag";
    // strMap.insert(make_pair("Sunday", "Sonntag"));
    strMap.insert(pair&lt;string, string&gt;("Sunday", "Sonntag"));
    for(map&lt;string, string&gt;::iterator p = strMap.begin();
     p != strMap.end(); ++p) {
     cout&lt;&lt; "English: "&lt;&lt; p-&gt;first
     &lt;&lt; German: "&lt;&lt; p-&gt;second&lt;&lt; endl;
    }
    cout&lt;&lt; endl;
    strMap.erase(strMap.find("Tuesday"));
    for (map&lt;string, string&gt;::iterator p = strMap.begin();
     p ! = strMap.end(); ++p) {
     cout&lt;&lt; "English: "&lt;&lt; p-&gt;first
     &lt;&lt; ", German: "&lt;&lt; p-&gt;second&lt;&lt; endl;
    }
   }Обсуждение
   map— это ассоциативный контейнер, который отображает ключи на значения, предоставляет логарифмическую сложность вставки и поиска и постоянную сложность удаления одного элемента. Обычно разработчики используют отображение для хранения объектов по их ключам типаstring.Именно это делает пример 6.6. В этом случае отображаемый тип является строкой, но он может быть почти чем угодно.
   Отображение объявляется вот так.
   map&lt;typename Key, //Тип ключа
    typename Value,  // Тип значения
    typename LessThanFun = std::less&lt;Key&gt;, //Функция/функтор,
                                           // используемые для сортировки
    typename Alloc = std::allocator&lt;Key&gt;&gt; //Распределитель памяти
   KeyиValue— это типы ключа и связанного значения, которые хранятся в отображении.LessThanFun— это функция или функтор, который принимает два аргумента и возвращает истину, если первый меньше, чем второй. По умолчанию используется стандартный функторless.Alloc— это распределитель памяти, и по умолчанию используется стандартный.
   Использованиеmapдовольно просто. Объявите тип ключа и значения вот так.
   map&lt;string, string&gt; strMan;
   В результате будет созданmap,в котором и ключ, и значение имеют типstring.С помощьюoperator[]поместите в отображение объекты, что интуитивно и легко читаемо.
   strMap["Monday"] = Montag";
   strMap["Tuesday"] = "Dienstag";
   strMap["Wednesday"] = "Mittwoch"; // ...
   В результате вmapбудут вставлены элементы с индексом (например,"Monday")в качестве ключа и правым операндом в качестве значения. Они хранятся в порядке, определяемом параметром шаблонаLessThanFun,и если он не указан, тоmapиспользуетstd::less&lt;Key&gt;.
   Чтобы получить значения изmap,используйтеoperator[]в правой части присвоения, как здесь.
   wedInGerman = strMap["Wednesday"];
   В манере всех стандартных контейнеров значение, связанное с ключом"Wednesday",с помощьюoperator=копируется в объектwedInGerman.
   operator[]— это удобный способ вставки или обновления элементов или получения значений из map, но он имеет побочный эффект, который может оказаться неожиданным. Строго говоря,operator[k]возвращает ссылку на значение, ассоциированное сk— независимо от того, существует лиkвmapили нет. Еслиkуже находится вmap,то возвращается ассоциированное с ним значение. Если нет, тоkвставляется, а затем используется конструктор по умолчанию, который создает объект значения для этого ключа. Чтобы сделать это более понятным, рассмотрим, что делает следующий код.
   map&lt;string, string&gt; mapZipCodes;     // Сейчас здесь ноль элементов
   string myZip = mapZipCodes["Tempe"]; //В map пока что нет элементов,
                                        // но чему теперь равно count()?
   Что находится вmyZipи сколько теперь элементов вmapZipCodes?Так какoperator[]вставляет указанный ключ, если он не существует,myZipсодержит пустую строку, а вmapZipCodesсодержится один элемент. Это может оказаться нежелательно, но независимо от вашего желания помните, чтоoperator[]не являетсяconst-методом: всегда есть вероятность того, что он изменит состояниеmap,добавив узел.
   Методinsertпредоставляет альтернативный метод добавления пар в отображение,insertвыполняет строгую вставку, а не вставку/обновление, какoperator[].При использовании map (но неmultimap,который может содержать дублирующиеся ключи)insert,если ключ уже существует, не делает ничего. По сравнению с нимoperator[],если ключ уже существует, заменяет значение объекта для этого ключа на новое.
   Но синтаксис вставки требует несколько большей работы, чемoperator[],и он связан с тем, какmapхранит данные. Рассмотрим строку из примера 6.6.
   strMap.insert(std::make_pair("Sunday", "Sonntag"));
   mapхранит пары ключ/значение в объектеpair,pair— это простой вспомогательный шаблон класса (объявленный в&lt;utility&gt;и включенный в&lt;map&gt;),который хранит два значения двух типов. Чтобы объявитьpairиз двухstring,сделайте так.
   pair&lt;string, string&gt; myPair;
   Первый и второй элементы вpairдоступны по открытым членамfirstиsecond.При использовании для доступа к элементамmapоператораoperator[]обычно работать сpairне приходится, но в случае со многими другими методами это придется делать, так что следует знать, как создавать и использовать объектыpair.Например, итераторы разыменовываются в простые объектыpair,так что при их использовании, как это делается в примере 6.6, следует знать, как получить ключ и его значение.
   for (map&lt;string, string&gt; iterator p = strMap.begin();
    p != strMap.end(); ++p)
    cout&lt;&lt; "English: "&lt;&lt; p-&gt;first
    &lt;&lt; ", German: "&lt;&lt; p-&gt;second&lt;&lt; endl;
   Ключ хранится вfirst,а значение хранится вsecond.
   Однако это не объясняет, почему я использовалmake_pair.make_pair— это вспомогательный шаблон функции, который создает объектpairна основе двух переданных в него аргументов. Некоторые предпочитают этот подход вызову конструктораpair,так как шаблон класса не может догадаться о типах своих аргументов, в то время как шаблон функции может. Таким образом, эти две строки кода функционально эквивалентны.
   strMap.insert(std::make_pair("Sunday", "Sonntag"));
   strMap.insert(std::pair&lt;string, string&gt;("Sunday", "Sonntag"));
   mapне допускает наличия дублирующихся ключей. Если требуется разрешить дублирование ключей, следует использоватьmultimap,который являетсяmap,разрешающим наличие несколько одинаковых ключей. Его интерфейс идентиченmap,но поведение методов в необходимых случаях отличается. В табл. 6.1 приведен перечень методов, которые есть в одном, но отсутствуют в другом, и пояснения различий в поведении общих методов, map иmultimapсодержат несколькоtypedef,которые описывают различные значения, хранящиеся в них. В табл. 6.1 они используются следующим образом:
   key_type
   Это тип ключа. Вstring map,объявленном какmap&lt;string, MyClass*&gt;,key_typeдолжен бытьstring.
   mapped_type
   Это тип значения, на которое отображается ключ. Вstring map,объявленном какmap&lt;string, MyClass*&gt;,mapped_typeдолжен бытьMyClass*.
   value_type
   Это тип объекта, содержащего ключ и значение, которой, применительно кmapиmultimap,являетсяpair&lt;const key_type, mapped_type&gt;.

   Табл. 6.1. map и multimapМетодmap, multimapили обаПоведениеT& operator[] (const key_type& k)mapВозвращает ссылку на объект значения, сохраненный с ключомk.Еслиkв map отсутствует, то он добавляется, а объект значения создается с помощью конструктора по умолчаниюiterator insert(const value_type& v) pair&lt;iterator, bool&gt; insert(const value_type& v)ОбаПервая версия вставляетvвmultimapи возвращает итератор, который указывает на вставленную паруpair.Вторая версия вставляетvиmapпри условии, что вmapеще не содержится ключа, равногоv.Возвращаемаяpairсодержит итератор который указывает на вставленнуюpair,если произошла вставка, иbool,указывающий, была ли вставка успешнойiterator find(const key_type& k)ОбаВозвращает итератор илиconst_iterator,который указывает на mapped_type,соответствующийk.Вmultimapне гарантируется, что возвращаемый итератор будет указывать на первое значение, соответствующееk.Если ключа, равного k, нет, то возвращаемый итератор равенend()
   Также табл 6.1 показывает разницу в поведении междуmapиmultimap.
   Еслиoperator[]вам не подходит, т.е. другой способ найти ключ вmap.Для этого можно использовать методfind.
   map&lt;string, string&gt;::const_iterator p
    = strMap.find("Thursday");

   if (p != strMap.end())
    cout&lt;&lt; "Thursday = "&lt;&lt; p-&gt;second&lt;&lt; endl;
   Но не забудьте, что при использованииmultimapне гарантируется, что возвращаемый элемент будет первым элементом с ключом, равным искомому. Если нужен первый элемент, чей ключ не меньше определенного значения или не больше определенного значения, используйтеlower_boundилиupper_bound.lower_boundвозвращает итератор, указывающий на первую пару ключ/значение, равную или большую, чем аргументkey_type.Другими словами, если вашmapсодержит дни недели, как в примере 6.6, следующий код вернет итератор, который указывает на пару, содержащую"Friday"и"Freitag".
   p = strMap.lower_bound("Foo");
   if (p != strMap.end())
    cout&lt;&lt; p-&gt;first&lt;&lt; " = "&lt;&lt; p-&gt;second&lt;&lt; endl;
   Это происходит благодаря тому, что первый ключ больше или равен"Foo".upper_boundработает аналогично, но с противоположным условием.
   В начале этого обсуждения я упоминал, что элементы в map хранятся в отсортированном по ключам порядке, так что при переборе отbeginдоendкаждый элемент будет «больше», чем предшествующий (а вmultimap— больше или равен ему) Но при использовании более сложных ключей, чемstringили числа, может потребоваться указать, как при вставке элементов в отображение следует сравнивать ключи.
   По умолчанию ключи хранятся с помощью стандартного функтораless (объявленного в&lt;functional&gt;).less— это двоичная функция (принимает два аргумента одинакового типа), которая возвращаетbool,указывающий на то, больше ли первый аргумент, чем второй, или нет. Другими словами,less(a, b)возвращаетa&lt; b.Если это не то, что вам требуется, создайте свой собственный функтор и объявитеmapс его помощью. Например, если в качестве ключа используется объектPersonи каждыйPersonимеет имя и фамилию, то может потребоваться сравнивать фамилии и имена. Пример 6.7 показывает способ сделать это.
   Пример 6.7. Использование собственного функтора сортировки
   #include&lt;iostream&gt;
   #include&lt;map&gt;
   #include&lt;string&gt;

   using namespace std;

   class Person {
    friend class PersonLessThan;
   public:
    Person(const string& first, const string& last) :
     lastName_(last), firstName_(first) {}
    // ...
    string getFirstName() const {return(firstName_);}
    string getLastName() const {return(lastName_);}
   private:
    string lastName_;
    string firstName_;
   };

   class PersonLessThan {
   public:
    bool operator()(const Person& per1,
     const Person& per2) const {
     if (per1.lastName_&lt; per2. lastName_)      // Сравнить фамилии,
      return(true);                             // а затем
     else if (per1.lastName_ == per2.lastName_) // имена
      return(per1.firstName_&lt; per2.firstName_);
     else
      return(false);
    }
   };

   int main() {
    map&lt;Person, string, PersonLessThan&gt; personMap;
    Person per1("Billy", "Silly"),
     per2("Johnny", "Goofball"),
     per3("Frank", "Stank"),
     реr4("Albert", "Goofball");
    personMap[per1] = "cool";
    personMap[per2] = "not cool";
    personMap[per3] = "not cool";
    personMap[per4] = "cool";
    for (map&lt;Person, string, PersonLessThan&gt;::const_iterator p =
     personMap.begin(); p != personMap.end(); ++p) {
     cout&lt;&lt; p-&gt;first.getFirstName()&lt;&lt; " "&lt;&lt; p-&gt;first.getLastName()
     &lt;&lt; " is "&lt;&lt; p-&gt;second&lt;&lt; endl;
    }
   }
   map— это прекрасный способ хранить пары ключ/значение. После того как вы поймете поведение его частей, таких какoperator[]и хранение данных (в виде объектовpair&lt;Key, Value&gt;),mapпредоставит простоту в использовании и высокую производительность.Смотри также
   Рецепт 6.7.
   6.7.Использование хеш-контейнеровПроблема
   Требуется сохранить ключи и значения, обеспечив постоянное время доступа к элементам, и не требуется хранения элементов в упорядоченном виде.Решение
   Используйте один из связанных с хешами контейнеров —hash_mapилиhash_set.Однако помните, что они не входят в число стандартных контейнеров, определяемых стандартом С++, а представляют собой расширения, включаемые большинством реализаций стандартной библиотеки. Пример 6.8 показывает, как использоватьhash_set.
   Пример 6.8. Хранение строк в hash_set
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;hash_set&gt;

   int main() {
    hash_set&lt;std::string&gt; hsString;
    string s = "bravo";
    hsString.insert(s);
    s = "alpha";
    hsString.insert(s);
    s = "charlie";
    hsString.insert(s);
    for (hash set&lt;string&gt;::const_iterator p = hsString.begin();
     p != hsString.end(); ++p)
     cout&lt;&lt; *p&lt;&lt; endl; //заметьте, что здесь не гарантируется хранение
                         // в упорядоченном виде
   }Обсуждение
   Контейнеры, основанные на хешах, — это популярные во всех языках структуры данных, и прискорбно, что стандарт C++ не требует их реализации. Однако если требуется использовать хеш-контейнер, то не все потеряно: высока вероятность, что используемая вами реализация стандартной библиотеки содержитhash_mapиhash_set,но тот факт, что они не стандартизованы, означает, что их интерфейсы могут отличаться от одной реализации стандартной библиотеки к другой. Я опишу хеш-контейнеры, которые поставляются в составе реализации стандартной библиотеки STLPort.
    [Картинка: tip_yellow.png] STLPort— это свободно распространяемая переносимая реализация стандартной библиотеки, существующая уже довольно длительное время и предоставляющая хеш-контейнеры. При использовании другой библиотеки интерфейс может быть другим, но общая идея будет той же самой.
   Главной особенностью хеш-контейнеров (называемых во многих книгах по ассоциативными хеш-контейнерами) является то, что они в общем случае предоставляют постоянное время поиска, вставки и удаления элементов, а в худшем случае эти операции имеют линейное время. Ценой постоянного времени выполнения этих операций является то, что в хеш-контейнере они хранятся в неупорядоченном виде, как вmap.
   Посмотрите на пример 6.8. Использование хеш-контейнера (в данном случаеhash_set)довольно просто — объявите его как большинство других контейнеров и начните вставлять в него элементы.
   hash_set&lt;string&gt; hsString; // hash_setстрок
   string s = "bravo";
   hsString.insert(s); //Вставка копии s
   Использованиеhash_mapаналогично, за исключением того, что требуется, как минимум, указать типы данных используемых ключей и значений. Это аналогичноmap.
   hash_map&lt;string, string&gt;
   hmStrings; //Отображение строк на строки
   string key = "key";
   string val = "val";
   hmStrings[key] = val;
   Это только основы использования хеш-контейнеров. Также имеется набор параметров шаблона, которые позволяют указать используемую хеш-функцию, функцию, проверяющую ключи на эквивалентность, и объект, используемый для распределения памяти. Я опишу их немного позже.
   В большинстве библиотек есть четыре хеш-контейнера, и они похожи на другие ассоциативные контейнеры стандартной библиотеки (т.е.mapиset).Этоhash_map,hash_multimap,hash_setиhash_multiset.хеш-контейнеры реализуются с помощью хеш- таблицы. Хеш-таблица — это структура данных, которая обеспечивает постоянное время доступа к элементам, используя для этого хеш-функцию перехода к месту, близкому к хранению искомого объекта, а не проход по древовидной структуре. Разница междуhash_mapиhash_setсостоит в том, как данные хранятся в хеш-таблице.
   Объявления контейнеров, использующих хеш-таблицу, в STLPort выглядят так.
   hash_map&lt;Key,             // Тип ключа
    Value,                   // Тип значения,
                             // связанного с ключом
    HashFun = hash&lt;Key&gt;,     // Используемая хеш-функция
    EqualKey = equal_to&lt;Key&gt; //Функция, используемая для
                             // проверки равенства ключей
    Alloc = alloc&gt;;          // Используемый распределитель памяти

   hash_set&lt;Key,              // Тип ключа
    HashFun = hash&lt;Key&gt;,      // Используемая хеш-функция
    EqualKey = equal_to&lt;Key&gt;, //Функция, используемая для
                              // проверки равенства ключей
    Alloc = alloc&gt;;           // Используемый распределитель памяти
   hash_map— это хеш-таблица, которая хранит значения как объектыpair&lt;const Key, Data&gt;.Это означает, что когда я буду далее описывать хеш-таблицы, «элементы» в таблице будут означать пары ключ/значение.hash_mapне хранит ключи значение по отдельности (как и map).hash_setпросто хранит ключ как значение.
   Параметр шаблонаHashFun— это функция, которая превращает объекты типаKeyв значения, которые могут быть сохранены какsize_t.Более подробно это описывается ниже. Параметр шаблонаEqualKey— это функция, которая принимает два аргумента и, если они эквивалентны, возвращаетtrue.В контейнерахhash_mapиhash_setдва ключа не могут быть равны,hash_multimapиhash_multisetмогут содержать по нескольку одинаковых ключей. Как и в случае с другими контейнерами,Alloc— это используемый распределитель памяти.
   Хеш-таблица содержит две части. В ней есть относительно большой вектор, где каждый индекс это «участок». Каждый из участков является на самом деле указателем на первый узел в относительно коротком одно- или двухсвязном списке (в STLPort — односвязном). Именно в этих списках и хранятся данные. Чтобы получить число участков в хеш-контейнере, используйте методbucket_count.Рисунок 6.3 дает представление о том, как выглядит в памяти хеш-отображение. [Картинка: img_4.jpg] 
   Рис. 6.3. Хеш-таблица
   Рассмотрим использованиеhash_setиз примера 6.8. При вставке элемента контейнер вначале должен определить, к какому участку он относится. Это делается с помощью вызова хеш-функции контейнера, передачи в нее ключа (хеш-функция обсуждается немного позже) и вычисления остатка от деления значения на число участков. В результате получается индекс в векторе участков.
   Если вы незнакомы с тем, что такое «хеширование», то это очень простая концепция. Если есть какое-то значение (скажем, массив типаchar),то хеш-функция для него — это функция, которая принимает один аргумент и возвращает значение хеша типаsize_t (т.е. число). В идеале требуется хеш-функция, которая генерирует уникальные значения хешей, но она не обязана это делать. Эта функция в математическом смысле неоднозначна: несколько строк типа string могут иметь одно и то же значение хеша. Далее я скажу, почему это не страшно.
   STLPortвключает в&lt;hash_map&gt;и&lt;hash_set&gt;такую хеш-функцию как шаблон функции. Однако эта функция не работает для любого объекта, так как невозможно создать общей хеш-функции, которая бы работала с любым вводом. Вместо этого имеется несколько специализированных встроенных типов, наиболее часто используемых для ключей в хеш-таблицах. Например, если требуется посмотреть, как выглядит значение хеша, хешируйте строку символов.
   std::hash&lt;const char*&gt; hashFun;
   std::cout&lt;&lt; "\"Hashomatic\"хешируется как "
    &lt;&lt; hashFun("Hashomatic")&lt;&lt; '\n';
   Вы увидите что-то похожее на следующее.
   "Hashomatic"хешируется как 189555649
   STLPortпредоставляет специализации для следующих типов:char*,const char*,char,unsigned char,signed char,short,unsigned short,int,unsigned int,longиunsigned long.Кажется, что их очень много, но в целом это означает, что библиотека содержит встроенные хеш-функции, которые поддерживают символьные строки и числа. Если требуется хешировать что-то другое, то просто укажите собственную хеш-функцию.
   При помещении элемента в хеш-таблицу она определяет, какому участку принадлежит элемент, используя оператор взятия остатка от деления и число участков, т.е.hashFun(key) % bucket_count().Это быстрый оператор, который указывает непосредственно на индекс в главном векторе, по которому начинается участок.
   Хеш-контейнер можно использовать как обычный ассоциативный контейнер, используя для добавления элементов в, скажем,hash_mapоператорoperator[].Разница заключается в том, что вы знаете, что вставка и поиск займут постоянное время, а не логарифмическое. Рассмотрим пример 6.9, который содержит простой класс, отображающий имена логинов на объектыSession.Он использует некоторые из возможностей хеш-контейнеров, описываемых в этом рецепте.
   Пример 6.9. Простой менеджер сессий
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;hash_map&gt;

   using namespace std;

   class Session { /* ... */ };

   //Облегчение читаемости с помощью typedef
   typedef hash_map&lt;string, Session*&gt; SessionHashMap;

   class SessionManager {
   public:
    SessionManager() : sessionMap_(500) {} // Инициализация хеш-таблицы
                                           // 500-ми участками

    ~SessionManager() {
     for (SessionHashMap::iterator p = sessionMap_.begin();
      p != sessionMap_.end(); ++p)
      delete (*p).second; // Удаление объекта Session
    }

    Session* addSession(const string& login) {
     Session* p = NULL;
     if (!(p = getSession(login))) {
      p = new Session();
      sessionMap_[login] = d; // Присвоение новой сессии с помощью
     }                        // operator[]
     return(p);
    }

    Session* getSession(const string& login) {
     return(sessionMap_[login]);
    }
    // ...

   private:
    SessionHashMap sessionMap_;
   };
   Каждый ключ отображается на единственный участок, а в участке может храниться несколько ключей. Участок это обычно одно- или двухсвязный список.
   По хеш-функциям и таблицам написано огромное количество книг. Если вы заинтересовались этим вопросом, поищите в Google «C++ hash function».Смотри также
   Рецепт 6.6.
   6.8.Хранение объектов в упорядоченном видеПроблема
   Требуется сохранить набор объектов в заданном порядке, например с целью доступа к упорядоченным диапазонам этих объектов без их пересортировки при каждом таком обращении.Решение
   Используйте ассоциативный контейнерset,объявленный в&lt;set&gt;,который хранит элементы в упорядоченном виде. По умолчанию он использует стандартный шаблон классаless (который для своих аргументов вызываетoperator&lt;),а можно передать в него собственный предикат сортировки. Пример 6.10 показывает, как сохранить строки вset.
   Пример 6.10. Хранение строк в set
   #include&lt;iostream&gt;
   #include&lt;set&gt;
   #include&lt;string&gt;

   using namespace std;

   int main() {
    set&lt;string&gt; setStr;
    string s = "Bill";
    setStr.insert(s);
    s = "Steve";
    setStr.insert(s);
    s = "Randy";
    setStr.insert(s);
    s = "Howard";
    setStr.insert(s);
    for (set&lt;string&gt;::const_iterator p = setStr.begin();
     p != setStr.end(); ++p)
     cout&lt;&lt; *p&lt;&lt; endl;
   }
   Так как значения хранятся в упорядоченном виде, вывод будет выглядеть так.
   Bill
   Howard
   Randy
   SteveОбсуждение
   set (набор) — это ассоциативный контейнер, который предоставляет логарифмическую сложность вставки и поиска и постоянную сложность удаления элементов (если требуется удалить найденный элемент),set— это уникальный ассоциативный контейнер, что означает, что никакие два элемента не могут быть равны, однако если требуется хранить несколько экземпляров одинаковых элементов, используйтеmultiset,setможно представить как набор в математическом смысле, т.е. коллекцию элементов, в дополнение обеспечивающую поддержание определенного порядка элементов.
   Поддерживаются вставка и поиск элементов, но, как и список, набор не позволяет производить произвольный доступ к элементам. Если требуется получить что-то из набора, то можно найти элемент с помощью методаfindили перебрать элементы с помощьюset&lt;T&gt;::iteratorилиset&lt;T&gt;::const_iterator.Объявление набора имеет знакомый вид.
   set&lt;typename Key,                       // Тип элемента
    typename LessThanFun = std::less&lt;Key&gt;, //Функция/Функтор
                                           // используемый для сортировки
    typename Alloc = std::allocator&lt;Key&gt;&gt; //Распределитель памяти
   УказыватьKeyтребуется всегда, иногда требуется предоставить собственнуюLessThanFun,а указывать собственный распределитель требуется очень редко (так что я не буду здесь его описывать).
   Параметр шаблонаKey— это, как и в случае с другими стандартными контейнерами, тип сохраняемых элементов. Дляsetон определяется черезtypedefкакset&lt;Key&gt;::key_type,так что доступ к нему есть при выполнении программы. КлассKeyдолжен обеспечивать конструктор копирования и присвоение, и все.
   Пример 6.10 показывает, как использоватьsetдля строк. Использование набора для хранения объектов других типов работает точно так же — объявите набор с именем класса в качестве параметра шаблона.
   std::set&lt;MyClass&gt; setMyObjs;
   Это все, что требуется сделать для использования набора простейшим образом. Но в большинстве случаев жизнь не будет такой простой. Например, при сохранении в наборе указателей использовать предикат сортировки по умолчанию нельзя, так как он просто отсортирует объекты по их адресам. Чтобы гарантировать, что элементы будут отсортированы правильно, требуется создать собственный предикат, выполняющий сравнение «меньше чем». Пример 6.11 показывает, как это делается.
   Пример 6.11. Хранение указателей в set
   #include&lt;iostream&gt;
   #include&lt;set&gt;
   #include&lt;string&gt;
   #include&lt;functional&gt;
   #include&lt;cassert&gt;

   using namespace std;

   //Класс для сравнения строк, переданных через указатели
   struct strPtrLess {
    bool operator()(const string* p1,
     const string* p2) {
     assert(p1&& p2);
     return(*p1&lt; *p2);
    }

    int main() (
     set&lt;string*, strPtrLess&gt; setStrPtr; //Передаем специальный
                                         // «меньше чем» функтор
    string s1 = "Tom";
    string s2 = "Dick";
    string s3 = "Harry";
    setStrPtr.insert(&s1);
    setStrPtr.insert(&s2);
    setStrPtr.insert(&s3);
    for (set&lt;string*, strPtrLess&gt;::const_iterator p =
     setStrPtr.begin(); p != setStrPtr.end(); ++p)
     cout&lt;&lt; **p&lt;&lt; endl; //Разыменовываем итератор и то, на что
                          // он указывает
   }
   strPtrLessвозвращает истину, если строка, на которую указываетp1,меньше, чем та, на которую указываетp2.Это делает его двоичным предикатом, так как он принимает два аргумента и возвращаетbool.Так какoperator&lt;определен дляstring,для сравнения я использую именно его. На самом деле, если требуется использовать более общий подход, используйте для предиката сравнения шаблон класса
   template&lt;typename T&gt;
   class ptrLess {
   public:
    bool operator()(const T* p1,
     const T* p2) {
     assert(p1&& p2);
     return(*p1&lt; *p2);
    }
   };
   Это работает для указателей на любые объекты, для которых определенoperator&lt;.Объявление набора с его использованием имеет такой вид.
   set&lt;string*, ptrLess&lt;string&gt;&gt; setStrPtr;
   setподдерживает многие из функций, поддерживаемых другими стандартными последовательными контейнерами (например,begin,end,size,max_size)и другими ассоциативными контейнерами (например,insert,erase,clear,find).
   При использованииsetпомните, что при каждом изменении состояния набора выполняется его сортировка. Когда число его элементов велико, логарифмическая сложность добавления или удаления элементов может оказаться очень большой — вам действительно требуется, чтобы объекты сортировались каждый раз? Если нет, то для повышения производительности используйтеvectorилиlistи сортируйте его только тогда, когда это необходимо, что обычно имеет сложность порядка n*log(n).
   6.9.Хранение контейнеров в контейнерахПроблема
   Имеется несколько экземпляров стандартного контейнера (list,setи т.п.) и требуется сохранить их в еще одном контейнере.Решение
   Сохраните в главном контейнере указатели на остальные контейнеры. Например, можно использоватьmapдля хранения ключа типаstringи указателя наsetкак значения. Пример 6.12 показывает простой класс журналирования транзакций, который хранит данные как map из пар, состоящих изstringи указателей наset.
   Пример 6.12. Хранение набора указателей в отображении
   #include&lt;iostream&gt;
   #include&lt;set&gt;
   #include&lt;map&gt;
   #include&lt;string&gt;

   using namespace std;

   typedef set&lt;string&gt; SetStr
   typedef map&lt;string, SetStr*&gt; MapStrSetStr;

   //Фиктивный класс базы данных
   class DBConn {
   public:
    void beginTxn() {}
    void endTxn() {}
    void execSql(string& sql) {}
   };

   class SimpleTxnLog {
   public:
    SimpleTxrLog() {}
    ~SimpleTxrLog() {purge();}

    // Добавляем в список выражение SQL
    void addTxn(const string& id
     const string& sql) {
     SetStr* pSet = log_[id]; // Здесь создается запись для
     if (pSet == NULL) {      // данного id, если ее еще нет
      pSet = new SetStr();
      log_[id] = pSet;
     }
     pSet-&gt;insert(sol);
    }

    // Применение выражений SQL к базе данных, по одной транзакции
    // за один раз
    void apply() {
     for (MapStrSetStr::iterator p = log_.begin();
      p != log_.end(); ++p) {
      conn_-&gt;beginTxn();
      // Помните, что итератор отображения ссылается на объект
      // типа pair&lt;Key,Val&gt;.Указатель на набор хранится в p-&gt;second.
      for (SetStr::iterator pSql = p-&gt;second-&gt;begin();
       pSql != p-&gt;second-&gt;end(); ++pSql) {
       string s = *pSql;
       conn_-&gt;execSql(s);
       cout&lt;&lt; "Executing SQL: "&lt;&lt; s&lt;&lt; endl;
      }
      conn_-&gt;endTxn();
      delete p-&gt;second;
     }
     log_.clear();
    }

    void purge() {
     for (MapStrSetStr::iterator p = log_.begin();
      p != log_.end(); ++p)
      delete p-&gt;second;
     log_.clear();
    }
    //...

   private:
    MapStrSetStr log_;
    DBConn* conn_;
   };Обсуждение
   Пример 6.12 предлагает ситуацию, где может потребоваться хранение одного контейнера в другом. Представьте, что требуется сохранить набор выражений SQL в виде пакета, выполнить их в будущем все сразу для реляционной базы данных. Именно это делаетSimpleTxnLog.Чтобы сделать его еще полезнее, можно добавить в него другие методы, а для обеспечения безопасности — добавить обработку исключений, но целью этого примера является показать, как хранить один тип контейнеров в другом.
   Для начала я создаю несколькоtypedef,облегчающих чтение кода.
   typedef std::set&lt;std::string&gt; SetStr;
   typedef std::map&lt;std::string, SetStr*&gt; MapStrSetStr;
   При использовании шаблонов шаблонов (шаблонов… и т.д.) объявления становятся очень длинными, что затрудняет их чтение, так что облегчите себе жизнь, использовавtypedef.Более того, использованиеtypedefоблегчает внесение изменений в объявление шаблонов, избавляя от необходимости выполнять поиск и замену во многих местах большого количества исходных файлов.
   КлассDBConn— это фиктивный класс, который представляет подключение к реляционной базе данных. Интересно здесь то, как вSimpleTxnLogопределяется методaddTxn.В начале этой функции я смотрю, существует ли уже объект набора для переданногоid.
   SetStr* pSet = log_[id];
   log_— этоmap (см. рецепт 6.6), так чтоoperator[]выполняет поискidи смотрит, связаны ли с ним какие-либо данные. Если да, то возвращается объект данных, иpSetне равенNULL.Если нет, он создается, и возвращается указатель, который будет равенNULL.Затем я проверяю, указывает ли на что-тоpSet,и определяю, требуется ли создать еще один набор.
   if (pSet == NULL) {
    pSet = new SetStr(); // SetStr = std::set&lt;std::string&gt;
    log_[id] = pSet;
   }
   Так какpSet— это копия объекта данных, хранящихся в map (указатель на набор), а не само значение, то после созданияsetя должен поместить его обратно в связанный с ним ключ вmap.После этого все, что остается сделать, — это добавить элемент в набор и выйти.
   pSet-&gt;insert(sql);
   Выполнив указанные шаги, я в один контейнер (map)добавил указатель на адрес другого контейнера (set).Что я не делал — это добавлениеобъектаsetвmap.Разница очень существенна. Так как контейнеры обладают семантикой копирования, следующий код приведет к копированию всего набораsвmap.
   set&lt;string&gt; s;
   //Заполнить s данными...
   log_[id] = s; //Скопировать s и добавить его копию в log_
   Это приведет к огромному числу дополнительных нежелательных копирований. Следовательно, общее правило при использовании контейнеров из контейнеров — это использоватьуказателина контейнеры.
   Глава 7
   Алгоритмы
   7.0.Введение
   Эта глава рассказывает, как работать со стандартными алгоритмами и как использовать их для стандартных контейнеров. Эти алгоритмы первоначально являлись частью того, что часто называется Standard Template Library (STL — стандартная библиотека шаблонов) и представляет собой набор алгоритмов, итераторов и контейнеров, которые теперь вошли в стандартную библиотеку (глава 6 содержит рецепты по работе со стандартными контейнерами). Я их буду называть просто стандартными алгоритмами, итераторами и контейнерами, но не забывайте, что это то же самое, что другие авторы называют частью STL. Одним из базовых элементов стандартной библиотеки являются итераторы, так что первый рецепт описывает, что они собой представляют и как их использовать. После этого идет несколько рецептов, которые объясняют, как использовать и расширять стандартные алгоритмы. Наконец, если вы не нашли ничего подходящего в стандартной библиотеке, то рецепт 7.10 расскажет, как написать собственный алгоритм.
   Представленные здесь рецепты в основном предназначены для работы со стандартными контейнерами, и тому есть две причины. Во-первых, стандартные контейнеры очень распространены, и лучше изучить стандарт, чем изобретать колесо. Во-вторых, реализация алгоритмов из стандартной библиотеки предоставляет хороший пример для подражания в смысле взаимодействия и производительности. Если вы посмотрите, как профессионалы выполнили код стандартной библиотеки, вы, скорее всего, узнаете много нового и полезного для себя.
   Все стандартные алгоритмы используют итераторы. Даже если вы знакомы с концепцией итераторов, которые рассматриваются в первом рецепте, посмотрите на табл. 7.1, которая содержит перечень соглашений, используемых в остальных рецептах главы при демонстрации объявлений функций стандартных алгоритмов.

   Табл. 7.1. Сокращения категорий итераторовСокращениеЗначениеInInput iterator (Итератор ввода)OutOutput iterator (Итератор вывода)FwdForward iterator (Однонаправленный итератор)BidBidirectional iterator (Двунаправленный итератор)RandRandom-access iterator (Итератор произвольного доступа)
   Стандартные алгоритмы также используют функциональные объекты, илифункторы.Функциональный объект — это класс, который переопределяетoperator()так, что его можно вызвать как функцию. Функтор, который возвращаетbool (и не поддерживает состояния, и, следовательно, называетсячистым (pure),называетсяпредикатом (predicate),и он является еще одной обычной функциональной особенностью стандартных алгоритмов. Обычно предикат принимает один или два аргумента: если он принимает один аргумент, то этоунарныйпредикат, а если два — тобинарныйпредикат. Для краткости я при демонстрации объявлений функций использую сокращения, приведенные в табл. 7.2.

   Табл. 7.2. Типы функторовИмя типаОписаниеUnPredУнарный предикат. Принимает один аргумент и возвращает boolBinPredБинарный предикат. Принимает два аргумента и возвращает boolUnFuncУнарная функция. Принимает один аргумент и возвращает некое значениеBinFuncБинарная функция. Принимает два аргумента и возвращает некое значение
   В большинстве случаев там, где требуется аргумент в виде функтора, может использоваться указатель на функцию. При использовании термина «функтор» я также подразумеваю указатель на функцию, если не указано иного.
   7.1.Перебор элементов контейнераПроблема
   Имеется диапазон итераторов — скорее всего, из стандартного контейнера — и стандартные алгоритмы не удовлетворяют вашим требованиям, так что вам требуется выполнить итерации самостоятельно.Решение
   Для доступа к элементам контейнера и перехода от одного элемента к другому используйтеiteratorилиconst_iterator.В стандартной библиотеке алгоритмы и контейнеры взаимодействуют с помощью итераторов, и одной из базовых идей стандартных алгоритмов является то, что они избавляют вас от необходимости непосредственного использования итераторов, за исключением тех случаев, когда вы пишете собственный алгоритм. И даже в этом случае вы должны понимать различные типы итераторов с тем, чтобы эффективно использовать стандартные алгоритмы и контейнеры. Пример 7.1 представляет некоторые простые способы использования итераторов.
   Пример 7.1. Использование итераторов с контейнерами
   #include&lt;iostream&gt;
   #include&lt;list&gt;
   #include&lt;algorithm&gt;
   #include&lt;string&gt;

   using namespace std;

   static const int ARRAY_SIZE = 5;

   template&lt;typename T, typename FwdIter&gt;
   FwdIter fixOutliersUBound(FwdIter p1,
    FwdIter p2, const T& oldVal, const T& newVal) {
    for ( ; p1 != p2; ++p1) {
     if (greater&lt;T&gt;(*p1, oldVal)) {
      *p1 = newVal;
     }
    }
   }

   int main() {
    list&lt;string&gt; lstStr;
    lstStr.push_back("Please");
    lstStr.push_back("leave");
    lstStr.push_back("a");
    lstStr.push_back("message");
    // Создать итератор для последовательного перебора элементов списка
    for (list&lt;string&gt;::iterator p = lstStr.begin();
     p != lstStr.end(); ++p) {
     cout&lt;&lt; *p&lt;&lt; endl;
    }
    // Или можно использовать reverse_iterator для перебора от конца
    // к началу, rbegin возвращает reverse_iterator, указывающий
    // на последний элемент, a rend возвращает reverse_iterator, указывающий
    // на один-перед-первым.
    for (list&lt;string&gt;::reverse_iterator p = lstStr.rbegin();
     p != lstStr.rend(); ++p) {
     cout&lt;&lt; *p&lt;&lt; endl;
    }
    // Перебор диапазона элементов
    string arrStr[ARRAY_SIZE] = {"My", "cup", "cup", "runneth", "over"};
    for (string* p =&arrStr[0];
     p !=&arrStr[ARRAY_SIZE]; ++p) {
     cout&lt;&lt; *p&lt;&lt; endl;
    }
    // Использование стандартных алгоритмов со стандартной последовательностью
    list&lt;string&gt; lstStrDest;
    unique_copy(&arrStr[0],&arrStr[ARRAY_SIZE],
     back_inserter(lstStrDest));
   }Обсуждение
   Итератор — это тип, который используется для ссылки на единственный объект в контейнере. Стандартные контейнеры используют итераторы как основной механизм для доступа к содержащимся в них элементам. Итератор ведет себя как указатель; для доступа к объекту, на который указывает итератор, вы его разыменовываете (с помощью операторов*или-&gt;),а для перевода итератора вперед или назад используется синтаксис, аналогичный арифметике указателей. Однако есть несколько причин, по которым итератор — это не то же самое, что указатель. Однако перед тем, как я покажу их, давайте рассмотрим основы использования итераторов.Использование итераторов
   Итератор объявляется с помощью типа, элементы которого с его помощью будут перебираться. Например, в примере 7.1 используетсяlist&lt;string&gt;,так что итератор объявляется вот так.
   list&lt;string&gt;::iterator p = lstStr.begin();
   Если вы не работали со стандартными контейнерами, то часть этого объявления::iteratorможет выглядеть несколько необычно. Это вложенный в шаблон классаlist typedef,предназначенный именно для этой цели — чтобы пользователи контейнера могли создать итератор для данного конкретного экземпляра шаблона. Это стандартное соглашение, которому следуют все стандартные контейнеры. Например, можно объявить итератор дляlist&lt;int&gt;или дляset&lt;MyClass&gt;,как здесь.
   list&lt;int&gt;::iterator p1;
   set&lt;MyClass&gt;::iterator p2;
   Возвращаясь обратно к нашему примеру, итератор о инициализируется первым элементом последовательности, который возвращается методомbegin.Чтобы перейти к следующему элементу, используетсяoperator++.Можно использовать как префиксный инкремент так и постфиксный инкремент (p++),аналогично указателям на элементы массивов, но префиксный инкремент не создает временного значения, так что он более эффективен и является предпочтительным. Постфиксный инкремент (p++)должен создавать временную переменную, так как он возвращает значениеpдо его инкрементирования. Однако он не может инкрементировать значение после того, как вернет его, так что он вынужден делать копию текущего значения, инкрементировать текущее значение, а затем возвращать временное значение. Создание таких временных переменных с течением времени требует все больших и больших затрат, так чтоесли вам не требуется именно постфиксное поведение, используйте префиксный инкремент.
   Как только будет достигнут элементend,переход на следующий элемент следует прекратить. Или, строго говоря, когда будет достигнут элемент, следующий заend.В отношении стандартных контейнеров принято некое мистическое значение, которое представляет элемент, идущий сразу за последним элементом последовательности, и именно оно возвращается методомend.Этот подход работает в циклеfor,как в этом примере:
   for (list&lt;string&gt;::iterator p = lstStr.begin();
    p != lstStr.end(); ++p) {
    cout&lt;&lt; *p&lt;&lt; endl;
   }
   Как толькоpстанет равенend,pбольше не может увеличиваться. Если контейнер пуст, тоbegin == endравноtrue,и тело цикла никогда не выполнится. (Однако для проверки пустоты контейнера следует использовать методempty,а не сравниватьbeginиendили использовать выражение видаsize == 0.)
   Это простое объяснение функциональности итераторов, но это не все. Во-первых, как только что было сказано, итератор работает какrvalueилиlvalue,что означает, что его разыменованное значение можно присваивать другим переменным, а можно присвоить новое значение ему. Для того чтобы заменить все элементы в списке строк, можно написать нечто подобное следующему
   for (list&lt;string&gt;::iterator p = lstStr.begin();
    p != lstStr.end(); ++p) {
    *p = "mustard";
   }
   Так как*pссылается на объект типаstring,для присвоения элементу контейнера новой строки используется выражениеstring::operator=(const char*).Но что, еслиlstStr — это объект типаconst?В этом случаеiteratorне работает, так как его разыменовывание дает не-const объект. Здесь требуется использоватьconst_iterator,который возвращает толькоrvalue.Представьте, что вы решили написать простую функцию для печати содержимого контейнера. Естественно, что передавать контейнер следует какconst-ссылку.
   template&lt;typename T&gt;
   void printElements(const T& cont) {
    for(T::const_iterator p = cont.begin();
     p ! = cont.end(); ++p) {
     cout&lt;&lt; *p&lt;&lt; endl;
    }
   }
   В этой ситуации следует использовать именноconst, aconst_iteratorпозволит компилятору не дать вам изменить*p.
   Время от времени вам также может потребоваться перебирать элементы контейнера в обратном порядке. Это можно сделать с помощью обычногоiterator,но также имеетсяreverse_iterator,который предназначен специально для этой задачи.reverse_iteratorведет себя точно так же, как и обычныйiterator,за исключением того, что его инкремент и декремент работают противоположно обычномуiteratorи вместо использования методовbeginиendконтейнера с ним используются методыrbeginиrend,которые возвращаютreverse_iterator.reverse_iteratorпозволяет просматривать последовательность в обратном порядке. Например, вместо инициализацииreverse_iteratorс помощьюbeginон инициализируется с помощьюrbegin,который возвращаетreverse_iterator,указывающий на последний элемент последовательности.operator++перемещает его назад — по направлению к началу последовательности,rendвозвращаетreverse_iterator,который указывает на элемент, находящийся перед первым элементом. Вот как это выглядит.
   for (list&lt;string&gt;::reverse_iterator p = lstStr.rbegin();
    p != lstStr.rend(); ++p) {
    cout&lt;&lt; *p&lt;&lt; endl;
   }
   Но может возникнуть ситуация, когда использоватьreverse_iteratorневозможно. В этом случае используйте обычныйiterator,как здесь.
   for (list&lt;string&gt;::iterator p = --lstStr.end();
    p != --lstStr.begin(); --p) {
    cout&lt;&lt; *p&lt;&lt; endl;
   }
   Наконец, если вы знаете, на сколько элементов вперед или назад следует выполнить перебор, используйте вычисление значения, на которое следует перевести итератор. Например, чтобы перейти в середину списка, сделайте вот так.
   size_t i = lstStr.size();
   list&lt;string&gt;::iterator p = begin();
   p += i/2; //Переход к середине последовательности
   Но помните: в зависимости от типа используемого контейнера эта операция может иметь как постоянную, так и линейную сложность. При использовании контейнеров, которые хранят элементы последовательно, таких какvectorилиdeque,iteratorможет перейти на любое вычисленное значение за постоянное время. Но при использовании контейнера на основе узлов, такого какlist,такая операция произвольного доступа недоступна. Вместо этого приходится перебирать все элементы, пока не будет найден нужный. Это очень дорого. Именно поэтому выбор контейнера, используемого в каждой конкретной ситуации, определяется требованиями к перебору элементов контейнера и их поиска в нем. (За более подробной информацией о работе стандартных контейнеров обратитесь к главе 6.)
   При использовании контейнеров, допускающих произвольный доступ, для доступа к элементам использованияoperator[]с индексной переменной следует предпочитатьiterator.Это особенно важно при написании обобщенного алгоритма в виде шаблона функции, так как не все контейнеры поддерживаютiteratorс произвольным доступом.
   С итератором можно делает еще много чего, но не с любымiterator.iteratorможет принадлежать к одной из пяти категорий, обладающих разной степенью функциональности. Однако они не так просты, как иерархия классов, так что именно это я далее и опишу.Категории итераторов
   Итераторы, предоставляемые различными типами контейнеров, не обязательно все умеют делать одно и то же. Например,vector&lt;T&gt;::iteratorпозволяет использовать для перехода на некоторое количество элементов впередoperator+=,в то время какlist&lt;T&gt;::iteratorне позволяет. Разница между этими двумя типами итераторов определяется ихкатегорией.
   Категории итераторов — это, по сути, интерфейс (не технически; для реализации категорий итераторов абстрактные базовые классы не используются). Имеется пять категорий, и каждая предлагает увеличение возможностей. Вот как они выглядят — от наименее до наиболее функциональной.
   Input iterator (Итератор ввода)
   Итератор ввода поддерживает переход вперед с помощьюp++или++pи разыменовывание с помощью*p.При его разыменовывании возвращаетсяrvalue,iteratorввода используется для таких вещей, как потоки, где разыменовывание итератора ввода означает извлечение очередного элемента из потока, что позволяет прочесть только один конкретный элемент.
   Output iterator (Итератор вывода)
   Итератор вывода поддерживает переход вперед с помощьюp++или++pи разыменовывание с помощью*p.От итератора ввода он отличается тем, что из него невозможно читать, а можно только записывать в него — по одному элементу за раз. Также, в отличие от итератора ввода, он возвращает неrvalue, alvalue,так что в него можно записывать значение, а извлекать из него — нельзя.
   Forward iterator (Однонаправленный итератор)
   Однонаправленный итератор объединяет функциональность итераторов ввода и вывода: он поддерживает++pиp++,а*pможет рассматриваться какrvalueилиlvalue.Однонаправленный итератор можно использовать везде, где требуется итератор ввода или вывода, используя то преимущество, что читать из него и записывать в него после его разыменовывания можно без ограничений
   Bidirectional iterator (Двунаправленный итератор)
   Как следует из его названия, двунаправленныйiteratorможет перемещаться как вперед, так и назад. Это однонаправленныйiterator,который может перемещаться назад с помощью--pилиp--.
   Random-access iterator (Итератор произвольного доступа)
   Итератор произвольного доступа делает все, что делает двунаправленныйiterator,но также поддерживает операции, аналогичные операциям с указателями.. Для доступа к элементу, расположенному в позицииnпослеpпоследовательности, можно использоватьp[n],можно складывать его значение или вычитать из него с помощью+,+=,-или-=,перемещая его вперед или назад на заданное количество элементов. Также с помощью&lt;,&gt;,&lt;=или&gt;=можно сравнивать два итератораp1иp2,определяя их относительный порядок (при условии, что они оба относятся к одной и той же последовательности).
   Или можно представить все в виде диаграммы Венна. Она представлена на рис. 7.1. [Картинка: img_5.jpg] 
   Рис. 7.1. Категории итераторов
   Большая часть стандартных контейнеров поддерживает как минимум двунаправленныйiterator,некоторые (vectorиdeque)предоставляютiteratorпроизвольного доступа. Категория итератора, поддерживаемая контейнером, определяется стандартом.
   В большинстве случае вы будете использоватьiteratorдля простейших задач: поиск элемента и его удаление или что-либо подобное. Для этой цели требуется только однонаправленныйiterator,который доступен для всех контейнеров. Но когда потребуется написать нетривиальный алгоритм или использовать алгоритм из стандартной библиотеки, часто потребуется нечто большее, чем простой однонаправленныйiterator.Но как определить, что вам требуется? Здесь на сцену выходят категории итераторов.
   Различные категории итераторов позволяют стандартным (и нестандартным) алгоритмам указать диапазон требуемой функциональности. Обычно стандартные алгоритмы работают с диапазонами, указываемыми с помощью итераторов, а не с целыми контейнерами. Объявление стандартного алгоритма говорит, какую категориюiteratorон ожидает». Например,std::sortтребует итераторов произвольного доступа, так как ему требуется за постоянное время ссылаться на несмежные элементы. Таким образом, объявлениеsortвыглядит вот так.
   template&lt;typename RandomAccessIterator&gt;
   void sort(RandomAccessIterator first, RandomAccessIterator last);
   По имени типа итератора можно определить, что он ожидает итератор произвольного доступа. Если попробовать откомпилироватьsortдля категории итератора, отличной от произвольного доступа, то она завершится ошибкой, так как младшие категорииiteratorне реализуют операций, аналогичных арифметике с указателями.
   Категория итератора, предоставляемая определенным контейнером и требуемая определенным стандартным алгоритмом, — это то, что определяет, какой алгоритм с каким контейнером может работать. Многие из стандартных алгоритмов описаны далее в этой главе. Таблица 7.1 показывает сокращения, используемые в остальной части главы дляуказания типов итераторов, принимаемых алгоритмами в качестве аргументов.
   Этот рецепт описывал итераторы, как они используются для контейнеров. Но шаблон итераторов используется не только для контейнеров, и, таким образом, имеются другие типы итераторов. Имеются потоковые итераторы, итераторы буферов потоков и итераторы хранения в необработанном виде, но они здесь не описываются.Смотри также
   Глава 6.
   7.2.Удаление объектов из контейнераПроблема
   Требуется удалить объекты из контейнера.Решение
   Для удаления одного или диапазона элементов используйте метод контейнера erase или один из стандартных алгоритмов. Пример 7.2 показывает пару различных способов удаления элементов из последовательностей.
   Пример 7.2. Удаление элементов из контейнера
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;list&gt;
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include "utils.h" //Для printContainer(): см. 7.10

   using namespace std;

   int main() {
    list&lt;string&gt; lstStr;
    lstStr.push_back("On");
    lstStr.push_back("a");
    lstStr.push_back("cloudy");
    lstStr.push_back("cloudy");
    lstStr.push_back("day");
    list&lt;string&gt;::iterator p;
    // Найти то что требуется, с помощью find
    p = find(lstStr.begin(), lstStr.end(), "day");
    p = lstStr.erase(p); // Теперь p указывает на последний элемент
    // Или для удаления всех вхождений чего-либо используйте remove
    lstStr.erase(remove(lstStr.begin(), lstStr.end(), "cloudy"),
     listStr.end());
    printContainer(lstStr); // См. 7.10
   }Обсуждение
   Для удаления одного или нескольких элементов из контейнера используйте методerase.Все контейнеры содержат два перегруженныхerase:один принимает единственный аргументiterator,который указывает на элемент, который требуется удалить, а другой принимает два аргумента, которые представляют диапазон удаляемых элементов. Чтобы удалить один элемент, получитеiterator,указывающий на этот элемент, и передайте этотiteratorвerase,как в примере 7.2.
   p = find(lstStr.begin(), lstStr.end(), "day");
   p = lstStr.erase(p);
   В результате объект, на который указываетp,будет удален, для чего будет вызван его деструктор, а после этого оставшиеся элементы будут реорганизованы. Реорганизация зависит от типа контейнера, и, следовательно, сложность этой операции от контейнера к контейнеру будет различаться. Сигнатура и поведение при использовании последовательного контейнера и ассоциативного контейнера также будут различаться.
   В последовательностяхeraseвозвращаетiterator,который ссылается на первый элемент, следующий непосредственно за последним удаленным элементом, что может оказатьсяend,если был удален последний элемент последовательности. Сложность этой операции для каждого контейнера различна, так как последовательности реализованы по- разному. Например, из-за того, что все элементыvectorхранятся в непрерывном фрагменте памяти, удаление из него элемента, кроме первого и последнего, с целью заполнения образовавшегося промежутка требует сдвига всехпоследующих элементов в сторону начала. Это приводит к значительному снижению производительности (в линейном отношении), и именно по этой причине не следует использоватьvector,если требуется удалять (или вставлять, что в данном случае приводит к таким же последствиям) элементы где-либо, кроме концов. Более подробно этот вопрос обсуждается в рецепте 6.2.
   В ассоциативных контейнерахeraseвозвращаетvoid.При удалении одного элемента сложность имеет вид амортизированной константы, а при удалении диапазона — логарифмической зависимости плюс количество удаляемых элементов. Причина этого заключается в том, что ассоциативные контейнеры часто реализуются как сбалансированные деревья (например, красно-черное дерево).
   eraseудобен, но не интересен. Если требуется большая гибкость в выражении того, что требуется удалить, следует обратить внимание на стандартные алгоритмы (из&lt;algorithm&gt;).Рассмотрим такую строку из примера 7.2.
   lstStr.erase(std::remove(lstStr.begin(), lstStr.end(), "cloudy"),
    lstStr.end());
   Обратите внимание, что я используюerase,но на этот раз по какой-то причине мне требуется удалить изlist&lt;string&gt;все вхождения слова «cloudy»,removeвозвращаетiterator,который передается вeraseкак начало удаляемого диапазона, aendпередается вeraseкак конечная точка диапазона. В результате удаляются все объектыobj (вызывая их методdelete)из диапазона, для которогоobj == "cloudy"равно истине. Но поведение этой строки может оказаться не совсем таким, как ожидается. Здесь мне требуется пояснить некоторую терминологию.
   removeна самом деле ничегоне удаляет.Он перемещает все, что не равно указанному значению, в начало последовательности и возвращаетiterator,который ссылается на первый элемент, следующий за этими перемещенными элементами. Затем вы должны вызватьeraseдля контейнера, чтобы удалить объекты между [p, end),гдеp— этоiterator,возвращенныйremove.
   removeтакже имеет несколько вариантов. Что, если требуется удалить элементы, которые удовлетворяют некоторому предикату, а не просто равны какому-то значению? Используйтеremove_if.Например, представьте, что есть класс с именемConn,который представляет какой-то тип соединений. Если это соединение простаивает больше определенного значения, его требуется удалить. Во-первых, создайте функтор, как здесь.
   struct IdleConnFn :
    public std::unary_function&lt;const Conn, bool&gt; { //Включите эту строку,
    bool operator() (const Conn& c) const {        // чтобы он работал с
     if (с.getIdleTime()&gt; TIMEOUT) {              // другими объектами из
      return(true);                                //&lt;functional&gt;
     } else return(false);
    }
   } idle;
   Затем вызовитеremove_ifс erase и передайте в него новый функтор, как здесь.
   vec.erase(std::remove_if(vec.begin(), vec.end(), idle), vec.end());
   Есть причина, по которой такие функторы следует наследовать отunary_function,unary_functionопределяет несколькоtypedef,используемых другими функторами из&lt;functional&gt;,и если они их не найдут, то другие функторы не скомпилируются. Например, если вы очень злы и хотите удалить все не задействованные в данный момент соединения, то в функторе проверки на простой можно использовать функторnot1.
   vec.erase(std::remove_if(vec.begin(), vec.end(); std::not1(idle)),
    vec.end());
   Наконец, вам может потребоваться сохранить первоначальную последовательность (может, с помощьюconst)и скопировать результаты, кроме некоторых элементов, в новую последовательность. Это можно сделать с помощьюremove_copyиremove_copy_if,которые работают аналогично remove иremove_if,за исключением того, что здесь также требуется передаватьiteratorвывода, в который будут записываться результирующие данные. Например, чтобы скопировать из одного списка в другой строку, сделайте так.
   std::remove_copy(lstStr.begin(), lstStr.end(), lstStr2, "cloudy");
   При использованииremove_copyили любого стандартного алгоритма, записывающего в выходной диапазон, следует помнить, что выходной диапазон должен уже быть достаточно большим, чтобы в нем поместились элементы, которые туда будут записываться.
   eraseиremove (и связанные с ними алгоритмы) предлагают удобный способ удалять определенные элементы последовательностей. Они предоставляют простую альтернативу самостоятельному перебору и поиску нужных элементов с последующим их удалением по одному.Смотри также
   Рецепты 6.2 и 7.1.
   7.3.Случайное перемешивание данныхПроблема
   Имеется последовательность данных и требуется перемешать их так, чтобы они были расположены в случайном порядке.Решение
   Используйте стандартный алгоритмrandom_shuffle,определенный в&lt;algorithm&gt;.random_shuffleпринимает два итератора произвольного доступа и (необязательно) функтор генератора случайных чисел и реорганизует случайным образом элементы заданного диапазона. Пример 7.3 показывает, как это делается.
   Пример 7.3. Случайное перемешивание последовательностей
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;algorithm&gt;
   #include&lt;iterator&gt;
   #include "utils.h" //Для printContainer(): см. 7.10

   using namespace std;

   int main() {
    vector&lt;int&gt; v;
    back_insert_iterator&lt;std::vector&lt;int&gt;&gt; p = back_inserter(v);
    for (int i = 0; i&lt; 10; ++i) *p = i;
    printContainer(v, true);
    random_shuffle(v.begin(), v.end());
    printContainer(v, true);
   }
   Вывод должен выглядеть примерно так.
   -----
   0123456789
   -----
   8192057346Обсуждение
   random_shuffleочень прост в использовании. Дайте ему диапазон, и он перемешает этот диапазон случайным образом. Имеется две версии, и их прототипы выглядят так.
   void random_shuffle(RndIter first, RndIter last);
   void random_shuffle(RndIter first, RndIter last, RandFunc& rand);
   В первой версии используется зависящая от реализации функция генерации случайных чисел, которой должно быть достаточно для большинства задач. Если ее недостаточно — например, требуется неоднородное распределение, такое, как гауссово — то можно написать собственную функцию, которую можно передать во вторую версию.
   Этот генератор случайных чисел должен быть функтором с единственным аргументом, возвращающим единственное значение, и оба они должны преобразовываться вiterator_traits&lt;RndIter&gt;::difference_type.В большинстве случаев для этого подойдет целое число. Например, вот мой псевдогенератор случайных чисел.
   struct RanNumGenFtor {
    size_t operator()(size_t n) const {
     return(rand() % n);
    }
   } rnd;

   random_shuffle(v.begin(), vend(), rnd);
   Приложенияrandom_shuffleограничены последовательностями, которые предоставляют итераторы случайного доступа (string,vectorиdeque),массивами или собственными контейнерами, удовлетворяющими этому требованию. Перемешать случайным образом ассоциативный контейнер невозможно, так как его содержимое всегда хранится в упорядоченном виде. На самом деле для ассоциативных контейнеров не всегда можно использовать алгоритм, изменяющий его диапазон (и который часто называется видоизменяющим (mutating)алгоритмом).
   7.4.Сравнение диапазоновПроблема
   Имеется два диапазона и требуется сравнить их на равенство или определить, какой из них меньше, чем другой, основываясь на каком-либо порядке сортировки элементов.Решение
   В зависимости от типа выполняемого сравнения используйте один из стандартных алгоритмов —equal,lexicographical_compareилиmismatch,определенных в&lt;algorithm&gt;.Пример 7.4 показывает некоторые из них в действии.
   Пример 7.4. Различные типы сравнения
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;string&gt;
   #include&lt;algorithm&gt;
   #include "utils.h"

   using namespace std;
   using namespace utils;

   int main() {
    vector&lt;string&gt; vec1, vec2;
    vec1.push_back("Charles");
    vec1.push_back("in");
    vec1.push_back("Charge");
    vec2.push_back("Charles");
    vec2.push_back("in");
    vec2.push_back("charge"); // Обратите внимание на строчную "с"
    if (equal(vec1.begin(), vec1.end(), vec2.begin())) {
     cout&lt;&lt; "Два диапазона равны!"&lt;&lt; endl;
    } else {
     cout&lt;&lt; "Два диапазона HE равны!"&lt;&lt; endl;
    }
    string s1 = "abcde";
    string s2 = "abcdf";
    string s3 = "abc";
    cout&lt;&lt; boolalpha //Отображает логические значения как "true" или "false"
    &lt;&lt; lexicographical_compare(s1.begin(), s1.end(),
      s1.begin(), s1.end())&lt;&lt; endl;
    cout&lt;&lt; lexicographical_compare(s1.begin(), s1.end(),
     s2.begin(), s2.end())&lt;&lt; endl;
    cout&lt;&lt; lexicographical_compare(s2.begin(), s2.end(),
     s1.begin(), s1.end())&lt;&lt; endl;
    cout&lt;&lt; lexicographical_compare(s1.begin(), s1.end(),
     s3.begin(), s3.end())&lt;&lt; endl;
    cout&lt;&lt; lexicographical_compare(s3.begin(), s3.end(),
     s1.begin(), s1.end())&lt;&lt; endl;
    pair&lt;string::iterator, string::iterator&gt; iters =
     mismatch(s1.begin(), s1.end(), s2.begin());
    cout&lt;&lt; "first mismatch = "&lt;&lt; *(iters.first)&lt;&lt; endl;
    cout&lt;&lt; "second mismatch = "&lt;&lt; *(iters.second)&lt;&lt; endl;
   }
   Вывод примера 7.4 выглядит так.
   Два диапазона НЕ равны!
   false
   true
   false
   false
   true
   first mismatch = e
   second mismatch = fОбсуждение
   Для сравнения двух последовательностей на равенство используйтеequal.Он принимает три или четыре аргумента, в зависимости от используемой версии. Вот как объявленequal.
   bool equal(In1 first1, In1 last1, In2 first2);
   bool equal(In1 first1, In1 last1, In2 first2, BinPred pred);
   equalс помощьюoperator==сравнивает каждый элемент междуfirst1иlast1с элементами, начиная сfirst2.Если указатьpred,тоequalдля проверки будет использовать его. Перед вызовомequalубедитесь, что каждая последовательность имеет одинаковую длину. Он предполагает, что второй диапазон не меньше первого, и если это не так, то его поведение не определено.
   Если требуется узнать, где и как последовательности отличаются, используйтеlexicographical_compareилиmismatch.lexicographical_compareсравнивает две последовательности и возвращает истину, если первая лексикографически меньше второй, что означает, что каждая пара элементов в двух последовательностях сравнивается с помощью оператора&lt;.Объявлениеlexicographical_compareвыглядит вот так.
   bool lexicographical_compare(In1 first1, In1 last1,
    In2 first2, In2 last2);
   bool lexicographical_compare(In1 first1, In1 last1,
    In2 first2, In2 last2, Compare comp);
   Еслиoperator&lt;возвращает истину или первая последовательность заканчивается раньше второй, то возвращается истина. В противном случае возвращается ложь. Рассмотрим последовательность символов из примера 7.4.
   string s1 = "abcde";
   string s2 = "abcdf";
   string s3 = "abc";
   lexicographical_compare(s1.begin(), s1.end(), // abcde&lt; abcde
    s1.begin(), s1.end());                       // = false
   lexicographical_compare(s1.begin(), s1.end(), // abcde&lt; abcdf
    s2.begin(s2.end());                          // = true
   lexicographical_compare(s2.begin(), s2.end(), // abcdf&lt; abcde
    s1.begin(), s1.end());                       // = false
   lexicographical_compare(s1.begin(), s1.end(), // abcde&lt; abc
    s3.begin(s3.end());                          // = false
   lexicographical_compare(s3.begin(), s3.end(), // abc&lt; abcde
    s1.begin(), s1.end());                       // = true
   Сложностьlexicographical_compareлинейна и выполняет число сравнений, равное длине меньшей из двух последовательностей, или до тех пор, пока один из элементов в одной из последовательностей не окажется меньше соответствующего элемента другой. Сравнения реализованы полностью на основеoperator&lt;,так что еслиiter1иiter2— это итераторы двух последовательностей, то сравнение останавливается тогда, когда*iter1&lt; *iter2или*iter2&lt; *iter1.
   mismatchговорит, где две последовательности различаются. Однако его объявление несколько отличается отequalиlexicographical_compare,так как он возвращает неbool, apair&lt;&gt;итераторов. Вот оно.
   pair&lt;In1, In2&gt; mismatch(In1 first1, In1 last1, In2 first2);
   pair&lt;In1, In2&gt; mismatch(In1 first1, In1 last1, In2 first2, BinPred);
   Два возвращаемых итератора указывают на различные элементы каждой из последовательностей. Рассмотрим пример 7.4.
   string s1 = "abcde";
   string s2 = "abcdf";
   pair&lt;string::iterator, string::iterator&gt; iters =
    mismatch(s1.begin(), s1.end(), s2.begin());
   cout&lt;&lt; "first mismatch = "&lt;&lt; *(iters.first)&lt;&lt; '\n'; // 'e'
   cout&lt;&lt; "second mismatch = "&lt;&lt; *(iters.second)&lt;&lt; '\n'; // 'f'
   Вы должны убедиться, что длина второго диапазона не меньше первого. Если вторая последовательность короче первой,mismatchне сможет узнать этого и продолжит выполнение сравнения элементов за границей второй последовательности, что приведет к непредсказуемому поведению. Кроме того, если несовпадений нет, то первый итератор будет указывать наlast1,который может оказаться недействительным (например, если в качествеlast1передатьend().
   Вы, должно быть, заметили по объявлениям каждой из этих функций, что типы итераторов для каждой из этих последовательностей различны. Это означает, что две последовательности могут быть контейнерами разных типов, но при условии, что типы элементов, на которые указывают итераторы, имеют определенный для нихoperator&lt;.Например, можно сравниватьstringиvector&lt;char&gt;.
   string s = "Coke";
   vector&lt;char&gt; v;
   v.push.back('c');
   v.push_back('o');
   v.push_back('k');
   v.push_back('e');
   std::cout&lt;&lt; std::lexicographical_compare(s.begin(), s.end(),
    v.begin(), v.end())&lt;&lt; '\n';
   Здесь каждый символ двух последовательностей сравнивается вне зависимости от типа контейнера, в которых они хранятся.
   Стандартная библиотека C++ предоставляет несколько различных способов сравнения последовательностей. Если ни один из них вам не подходит, посмотрите на их исходный код — он является хорошим примером того, как надо писать собственные эффективные обобщенные алгоритмы.Смотри также
   Рецепт 7.1.
   7.5.Объединение данныхПроблема
   Имеется две отсортированные последовательности и их требуется объединить.Решение
   Используйте либо шаблон функцииmerge,либо шаблон функцииinplace_merge.mergeобъединяет две последовательности и помещает результат в третью, ainplace_mergeобъединяет две последовательно расположенные последовательности. Пример 7.5 показывает, как это делается.
   Пример 7.5. Объединение двух последовательностей
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;list&gt;
   #include&lt;vector&gt;
   #include&lt;algorithm&gt;
   #include&lt;iterator&gt;
   #include "utils.h" //Для printContainer(): см. 7.10

   using namespace std;

   int main() {
    vector&lt;string&gt; v1, v2, v3;
    v1.push_back("a");
    v1.push_back("c");
    v1.push_back("e");
    v2.push_back("b");
    v2.push_back("d");
    v2.push_back("f");
    v3.reserve(v1.size() + v2.size() + 1);
    // Используйте back_inserter от итератора, чтобы избежать необходимости
    // помещать в контейнер набор объектов по умолчанию. Но это не означает,
    // что не требуется использовать reserve!
    merge(v1.begin(), v1.end(), v2.begin(), v2.end(),
     back_inserter&lt;vector&lt;string&gt;&gt;(v3));
    printContainer(v3);
    // Теперь выполняем действия
    random_shuffle(v3.begin(), v3.end());
    sort(v3.begin(), v3.begin() + v3.size() / 2);
    sort(v3.begin() + v3.size() / 2, v3.end());
    printContainer(v3);
    inplace_merge(v3.begin(), v3.begin() + 3, v3.end());
    printContainer(v3);
    // Однако если используется два списка, используйте list::merge.
    // Как правило, ...
    list&lt;string&gt; lstStr1, lstStr2;
    lstStr1.push_back("Frank");
    lstStr1.push_back("Rizzo");
    lstStr1.push_back("Bill");
    lstStr1.push_back("Cheetoh");
    lstStr2.push_back("Allie");
    lstStr2.push_back("McBeal");
    lstStr2.push_back("Slick");
    lstStr2.push_back("Willie");
    lstStr1.sort(); // Отсортировать, иначе объединение выдаст мусор!
    lstStr2.sort();
    lstStr1.merge(lstStr2); // Заметьте, что это работает только для другого
                            // списка того же типа
    printContainer(lstStr1);
   }
   Вывод примера 7.5 выглядит так.
   -----
   a
   b
   с
   d
   e
   f
   -----
   b
   d
   e
   a
   c
   f
   -----
   a
   b
   с
   d
   e
   f
   Allie
   Bill
   Cheetoh
   Frank
   McBeal
   Rizzo
   Slick
   WillieОбсуждение
   mergeобъединяет две последовательности и помещает результат в третью — опционально используя функтор сравнения, указанный пользователем и определяющий, когда один элемент меньше другого, а по умолчанию используяoperator&lt;.Сложность линейна: число выполняемыхmergeсравнений равно сумме длин двух последовательностей минус один. Типы элементов в обеих последовательностях должны быть сравниваемы с помощьюoperator&lt; (или указанного вами функтора сравнения) и должны быть преобразуемы к типу элементов выходной последовательности при помощи конструктора копирования или присвоения; или должен быть определен оператор преобразования, определенный так, чтобы тип элементов выходной последовательности имел для обоих типов операторы присвоения и конструкторы копирования.
   Объявленияmergeвыглядят вот так
   void merge(In1 first1, In1 last1, In2 first2, In2 last2, Out result);
   void merge(In1 first1, In1 last1, In2 first2, In2 last2, Out result,
    BinPred comp)
   Использованиеmergeдовольно просто. Обе последовательности должны быть отсортированы (иначе вывод будет представлять собой мусор), и ни одна из них при использованииmergeне изменяется. Итератор вывода, в который помещаются результаты, должен иметь достаточно места для помещения в него числа элементов, равного сумме длин входных последовательностей. Этого можно добиться, явно зарезервировав достаточно места либо, как это сделано в примере 7.5, использовавback_inserter:
   merge(v1.begin(), v1.end(), v2.begin(), v2.end(),
    back_inserter(v3));
   back_inserter— это класс, определенный в&lt;iterator&gt;,который предоставляет удобный способ создания выходного итератора, который каждый раз, когда ему присваивается значение, вызывает для последовательности методpush_back.Таким образом, вам не требуется явно изменять размер выходной последовательности. Следующий вызов создаетback_inserterдляvector&lt;string&gt;с именемv3.
   back_inserter(v3);
   Указывать аргументы шаблона не требуется, так какback_inserter— это шаблон функции, а не класса, так что тип аргументов, с которыми он вызван, определяется автоматически. Эквивалентный вызов с явным указанием аргументов шаблона выглядит вот так.
   back_inserter&lt;vector&lt;string&gt;&gt;(v3);
   Однако заметьте, что иногда вам потребуется явно указывать размер выходной последовательности, особенно при использовании в качестве такой последовательностиvector,vectorпри добавлении в него элементов с помощьюpush_backможет потребовать изменений своего размера, а это очень дорогостоящая операция. За подробностями обратитесь к рецепту 6.2.
   Если в последовательностях есть два одинаковых элемента, то элемент из первой последовательности будет предшествовать элементу из второй. Следовательно, если дважды вызватьmerge,поменяв для второго вызова последовательности местами, результирующие выходные последовательности будут различаться (предсказуемо и правильно, но различаться).
   Объединение двухlist— это хороший пример ситуации, где можно использовать метод последовательности или аналогичный стандартный алгоритм. Следует предпочесть метод стандартному алгоритму, делающему то же самое, но это не всегда работает, и вот пример, который показывает, почему.
   Рассмотрим список строк из примера 7.5:
   lstStr1.sort(); //Сортируем, или объединение даст мусор!
   lstStr2.sort(),
    lstStr1.merge(lstStr2); // Это list::merge
   Есть две причины, по которым этот код отличается от вызоваstd::merge.Во-первых, оба спискаlistдолжны иметь один и тот же тип элементов. Это требование следует из объявленияlist::merge,которое имеет вид:
   void merge(list&lt;T, Alloc&gt;& lst);
   template&lt;typename Compare&gt;
   void merge(list&lt;T, Alloc&gt;& lst, Compare comp)
   ГдеT— это такой же тип, как и в самом шаблоне класса списка. Так что, например, невозможно объединить список из символьных массивов с завершающим нулем со списком из строк типаstring.
   Второе отличие состоит в том, чтоlist::mergeстирает входную последовательность, в то время какstd::mergeоставляет две входные последовательности неизменными. Скорее всегоlist::mergeбудет обладать лучшей производительностью, так как в большинстве случаев элементы списка не копируются, а перекомпонуются, но такая перекомпоновка не гарантируется, так что с целью выяснения реального поведения требуются эксперименты.
   Также объединить две непрерывные последовательности можно с помощьюinplace_merge.inplace_mergeотличается отmerge,так как он объединяет две последовательности «на месте». Другими словами, если есть две непрерывные последовательности (т.е. они являются частями одной и той же последовательности) и они отсортированы и требуется отсортировать общую последовательность, то вместо алгоритма сортировки можно использоватьinplace_merge.Преимуществоinplace_mergeзаключается в том, что при наличии достаточного объема памяти его работа занимает линейное количество времени. Если же памяти недостаточно, то он занимаетn logn,что равно средней сложности сортировки.
   Объявлениеinplace_mergeнесколько отличается от merge:
   void inplace_merge(Bid first, Bid mid, Bid last);
   void inplace_merge(Bid first, Bid mid, Bid last, BinPred comp)
   inplace_mergeтребует двунаправленных итераторов, так что он не является взаимозаменяемым с merge, но в большинстве случаев должен работать. Как иmerge,для определения относительного порядка элементов он по умолчанию используетoperator&lt;,а при наличии —comp.
   7.6.Сортировка диапазонаПроблема
   Имеется диапазон элементов, которые требуется отсортировать.Решение
   Для сортировки диапазонов имеется целый набор алгоритмов. Можно выполнить обычную сортировку (в восходящем или нисходящем порядке) с помощьюsort,определенного в&lt;algorithm&gt;,а можно использовать одну из других функций сортировки, таких какpartial_sort.Посмотрите на пример 7.6, показывающий как это сделать
   Пример 7.6. Сортировка
   #include&lt;iostream&gt;
   #include&lt;istream&gt;
   #include&lt;string&gt;
   #include&lt;list&gt;
   #include&lt;vector&gt;
   #include&lt;algorithm&gt;
   #include&lt;iterator&gt;
   #include "utils.h" //Для printContainer(): см. 7.10

   using namespace std;

   int main() {
    cout&lt;&lt; "Введите набор строк: ";
    istream_iterator&lt;string&gt; start(cin);
    istream_iterator&lt;string&gt; end; //Здесь создается "маркер"
    vector&lt;string&gt; v(start, end);
    // Стандартный алгоритм sort сортирует элементы диапазона. Он
    // требует итератор произвольного доступа, так что он работает для vector.
    sort(v.begin(), v.end());
    printContainer(v);
    random_shuffle(v.begin(), v.end()); // См. 7.2
    string* arr = new string[v.size()];
    // Копируем элементы в массив
    copy(v.begin(), v.end(),&arr[0]);
    // Сортировка работает для любого типа диапазонов, но при условии, что
    // ее аргументы ведут себя как итераторы произвольного доступа.
    sort(&arr[0],&arr[v.size()]);
    printRange(&arr[0],&arr[v.size()]);
    // Создаем список с такими же элементами
    list&lt;string&gt; lst(v.begin(), v.end());
    lst.sort(); // Самостоятельная версия sort работать не будет, здесь требуется
            // использовать list::sort. Заметьте, что невозможно отсортировать
            // только часть списка.
    printContainer(lst);
   }
   Запуск примера 7.6 может выглядеть вот так.
   Введите набор строк: a z b y c x d w
   ^Z
   -----
   a b c d w x y z
   -----
   w b y c a x z d
   -----
   a b c d w x y z
   -----
   a b c d w x y zОбсуждение
   Сортировка — это очень часто выполняющаяся операция, и есть два способа отсортировать последовательность. Можно обеспечить хранение элементов в определенном порядке с помощью ассоциативного контейнера, но при этом длительность операции вставки будет иметь логарифмическую зависимость от размера последовательности. Либо можно сортировать элементы только по мере надобности с помощьюsort,имеющей несколько опций.
   Стандартный алгоритмsortделает именно то, что от него ожидается: он сортирует элементы диапазона в восходящем порядке с помощьюoperator&lt;.Он объявлен вот так.
   void sort(Rnd first, Rnd last);
   void sort(Rnd first, Rnd last, BinPred comp);
   Как и в большинстве других алгоритмов, еслиoperator&lt;не удовлетворяет вашим требованиям, можно указать собственный оператор сравнения. В среднем случае сложность имеет зависимостьn logn.В худшем случае она может быть квадратичной.
   Если требуется, чтобы одинаковые элементы сохранили свой первоначальный порядок, используйтеstable_sort.Он имеет такую же сигнатуру, но гарантирует, что порядок эквивалентных элементов изменен не будет. Его сложность при наличии достаточного объема памяти в худшем случае составляетn logn.Если памяти недостаточно, то сложность может оказаться равнойn(logn)?.
   Однакоsortработает не для всех контейнеров. Он требует итераторов произвольного доступа, так что при использовании контейнера, не предоставляющего таких итераторов, он неприменим. Итераторы произвольного доступа предоставляют стандартные последовательные контейнерыdeque,vectorиstring/wstring (которые не являются контейнерами, но удовлетворяют большинству требований к ним),list— это единственный, который такого итератора не предоставляет. Если требуется отсортировать список, используйтеlist::sort.Например, в примере 7.6 вы, вероятно, заметили, чтоlist::sortне принимает никаких аргументов.
   lst.sort();
   Это отличает его отstd::sort,с помощью которого можно отсортировать только часть последовательности. Если требуется отсортировать часть последовательности, то не следует использоватьlist.
   Концепция сортировки очень проста, но есть несколько вариаций на тему ее реализации в стандартной библиотеке. Следующий перечень описывает эти вариации.
   partial_sort
   Принимает три итератора произвольного доступа —first,middleиlast— и (необязательно) функтор сравнения. Он имеет два постусловия: элементы диапазона (first,middle)будут меньше, чем элементы диапазона (middle,last),и диапазон (first,middle)будет отсортирован с помощьюoperator&lt;или указанного функтора сравнения. Другими словами, он сортирует только первыеnэлементов.
   partial_sort_сору
   Делает то же, что иpartial_sort,но помещает результаты в выходной диапазон. Он берет первыеnэлементов из исходного диапазона и в соответствующем порядке копирует их в результирующий диапазон. Если результирующий диапазон (n)короче, чем исходный диапазон (m),то в результирующий диапазон копируется толькоnэлементов.
   nth_element
   Принимает три итератора произвольного доступа —first,nthиlast— и необязательный функтор сравнения. Он помешает элемент, на который ссылаетсяnth,в то место, где он находился бы, если бы весь диапазон был отсортирован. Следовательно, все элементы диапазона (first,nth)будут меньше, чем элемент в позицииnth (те, что находятся в диапазоне (nth,last)не сортируются, но больше, чем те, что предшествуютnth).Этот алгоритм следует использовать тогда, когда требуется отсортировать только один или несколько элементов диапазона и избежать затрат на сортировку всего диапазона.
   Также можно разделить элементы диапазона в соответствии с каким-либо критерием (функтором), и это является предметом обсуждения рецепта 7.7.Смотри также
   Рецепт 7.7.
   7.7.Разделение диапазонаПроблема
   Имеется диапазон элементов, которые требуется каким-либо образом разделить на группы. Например, необходимо переместить в начало диапазона все элементы, которые меньше определенного значения.Решение
   Для перемещения элементов используйте стандартный алгоритмpartitionс предикатом-функтором. См. пример 7.7.
   Пример 7.7. Разделение диапазона
   #include&lt;iostream&gt;
   #include&lt;istream&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;iterator&gt;
   #include "utils.h" //Для printContainer(): см. рецепт 7.10

   using namespace std;

   int main() {
    cout&lt;&lt; "Введите набор строк: ";
    istream_iterator&lt;string&gt; start(cin);
    istream_iterator&lt;string&gt; end; //Здесь создается "маркер"
    vector&lt;string&gt; v(start, end);
    // Реорганизуем элементы в v так, чтобы те, которые меньше,
    // чем "foo", оказались перед остальными.
    vector&lt;string&gt;::iterator p =
     partition(v.begin(), v.end(),
     bind2nd(less&lt;string&gt;(), "foo"));
    printContainer(v);
    cout&lt;&lt; "*p = "&lt;&lt; *p&lt;&lt; endl;
   }
   Вывод примера 7.7 выглядит примерно так.
   Введите набор строк: a d f j k l
   ^Z
   -----
   a d f j k l
   *p = j
   После работыpartitionитераторpуказывает на первый элемент, для которогоless(*p, "foo")не равноtrue.Обсуждение
   partitionпринимает начало и конец диапазона и предикат и перемешает все элементы, для которых предикат равенtrue,в начало диапазона. Он возвращает итератор, указывающий на первый элемент, для которого предикат не равенtrue,или на конец диапазона, если все элементы удовлетворяют предикату. Он объявлен вот так.
   Bi partition(Bi first, Bi last, Pred pred);
   pred— это функтор, который принимает один аргумент и возвращаетtrueилиfalse.Предиката по умолчанию не существует — вы должны указать такой предикат, который удовлетворяет требованию разделения диапазона. При этом можно написать свой предикат, а можно использовать один из предикатов стандартной библиотеки. Например, в примере 7.7 можно видеть, что я для создания функтора использовалlessиbind2nd.
   vector&lt;string&gt;::iterator p =
   partition(v.begin(), v.end(),
   bind2nd(less&lt;string&gt;(), "foo"));
   Здесь все элементы, которые меньше"foo",перемещаются в начало последовательности.bind2ndздесь необязателен, но он удобен для автоматического создания функтора, который принимает один аргумент и возвращает результат вычисленияless&lt;string&gt;(*i, "foo")для каждого i-го элемента последовательности. Если требуется, чтобы одинаковые элементы сохранили свой первоначальный порядок, то следует использоватьstable_partition.
    [Картинка: tip_yellow.png] partitionи другие алгоритмы, которые меняют порядок элементов диапазона, не работают со стандартными ассоциативными контейнерамиset,multiset,mapиmultimap.Причиной этого является то, что ассоциативные контейнеры хранят свои элементы в упорядоченном виде и перемещать и удалять элементы разрешается только самим контейнерам. Использоватьpartitionможно с любым диапазоном, для которого можно получить, по крайней мере, двунаправленный итератор, и это выполняется для всех стандартных последовательных контейнеров, включаяdeque,vectorиlist.Смотри также
   Рецепт 7.9.
   7.8.Выполнение для последовательностей операций над множествамиПроблема
   Имеются последовательности, которые требуется реорганизовать с помощью операций над множествами, таких как объединение (union), различие (difference) или пересечение (intersection).Решение


   Для этой цели используйте специальные функции стандартной библиотеки.set_union,set_differenceиset_intersection.Каждая из них выполняет соответствующую операцию над множеством и помещает результат в выходной диапазон. Их использование показано в примере 7.8.
   Пример 7.8. Использование операций над множествами
   #include&lt;iostream&gt;
   #include&lt;algorithm&gt;
   #include&lt;string&gt;
   #include&lt;set&gt;
   #include&lt;iterator&gt;
   #include "utils.h" //Для printContainer(): см. 7.10

   using namespace std;

   int main() {
    cout&lt;&lt; "Введите несколько строк: ";
    istream_iterator&lt;string&gt; start(cin);
    istream_iterator&lt;string&gt; end;
    set&lt;string&gt; s1(start, end);
    cin.clear();
    cout&lt;&lt; "Введите еще несколько строк: ";
    set&lt;string&gt; s2(++start, end);
    set&lt;string&gt; setUnion;
    set&lt;string&gt; setInter;
    set&lt;string&gt; setDiff;
    set_union(s1.begin(), s1.end(), s2.begin(), s2.end(),
     inserter(setUnion, setUnion.begin()));
    set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
     inserter(setDiff, setDiff.begin()));
    set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),
     inserter(setInter,setInter.begin()));
    cout&lt;&lt; "Объединение:\n";
    printContainer(setUnion);
    cout&lt;&lt; "Различие:\n";
    printContainer(setDiff);
    cout&lt;&lt; "Пересечение:\n";
    printContainer(setInter);
   }
   Вывод этой программы выглядит примерно так (printContainerпросто печатает содержимое контейнера).
   Введите несколько строк: a b c d
   ^Z
   Введите еще несколько строк: d е f g
   ^Z
   Объединение: a b с d e f g
   Различие: a b c
   Пересечение: dОбсуждение
   Операции с множествами в стандартной библиотеке выглядят и работают сходным образом. Каждая принимает два диапазона, выполняет свою операцию с ними и помешает результаты в выходной итератор. Вы должны убедиться, что для выходной последовательности имеется достаточно места, или использоватьinserterилиback_inserter (как использоватьback_inserter,рассказывается в рецепте 7.5).
   Объявлениеset_unionвыглядит вот так.
   Out set_union(In first1, In last1, In first2, In last2, Out result);
   Объявленияset_difference,set_intersectionиset_symmetric_differenceвыглядят точно так же.
   Чтобы использовать эти функции, сделайте так, как показано в примере 7.8. Например, чтобы найти пересечение двух множеств, вызовитеset_intersectionвот так.
   set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),
    inserter(setInter, setInter.begin()));
   Последний аргументset_intersectionтребует некоторых пояснений,inserter— это шаблон функции, определенный в&lt;iterator&gt;,который принимает контейнер и итератор и возвращает выходной итератор, который при записи в него значения вызывает для первого аргументаinserterметодinsert.При его использовании для последовательного контейнера он вставляет значения передiterator,переданным в качестве второго аргумента. При его использовании для ассоциативного контейнера, как это делается в показанном выше фрагменте кода, этот итератор игнорируется, и элементы вставляются в соответствии с критерием сортировки контейнера.
   set— это удобный пример для наших целей, но операции над множествами работают для любых последовательностей, а не только дляset.Например, операции над множествами можно выполнить дляlist:
   list&lt;string&gt; lst1, lst2, lst3;
   //Заполняем их данными
   lst1.sort(); //Элементы должны быть отсортированы
   lst2.sort();
   set_symmetric_difference(lst1 begin(), lst1.end(),
   lst2.begin(), lst2.end(), back_inserter(lst3));
   Однако так какlistхранит данные в неотсортированном виде, его вначале требуется отсортировать иначе результаты операций над множествами будут неверными. Также обратите внимание, что в этом примере вместоinserterиспользуетсяback_inserter.back_inserterработает аналогичноinserter,за исключением того, что для добавления элементов в контейнер он используетpush_back.Вы не обязаны действовать точно так же. Например, можно изменить размер выходного контейнера так, чтобы он стал достаточно большим
   lst3.resize(lst1.size() + lst2.size()),
   set_symmetric_difference(lst1.begin(), lst1.end(),
    lst2.begin(), lst2.end(), lst3.begin());
   Если выходная последовательность будет достаточно большой, то можно просто передать итератор, указывающий на первый элемент последовательности, используяbegin.
   Если вы не знаете, что такоеset_symmetric_difference,я вам расскажу. Это объединение разностей двух множеств, определенных в прямом и обратном порядке. Это значит, что если а и b — это множества, то симметричная разность — это а - b b - а. Другими словами, симметричная разность — это множество всех элементов, которые присутствуют в одном из множеств, но отсутствуют в другом.
   Есть еще один момент, который следует знать при работе с операциями над множествами. Так как последовательности не обязаны быть уникальными, можно получить «множество» с повторяющимися значениями. Конечно, строго математически множество не может содержать повторяющиеся значения, так что этот момент может быть не очевиден, Рассмотрим, как будет выглядеть вывод примера 7.8, если вместоsetиспользоватьlist (при запуске примера 7.8 можно вводить повторяющиеся значения, но они не будут добавлены вset,так какset::insertне выполняется для элементов, которые уже присутствуют вset).
   Введите несколько строк: a a a b с с
   ^Z
   Введите еще несколько строк: a a b b с
   ^Z
   Объединение a a a b b с с
   Различие: a c
   Пересечение: a a b с
   Здесь операции над множествами перебирают обе последовательности и сравнивают соответствующие значения, определяя, что следует поместить в выходную последовательность.
   Наконец, операции над множествами в их оригинальном виде (использующие для сравнения элементовoperator&lt;)могут не работать так, как вам требуется, если последовательности содержат указатели. Чтобы обойти эту проблему, напишите функтор, который сравнивает объекты указателей, как в рецепте 7.4.Смотри также
   Рецепт 7.4.
   7.9.Преобразование элементов последовательностиПроблема
   Имеется последовательность элементов, и с каждым элементом требуется выполнить какие-либо действия — либо на месте, либо скопировав их в другую последовательность.Решение
   Используйте стандартные алгоритмыtransformилиfor_each.Они оба просты, но позволяют выполнить почти любые действия с элементами последовательностей. Пример 7.9 показывает, как это делается.
   Пример 7.9. Преобразование данных
   #include&lt;iostream&gt;
   #include&lt;istream&gt;
   #include&lt;string&gt;
   #include&lt;list&gt;
   #include&lt;algorithm&gt;
   #include&lt;iterator&gt;
   #include&lt;cctype&gt;
   #include "utils.h" //Для printContainer(): см. 7.10

   using namespace std;

   //Преобразуем строки к верхнему регистру
   string strToUpper(const string& s) {
    string tmp;
    for (string::const_iterator p = s.begin(); p != s.end(); ++p)
     tmp += toupper(*p);
    return(tmp);
   }

   string strAppend(const string& s1, const string& s2) {
    return(s1 + s2);
   }

   int main() {
    cout&lt;&lt; "Введите несколько строк: ";
    istream_iterator&lt;string&gt; start(cin);
    istream iterator&lt;string&gt; end;
    list&lt;string&gt; lst(start, end), out;
    // Используем преобразование с помощью унарной функции...
    transform(lst.begin(), lst.end(), back_inserter(out),
     strToUpper);
    printContainer(out);
    cin.clear();
    cout&lt;&lt;Введите другой набор строк: ";
    list&lt;string&gt; lst2(++start, end);
    out.clear();
    // ...или бинарную функцию и другую входную последовательность
    transform(lst.begin(), lst.end(), lst2.begin(),
     back_inserter(out), StrAppend);
    printContainer(out);
   }Обсуждение
   Очевидно, что для преобразования данных используетсяtransform.Он имеет две формы. Первая форма принимает последовательность, итератор вывод и унарный функтор. Он применяет функтор к каждому элементу последовательности и присваивает возвращаемое значение следующему значению, на которое указывает итератор вывода. Итератор вывода может быть другой последовательностью или началом оригинальной последовательности. В этом отношенииtransfоrmможет выполнять преобразование как «на месте», так и копируя результат в другую последовательность.
   Вот как выглядит объявлениеtransform.
   Out transform(In first, In last, Out result, UnFunc f);
   Out transform(In first1, In last1, In first2, In last2,
    Out result, BinFunc f);
   Обе версии возвращают итератор, который указывает на один после конца результирующей последовательности.
   Использование обеих версий очень просто. Чтобы скопировать строку из одной последовательности в другую, но с преобразованием ее к верхнему регистру, сделайте так,как в примере 7.9.
   std::transform(lst.begin(), lst.end(),
    std::back_inserter(out), strToUpper);
   Если требуется изменить первоначальную последовательность, просто передайте в качестве результирующего итератора начало этой последовательности.
   std::transform(lst.begin(), lst.end(),
    lst.begin(), strToUpper);
   Использование двух последовательностей и бинарной операции работает точно так же. и в качестве выходной последовательности можно использовать одну из входных.
   Если требуется преобразовать элементы на месте, можно избежать накладных расходов на присвоение каждому элементу возвращаемого значения некоторой функции. Или, если функтор, который требуется использовать, изменяет свой объект-источник, то можно использоватьfor_each.
   void strToUpperInPlace(string& s) {
    for (string::iterator p = s.begin(); p != s.end(); ++p)
     *p = std::toupper(*p);
   }

   // ...
   std::for_each(lst.begin(), lst.end(), strToUpperInPlace);
   Если же все, что требуется сделать, — это изменить саму последовательность, не изменяя каждый из ее элементов, то в рецепте 7.6 описывается множество стандартных алгоритмов для реорганизации элементов в последовательностях.Смотри также
   Рецепты 7.1 и 7.6.
   7.10.Написание собственного алгоритмаПроблема
   Для диапазона требуется выполнить алгоритм, и ни один из стандартных алгоритмов не удовлетворяет требованиям.Решение
   Напишите алгоритм в виде шаблона функции и с помощью имен параметров шаблона укажите свои требования к итератору. В примере 7.10 показан измененный стандартный алгоритмсору.
   Пример 7.10. Написание собственного алгоритма
   #include&lt;iostream&gt;
   #include&lt;istream&gt;
   #include&lt;iterator&gt;
   #include&lt;string&gt;
   #include&lt;functional&gt;
   #include&lt;vector&gt;
   #include&lt;list&gt;
   #include "utils.h" //Для printContainer(): см. 7.10

   using namespace std;

   template&lt;typename In, typename Out, typename UnPred&gt;
   Out copyIf(In first, In last, Out result, UnPred pred) {
    for ( ; first != last; ++first)
     if (pred(*first)) *results = *first;
    return(result);
   }

   int main() {
    cout&lt;&lt; "Введите несколько строк: ";
    istream_iterator&lt;string&gt; start(cin);
    istream_iterator&lt;string&gt; end; //Здесь создается "маркер"
    vector&lt;string&gt; v(start, end);
    list&lt;string&gt; lst;
    copyIf(v.begin(), v.end(), back_inserter&lt;list&lt;string&gt;&gt;(lst),
     bind2nd(less&lt;string&gt;(), "cookie"));
    printContainer(lst);
   }
   Запуск примера 7.10 будет выглядеть примерно так.
   Введите несколько строк: apple banana danish eclaire
   ^Z
   -----
   apple banana
   Вы видите, что он копирует в результирующий диапазон только те значения, которые меньше, чем «cookie».Обсуждение
   Стандартная библиотека содержит шаблон функциисору,который копирует элементы из одного диапазона в другой, но нет стандартной версии, которая принимает предикат и выполняет условное копирование элементов (т.е. алгоритмcopy_if),так что пример 7.10 делает именно это. Его поведение довольно просто: при наличии диапазона-источника и начала диапазона-приемника производится копирование в целевой диапазон элементов, для которых унарный функтор-предикат возвращаетtrue.
   Этот алгоритм прост, но в его реализации есть еще кое-что, что привлекает внимание. Посмотрев на объявление, вы увидите, что в нем присутствует три параметра шаблона.
   template&lt;typename In, typename Out, typename UnPred&gt;
   Out copyIf(In first, In last, Out result UnPred pred) {
   Первый параметр шаблонаIn— это тип входного итератора. Так как это входной диапазон, все, что должен иметь возможность сделать с нимcopyIf,— это извлечь разыменованное значение этого итератора и перевести итератор на следующий элемент. Это дает описание категории итератора ввода (категории итераторов описаны в рецепте 7.1), так что с помощью указания имени параметра шаблонаInмы объявляем именно этот тип итератора. Стандартного соглашения здесь нет (InиOut— это мои соглашения, которые я описал в первом рецепте этой главы), но вы легко можете придумать свои собственные соглашения об именах:InIter,Input_Tили дажеInputIterator.Второй параметр шаблонаOut— это тип итератора, который указывает на диапазон, в который будут копироваться элементы,copyIfдолжен иметь возможность записать разыменованное значение в выходной итератор и увеличить его значение, что дает нам описание оператора вывода. Объявив требования к итераторам с помощью имен параметров шаблона, вы делаете соглашения о вызовах алгоритма понятными без документации. Но зачем использовать две разные категории итераторов?
   Имеется, по крайней мере, две причины использования вcopyIfдвух различных категорий итераторов. Во-первых, операции с каждым диапазоном несколько отличаются друг от друга, и так как мне никогда не потребуется возвращатьсяназад по входному диапазону или присваивать ему значения, все, что мне требуется, — это итератор ввода. Аналогично мне никогда не потребуется читать из выходного диапазона, так что все, что здесь требуется, — это итератор вывода. Имеются требования к каждому из итераторов, которые не применимы к другому итератору, так что нет никакого смысла использовать для обоих диапазонов, например, два двунаправленных итератора. Во-вторых, использование различных типов итераторов позволяет вызывающему коду читать из одного типа диапазона и записывать в другой. В примере 7.10 я читаю изvectorи записываю вlist.
   vector&lt;string&gt; v(start, end);
   list&lt;string&gt; lst;
   copyIf(v.begin(), v.end(), back_inserter&lt;list&lt;string&gt;&gt;(lst),
    bind2nd(less&lt;string&gt;(), "cookie"));
   Если попробовать сделать то же самое, использовав в алгоритме один и тот же тип итераторов, то он просто не скомпилируется.
   В примере 7.10 я в качестве начала выходного диапазона передаюback_inserter,а не, скажем, итератор, возвращаемыйlst.begin.Это делается потому, что lst не содержит элементов, и в этом алгоритме (как и в стандартном алгоритме копирования) целевой диапазон должен быть достаточно большим, чтобы вместить все элементы, которые будут в него скопированы. В противном случае увеличение итератора вывода вcopyIfприведет к неопределенному поведению.back_inserterвозвращает итератор вывода, который при его увеличении вызывает для контейнера методpush_back.В результате этого при каждом увеличении выходного итератора размерlstувеличивается на один. Более подробно шаблон классаback_inserterя описываю в рецепте 7.5.
   При написании собственного алгоритма для работы с диапазонами (т.е. со стандартными контейнерами) вы должны работать с аргументами-итераторами, а не с аргументами-контейнерами. У вас может возникнуть желание объявитьcopyIfтак, чтобы он принимал два контейнера, а не итератор исходного и результирующего диапазонов, но это менее обобщенное решение, чем диапазоны. Во-первых, если передавать аргументы-контейнеры, то станет невозможно работать с подмножеством элементов контейнера. Далее, в телеcopyIfпоявится зависимость от методов контейнеровbeginиend,которые дадут требуемый диапазон, и возвращаемый тип будет зависеть от типа контейнера, используемого в качестве выходного. Это означает, что использование вcopyIfнестандартных диапазонов, таких как встроенные массивы или собственные контейнеры, работать не будет. Именно по этим и некоторым другим причинам все стандартные алгоритмы оперируют с диапазонами.
   Наконец, если вы пишете свой алгоритм, дважды убедитесь, что стандартные алгоритмы вас не устраивают. На первый взгляд они могут казаться очень простыми алгоритмами, но их кажущаяся простота проистекает из их обобщенности, и в девяти случаях из десяти их можно расширить так, что они подойдут для новых задач. Иногда следует стремиться к повторному использованию стандартных алгоритмов, так как это дает гарантию переносимости и эффективности.Смотри также
   Рецепт 7.5.
   7.11.Печать диапазона в потокПроблема
   Имеется диапазон элементов, который требуется напечатать в поток, например, вcoutс целью отладки.Решение
   Напишите шаблон функции, который принимает диапазон или контейнер, перебирает все его элементы и использует алгоритмсоруиostream_iteratorдля записи. Если требуется дополнительное форматирование, напишите свой простой алгоритм, который перебирает диапазон и печатает каждый элемент в поток. (См. пример 7.11)
   Пример 7.11. Печать диапазона в поток
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;algorithm&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;

   using namespace std;

   int main() {
    // Итератор ввода - это противоположность итератору вывода: он
    // читает элементы из потока так. как будто это контейнер.
    cout&lt;&lt; "Введите несколько строк: ";
    istream_iterator&lt;string&gt; start(cin);
    istream_iterator&lt;string&gt; end;
    vector&lt;string&gt; v(start, end);
    // Используем выходной поток как контейнер, используя
    // output_iterator. Он создает итератор вывода, для которого запись
    // в каждый элемент эквивалентна записи в поток.
    copy(v.begin(), v.end(), ostreamIterator&lt;string&gt;(cout, ", "));
   }
   Вывод примера 7.11 может выглядеть так.
   Введите несколько строк: z x y a b с
   ^Z
   z, x, y, a, b,с,Обсуждение
   Потоковый итератор — это итератор, который основан на потоке, а не на диапазоне элементов контейнера, и позволяет рассматривать поток как итератор ввода (читать из разыменованного значения и увеличивать итератор) или итератор вывода (аналогично итератору ввода, но для записи в разыменованное значение вместо чтения из него). Это облегчает чтение значений (особенно строк) из потока, что делается в нескольких других примерах этой главы, и запись значений в поток, что делается в примере 7.11. Я знаю, что этот рецепт посвящен записи диапазона в поток, но позвольте мне немного отойти от этой задачи и, поскольку я использую потоковые итераторы во многих примерах этой главы, объяснить, что это такое.
   В примере 7.11 показаны три ключевые частиistream_iterator.Первая часть — это созданиеistream_iterator,указывающего на начало потокового ввода. Это делается вот так.
   istream_iterator&lt;string&gt; start(cin);
   В результате создается итератор с именемstart,который указывает на первый элемент входной последовательности, точно так же, какvec.begin (vec— этоvector)возвращает итератор, который указывает на первый элемент в векторе. Аргумент шаблонаstringговоритistream_iterator,что элементы в этой последовательности имеют типstring.Аргумент конструктораcin— это входной поток, из которого производится чтение. Однако это абстракция, так как первого элемента не существует, поскольку изcinеще ничего прочитано не было. Это произойдет несколько позже.
   Вторая часть итератора входного потока — это маркер конца, который создается вот так.
   istream_iterator&lt;string&gt; end;
   Стандартные контейнеры используют специальное значение «один после конца», указывающее на точку, где должно остановиться использование алгоритма. Так как итератор входного потока не имеет в памяти последнего элемента, он для создания логической конечной точки, представляющей точку остановки использования алгоритма, использует конструктор без аргументов.
   Последней частью методики использованияistream_iteratorявляется его использование для извлечения значений. Удобным способом вытащить в контейнер все значения, введенные в поток, является использование конструктора диапазона контейнера. Например, если создатьvectorс двумя итераторами, то его конструктор скопирует в контейнер все элементы диапазона, определяемого итераторами. Если передать только что созданные итераторыstartиend,то это будет выглядеть так.
   vector&lt;string&gt; v(start, end);
   Именно здесь происходит чтение значений из потока. При созданииvон начинает соstartи перебирает все значения, пока не достигнетend.Каждый раз, когдаvчитает из*start,происходит нечто эквивалентное такому вызовуcin.
   cin&gt;&gt; v[i]; // v -это vector&lt;string&gt;
   Другими словами, следующее значение, извлекаемое изcin,преобразуется вstringи вставляется вvector.
    [Картинка: tip_yellow.png] При использованииcinкак входного потока маркер конца файла, который отмечает конец потока, определяется используемой платформой. В Windows для завершения входного потока требуется нажать на Enter, Ctrl-Z, Enter. Чтобы увидеть, что требуется сделать на вашей платформе, проведите эксперименты, но велика вероятность, что будут использоваться эти же клавиши.
   Итераторы выходных потоков ведут себя аналогично итераторам потоков ввода. В примере 7.11 я копирую значения из своегоvectorвcout,создав для этогоostream_iterator,который указывает наcout,следующим образом.
   copy(v.begin(), v.end(), ostream_iterator&lt;string&gt;(cout, ", "));
   Аргумент шаблонаostream_iteratorговорит, что записываемые элементы будут иметь типstring.Первый аргумент конструктораostream_iterator— это поток, в который будет производиться запись (и который может быть любым потоком вывода, включаяofstreamиostringstream),а второй это используемый разделитель. Это дает удобный способ выводить диапазон значений на стандартный вывод, что я часто делаю при отладке.
   Если требуется дополнительное управление внешним видом вывода, например вывод последовательности в квадратных или фигурных скобках или отсутствие последнего разделителя в конце последовательности, то это потребует всего нескольких дополнительных строк кода. Пример 7.12 показывает телоprintContainerиprintRange,первая из которых используется в примерах этой главы.
   Пример 7.12. Написание собственной функции печати
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;algorithm&gt;
   #include&lt;iterator&gt;
   #include&lt;vector&gt;

   using namespace std;

   template&lt;typename C&gt;
   void printContainer(const C& c, char delim = ',', ostream& out = cout) {
    printRange(c.begin(), c.end(), delim, out);
   }

   template&lt;typename Fwd&gt;
   void printRange(Fwd first, Fwd last, char delim = ',', ostream& out = cout) {
    out&lt;&lt; "{";
    while (first != last) {
     out&lt;&lt; *first;
     if (++first != last)
      out&lt;&lt; delim&lt;&lt; ' ';
    }
    out&lt;&lt; "}"&lt;&lt; endl;
   }

   int main() {
    cout&lt;&lt; "Введите набор строк: ";
    istream_iterator&lt;string&gt; start(cin);
    istream_iterator&lt;string&gt; end;
    vector&lt;string&gt; v(start, end);
    printContainer(v);
    printRange(v.begin(), v.end(), ';', cout);
   }
   ФункцияprintRangeпредставляет собой более общий подход, так как оперирует с диапазонами (более подробно это объясняется в рецепте 7.10), ноprintContainerболее удобна для печати целого контейнера. Имеется множество других способов сделать это. В голову также приходит определение версииoperator&lt;&lt;,которая бы работала с выходным потоком и контейнером, и использование стандартного алгоритмаfor_eachс собственным функтором для записи элементов в поток.
   Глава 8
   Классы
   8.0.Введение
   Эта глава содержит решения проблем, часто возникающих при работе с классами С++. Рецепты по большей части независимы, но разбиты на две части, каждая из которых занимает примерно по половине главы. Первая половина главы содержит решения проблем, которые могут возникнуть при создании объектов классов, таких как использование функции для создания объекта (которая часто называется шаблоном фабрики) или использование конструкторов и деструкторов для управления ресурсами. Вторая половина содержит решения проблем, возникающих после создания объектов, таких как определение типа объекта во время выполнения, а также некоторые методики реализации наподобие создания интерфейса с помощью абстрактного базового класса.
   Конечно, классы — это главная особенность С++, которая обеспечивает возможность объектно-ориентированного программирования, и с ними можно выполнять очень много разных действий. Эта глава не содержит рецептов, объясняющих основы классов: виртуальные функции (полиморфизм), наследование и инкапсуляцию. Я полагаю, что вы уже знакомы с этими основными принципами объектно-ориентированного проектирования независимо от используемого языка программирования. Напротив, целью этой главы является описание принципов некоторых механических сложностей, с которыми можно столкнуться при реализации объектно-ориентированного дизайна на С++.
   Объектно-ориентированное проектирование и связанные с ним шаблоны проектирования — это обширный вопрос, и имеется большое количество различной литературы на эту тему. В этой главе я упоминаю названия только некоторых шаблонов проектирования, и это шаблоны, для которых возможности C++ обеспечивают элегантное или, возможно, не совсем очевидное решение. Если вы не знакомы с концепцией шаблонов проектирования, я рекомендую прочесть книгуDesign Patterns (Addison Wesley),поскольку это полезная вещь при разработке программного обеспечения. Однако для этой главы знание шаблонов проектирования не требуется.
   8.1.Инициализация переменных-членов классаПроблема
   Требуется инициализировать переменные-члены, которые имеют встроенные типы, являются указателями или ссылками.Решение
   Для установки начальных значений переменных членов используйте список инициализации. Пример 8.1 показывает, как это делается для встроенных типов, указателей и ссылок.
   Пример 8.1. Инициализация членов класса
   #include&lt;string&gt;

   using namespace std;

   class Foo {
   public:
    Foo() : counter_(0), str_(NULL) {}
    Foo(int c, string* p) : counter_(c), str_(p) {}
   private:
    int counter_;
    string* str_;
   };

   int main() {
    string s = "bar";
    Foo(2,&s);
   }Обсуждение
   Переменные встроенных типов следует всегда инициализировать, особенно если они являются членами класса. С другой стороны, переменные класса должны иметь конструктор, который корректно инициализирует их состояние, так что самостоятельно инициализировать их не требуется. Сохранить неинициализированное состояние переменных встроенных типов, когда они содержат мусор, — значит напрашиваться на проблемы. Но в C++ есть несколько различных способов выполнить инициализацию, и они описываются в этом рецепте.
   Простейшими объектами инициализации являются встроенные типы. Работать сint,charи указателями очень просто. Рассмотрим простой класс и его конструктор по умолчанию.
   class Foo {
   public:
    Foo() : counter_(0), str_(NULL) {}
    Foo(int c, string* p) : counter_(c), str_(p) {}
   private:
    int counter_;
    string* str_;
   };
   Для инициализации переменных-членов используется список инициализации, в результате чего тело конструктора освобождается от этой задачи. Тело конструктора может при этом содержать логику, выполняемую при создании объектов, а инициализацию переменных-членов становится легко найти. Это не столь значительное преимущество по сравнению с присвоением начальных значений в теле конструктора, но все его преимущества становятся очевидны при создании переменных-членов типа класса или ссылок или при попытке эффективного использования исключений.
    [Картинка: tip_yellow.png] Члены инициализируются в порядке их указания в объявлении класса, а не в порядке объявления их в списке инициализации.
   Используя тот же классFoo,как и в примере 8.1, рассмотрим переменную-член класса.
   class Foo {
   public:
    Foo() : counter_(0), str_(NULL), cls_(0) {}
    Foo(int с, string* p) :
     counter_(c), str_(p), cls_(0) {}
   private:
    int counter_;
    string* str_;
    SomeClass cls_;
   };
   В конструкторе по умолчаниюFooинициализироватьcls_не требуется, так как будет вызван ее конструктор по умолчанию. Но если требуется создатьFooс аргументами, то следует добавить аргумент в список инициализации, как это сделано выше, а не делать присвоение в теле конструктора. Используя список инициализации, вы избежите дополнительного шага созданияcls_ (так как при присвоенииcls_значения в теле конструктораcls_вначале создается с использованием конструктора по умолчанию, а затем с помощью оператора присвоения выполняется присвоение нового значения), а также получите автоматическую обработку исключений. Если объект создается в списке инициализации и этот объект в процессе его создания выбрасывает исключение, то среда выполнения удаляет все ранее созданные объекты списка и передает исключение в код, вызывавший конструктор. С другой стороны, при присвоении аргумента в теле конструктора такое исключение необходимо обрабатывать с помощью блокаtry/catch.
   Ссылки более сложны: инициализация переменной-ссылки (иconst-членов)требует обязательногоиспользования списка инициализации. В соответствии со стандартом ссылка всегда должна ссылаться на одну переменную и никогда не может измениться и ссылаться на другую переменную. Переменная-ссылка никогда не может не ссылаться на какой-либо объект. Следовательно, чтобы присвоить что-то осмысленное переменной-члену, являющейся ссылкой, это должно происходить приинициализации,т.е. в списке инициализации.
   Следующая запись в C++ недопустима.
   int& x;
   Это значит, что невозможно объявить переменную-ссылку без ее инициализации. Вместо этого ее требуется инициализировать каким-либо объектом. Для переменных, не являющихся членами класса, инициализация может выглядеть вот так.
   intа;
   int& x = a;
   Это все замечательно, но приводит к возникновению проблемы при создании классов. Предположим, вам требуется переменная-член класса, являющаяся ссылкой, как здесь.
   class HasARef {
   public:
    int& ref;
   };
   Большинство компиляторов примет эту запись, но только до тех пор, пока вы не попытаетесь создать экземпляр этого класса, как здесь.
   HasARef me;
   В этот момент вы получите ошибку. Вот какую ошибку выдаст gcc.
   error: structure 'me' with uninitialized reference members
   (ошибка: структура 'me' с неинициализированными членами-ссылками)
   Вместо этого следует использовать список инициализации.
   class HasARef {
   public:
    int&ref;
    HasARef(int&aref) : ref(aref) {}
   };
   Затем при создании экземпляра класса требуется указать переменную, на которую будет ссылаться переменнаяref,как здесь.
   int var;
   HasARef me(var);
   Именно так следует безопасно и эффективно инициализировать переменные-члены. В общем случае всегда, когда это возможно, используйте список инициализации и избегайте инициализации переменных-членов в теле конструктора. Даже если требуется выполнить какие-либо действия с переменными в теле конструктора, список инициализации можно использовать для установки начальных значений, а затем обновить их в теле конструктора.Смотри также
   Рецепт 9.2.
   8.2.Использование функции для создания объектов (шаблон фабрики)Проблема
   Вместо создания объекта в куче с помощью new вам требуется функция (член или самостоятельная), выполняющая создание объекта, тип которого определяется динамически. Такое поведение достигается с помощью шаблона проектирования Abstract Factory (абстрактная фабрика).Решение
   Здесь есть две возможности. Вы можете:
   • создать функцию, которая создает экземпляр объекта в куче и возвращает указатель на этот объект (или обновляет переданный в нее указатель, записывая в него адрес нового объекта);
   • создать функцию, которая создает и возвращает временный объект.
   Пример 8.2 показывает оба этих способа. КлассSessionв этом примере может быть любым классом, объекты которого должны не создаваться непосредственно в коде (т.е. с помощьюnew),а их создание должно управляться каким-либо другим классом. В этом примере управляющий класс — этоSessionFactory.
   Пример 8.2. Функции, создающие объекты
   #include&lt;iostream&gt;

   class Session {};

   class SessionFactory {
   public:
    Session Create();
    Session* CreatePtr();
    void Create(Session*& p);
    // ...
   };

   //Возвращаем копию объекта в стеке
   Session SessionFactory::Create() {
    Session s;
    return(s);
   }

   //Возвращаем указатель на объект в куче
   Session* SessionFactory::CreatePtr() {
    return(new Session());
   }

   //Обновляем переданный указатель, записывая адрес
   //нового объекта
   void SessionFactory::Create(Session*& p) {
    p = new Session();
   }

   static SessionFactory f; //Единственный объект фабрики

   int main() {
    Session* p1;
    Session* p2 = new Session();
    *p2 = f.Create();   // Просто присваиваем объект, полученный из Create
    p1 = f.CreatePtr(); // или полученный указатель на объект в куче
    f.Create(p1);       // или обновляем указатель новым адресом
   }Обсуждение
   Пример 8.2 показывает несколько различных способов написания функции, возвращающей объект. Сделать так вместо обращения кnewможет потребоваться, если создаваемый объект берется из пула, связан с оборудованием или удаление объектов должно управляться не вызывающим кодом. Существует множество причин использовать этот подход (и именно поэтому существует шаблон проектирования для него), я привел только некоторые. К счастью, реализация шаблона фабрики в C++ очень проста.
   Наиболее часто используют возврат адреса нового объекта в куче или обновление адреса указателя, переданного как аргумент. Их реализация показана в примере 8.2, и она тривиальна и не требует дальнейших пояснений. Однако возврат из функции целого объекта используется реже — возможно, потому, что это требует больших накладных расходов.
   При возврате временного объекта в стеке тела функции создается временный объект. При выходе из функции компилятор копирует данные из временного объекта в другой временный объект, который и возвращается из функции, Наконец, в вызывающей функции объекту с помощью оператора присвоения присваивается значение временного объекта. Это означает, что на самом деле создается два объекта: объект в функции фабрики и временный объект, который возвращается из функции, содержимое которого затем копируется в целевой объект. Здесь осуществляется большое количество копирований (хотя компилятор может оптимизировать временный объект), так что при работе с большими объектами или частыми вызовами этой функции фабрики внимательно следите за тем, что в ней происходит.
   Также эта методика копирования временных объектов работает только для объектов, которые ведут себя какобъекты значений,что означает, что когда он копируется, то новая версия будет эквивалентна оригинальной. Для большинства объектов это выполняется, но для некоторых — нет. Например, рассмотрим создание объекта класса, прослушивающего сетевой порт. При создании экземпляра объекта он может начинать прослушивать целевой порт, так что скопировать его в новый объект не получится, так как при этом появятся два объекта, пытающиеся слушать один и тот же порт. В этом случае следует возвращать адрес объекта в куче.
   Если вы пишете функцию или метод, создающий объекты, то посмотрите также рецепт 8.12. Используя шаблоны, функций можно написать одну функцию, которая будет возвращать новый объект любого типа. Например:
   template&lt;typename T&gt;
   T* createObject() {
    return(new T());
   }

   MyClass* p1 = createObject();
   MyOtherClass* p2 = createObject();
   // ...
   Этот подход удобен, если требуется единственная функция фабрики, которая сможет одинаковым образом создавать объекты любых классов (или группы связанных классов), что позволит избежать избыточного многократного кодирования функции фабрики.Смотри также
   Рецепт 8.12.
   8.3.Использование конструкторов и деструкторов для управления ресурсами (RAII)Проблема
   Для класса, представляющего некоторый ресурс, требуется использовать конструктор для получения этого ресурса и деструктор для его освобождения. Эта методика часто называется «получение ресурсов как инициализация» (resource acquisition is initialization— RAII).Решение
   Выделите или получите ресурс в конструкторе и освободите этот ресурс в деструкторе. Это снизит объем кода, который пользователь класса должен будет написать для обработки исключений. Простая иллюстрация этой методики показана в примере 8.3.
   Пример 8.3. Использование конструкторов и деструкторов
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using namespace std;

   class Socket {
   public:
    Socket(const string& hostname) {}
   };

   class HttpRequest {
   public:
    HttpRequest(const string& hostname) :
     sock_(new Socket(hostname)) {}
    void send(string soapMsg) {sock&lt;&lt; soapMsg;}
    ~HttpRequest() {delete sock_;}
   private:
    Socket* sock_;
   };

   void sendMyData(string soapMsg, string host) {
    HttpRequest req(host);
    req.send(soapMsg);
    // Здесь делать ничего не требуется, так как когда req выходит
    // за диапазон, все очищается.
   }

   int main() {
    string s = "xml";
    sendMyData(s, "www.oreilly.com");
   }Обсуждение
   Гарантии, даваемые конструкторами и деструкторами, представляют собой удобный способ заставить компьютер выполнить всю очистку за вас. Обычно инициализация объекта и выделение используемых ресурсов производится в конструкторе, а очистка — в деструкторе. Это нормально. Но программисты имеют склонность использовать последовательность событий «создание-открытие-использование-закрытие», когда пользователю класса требуется выполнять явные открытия и закрытия ресурсов. Класс файла является хорошим примером.
   Примерно так звучит обычный аргумент в пользу RAII. Я легко мог бы создать в примере 8.3 свой классHttpRequest,который заставил бы пользователя выполнить несколько больше работы. Например:
   class HttpRequest {
   public:
    HttpRequest();
    void open(const std::string& hostname);
    void send(std::string soapMsg);
    void close();
    ~HttpRequest();
   private:
    Socket* sock_;
   };
   При таком подходе соответствующая версияsendMyDataможет выглядеть так.
   void sendMyData(std::string soapMsg, std::string host) {
    HttpRequest req;
    try {
     req.open();
     req.send(soapMsg);
     req.close();
    } catch (std::exception& e) {
     req.close(); // Do something useful...
    }
   }
   Здесь требуется выполнить больше работы без каких бы то ни было преимуществ. Этот дизайн заставляет пользователя писать больше кода и работать с исключениями, очищая ваш класс (при условии, что в деструктореcloseне вызывается).
   Подход RAII имеет широкое применение, особенно когда требуется гарантировать, что при выбрасывании исключения будет выполнен «откат» каких-либо действий, позволяя при этом не загромождать код бесконечнымиtry/catch.Рассмотрим настольное приложение, которое в процессе выполнения какой-либо работы отображает в строке состояния или заголовка сообщение.
   void MyWindow : thisTakesALongTime() {
    StatusBarMessage("Copying files...");
    // ...
   }
   Все, что классStatusBarMessageдолжен сделать, — это использовать информацию о статусе для обновления соответствующего окна при создании и вернуть его первоначальное состояние при удалении. Вот ключевой момент: если функция завершает работу или выбрасывается исключение,StatusBarMessageвсе равно выполнит работу. Компилятор гарантирует, что при выходе из области видимости стековой переменной для нее будет вызван ее деструктор. Без этого подхода авторthisTakesALongTimeдолжен был бы принять во внимание все пути передачи управления, чтобы неверное сообщение не осталось в окне при неудачном завершении операции, ее отмене пользователем и т.п. И снова повторю, что этот подход приводит к уменьшению кода и снижению числа ошибок автора вызывающего кода.
   RAIIне является панацеей, но если вы его еще не использовали, то вы, скорее всего, найдете немало возможностей для его применения. Еще одним хорошим примером является блокировка. При использовании RAII для управления блокировками ресурсов, таких как потоки, объекты пулов, сетевые соединения и т.п., этот подход позволяет создавать более надежный код меньшего размера. На самом деле именно так многопоточная библиотека Boost реализует блокировки, делая программирование пользовательской части более простым. За обсуждением библиотеки Boost Threads обратитесь к главе 12.
   8.4.Автоматическое добавление новых экземпляров класса в контейнерПроблема
   Требуется хранить все экземпляры класса в едином контейнере, не требуя от пользователей класса выполнения каких-либо специальных операций.Решение
   Включите в класс статический член, являющийся контейнером, таким какlist,определенный в&lt;list&gt;.Добавьте в этот контейнер адрес объекта при его создании и удалите его при уничтожении. Пример 8.4 показывает, как это делается.
   Пример 8.4. Отслеживание объектов
   #include&lt;iostream&gt;
   #include&lt;list&gt;
   #include&lt;algorithm&gt;

   using namespace std;

   class MyClass {
   protected:
    int value_;
   public:
    static list&lt;MyClass*&gt; instances_;
    MyClass(int val);
    ~MyClass();
    static void showList();
   };

   list&lt;MyClass*&gt; MyClass::instances_;

   MyClass::MyClass(int val) {
    instances_.push_back(this);
    value_ = val;
   }

   MyClass::~MyClass() {
    list&lt;MyClass*&gt;::iterator p =
     find(instances_.begin(), instances_.end(), this);
    if (p != instances_.end()) instances_.erase(p);
   }

   void MyClass::showList() {
    for (list&lt;MyClass*&gt;::iterator p = instances_.begin();
     p != instances_.end(); ++p)
     cout&lt;&lt; (*p)-&gt;value_&lt;&lt; endl;
   }

   int main() {
    MyClass a(1);
    MyClass b(10);
    MyClass с(100);
    MyClass::showList();
   }
   Пример 8.4 создаст следующий вывод.
   1
   10
   100Обсуждение
   Подход в примере 8.4 очень прост: используйте для хранения указателей на объектыstatic list.При создании объекта его адрес добавляется вlist;при его уничтожении он удаляется. Здесь имеется пара важных моментов.
   При использовании любых членов-данных типаstaticих требуется объявлять в заголовочном файле класса и определять в файле реализации. Пример 8.4 весь находится в одном файле, так что здесь это не применимо, но помните, что переменную типаstaticтребуется определять в файле реализации, а не в заголовочном файле. За объяснением причин обратитесь к рецепту 8.5.
   Вы не обязаны использовать членstatic.Конечно, можно использовать глобальный объект, но тогда дизайн не будет таким «замкнутым». Более того, вам где-то еще придется выделять память для глобального объекта, передавать его в конструкторMyClassи в общем случае выполнять еще целый ряд действий.
   Помните, что совместное использование глобального контейнера, как в примере 8.4, не будет работать, если объекты классаMyClassсоздаются в нескольких потоках. В этом случае требуется сериализация доступа к общему объекту через мьютексы. Рецепты, относящиеся к этой и другим методикам многопоточности, приведены в главе 12.
   Если требуется отслеживать все экземпляры класса, можно также использовать шаблон фабрики. В целом это будет означать, что для создания нового объекта клиентский код вместо вызова оператора new должен будет вызывать функцию. За подробностями о том, как это делается, обратитесь к рецепту 8.2.Смотри также
   Рецепт 8.2.
   8.5.Гарантия единственности копии переменной-членаПроблема
   Имеется переменная-член, у которой должен быть только один экземпляр независимо от числа создаваемых экземпляров класса. Этот тип переменных-членов обычно называется статическими членами или переменнымикласса— в противоположность переменнымэкземпляра,свои копии которых создаются для каждого объекта класса.Решение
   Объявите переменную-член с ключевым словомstatic,затем инициализируйте ее в отдельном исходном файле (но не в заголовочном файле, где она объявлена), как показано в примере 8.5.
   Пример 8.5. Использование статических переменных-членов

   // Static.h
   class OneStatic {
   public:
    int getCount() {return count;}
    OneStatic();
   protected:
    static int count;
   };

   // Static.cpp
   #include "Static.h"

   int OneStatic::count = 0;

   OneStatic::OneStatic() {
    count++;
   }

   // StaticMain.cpp
   #include&lt;iostream&gt;
   #include "static.h"

   using namespace std;

   int main() {
    OneStatic a;
    OneStatic b;
    OneStatic c;
    cout&lt;&lt; a.getCount()&lt;&lt; endl;
    cout&lt;&lt; b.getCount()&lt;&lt; endl;
    cout&lt;&lt; c.getCount()&lt;&lt; endl;
   }Обсуждение
   static— это способ C++ разрешить создание только одной копии чего-либо. Если переменную-член объявить какstatic,то будет создана только одна такая переменная вне зависимости от количества созданных объектов этого класса. Аналогично, если объявить какstaticпеременную функции, она будет создана только один раз и будет хранить свое значение от одного вызова функции к другому. Однако в случае с переменными-членами, чтобы убедиться, что переменная создана правильно, требуется проделать несколько больше работы. Именно по этой причине в примере 8.5 показано три файла.
   Во-первых, при объявлении переменной требуется использовать ключевое словоstatic.Это достаточно просто: добавьте это ключевое слово в заголовок класса, находящийся в заголовочном файлеStatic.h.
   protected:
   static int count;
   После этого требуется определить эту переменную в исходном файле. При этом для нее будет выделена память. Это делается с помощью указания полного имени переменнойи присвоения ей значения, как здесь.
   int OneStatic::count = 0;
   В примере 8.5 я поместил это определение в файлStatic.cpp.Именно так вы и должны делать — не помещайте определение в заголовочный файл. Если это сделать, память будет выделена в каждом файле реализации, включающем этот заголовочный файл, и либо возникнут ошибки компиляции, либо, что хуже, в памяти появятся несколько экземпляров этой переменной. Это не то, что требуется при использовании переменной-членаstatic.
   В главном файлеStaticMain.cppвы можете видеть то, что происходит. Создается несколько экземпляров классаOneStatic,и каждый раз конструктор по умолчаниюOneStaticинкрементирует статическую переменную. В результате выводmainизStaticMain.cppимеет вид:
   3
   3
   3
   Каждый вызовgetCountвозвращает одно и то же целое значение, даже несмотря на то, что он делается для различных экземпляров класса.
   8.6.Определение типа объекта во время выполненияПроблема
   Во время выполнения требуется динамически узнавать тип определенного класса.Решение
   Для запроса, на объект какого типа указывает адрес объекта, используйте идентификацию типов во время выполнения (обычно называемую просто RTTI — runtime type identification). Пример 8.6 показывает, как это делается.
   Пример 8.6. Использование идентификации типов во время выполнения
   #include&lt;iostream&gt;
   #include&lt;typeinfo&gt;

   using namespace std;

   class Base {};

   class Derived : public Base {};

   int main() {
    Base b, bb;
    Derived d;

    // Используем typeid для проверки равенства типов
    if (typeid(b) == typeid(d)) { // No
     cout&lt;&lt; "bи d имеют один и тот же тип.\n";
    }
    if (typeid(b) == typeid(bb)) { // Yes
     cout&lt;&lt; "bи bb имеют один и тот же тип.\n";
    }
    it (typeid(a) == typeid(Derived)) { // Yes
     cout&lt;&lt; "dимеет тип Derived.\n";
    }
   }Обсуждение
   Пример 8.6 показывает, как использовать операторtypeidдля определения и сравнения типов объектов,typeidпринимает выражение или тип и возвращает ссылку на объект типаtype_infoили его подкласс (что зависит от реализации). Возвращенное значение можно использовать для проверки на равенство или получить строковое представление имени типа. Например, сравнить типы двух объектов можно так.
   if (typeid(b) == typeid(d)) {
   Это выражение возвращает истину, если возвращаемые объектыtype_infoравны. Это работает благодаря тому, чтоtypeidвозвращает ссылку на статический объект, так что при его вызове для двух объектов одного и того же типа будут получены две ссылки на один и тот же объект и сравнение вернет истину.
   typeidтакже можно использовать непосредственно с типом, как здесь.
   if (typeid(d) == typeid(Derived)) {
   Это позволяет явно проверять определенный тип.
   Вероятно, наиболее частоtypeidиспользуется для отладки. Для записи имени типа используйтеtype_info::name,как здесь.
   std::cout&lt;&lt; typeid(d).name()&lt;&lt; std::endl;
   При передаче объектов различных типов это может быть очень полезно. Строка, завершающаяся нулем, возвращаемаяname,зависит от реализации, но вы можете ожидать (но не полагаться на это), что она будет равна имени типа. Это также работает и для встроенных типов.
   Не злоупотребляйте этой методикой, основывая на информации о типе логику программы, если это не абсолютно необходимо. В общем случае наличие логики, которая выполняет что-то похожее на следующее, расценивается как плохой дизайн.
   Еслиobjимеет типX,сделать что-то одно, а еслиobjимеет типY,сделать что-то другое.
   Это плохой дизайн, потому что клиентский код теперь содержит избыточные зависимости от типов используемых объектов. Это также приводит к большой каше из if/then кода,который то и дело повторяется, если для объектов типовXилиYтребуется различное поведение. Объектно-ориентированное программирование и полиморфизм существуют в большой степени для того, чтобы избавить нас от написания подобного рода логики. Если для какого-либо семейства связанных классов требуется зависящее от типа поведение, то они все должны наследоваться от какого-то базового класса и использовать виртуальные функции, динамически вызывая различное поведение в зависимости от типа.
   RTTIприводит к накладным расходам, так что компиляторы обычно по умолчанию его отключают. Скорее всего ваш компилятор имеет параметр командной строки для включения RTTI. Также это не единственный способ, которым можно получить информацию о типе. Другая методика приведена в рецепте 8.7.Смотри также
   Рецепт 8.7.
   8.7.Определение, является ли класс объекта подклассом другого классаПроблема
   Имеется два объекта и требуется узнать, имеют ли их классы отношения на уровне базовый класс/производный класс, или они не связаны друг с другом.Решение
   Используйте операторdynamic_cast,который пытается выполнить преобразование одного типа в другой. Результат скажет, имеется ли связь между классами. Пример 8.7 представляет код, который это делает.
   Пример 8.7. Определение отношений классов
   #include&lt;iostream&gt;
   #include&lt;typeinfo&gt;

   using namespace std;

   class Base {
   public:
    virtual ~Base() {} // Делаем класс полиморфным
   };

   class Derived : public Base {
   public:
    virtual ~Derived() {}
   };

   int main() {
    Derived d;
    // Запрашиваем тип отношений
    if (dynamic_cast&lt;Base*&gt;(&d)) {
     cout&lt;&lt; "Derivedявляется классом, производным от Base"&lt;&lt; endl;
    } else {
     cout&lt;&lt; "Derived HEявляется классом, производным от Base"&lt;&lt; endl;
    }
   }Обсуждение
   Для запроса отношений между двумя типами используйте операторdynamic_cast.dynamic_castпринимает указатель или ссылку на некий тип и пытается преобразовать его к указателю или ссылке на производный класс, т.е. выполняя преобразование типа вниз по иерархии классов. Если естьBase*,который указывает на объектDerived,тоdynamic_cast&lt;Base*&gt;(&d)возвращает указатель типаDerivedтолько в том случае, еслиd— это объект типа, производного отBase.Если преобразование невозможно (из-за того, чтоDerivedне является подклассом — явным или косвенным — классаBase),то преобразование завершается неудачей и, если вdynamic_castбыл передан указатель на производный класс, возвращаетсяNULL.Если в него была передана ссылка, то выбрасывается стандартное исключениеbad_cast.Также базовый класс должен наследоваться какpublicи это наследование не должно быть двусмысленным. Результат говорит о том, является ли один класс наследником другого класса. Вот что я сделал в примере 8.7.
   if (dynamic_cast&lt;Base*&gt;(&d)) {
   Здесь возвращается нe-NULL-указатель, так какd— это объект класса, производного отBase.Эту возможность можно использовать для определения отношения любых двух классов. Единственным требованием является то, что аргумент объекта должен бытьполиморфнымтипом, что означает, что он должен иметь по крайней мере одну виртуальную функцию. Если это не будет соблюдено, то такой код не скомпилируется. Однако обычно это не вызывает особых проблем, так как иерархия классов без виртуальных функций встречается крайне редко.
   Если этот синтаксис кажется вам слишком запутанным, используйте макрос, скрывающий некоторые подробности.
   #define IS_DERIVED_FROM(BaseClass, x) (dynamic_cast&lt;baseClass*&gt;(&(x)))
   //...
   if (IS_DERIVED_FROM(Base, l)){//...
   Но помните, что такая информация о типах не бесплатна, так какdynamic_castдолжен во время выполнения пройти по иерархии классов и определить, является ли один класс наследником другого, так что не злоупотребляйте этим способом. Кроме того, компиляторы не включают эту информацию по умолчанию, так как RTTI приводит к накладным расходам, и не все используют эту функцию, так что вам может потребоваться включить ее с помощью опции компилятора.Смотри также
   Рецепт 8.6.
   8.8.Присвоение каждому экземпляру класса уникального идентификатораПроблема
   Требуется, чтобы каждый объект класса имел уникальный идентификатор.Решение
   Для отслеживания следующего доступного для использования идентификатора используйте статическую переменную-член. В конструкторе присвойте текущему объекту очередное доступное значение, а затем инкрементируйте статическую переменную. Чтобы понять, как это работает, посмотрите на пример 8.8.
   Пример 8.8. Присвоение уникальных идентификаторов
   #include&lt;iostream&gt;

   class UniqueID {
   protected:
    static int nextID;
   public:
    int id;
    UniqueID();
    UniqueID(const UniqueID& orig);
    UniqueID& operator=(const UniqueID& orig);
   };

   int UniqueID::nextID = 0;

   UniqueID::UniqueID() {
    id = ++nextID;
   }

   UniqueID::UniqueID(const UniqueID& orig) {
    id = orig.id;
   }

   UniqueID& UniqueID::operator=(const UniqueID& orig) {
    id = orig.id;
    return(*this);
   }

   int main() {
    UniqueID a;
    std::cout&lt;&lt; a.id&lt;&lt; std::endl;
    UniqueID b;
    std::cout&lt;&lt; b.id&lt;&lt; std::endl;
    UniqueID c;
    std::cout&lt;&lt; c.id&lt;&lt; std::endl;
   }Обсуждение
   Для отслеживания следующего доступного для использования идентификатора используйте статическую переменную. В примере 8.8 используетсяstatic int,но вместо нее можно использовать все, что угодно, при условии, что имеется функция, которая может генерировать уникальные значения.
   В данном случае идентификаторы не используются повторно до тех пор, пока не будет достигнуто максимально возможное для целого числа значение. При удалении объекта его уникальное значение пропадает либо до перезапуска программы, либо до переполнения значения идентификатора. Эта уникальность в программе может иметь несколько интересных преимуществ. Например, при работе с библиотекой управления памятью, которая перемещает блоки памяти и обновляет значения указателей, можно быть уверенным, что для каждого объекта будет сохранено его первоначальное уникальное значение. При использовании уникальных значений в сочетании с рецептом 8.4, но примененииmapвместоlistможно легко найти объект с заданным уникальным номером. Чтобы сделать это, просто отобразите уникальные ID на экземпляры объектов, как здесь.
   static map&lt;int, MyClass*&gt; instmap;
   Таким образом любой код, который отслеживает идентификаторы объектов, всегда сможет найти его без необходимости хранить ссылку на него.
   Но это еще не все. Рассмотрим случай, когда один из этих объектов требуется добавить в стандартный контейнер (vector,list,setи т.п.). Стандартные контейнеры хранят копии объектов, добавляемых в них, а не ссылки или указатели на эти объекты (конечно, при условии, что это не контейнер указателей). Таким образом, стандартные контейнеры ожидают, чтообъекты, которые в них содержатся, ведут себя как объектызначений,что означает, что при присвоении с помощью оператора присвоения или копировании с помощью конструктора копирования создается новая версия, полностью эквивалентная оригинальной версии.
   Это означает, что требуется решить, как должны себя вести уникальные объекты. При создании объекта с уникальным идентификатором и добавлении его в контейнер у вас появятся два объекта с одним и тем же идентификатором при условии, что вы не переопределили оператор присвоения. В операторе присвоения и конструкторе копирования требуется выполнить те действия с уникальным значением, которые имеют смысл для вашего случая. Имеет ли смысл то, что объект в контейнере будет равен оригинальному объекту? Если да, то вполне подойдет стандартный конструктор копирования и оператор присвоения, но вы должны указать это явно, чтобы пользователи вашего класса знали, что вы делаете это намеренно, а не просто забыли, как работают контейнеры. Например, чтобы использовать одно и то же значение идентификатора, конструктор копирования и оператор присвоения должны выглядеть вот так.
   UniqueID::UniqueID(const UniqueID& orig) {
    id = orig.id;
   }

   UniqueID& UniqueID::operator=(const UniqueID& orig) {
    id = orig.id;
    return(*this);
   }
   Но может возникнуть ситуация, когда в контексте приложения будет иметь смысл создать для объекта в контейнере новое уникальное значение. В этом случае просто снова используйте статическую переменную, как это сделано в обычном конструкторе и показано здесь.
   UniqueID::UniqueID(const UniqueID& orig) {
    id = ++nextID;
   }

   UniqueID& UniqueID::operator=(const UniqueID& orig) {
    id = ++nextID;
    return(*this);
   }
   Однако трудности еще не закончились. ЕслиUniqueIDбудет использоваться несколькими потоками, у вас снова возникнут проблемы, так как доступ к статическим переменным не синхронизирован. За дополнительной информацией о работе с ресурсами при наличии нескольких потоков обратитесь к главе 12.Смотри также
   Рецепт 8.3.
   8.9.Создание Singleton-классаПроблема
   Имеется класс, который должен иметь только один экземпляр, и требуется предоставить способ доступа к этому классу из клиентского кода таким образом, чтобы каждый раз возвращался именно этот единственный объект. Часто это называется шаблономsingletonили singleton-классом.Решение
   Создайте статический член, который указывает на текущий класс, ограничьте использование конструкторов для создания класса, сделав ихprivate,и создайте открытую статическую функцию-член, которая будет использоваться для доступа к единственному статическому экземпляру. Пример 8.9 демонстрирует, как это делается.
   Пример 8.9. Создание singleton-класса
   #include&lt;iostream&gt;

   using namespace std;

   class Singleton {
   public:
    // С помощью этого клиенты получат доступ к единственному экземпляру
    static Singleton* getInstance();
    void setValue(int val) {value_ = val;}
    int getValue() {return(value_);}
   protected:
    int value_;
   private:
    static Singleton* inst_;   // Единственный экземпляр
    Singleton() : value_(0) {} // частный конструктор
    Singleton(const Singleton&);
    Singleton& operator=(const Singleton&);
   };

   //Определяем указатель
   static Singleton Singleton* Singleton::inst_ = NULL;

   Singleton* Singleton::getInstance() {
    if (inst_ == NULL) {
     inst_ = new Singleton();
    }
    return(inst_);
   }

   int main() {
    Singleton* p1 = Singleton::getInstance();
    p1-&gt;setValue(10);
    Singleton* p2 = Singleton::getInstance();
    cout&lt;&lt; "Value = "&lt;&lt; p2-&gt;getValue()&lt;&lt; '\n';
   }Обсуждение
   Существует множество ситуаций, когда требуется, чтобы у класса существовал только один экземпляр. Для этой цели служит шаблонSingleton.Выполнив несколько простых действий, можно реализовать singleton-класс в С++.
   Когда принимается решение, что требуется только один экземпляр чего-либо, то на ум сразу должно приходить ключевое словоstatic.Как было сказано в рецепте 8.5, переменная-членstatic— это такая, которая может иметь в памяти только один экземпляр. Для отслеживания единственного объекта singleton-класса используйте переменную-членstatic,как сделано в примере 8.9.
   private:
    static Singleton* inst_;
   Чтобы клиентский код ничего про нее не знал, сделайте ееprivate.Убедитесь, что в файле реализации она проинициализирована значениемNULL.
   Singleton* Singleton::inst_ = NULL;
   Чтобы запретить клиентам создавать экземпляры этого класса, сделайте конструкторыprivate,особенно конструктор по умолчанию.
   private:
   Singleton() {}
   Таким образом, если кто-то попробует создать в куче или стеке новый singleton-класс, то он получит дружественную ошибку компилятора.
   Теперь, когда статическая переменная для хранения единственного объектаSingletonсоздана, создание объектовSingletonограничено с помощью ограничения конструкторов; все, что осталось сделать, — это предоставить клиентам способ доступа к единственному экземпляру объектаSingleton.Это делается с помощью статической функции-члена.
   Singleton* Singleton::getInstance() {
    if (inst_ == NULL) {
     inst_ = new Singleton();
    }
    return(inst_);
   }
   Посмотрите, как это работает. Если указательstatic SingletonравенNULL,создается объект. Если он уже был создан, то возвращается его адрес. Клиенты могут получить доступ к экземпляруSingleton,вызвав его статический метод.
   Singleton* p1 = Singleton::getInstance();
   И если вы не хотите, чтобы клиенты работали с указателями, то можно возвращать ссылку.
   Singleton& Singleton::getInstance() {
    if (inst_ == NULL) {
     inst_ = new Singleton();
    }
    return(*inst_);
   }
   Важно здесь то, что в обоих случаях клиентам запрещено создавать экземпляры объектаSingleton,и создается единый интерфейс, который предоставляет доступ к единственному экземпляру.Смотри также
   Рецепт 8.3.
   8.10.Создание интерфейса с помощью абстрактного базового классаПроблема
   Требуется определить интерфейс, который будет реализовываться производными классами, но концепция этого интерфейса является абстракцией и не должна наследоваться сама по себе.Решение
   Создайте абстрактный класс, который определяет интерфейс, объявляя, по крайней мере, одну из своих функций как чисто виртуальную (virtual).Создайте классы, производные от этого абстрактного класса, которые будут использовать различные реализации, обеспечивая при этом один и тот же интерфейс. Пример 8.10 показывает, как можно определить абстрактный класс для чтения настроечного файла.
   Пример 8.10. Использование абстрактного базового класса
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;fstream&gt;

   using namespace std;

   class AbstractConfigFile {
   public:
    virtual ~AbstractConfigFile() {}
    virtual void getKey(const string& header,
     const string& key, strings val) const = 0;
    virtual void exists(const string& header,
     const string& key, strings val) const = 0;
   };

   class TXTConfigFile : public AbstractConfigFile {
   public:
    TXTConfigFile() : in_(NULL) {}
    TXTConfigFile(istream& in) : in_(&in) {}
    virtual ~TXTConfigFile() {}
    virtual void getKey(const string& header,
     const string& key, strings val) const {}
    virtual void exists(const string& header,
     const strings key, strings val) const {}
   protected:
    istream* in_;
   };

   class MyAppClass {
   public:
    MyAppClass() : config_(NULL) {}
    ~MyAppClass() {}
    void setConfigObj(const AbstractConfigFile* p) {config_ = p;}
    void myMethod();
   private:
    const AbstractConfigFile* config_;
   };

   void MyAppClass::myMethod() {
    string val;
    config_-&gt;getKey("Foo", "Bar", val);
    // ...
   }

   int main() {
    ifstream in("foo.txt");
    TXTConfigFile cfg(in);
    MyAppClass m;
    m.setConfigObj(&cfg);
    m.myMethod();
   }Обсуждение
   Абстрактный базовый класс (часто называемый ABC — abstract base class) — это класс, для которого невозможно создать экземпляры, и, таким образом, он выполняет роль исключительно интерфейса. Класс является абстрактным, если он объявляет, по крайней мере, одну чисто виртуальную функцию или наследует функцию без реализации. Таким образом,если требуется создать экземпляр подкласса ABC, то он должен реализовать все виртуальные функции, что означает, что он будет поддерживать интерфейс, объявленный в ABC.
   Подкласс, который наследуется от ABC (и реализует все его чисто виртуальные методы), поддерживает контракт, определенный интерфейсом. Рассмотрим классыMyAppClassиTXTConfigFileиз примера 8.10.MyAppClassсодержит указатель, который указывает на объект типаAbstractConfigFile.
   const AbstractConfigFile* config_;
   (Я сделал егоconst,потому чтоМуАррСlassне должен изменять настроечный файл, а только читать из него.) Пользователи могут указать используемый вMyAppClassнастроечный файл с помощью функции установки значенияsetConfigObj.
   Когда приходит время использовать вMyAppClassнастроечный файл, как это делаетMyAppClass::myMethod,можно вызвать любую из функций, объявленных вAbstractConfigFile,независимо от реально используемого типа настроечного файла. Это может бытьTXTConfigFile,XMLConfigFileили любой другой, который наследуется отAbstractConfigFile.
   Это полиморфное поведение является следствием наследования: если код ссылается на объект базового класса, вызов виртуальных функций для него приведет к их динамической переадресации и вызову правильных версий подкласса этого класса при условии, что реальный объект, на который ссылается код, является объектом этого подкласса. Но это происходит независимо от того, является ли базовый класс ABC или нет. Так в чем же разница?
   Здесь имеется два различия. Чисто виртуальный класс (ABC, который не предоставляет никаких реализаций) служит только как контракт, которому должны подчиняться все подклассы, если требуется создавать их объекты. Часто это означает, что проверка на принадлежность подкласса к чисто интерфейсному классу может не сработать (что означает, что нельзя сказать, что объект подкласса является также и объектом базового класса), но что сработает проверка «ведет себя как». Это позволяет различать то, чем объект является, оттого, что он может сделать. Спасибо Супермену. Он человек, но он также и супергерой. Супергерои могут летать как птицы, но сказать, что супергерой — это птица, будет неверно. Иерархия классов для Супермена может выглядеть так, как это показано в примере 8.11.
   Пример 8.11. Использование чистого интерфейса
   class Person {
   public:
    virtual void eat() = 0;
    virtual void sleep() = 0;
    virtual void walk() = 0;
    virtual void jump() = 0;
   };

   class IAirborne {
   public:
    virtual void fly() = 0;
    virtual void up() = 0;
    virtual void down() = 0;
   };

   class Superhero : public Person, //Супергерой «является» человеком
                 public IAirborne { // и летает
   public:
    virtual void eat();
    virtual void sleep();
    virtual void walk();
    virtual void jump();
    virtual void fly();
    virtual void up();
    virtual void down();
    virtual ~Superhero();
   };

   void Superhero::fly() {
    // ...
   }

   //Все виртуальные методы реализуем в родительских классах супергероя...
   int main() {
    Superhero superman;
    superman.walk(); // Супермен может ходить как человек
    superman.fly();  // или летать как птица
   }
   Однако летать может огромное количество объектов, так что не стоит называть этот интерфейс, например,IBird.IAirborneуказывает, что всё, что поддерживает этот интерфейс, может летать. Все, что он делает, — это позволяет клиентскому коду быть уверенным, что если он работает с объектом, наследуемым отIAirborne,клиентский код может вызвать методыfly,upиdown.
   Второе различие состоит в том, что ABC может определить абстрактную сущность, которая не имеет смысла как объект, так как она, по сути, является обобщением. В этом случае проверка на принадлежность при наследовании выполняется, но ABC — это абстракция, так как сам по себе он не содержит реализаций, которые могут наследоваться объектами. Рассмотрим классAbstractConfigFileиз примера 8.10. Имеет ли смысл создавать объект типаAbstractConfigFile?Нет, имеет смысл только создавать различные виды настроечных файлов, которые имеют конкретное представление.
   Вот краткий перечень правил, касающихся абстрактных классов и чисто виртуальных функций. Класс является абстрактным, если:
   • он объявляет, по крайней мере, одну чисто виртуальную функцию;
   • он наследует, но не реализует, по крайней мере, одну чисто виртуальную функцию.
   Создавать объекты абстрактного класса нельзя. Однако абстрактный класс может:
   • содержать данные-члены;
   • содержать не-виртуальные методы;
   • предоставлять реализации для чисто виртуальных функций;
   • делать большую часть из того, что может делать обычный класс.
   Другими словами, с ними можно делать почти все, что можно делать с обычными классами, кроме создания объектов этих классов.
   Когда дело доходит до реализации, использование ABC в C++ требует осторожности. Используется ли ABC как чистый интерфейс или нет, зависит от вас. Например, предположим на мгновение, что в примере с супергероем я решил, что классPersonдолжен быть абстрактным, но так как все виды людей имеют имя и фамилию, я добавил в класс эти два члена и связал с ними методы их задания и получения, так что авторам подклассов этого делать уже не требуется.
   class Person {
   public:
    virtual void eat() = 0;
    virtual void sleep() = 0;
    virtual void walk() = 0;
    virtual void jump() = 0;
    virtual void setFirstName(const string& s) {firstName_ = s;}
    virtual void setLastName(const string& s) {lastName_ = s;}
    virtual string getFirstName() {return(firstName_);}
    virtual string getLastName() {return(lastName_);}
   protected:
    string firstName_;
    string lastName_;
   };
   Теперь, если подклассSuperheroхочет переопределить одну из этих функций, то он может это сделать. Все, что он должен сделать, чтобы указать, какая версия должна вызываться, — это использовать имя базового класса. Например:
   string Superhero::getLastName() {
    return(Person::getLastName() + " (Superhero)");
   }
   Кстати, эти функции также можно сделать чисто виртуальными и предоставить реализацию по умолчанию. Для этого после объявления требуется использовать запись вида=0,а собственно определение поместить куда-либо еще, как здесь.
   class Person {
    // ...
    virtual void setFirstName(const string& s) = 0;
    // ...
    Person::setFirstName(const string& s) {
     firstName_ = s;
    }
   Сделав так, вы заставите подклассы переопределять этот метод, но они, если это требуется, по-прежнему могут вызвать версию по умолчанию, использовав для этого полное имя класса.
   Наконец, если в базовом классе создать виртуальный деструктор (чистый или нет), то потребуется предоставить тело для него. Это требуется потому, что деструктор подкласса автоматически вызывается деструктором базового класса.
   8.11.Написание шаблона классаПроблема
   Имеется класс, чьи члены в различных ситуациях должны иметь разные типы, а использование обычного полиморфного поведения очень сложно или сильно избыточно. Другими словами, как разработчик класса, вы хотите, чтобы пользователь класса при создании объектов этого класса мог выбрать типы различных его частей, вместо того чтобыуказывать их при первоначальном определении класса.Решение
   Для параметризации типов, которые используются при объявлении членов класса (и в других случаях), используйте шаблон класса. Это значит, что требуется написать класс с заполнителями типов, оставив, таким образом, выбор используемых типов на усмотрение пользователя класса. В примере 8.12 показан пример класса узла дерева, который может указывать на любой тип.
   Пример 8.12. Написание шаблона класса
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using namespace std;

   template&lt;typename T&gt;
   class TreeNode {
   public:
    TreeNode (const T& val) : val_(val), left_(NULL), right_(NULL) {}
    ~TreeNode() {
     delete left_;
     delete right_;
    }
    const T& getVal() const {return(val_);}
    void setVal(const T& val) {val_ = val;}
    void addChild(TreeNode&lt;T&gt;* p) {
     const T& other = p-&gt;getVal();
     if (other&gt; val_)
      if (rights)
       right_-&gt;addChild(p);
      else
       right_ = p;
     else
      if (left_)
       left_-&gt;addChild(p);
      else
       left_ = p;
    }
    const TreeNode&lt;T&gt;* getLeft() {return(left_);}
    const TreeNode&lt;T&gt;* getRight() {return(right_);}
   private:
    T val_;
    TreeNode&lt;T&gt;* left_;
    TreeNode&lt;T&gt;* right_;
   };

   int main() {
    TreeNode&lt;string&gt; node1("frank");
    TreeNode&lt;string&gt; node2("larry");
    TreeNode&lt;string&gt; node3("bill");
    node1.addChild(&node2);
    node1.addChild(&node3);
   }Обсуждение
   Шаблоны классов предоставляют способ параметризации типов, используемых в классе, так что эти типы могут указываться пользователем класса при создании объектов. Однако шаблоны могут оказаться несколько запутанными, так что позвольте мне перед разбором их работы пояснить приведенный выше пример.
   Рассмотрим объявление шаблона классаTreeNodeиз примера 8.12.
   template&lt;typename T&gt; class TreeNode {
   //...
   Частьtemplate&lt;typename T&gt;— это то, что делает этот класс шаблоном, а не обычным классом. Эта строка говорит, чтоT— это имя типа, который будет указан при использовании класса, а не при его объявлении. После этого параметрTможет использоваться в объявлении и определенииTreeNodeтак, как будто это обычный тип — встроенный или определенный пользователем. Например, имеется частный член с именемval_,который должен иметь типT.Тогда его объявление будет иметь вид:
   T val_;
   Здесь просто объявляется член класса с именемval_некоторого типа, который будет определен позднее. Это объявление выглядит так же, как и при использовании дляval_типовint,float,MyClassилиstring.В этом отношении его можно рассматривать как макрос (т.е. использование#define),хотя сходство с макросом на этом и заканчивается.
   Параметр типа может применяться любым способом, которым можно использовать обычный параметр: возвращаемые значения, указатели, параметры методов и т.д. Рассмотрим методы установки и полученияval_.
   const T& getVal() const (return(val_);}
   void setVal(const T& val) {val_ = val;}
   getValвозвращаетconst-ссылку наval_,имеющий типT, asetValпринимает ссылку наTи записывает ее значение вval_.Некоторые сложности появляются в отношении методовgetLeftиgetRight,так что далее я вернусь к этому вопросу. Подождите немного.
   Теперь, когдаTreeNodeобъявлен с помощью заполнителя типа, его должен использовать клиентский код. Вот как это делается.
   TreeNode— это простая реализация двоичного дерева. Чтобы создать дерево, которое хранит строковые значения, создайте узлы следующим образом.
   ТreeNode&lt;string&gt; node1("frank");
   TreeNode&lt;string&gt; node2("larry");
   TreeNode&lt;string&gt; node3("bill");
   Тип между угловыми скобками — это то, что используется вместоTприсоздании экземпляра класса.Создание экземпляра шаблона — это процесс, выполняемый компилятором при создании версииTreeNodeпри условии, чтоT— этоstring.Двоичное физическое представлениеTreeNode&lt;string&gt;создается тогда, когда создается его экземпляр (и только в этом случае). В результате в памяти получается структура, эквивалентная той, которая была бы, еслиTreeNodeбыл написан без ключевого словаtemplateи параметра типа, а вместоTиспользовался быstring.
   Создание экземпляра шаблона для данного параметра типа аналогично созданию экземпляра объекта любого класса. Ключевое различие состоит в том, что создание экземпляра шаблона происходит в процессе компиляции, в то время как создание объекта класса происходит во время выполнения программы. Это означает, что если вместоstringдвоичное дерево должно хранить данные типаint,его узлы должны быть объявлены вот так.
   TreeNode&lt;int&gt; intNode1(7);
   TreeNode&lt;int&gt; intNode2(11);
   TreeNode&lt;int&gt; intNode3(13);
   Как и в случае с версией дляstring,создается двоичное представление шаблона классаTreeNodeс использованием внутреннего типаint.
   Некоторое время назад я сказал, что рассмотрю методыgetLeftиgetRight.Теперь, когда вы знакомы с созданием экземпляра шаблона (если еще не были), объявление и определениеgetLeftиgetRightдолжно стать более осмысленным.
   const TreeNode&lt;T&gt;* getLeft() {return(left_);}
   const TreeNode&lt;T&gt;* getRight() {return(right_);}
   Здесь говорится, что каждый из этих методов возвращает указатель на экземплярTreeNodeдляT.Следовательно, когда создается экземплярTreeNodeдля, скажем,string,экземплярыgetLeftиgetRightсоздаются следующим образом.
   const TreeNode&lt;string&gt;* getLeft() {return(left_);}
   const TreeNode&lt;string&gt;* getRight() {return(right_);}
   При этом не существует ограничения одним параметром шаблона. Если требуется, можно использовать несколько таких параметров. Представьте, что вам требуется отслеживать число дочерних узлов данного узла, но пользователи вашего класса могут быть ограничены в использовании памяти и не захотят использоватьint,если смогут обойтисьshort.Аналогично они могут захотеть применять для подсчета использованных узлов что-то более сложное, чем простой встроенный тип (например, их собственный класс). В любом случае это можно разрешить сделать с помощью еще одного параметра шаблона.
   template&lt;typename T, typename N = short&gt;
   class TreeNode {
    // ...
    N getNumChildren();
   private:
    TreeNode() {}
    T val_;
    N numChildren_;
    // ...
   Таким образом, человек, использующий ваш класс, может указать для отслеживания размера поддеревьев каждого узлаint,shortили что-либо еще.
   Для параметров шаблона также можно указать аргументы по умолчанию, как это сделано в моем примере, для чего используется такой же синтаксис, как и при объявлении параметров функций по умолчанию.
   template&lt;typename T, typename N = short&gt;
   Как и в случае с параметрами функций по умолчанию, их можно использовать только для отдельных параметров при условии, что этот последний параметр или все параметры справа от него имеют аргументы по умолчанию.
   В примере 8.12 определение шаблона дается в том же месте, что и его объявление. Обычно это делается для экономии места, занимаемого примером, не в данном случае есть иеще одна причина. Шаблоны (классов или функций — см. рецепт 8.12) компилируются в двоичную форму только тогда, когда создается их экземпляр. Таким образом, невозможно создать объявление шаблона в заголовочном файле, а его реализацию — в исходном файле (т.е..cpp)Причина заключается в том, что в нем нечего компилировать! Из этого правила имеются исключения, но обычно при написании шаблона класса его реализация должна помешаться в заголовочном файле или встраиваемом файле, который подключается заголовочным.
   В этом случае требуется использовать несколько необычный синтаксис. Методы и другие части класса объявляются как в обычном классе, но при определении методов требуется включить дополнительные лексемы, которые говорят компилятору, что это части шаблона класса. Например,getValможно определить вот так (сравните с примером 8.12)
   template&lt;typename T&gt;
   const T& TreeNode&lt;T&gt;::getVal() const {
    return(val_);
   }
   Тело функции выглядит точно так же.
   Однако с шаблонами следует быть осторожными, так как если написать шаблон, который используется повсеместно, то можно получитьраздувание кода,что случается, когда один и тот же шаблон с одними и теми же параметрами (например,TreeNode&lt;int, short&gt;)компилируется в нескольких объектных файлах. По существу в нескольких файлах окажется одно и то же двоичное представление экземпляра шаблона, и это сделает библиотеку или исполняемый файл значительно больше по размеру, чем требуется.
   Одним из способов избежать этого является использование явного создания экземпляров, что позволяет указать компилятору создать версию шаблона класса для определенного набора аргументов шаблона. Если сделать это в таком месте, которое компонуется вместе с остальными клиентскими частями, то раздувания кода не произойдет. Например, если известно, что в приложении будет использоватьсяTreeNode&lt;string&gt;,то в общий исходный файл можно поместить такую строку.
   // common.cpp
   template class TreeNode&lt;string&gt;;
   Соберите динамическую библиотеку с этим файлом, и после этого код, использующийTreeNode&lt;string&gt;,сможет применять эту библиотеку динамически, не содержа своей собственной скомпилированной версии шаблона. Другой код может включить заголовочный файл шаблона класса, затем скомпоноваться с этой библиотекой и. следовательно, избежать необходимости иметь свою копию. Однако этот подход требует проведения экспериментов, так как не все компиляторы имеют одинаковые проблемы с раздуванием кода, но это общий подход для его минимизации.
   Шаблоны C++ (как классов, так и функций) — это очень обширная тема, и имеется огромное количество методик создания мощных, эффективных проектов на основе шаблонов. Великолепным примером шаблонов классов являются контейнеры из стандартной библиотеки, такие какvector,list,setи другие, которые описываются в главе 15. Большая часть интересных разработок, описанных в литературе по С++, связана с шаблонами. Если вы заинтересовались этим предметом, почитайте группы новостейcomp.lang.std.c++иcomp.lang.c++.В них всегда можно найти интересные вопросы и ответы на них.Смотри также
   Рецепт 8.12.
   8.12.Написание шаблона метода классаПроблема
   Имеется один метод, который должен принимать параметр любого типа, и невозможно ограничиться каким-либо одним типом или категорией типов (используя указатель на базовый класс).Решение
   Используйте шаблон метода и объявите параметр шаблона для типа объекта. Небольшая иллюстрация приведена в примере 8.13.
   Пример 8.13. Использование шаблона метода
   class ObjectManager {
   public:
    template&lt;typename T&gt; T* gimmeAnObject();
    template&lt;typename T&gt;
    void gimmeAnObject(T*& p);
   };

   template&lt;typename T&gt;
   T* ObjectManager::gimmeAnObject() {
    return(new T);
   }

   template&lt;typename T&gt;
   void ObjectManager::gimmeAnObject(T*& p) {
    p = new T;
   }

   class X { /*...*/ };

   class Y { /* ... */ };

   int main() {
    ObjectManager om;
    X* p1 = om.gimmeAnObject&lt;X&gt;(); //Требуется указать параметр
    Y* p2 = om.gimmeAnObject&lt;Y&gt;(); //шаблона
    om.gimmeAnObject(p1); // Однако не здесь, так как компилятор может
    om.gimmeAnObject(p2); // догадаться о типе T по аргументам
   }Обсуждение
   При обсуждении шаблонов функций или классов слова «параметр» и «аргумент» становятся несколько двусмысленными. Имеется по два вида каждого: шаблона и функции. Параметры шаблона — это параметры в угловых скобках, напримерTв примере 8.13, а параметры функции — это параметры в обычном смысле.
   Рассмотрим классObjectManagerиз примера 8.13. Это упрощенная версия шаблона фабрики, описанного в рецепте 8.2, так что мне потребовалось объявить методgimmeAnObject,который создает новые объекты и который клиентский код сможет использовать вместо непосредственного обращения кnew.Это можно сделать, либо возвращая указатель на новый объект, либо изменяя указатель, переданный в метод клиентским кодом. Давайте посмотрим на каждый из этих подходов.
   Объявление шаблона метода требует, чтобы было использовано ключевое словоtemplateи были указаны параметры шаблона.
   template&lt;typename T&gt; T* gimmeAnObject();
   template&lt;typename T&gt; void gimmeAnObject(T*& p);
   Оба этих метода используют в качестве параметра шаблонаT,но они не обязаны это делать. Каждый из них представляет параметр шаблона только для данного метода, так что их имена не связаны друг с другом. То же самое требуетсясделать для определения этих шаблонов методов, т.е. использовать это же ключевое слово и перечень параметров шаблона. Вот как выглядят мои определения.
   template&lt;typename T&gt;
   T* ObjectManager.:gimmeAnObject() {
    return(new T);
   }

   template&lt;typename T&gt;
   void ObjectManager::gimmeAnObject(T*& p) {
    p = new T;
   }
   Теперь есть пара способов вызвать эти шаблоны методов. Во-первых, их можно вызвать явно, используя параметры шаблона, как здесь.
   X* p1 = om.gimmeAnObject&lt;X&gt;();
   X— это имя некоего класса. Либо можно позволить компилятору догадаться об аргументах параметров шаблона, передав в методы аргументы типа (типов) параметров шаблона. Например, можно вызвать вторую формуgimmeAnObject,не передавая ей ничего в угловых скобках.
   om.gimmeAnObject(p1);
   Это работает благодаря тому, что компилятор может догадаться оT,посмотрев наp1и распознав, что он имеет типX*.Такое поведение работает только для шаблонов функций (методов или отдельных) и только тогда, когда параметры шаблона понятны изаргументов функции.
   Шаблоны методов не имеют большой популярности при разработке на C++, но время от времени они оказываются очень полезны, так что следует знать, как создавать их. Я часто сталкиваюсь с необходимостью сдерживать себя, когда мне хочется использовать метод, который бы работал с типами, которые не связаны друг с другом механизмом наследования. Например, если есть методfoo,который должен принимать один аргумент, который всегда будет классом, наследуемым от некоторого базового класса, то шаблон не требуется: здесь можно просто сделать параметр типа базового класса или ссылки. После этого этот метод будет прекрасно работать с параметром, имеющим тип любого подкласса; это обеспечивается самим C++.
   Но может потребоваться функция, которая работает с параметрами, которые не наследуются от одного и того же базового класса (или классов). В этом случае можно либо написать несколько раз один и тот же метод — по одному разу для каждого из типов, либо сделать его шаблоном метода. Использование шаблонов также позволяет использовать специализацию, предоставляющую возможность создавать реализации шаблонов для определенных аргументов шаблона. Но это выходит за рамки одного рецепта, так что сейчас я прекращаю обсуждение, но это мощная методика, поэтому при использовании программирования шаблонов не забудьте про такую возможность.Смотри также
   Рецепт 8.11.
   8.13.Перегрузка операторов инкремента и декрементаПроблема
   Имеется класс, для которого имеют смысл операции инкремента и декремента, и требуется перегрузитьoperator++иoperator--,которые позволят легко и интуитивно выполнять инкремент и декремент объектов этого класса.Решение
   Чтобы это сделать, перегрузите префиксную и постфиксную формы++и--.Пример 8.14 показывает обычную методику перегрузки операторов инкремента и декремента.
   Пример 8.14. Перегрузка инкремента и декремента
   #include&lt;iostream&gt;

   using namespace std;

   class Score {
   public:
    Score() : score_(0) {}
    Score(int i) : score_(i) {}
    Score& operator++() {
     // префикс
     ++score_;
     return(*this);
    }
    const Score operator++(int) {
     // постфикс
     Score tmp(*this);
     ++(*this); // Использование префиксного оператора
     return(tmp);
    }
    Score& operator--() {
     --score_;
     return(*this);
    }
    const Score operator--(int x) {
     Score tmp(*this);
     --(*this);
     return(tmp);
    }
    int getScore() const {return(score_);}
   private:
    int score_;
   };

   int main() {
    Score player1(50);
    player1++;
    ++player1; // score = 52
    cout&lt;&lt; "Счет = "&lt;&lt; player1.getScore()&lt;&lt; '\n';
    (--player1)--; // score_ = 50
    cout&lt;&lt; "Счет = "&lt;&lt; player1.getScore()&lt;&lt; '\n';
   }Обсуждение
   Операторы инкремента и декремента часто имеют смысл для классов, которые представляют некоторые разновидности целых значений. Если вы понимаете разницу между префиксной и постфиксной формами и следуете соглашениям о возвращаемых значениях, то их легко использовать.
   Представьте себе инкремент целого числа. С помощью оператора++имеется два способа выполнить его для некоторого целогоi.
   i++; //постфиксный
   ++i; //префиксный
   Оба инкрементируютi:первая версия создает временную копиюi,инкрементируетiи затем возвращает временное значение, а вторая инкрементируетiи затем возвращает его. C++ позволяет выполнять перегрузку операторов, что означает, что вы можете заставить свой собственный тип (класс илиenum)вести себя так же, как иint.
   Чтобы добиться нужного эффекта, перегрузитеoperator++иoperator--.Пример 8.14 иллюстрирует, как перегружать префиксную и постфиксную версии.
   Score& operator++() { //префиксный
    ++score_;
    return(*this);
   }

   const Score operator++(int) { //постфиксный
    Score tmp(*this);
    ++(*this);
    return(tmp);
   }
   Префикс выглядит так, как и следует ожидать, но компилятор различает эти две версии, и в объявление постфиксной версии включается параметрint.Он не имеет семантического применения — он всегда передается как ноль, так что его можно игнорировать.
   После этого классScoreможно использовать какint.
   Score player1(50);
   player1++;
   ++player1; // score_ = 52
   Вы, вероятно, заметили, что сигнатуры префиксной версииoperator++возвращают ссылку на текущий класс. Именно так и следует делать (а не возвращать, к примеру,void),чтобы инкрементируемый или декрементируемый объект мог использоваться в других выражениях. Рассмотрим такую строку из примера.
   (--player1)--;
   Да, это странно, но она иллюстрирует этот момент. Если бы префиксныйoperator--не возвращал чего-то осмысленного, то это выражение не скомпилировалось бы. Еще один пример показывает вызов функции.
   foo(--player1);
   Функцияfooожидает аргумент типаScore,и для корректной компиляции именно это должно возвращаться из префиксногоoperator--.
   Перегрузка операторов — это мощная возможность, которая позволяет для типов, определяемых пользователем, использовать те же операторы, что и для встроенных типов. Сторонники других языков, которые не поддерживают перегрузку операторов, утверждают, что эта возможность сбивает с толку и очень сложна, и, следует признать, может быть перегружено очень много операторов, соответствующих любому поведению. Но когда дело касается простого инкремента и декремента, хорошо иметь возможность изменить поведение класса так, как этого хочется.Смотри также
   Рецепт 8.14.
   8.14.Перегрузка арифметических операторов и операторов присвоения для работы с классамиПроблема
   Имеется класс, для которого имеют смысл некоторые из унарных или бинарных операторов С++, и требуется, чтобы пользователи класса могли использовать их при работе с объектами этого класса. Например, если есть класс с именемBalance,который содержит значение с плавающей точкой (например, баланс счета), будет удобно, если для объектовBalanceможно было бы использовать некоторые стандартные операторы С++, как здесь.
   Balance checking(50.0);
   savings(100.0);
   checking += 12.0;
   Balance total = checking + savings;Решение
   Перегрузите операторы, которые требуется использовать как методы и отдельные функции, указав аргументы различных типов, для которых данный оператор имеет смысл, как в примере 8.15.
   Пример 8.15. Перегрузка унарных и бинарных операторов
   #include&lt;iostream&gt;

   using namespace std;

   class Balance {
    // These have to see private data
    friend const Balance operator+(const Balance& lhs, const Balance& rhs);
    friend const Balance operator+(double lhs, const Balance& rhs);
    friend const Balance operator+(const Balance& lhs, double rhs);
   public:
    Balance() : val_(0.0) {}
    Balance(double val) : val_(val) {}
    ~Balance() {}

    // Унарные операторы
    Balance& operator+=(const Balance& other) {
     val_ += other.val_;
     return(*this);
    }
    Balance& operator+=(double other) {
     val_ += other;
     return(*this);
    }
    double getVal() const {return(val_);}
   private:
    double val_;
   };

   //Бинарные операторы
   const Balance operator+(const Balance& lhs, const Balance& rhs) {
    Balance tmp(lhs.val_ + rhs.val_);
    return(tmp);
   }

   const Balance operator+(double lhs, const Balance& rhs) {
    Balance tmp(lhs + rhs.val_);
    return(tmp);
   }

   const Balance operator+(const Balance& lhs, double rhs) {
    Balance tmp(lhs.val_ + rhs);
    return(tmp);
   }

   int main() {
    Balance checking(500.00);
    savings(23.91);
    checking += 50;
    Balance total = checking + savings;
    cout&lt;&lt; "Платежный баланс: "&lt;&lt; checking.getVal()&lt;&lt; '\n';
    cout&lt;&lt; "Общий баланс: "&lt;&lt; total.getVal()&lt;&lt; '\n';
   }Обсуждение
   Наиболее часто используют перегрузку для арифметических операторов и операторов присвоения. Существует огромное количество различных классов, для которых имеютсмысл арифметические операторы (сложение, умножение, остаток от деления, сдвиг битов вправо/влево) и операторы присвоения — вне зависимости от того, используются ли они для вычислений или для чего-то другого. Пример 8.15 показывает основные методики перегрузки этих операторов.
   Давайте начнем с того, что, вероятно, является наиболее часто перегружаемым оператором, — оператора присвоения. Оператор присвоения используется при присвоении одного объекта другому, как в следующем выражении.
   Balance x(0),у(32);
   x = y;
   Вторая строка — это краткая запись вызоваBalance::operator=(y).Оператор присвоения отличается от большинства других операторов тем, что если вы не создаете собственной его версии, то компилятором создается версия по умолчанию. Версия по умолчанию просто копирует в текущий объект каждый член целевого объекта, что, конечно, не всегда приемлемо, так что его можно перегрузить и обеспечить другое поведение или перегрузить и предоставить возможность присвоения объектов типов, отличных от текущего
   Для классаBalanceиз примера 8.15 оператор присвоения можно определить вот так.
   Balance& operator=(const Balance& other) {
    val_ = other.val_;
    return(*this);
   }
   Первое, на что вы должны обратить внимание, если не знакомы с перегрузкой операторов, — это синтаксисoperator=.Именно так объявляются все операторы. Все операторы можно рассматривать как функции с именамиoperator[symbol],гдеsymbol— это перегружаемый оператор. Единственным различием между операторами и обычными функциями является синтаксис их вызова. На самом деле, если вы хотите ввести побольше кода и написать отвратительно выглядящий код, то операторы можно вызывать и с помощью такого синтаксиса.
   x.operator=(y); //То же самое, что и x = y, но уродливее
   Работа моей реализации оператора присвоения проста. Он обновляет членval_текущего объекта, записывая в него значение аргументаother,а затем возвращает ссылку на текущий объект. Операторы присвоения возвращают текущий объект как ссылку, так что вызывающий код может использовать присвоение в выражениях:
   Balance x, y, z;
   // ...
   x = (y = z);
   Таким образом, возвращаемое из(y = z)значение — это измененный объектy,который затем передается в оператор присвоения объектаx.Такая запись для присвоения используется не так часто, как для арифметических операторов, но чтобы придерживаться общего соглашения, всегда следует возвращать ссылку на текущий объект (то, как это связано с арифметическими операторами, я рассказываю дальше).
   Однако простое присвоение — это только начало. Скорее всего, вам потребуется использовать другие арифметические операторы, определяющие более интересное поведение. В табл. 8.1 показан перечень арифметических операторов и операторов присвоения.

   Табл. 8.1. Арифметические операторы и присвоениеОператорПоведение=Присвоение (должен быть функцией-членом)+Сложение- -=Вычитание* *=Умножение и разыменование/ /=Деление% %=Остаток от деления++Инкремент--Декремент^ ^=Битовое исключающее ИЛИ~Битовое дополнение&&=Битовое И| |=Битовое ИЛИ&lt;&lt;&lt;&lt;=Сдвиг влево&gt;&gt;&gt;&gt;=Сдвиг вправо
   Для большинства операторов из табл. 8.1 существует две лексемы: первая — это версия оператора, используемая обычным образом, т.е.1+2,а вторая версия — это версия, которая также присваивает результат операции переменной, т. е.x+=5.Заметьте, что операторы инкремента и декремент++и--описываются в рецепте 8.13.
   Реализация всех арифметических операторов и оператора присвоения очень похожа, за исключением оператора присвоения, который не может быть отдельной функцией (т.е. он должен быть методом).
   Наиболее популярным при перегрузке является оператор сложения — благодаря тому что он может использоваться в отличных от математических контекстах, таких как объединение двух строк, так что давайте вначале рассмотрим именно его. Он складывает правый аргумент с левым и присваивает результирующее значение левому аргументу, как в выражении.
   int i = 0;
   i += 5;
   После выполнения второй строкиint iизменяется и содержит значение 5. Аналогично, если посмотреть на пример 8.15, следует ожидать такого же поведения от этих строк.
   Balance checking(500.00), savings(23.91);
   checking += 50;
   Это означает, что следует ожидать, что после использования оператора+=значениеcheckingбудет увеличено на 50. Именно это происходит при использовании реализации из примера 8.15. Посмотрите на определение функции для оператора+=.
   Balance& operator+=(double other) {
    val_ += other;
    return(*this);
   }
   Для оператора присвоения список параметров — это то, что будет указано в операторе в его правой части. В данном случае используется целое число. Тело этой функции тривиально: все, что здесь делается, — это добавление аргумента к частной переменной-члену. Когда эта работа сделана, возвращается*this.Возвращаемым значением из арифметических операторов и операторов присвоения должно быть*this,что позволяет использовать их в выражениях, когда их результаты будут входом для чего-то еще. Например, представьте, что operator+= объявлен вот так.
   void operator+=(double other) { //Не делайте так
    val += other;
   }
   Затем кто-то захочет использовать этот оператор для экземпляра класса и передать результат в другую функцию.
   Balance moneyMarket(1000.00);
   // ...
   updateGeneralLeager(moneyMarket += deposit); // Heскомпилируется
   Это приведет к проблеме, так какBalance::operator+=возвращаетvoid,а функция типаupdateGeneralLedgerожидает получить объект типа Balance. Если из арифметических операторов и оператора присвоения возвращать текущий объект, то этой проблемы не возникнет. Однако это верно не для всех операторов. Другие операторы, типа оператора элемента массива[]или оператора отношения возвращают объекты, отличные от*this,так что это правило верно только для арифметических операторов и операторов присвоения.
   Здесь обеспечивается работа операторов присвоения, выполняющих какие-то вычисления, но как насчет вычислений без присвоения? Еще один способ использовать арифметические операторы выглядит так.
   int i = 0, j = 2;
   i = j + 5;
   В этом случае к значениюjприбавляется 5, а затем результат присваиваетсяi (при этом, если быiбыл объектом класса, а не встроенного типа, использовался бы оператор присвоения этого класса), а значениеjостается без изменения. Если требуется, чтобы класс вел себя точно так же, то перегрузите оператор сложения как самостоятельную функцию. Например, имеется возможность сделать так, чтобы можно было записать следующее.
   Balance checking(500.00), savings(100.00), total(0);
   total = checking + savings;
   Это делается в два этапа. Первый шаг — это создание функции, которая перегружает оператор+.
   Balance operator+(const Balance& lhs, const Balance& rhs) {
    Balance tmp(lhs.val_ + rhs.val_);
    return(tmp);
   }
   Она принимает два объекта типаconst Balance,складывает их частные члены, создает временный объект и возвращает его. Обратите внимание, что в отличие от оператора присвоения здесь возвращается объект, а не ссылка на него. Это сделано потому, что возвращаемый объект является временным, и возврат ссылки на него будет означать, что вызывающий код получит ссылку на удаленную из памяти переменную. Однако само по себе это работать не будет, так как здесь требуется доступ к закрытым (частным) членам аргументов оператора (если, конечно, вы не сделали данные класса открытыми). Чтобы обеспечить такой доступ, классBalanceдолжен объявить эту функцию какfriend.
   class Balance {
    // Здесь требуется видеть частные данные
    friend Balance operator+(const Balance& lhs, const Balance& rhs);
    // ...
   Все что объявляется, какfriend,получает доступ ко всем членам класса, так что этот фокус сработает. Только не забудьте объявить параметры какconst,чтобы случайно не изменить их содержимое.Это почти все, что от вас требуется, но есть еще кое-что, что требуется сделать. Пользователи класса могут создать выражение, аналогичное такому.
   total = savings + 500.00;
   Для кода из примера 8.15 это выражение будет работать, так как компилятор увидит, что классBalanceсодержит конструктор, который принимает число с плавающей точкой, и создаст временный объектBalance,используя в конструкторе число 500.00. Однако здесь есть две проблемы: накладные расходы на создание временного объекта и отсутствие в классеBalanceконструктора для всех возможных аргументов, которые могут использоваться в операторе сложения. Скажем, имеется класс с именемTransaction,который представляет сумму кредита или дебета. ПользовательBalanceможет сделать что-то подобное этому.
   Transaction tx(-20.00);
   total = savings + tx;
   Этот код не скомпилируется, так как не существует оператора, который бы складывал объектыВаlanceиTransaction.Так что создайте такой.
   Balance operator+(const Balance& lhs, const Transaction& rhs) {
    Balance tmp(lhs.val_ + Transaction.amount_);
    return(tmp);
   }
   Однако необходимо сделать еще кое-что. Этот оператор также требуется объявить какfriendв классеTransaction,а кроме того, нужно создать идентичную версию этого оператора, которая бы принимала аргументы в обратном порядке, что позволит использовать аргументы сложения в любом порядке и сделает эту операцию коммутативной, т.е.x+y == y+x.
   Balance operator+(const Transaction& lhs, const Balance& rhs) {
    Balance tmp(lhs.amount_ + rhs.val_);
    return(tmp);
   }
   По той же причине и чтобы избежать создания дополнительного временного объекта при автоматическом вызове конструктора, создайте собственные версии операторов для работы с любыми другими типами переменных.
   Balance operator+(double lhs, const Balance& rhs) {
    Balance tmp(lhs + rhs.val_);
    return(tmp);
   }

   Balance operator+(const Balance& lhs, double rhs) {
    Balance tmp(lhs.val_ + rhs);
    return(tmp);
   }
   И снова требуется создать по две версии каждого, чтобы позволить запись, как здесь.
   total = 500.00 + checking;
   В этом случае создание временного объекта относительно недорого. Но временный объект — это временный объект, и в простых выражениях он не создаст заметных накладных расходов, но такие незначительные оптимизации всегда следует рассматривать в более широком контексте — что, если в результате инкремента каждого элементаvector&lt;Balance&gt;будет создан миллион таких временных объектов? Лучше всего заранее узнать, как будет использоваться класс, и в случае сомнений провести измерительные тесты.
   В этот момент уместно спросить, почему для этих операторов мы должны создавать отдельные функции и не можем использовать методы, как это делается для присвоения? На самом деле выможетеобъявить эти операторы как методы класса, но это не позволит создавать коммутативные операторы. Чтобы сделать оператор коммутативным, его потребуется объявить как метод в обоих классах, которые будут участвовать в операции, и это сработает (хотя и только для классов, знающих о внутренних членах друг друга), но если нет доступных конструкторов, это не сработает для операторов, использующих встроенные типы, и даже если конструкторы есть, придется платить за создание временных объектов.
   Перегрузка операторов — это мощная возможность С++, и аналогично множественному наследованию имеются как ее сторонники, так и противники. На самом деле большая часть популярных языков не поддерживает ее совсем. Однако при осторожном использовании она дает возможность писать качественный и компактный код, использующий классы.
   Большая часть стандартных операторов имеет несколько значений, и в общем случае вы должны следовать общепринятым соглашениям. Например, оператор&lt;&lt;означает битовый сдвиг влево или, при работе с потоками, помещение чего-либо в поток, как здесь.
   cout&lt;&lt; "Это записывается в поток стандартного вывода.\n.";
   Если вы решите перегрузить&lt;&lt;для одного из своих классов, он должен делать одно из этих действий или, по крайней мере, аналогичное им. Перегрузка оператора — это одно, а придание им другого семантического смысла — это совсем другое. Если вы не вводите новое соглашение, повсеместно используемое в вашем приложении или библиотеке (что все равно является плохой идеей), и оно не является интуитивно понятным кому-либо еще, кроме вас, следует строго придерживаться стандартных значений.
   Чтобы эффективно перегрузить операторы, требуется проделать большое количество черновой работы. Но ее требуется проделать только один раз, и она будет окупаться каждый раз, когда ваш класс будет использоваться в простых выражениях. При умеренном и разумном использовании перегрузки операторов она может сделать код легким как для чтения, так и для написания.Смотри также
   Рецепт 8.13.
   8.15.Вызов виртуальной функции родительского классаПроблема
   Требуется вызвать функцию родительского класса, но она переопределена в производном классе, так что обычный синтаксисp-&gt;method()не дает нужного результата.Решение
   Укажите полное имя вызываемого метода, включая имя родительского или базового класса (если есть только два класса, например). (См. пример 8.16.)
   Пример 8.16. Вызов определенной версии виртуальной функции
   #include&lt;iostream&gt;

   using namespace std;

   class Base {
   public:
    virtual void foo() {cout&lt;&lt; "Base::foo()"&lt;&lt; endl;}
   };

   class Derived : public Base {
   public:
    virtual void foo() {cout&lt;&lt; "Derived::foo()"&lt;&lt; endl;}
   };

   int main() {
    Derived* p = new Derived();
    p-&gt;foo();       // Вызов версии производного класса
    p-&gt;Base::foo(); //Вызов версии базового класса
   }Обсуждение
   Регулярное использование переопределения полиморфных возможностей C++ является плохой идеей, но иногда это требуется сделать. Как и в случае с большинством другихметодик С++, это по большей части вопрос синтаксиса. Когда требуется вызвать определенную версию виртуальной функции базового класса, просто укажите ее имя после имени этого класса, как это сделано в примере 8.16.
   p-&gt;Base::foo();
   Здесь будет вызвана версияfoo,определенная вBase,а не та, которая определена в каком-то из подклассовBase,на который указываетp.
   Глава 9
   Исключения и безопасность
   9.0.Введение
   Данная глава содержит рецепты по обработке исключений в С++. Язык C++ обеспечивает необходимую поддержку работы с исключениями, и, используя некоторые приемы, вы сможете создавать программный код, в котором исключительные ситуации эффективно обрабатываются и легко отлаживаются.
   Первый рецепт описывает семантику C++ по выбрасыванию (throwing) и перехвату (catching) исключений и затем показывает, как создавать класс для представления исключений. Это является хорошей отправной точкой, если у вас мало или совсем нет опыта работы с исключениями. Здесь описываются также стандартные классы исключений, определенные в заголовочных файлах&lt;stdexcept&gt;и&lt;exception&gt;.
   Остальные рецепты иллюстрируют методы оптимального использования исключений и попутно вводят несколько важных терминов. Программное обеспечение не станет хорошим, если вы будете просто выбрасывать исключение, когда происходит что-нибудь неожиданное, или перехватывать исключение только для того, чтобы напечатать сообщение об ошибке и завершить программу аварийно. Для эффективного использования средств C++ по обработке исключений вам придется создавать программный код, который предотвращает утечку ресурсов и обеспечивает четкий режим работы при выбрасывании исключения. Эти условия известны какбазовыеистрогиегарантии безопасности исключений. Я описываю методы, которые позволят вам обеспечить эти гарантии для конструкторов и различных функций-членов.
   9.1.Создание класса исключенияПроблема
   Требуется создать свой собственный класс исключения, предназначенный для выбрасывания и перехвата исключений.Решение
   Вы можете выбрасывать (throw)или перехватывать (catch)любые типы С++, которые удовлетворяют некоторым простым требованиям, а именно имеют конструктор копирования и деструктор. Однако исключения являются сложными объектами, поэтому при проектировании класса, который представляет исключительные ситуации, необходимо рассмотреть ряд вопросов. Пример 9.1 показывает, каким может быть простой класс исключения.
   Пример 9.1. Простой класс исключения
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using namespace std;

   class Exception {
   public:
    Exception(const string& msg) : msg_(msg) {}
    ~Exception() {}
    string getMessage() const {return(msg_);}
   private:
    string msg_;
   };

   void f() {
    throw(Exception("Mr. Sulu"));
   }

   int main() {
    try {
     f();
    } catch(Exception& e) {
     cout&lt;&lt; "You threw an exception: "&lt;&lt; e.getMessage()&lt;&lt; endl;
    }
   }Обсуждение
   В языке C++ поддержка исключений обеспечивается при помощи трех ключевых слов:try,catchиthrow.Они имеют следующий синтаксис.
   try {
    // Что-нибудь, что может вызвать функцию "throw", например:
    throw(Exception("Uh-oh"));
   } catch(Exception& e) {
    // Какие-нибудь полезные действия с объектом исключения е
   }
   Исключение в C++ (аналогично в Java и С#) - это способ, позволяющий поместить сообщение в бутылку, выбросить ее за борт и надеяться, что кто-нибудь пытается найти ваше сообщение где-нибудь ниже по стеку вызовов. Это является альтернативой другим, более простым методам, когда, например, возвращается код ошибки или выдается сообщение об ошибке. Семантика использования исключений (например, «попытка выполнения» каких-то действий, «выбрасывание» исключения с последующим его «перехватом») отличается от других операций С++, поэтому перед описанием способа создания класса исключения я кратко отвечу на вопрос, что представляет собой исключение и что значит выбросить и перехватить его.
   Когда возникает исключительная ситуация и вы полагаете, что вызывающая программа должна быть осведомлена об этом, можете «поместить ваше сообщение в бутылку» в оператореthrow,как показано ниже.
   throw(Exception("Something went wrong"));
   В результате среда времени выполнения сконструирует объектException (исключение), и затем начинается раскрутка стека вызовов до тех пор, пока не найдется блокtry,в который был сделан вход, но из которого еще не сделан выход. Если среда времени выполнения не найдет такой блок, т.е. достигнет функцииmain (или верхний уровень текущего потока вычислений), и не может дальше раскручивать стек вызовов, вызывается специальная глобальная функцияterminate.Но если блокtryнайден, то просматривается каждый операторcatchдля данного блокаtryи находится тот, который перехватывает тип исключения, который был только что выброшен. Подойдет оператор примерно такого вида.
   catch(Exception&е) { //...
   В этом месте на основе выброшенного исключения создается новый объектExceptionс помощью конструктора копирования классаException. (Объект исключения в области видимостиthrowявляется временным и может быть удален компилятором при оптимизации.) Первоначальное исключение уничтожается, поскольку осуществлен выход из диапазона его видимости и выполняется тело оператораcatch.
   Если, находясь в теле оператораcatch,вы хотите только что перехваченное исключение передать дальше, вы можете вызвать функциюthrowбез аргументов.
   throw;
   Это приведет к тому, что процесс обработки исключения будет продолжен на следующие уровни стека вызовов, пока не будет найден другой подходящий обработчик. Это позволяет каждой области видимости перехватывать исключение, выполнять какие-то полезные действия и затем повторно выбрасывать исключение после завершения (или незавершения) таких действий.
   Вышесказанное представляет собой ускоренный курс описания процессов выбрасывания и перехвата исключений. Теперь, когда вы обладаете этой информацией, давайте рассмотрим пример 9.1. Вы можете сконструировать исключениеException,содержащее указатель символьной строки или строкуstring,и затем выбрасывать его. Но такой класс не очень полезен, так как он мало чем отличается от класса-оболочки текстового сообщения. Собственно говоря, вы могли бы получить почти такой же результат, используя в качестве объекта исключения просто строкуstring.
   try {
    throw(string("Something went wrong!"));
   } catch (string& s) {
    cout&lt;&lt; "The exception was: "&lt;&lt; s&lt;&lt; endl;
   }
   Нельзя сказать, что этот подход обязательно даст хорошие результаты; моя цель продемонстрировать основное свойство исключения: им может быть любой тип C++. В качестве исключений вы можете выбрасывать типint,char,class,structили любой другой тип C++, если действительно это потребуется. Но вам лучше использовать иерархию классов исключений, находящихся либо в стандартной библиотеке, либо ваших собственных.
   Одно из самых больших преимуществ применения иерархии классов исключений состоит в том, что это позволяет выразить сущность исключительной ситуации с помощьютипасамого класса исключения, а не с помощью кода ошибки, текстовой строки, уровня серьезности ошибки или чего-то подобного. Именно так стандартная библиотека определяет стандартные исключения в заголовочном файле&lt;stdexcept&gt;.Базовым классом исключений в&lt;stdexcept&gt;являетсяexception,который фактически определяется в&lt;exception&gt;.На рис. 9.1 показана иерархия стандартных классов исключений. [Картинка: img_6.jpg] 
   Рис. 9.1. Иерархия стандартных классов исключений
   Название каждого стандартного класса исключений говорит, для каких исключительных ситуаций он предназначен. Например, классlogic_error (логическая ошибка) представляет ситуации, которые должны отыскиваться при написании или рецензировании программного кода, и его подклассы представляют следующие ситуации: нарушение предусловия, применение индекса, выходящего за допустимый диапазон, использование недопустимого аргумента и т.п. Дополнением логической ошибки является ошибка времени выполнения, которая представляется классомruntime_error.Она предназначена для ситуаций, которые не всегда могут быть выявлены на этапе кодирования программы, например выход за пределы диапазона, переполнение или потеря значимости (underflow).
   Это покрывает ограниченный набор исключительных ситуаций, и, вероятно, стандартные классы исключений имеют не все, что вам нужно. По-видимому, вам потребуется иметь исключения, более ориентированные на конкретные приложения, напримерdatabase_error,network_error,painting_errorи т.п. Мы обсудим это позже. А до этого давайте рассмотрим, как работают стандартные исключения.
   Поскольку стандартная библиотека использует стандартные классы исключений (допустим это), можно ожидать, что классы из стандартной библиотеки будут их выбрасывать при возникновении проблемной ситуации, например при попытке использовать индекс, выходящий за пределы диапазона вектораvector.
   std::vector&lt;int&gt; v;
   int i = -1;
   //заполнить вектор v...
   try {
    i = v.at(v.size()); // Выход на один элемент за конец вектора
   } catch (std::out_of_range&е) {
    std::cerr&lt;&lt; "Whoa, exception thrown: "&lt;&lt; e.what()&lt;&lt; '\n';
   }
   vector&lt;&gt;::atвыбросит исключениеout_of_range,если вы используете индекс, значение которого меньше или больше, чемsize() - 1.Поскольку вам это известно, вы можете написать обработчик, специально предназначенный для этой исключительной ситуации. Если вам не требуется обрабатывать отдельно конкретный тип исключения, а вместо этого вы предпочли бы одинаково обрабатывать все исключения, вы можете перехватить базовый класс всех исключений.
   catch(std::exception&е) {
    std::cerr&lt;&lt; "Nonspecific exception: "&lt;&lt; e.what()&lt;&lt; '\n';
   }
   В результате будет перехватываться любой класс, производный отexception,what— это виртуальная функция-член, которая выдает строку сообщения, зависящую от реализации.
   Я почти вернулся в исходную точку. Цель примера 9.1, который сопровождается продолжительным обсуждением, — иллюстрация достоинств класса исключения. Две вещи делают класс исключения полезным: иерархия, отражающая природу исключения, и сообщение, выдаваемое при перехвате исключения и предназначенное для пользователей программы. Иерархия классов исключений позволит разработчикам, использующим вашу библиотеку, создавать безопасный программный код и легко его отлаживать, а текст сообщения позволит тем же самым разработчикам предоставлять конечным пользователям приложения осмысленное сообщение об ошибке.
   Исключения представляют собой сложную тему, и безопасная и эффективная обработка исключительных ситуаций является одной из самых трудных задач в проектировании программного обеспечения в целом и на языке C++ в частности. Каким должен быть конструктор, который не приведет к утечке памяти, если исключение выбрасывается в его теле или в списке инициализации? Что такое безопасное исключение? Я отвечу на эти и другие вопросы в последующих рецептах.
   9.2.Создание безопасного при исключениях конструктораПроблема
   Ваш конструктор должен обеспечить базовые и строгие гарантии безопасности исключений. См. обсуждение, которое следует за определением «базовых» и «строгих» гарантий.Решение
   Используйте в конструкторе блокиtryиcatch,чтобы правильно завершить действия по очистке объекта, если в ходе конструирования выбрасывается исключение. В примере 9.2 приводятся простые классыDeviceиBroker.Brokerсоздает два объектаDeviceв динамической памяти (heap),но он должен правильно очистить память от этих объектов, если при конструировании выбрасывается исключение.
   Пример 9.2. Безопасный при исключениях конструктор
   #include&lt;iostream&gt;
   #include&lt;stdexcept&gt;

   using namespace std;

   class Device {
   public:
    Device(int devno) {
     if (devno == 2)
      throw runtime_error("Big problem");
    }
    ~Device() {}
   };

   class Broker {
   public:
    Broker (int devno1, int devno2) : dev1_(NULL), dev2_(NULL) {
     try {
      dev1_ = new Device(devno1); // Заключить операторы создания
      dev2_ = new Device(devno2); // объектов в динамической памяти в
                                  // блок try ...
     } catch (...) {
      delete dev1_; // ...очистить память и повторно
      throw;        // выбросить исключение, если что-то не
                    // получилось.
     }
    }
    ~Broker() {
     delete dev1_;
     delete dev2_;
    }
   private:
    Broker();
    Device* dev1_;
    Device* dev2_;
   };

   int main() {
    try {
     Broker b(1, 2);
    } catch(exception& e) {
     cerr&lt;&lt; "Exception: "&lt;&lt; e.what()&lt;&lt; endl;
    }
   }Обсуждение
   Сказать, что конструктор, функция-член, деструктор или что-нибудь другое «безопасно при исключениях», — значит гарантировать, что при их работе не будет утечки ресурсов и, вероятно, используемые ими объекты не будут находиться в противоречивом состоянии. В языке C++ такого рода гарантии названыбазовымиистрогими.
   Базоваягарантия безопасности при исключениях, которая интуитивно вполне понятна, означает, что при выбрасывании исключения текущая операция не приведет к утечке ресурсов и вовлеченный в операцию объект по-прежнему можно использовать (т.е. вы можете вызвать другие функции-члены и уничтожить объект, так как его состояние корректно). Это также означает, что программа находится в согласованном состоянии, хотя оно может быть непредсказуемым. Правила простые: если исключение выбрасывается где-нибудь в теле (например) функции-члена, созданные в динамической памяти объекты не лишаются поддержки, а вовлеченные в операцию объекты могут быть уничтожены или восстановлены в вызывающей программе. Другая гарантия, названнаястрогойгарантией безопасности исключений, обеспечивает неизменность состояния объекта, если операция завершается неудачно. Последнее относится к операциям, которые следуют после конструирования объекта, поскольку по определению объект, который выбрасывает исключение, всегда будет сконструирован не полностью и поэтому всегда будет иметь недостоверное состояние. Я вернусь к функциям-членам в рецепте 9.4. Теперь же давайте основное внимание уделим конструированию объектов.
   В примере 9.2 определяется два класса,DeviceиBroker,которые делают не очень много, но с их помощью можно было бы легко представить любой сценарий работы пары устройство/брокер, когда вы имеете некоторый класс, который открывает соединение к каждому из двух устройств и управляет связью между ними. Брокер бесполезен, если доступно только одно устройство, поэтому семантика обработки транзакций при наличии брокера должна учитывать, что при выбрасывании исключения одним из двух этих устройств, когда делается попытка получения доступа к нему, должно освобождаться другое устройство. Это обеспечивает невозможность утечки памяти и других ресурсов.
   Блокиtryиcatchсделают эту работу. В конструкторе заключите операторы по выделению динамической памяти для объекта в блокtryи перехватывайте все исключения, которые выбрасываются в ходе конструирования этого объекта.
   try {
    dev1_ = new Device(devno1);
    dev2_ = new Device(devno2);
   } catch (...) {
    delete dev1_;
    throw;
   }
   Многоточие в обработчикеcatchозначает, что любое выброшенное исключение будет перехвачено. В данном случае вам следует поступать именно так, поскольку вы лишь освобождаете память, если что-то не получилось, и затем повторно выбрасываете исключение независимо от его типа. Вам необходимо повторно выбросить исключение, чтобы клиентская программа, которая пытается инстанцировать объектBroker,могла сделать что-то полезное с исключением, например записать куда-нибудь соответствующее сообщение об ошибке.
   Вcatch-обработчике я удаляю лишьdev1_,так как последнее выбрасывание исключения возможно только в оператореnewдляdev2_.Если он выбрасывает исключение, то переменнойdev2_не будет присвоено никакого значения и, следовательно, мне не нужно удалять объектdev2_.Однако, если вы что-то делаете после инициализацииdev2_,вам потребуется выполнить зачистку этого объекта. Например:
   try {
    dev1_ = new Device(devno1);
    dev2_ = new Device(devno2);
    foo_ = new MyClass(); // Может выбросить исключение
   } catch (...) {
    delete dev1_;
    delete dev2_;
    throw;
   }
   В этом случае вам не следует беспокоиться об удалении указателей, которым никогда не присваивались реальные значения (если изначально вы не инициализировали их соответствующим образом), поскольку удаление указателяNULLне дает никакого эффекта. Другими словами, если присваивание значения переменнойdev1_приводит к выбрасыванию исключения, вашcatch-обработчик все же выполнит операторdelete dev2_,однако все будет нормально, если вы инициализировали его значениемNULLв списке инициализации.
   Как я говорил в рецепте 9.1, рассматривая основы обработки исключений, для обеспечения гибкой стратегии обработки исключений может потребоваться особая ловкость, и то же самое относится к обеспечению безопасности исключений. Подробное рассмотрение методов проектирования программного кода, безопасного при исключениях, приводится в книге «ExceptionalС++», написанной Гербом Саттером (Herb Sutter) (издательство «Addison Wesley»).Смотри также
   Рецепт 9.3.
   9.3.Создание безопасного при исключениях списка инициализацииПроблема
   Необходимо инициализировать ваши данные-члены в списке инициализации конструктора, и поэтому вы не можете воспользоваться подходом, описанным в рецепте 9.2.Решение
   Используйте специальный формат блоковtryиcatch,предназначенный для перехвата исключений, выбрасываемых в списке инициализации. Пример 9.3 показывает, как это можно сделать.
   Пример 9.3. Обработка исключений в списке инициализации
   #include&lt;iostream&gt;
   #include&lt;stdexcept&gt;

   using namespace std;

   //Некоторое устройство
   class Device {
   public:
    Device(int devno) {
     if (devno == 2)
      throw runtime error("Big problem");
    }
    ~Device() {}
   private:
    Device();
   };

   class Broker {
   public:
    Broker (int devno1, int devno2)
     try : dev1_(Device(devno1)), // Создать эти объекты в списке
      dev2_(Device(devno2)) {}    // инициализации
     catch (...) {
      throw; // Выдать сообщение в журнал событий или передать ошибку
             // вызывающей программе (см. ниже обсуждение)
    }
    ~Broker() {}
   private:
    Broker();
    Device dev1_;
    Device dev2_;
   };

   int main() {
    try {
     Broker b(1, 2);
    } catch(exception& e) {
     cerr&lt;&lt; "Exception: "&lt;&lt; e.what()&lt;&lt; endl;
    }
   }Обсуждение
   Синтаксис обработки исключений в списках инициализации немного отличается от традиционного синтаксиса С++, потому что здесь блокtryиспользуется в качестве тела конструктора. Критической частью примера 9.3 является конструктор классаBroker.
   Broker(int devno1, int devno2) //Заголовок конструктора такой же Constructor
    try :                         // Действует так же, как try {...}
     dev1_(Device(devno1)),       // Затем идут операторы списка
     dev2_(Device(devno2)) {      // инициализации
      // Здесь задаются операторы тела конструктора.
     } catch (...) { // catch обработчик задается *после*
      throw; // тела конструктора
     }
   Режим работы блоковtryиcatchвполне ожидаем; единственное синтаксическое отличие от обычного блокаtryзаключается в том, что при перехвате исключений, выброшенных из списка инициализации, за ключевым словомtryидет двоеточие, затем список инициализации ипосле этогособственно блокtry,который является одновременно и телом конструктора. Если какое-нибудь исключение выбрасывается из списка инициализации или из тела конструктора, оно будет перехваченоcatch-обработчиком, который расположен после тела конструктора. Вы можете при необходимости добавить в тело конструктора дополнительную пару блоковtry/catch,однако вложенные блокиtry/catchобычно выглядят непривлекательно.
   Кроме перемещения операторов инициализации членов в список инициализации пример 9.3 отличается от примера 9.2 еще одним свойством. Объекты-членыDeviceна этот раз не создаются в динамической памяти с помощью оператораnew.Я сделал это для иллюстрации двух особенностей, связанных с безопасностью и применением объектов-членов.
   Во-первых, использование стека вместо объектов динамической памяти позволяет компилятору автоматически обеспечить их безопасность. Если какой-нибудь объект в списке инициализации выбрасывает исключение в ходе конструирования, занимаемая им память автоматически освобождается по мере раскрутки стека в процессе обработки исключения. Во-вторых, что более важно, любые другие объекты, которые уже были успешно сконструированы, уничтожаются, и вам не требуется перехватывать исключения и явно их удалять операторомdelete.
   Но, возможно, вам требуется иметь члены, использующие динамическую память (или с ними вы предпочитаете иметь дело). Рассмотрим подход, используемый в первоначальном классеBrokerв примере 9.2. Вы можете просто инициализировать ваши указатели в списке инициализации, не так ли?
   class BrokerBad {
   public:
    BrokerBad(int devno1, int devno2)
     try :dev1_(new Device(devno1)), //Создать объекты динамической
      dev2_(new Device(devno2)) {}    // памяти в списке инициализации
     catch (...) {
      if (dev1_) {
       delete dev1_; // He должно компилироваться и
       delete dev2_; // является плохим решением, если
      }              // все же будет откомпилировано
      throw; // Повторное выбрасывание того же самого исключения
     }
    ~BrokerBad() {
     delete dev1_;
     delete dev2_;
    }
   private:
    BrokerBad();
    Device* dev1_;
    Device* dev2_;
   };
   Нет, так делать нельзя. Здесь две проблемы. Прежде всего, это не допустит ваш компилятор, потому что расположенный в конструкторе блокcatchне должен позволить программному коду получить доступ к переменным-членам, так как их еще нет. Во-вторых, даже если ваш компилятор позволяет это делать, это будет плохим решением. Рассмотрим ситуацию, когда при конструировании объектаdev1_выбрасывается исключение. Ниже дается программный код, который будет выполняться вcatch-обработчике.
   catch (...) {
    if (dev1_) { // Какое значение имеет эта переменная?
     delete dev1_; // в данном случае вы удаляете неопределенное значение
     delete dev2_;
    }
    throw; // Повторное выбрасывание того же самого исключения
   }
   Если исключение выбрасывается в ходе конструированияdev1_,то операторомnewне может быть возвращен адрес нового выделенного участка памяти и значениеdev1_не меняется. Тогда что эта переменная содержит? Она будет иметь неопределённое значение, так как она никогда не инициализировалась. В результате, когда вы станете выполнять операторdelete dev1_,вы, вероятно, попытаетесь удалить объект, используя недостоверный адрес, что приведет к краху программы, вы будете уволены, и вам придется жить с этим позором всю оставшуюся жизнь.
   Чтобы избежать такое фиаско, круто изменяющее вашу жизнь, инициализируйте в списке инициализации ваши указатели значениемNULLи затем создавайте в конструкторе объекты, использующие динамическую память. В этом случае будет легче перехватывать любую исключительную ситуацию и выполнять подчистку, поскольку допускается использовать операторdeleteдляNULL-указателей.
   BrokerBetter(int devno1, int devno2) :
    dev1_(NULL), dev2_(NULL) {
     try {
      dev1_ = new Device(devno1);
      dev2_ = new Device(devno2);
     } catch (...) {
      delete dev1_; // Это сработает в любом случае
      throw;
     }
    }
   Итак, вышесказанное можно подытожить следующим образом: если вам необходимо использовать члены-указатели, инициализируйте их значениемNULLв списке инициализации и затем выделяйте в конструкторе память для соответствующих объектов, используя блокtry/catch.Вы можете освободить любую память вcatch-обработчике. Однако, если допускается работа с автоматическими членами, сконструируйте их в списке инициализации и используйте специальный синтаксис блокаtry/catchдля обработки любых исключений.Смотри также
   Рецепт 9.2.
   9.4.Создание безопасных при исключениях функций-членовПроблема
   Создается функция-член и необходимо обеспечить базовые и строгие гарантии ее безопасности при исключениях, а именно отсутствие утечки ресурсов и то, что объект небудет иметь недопустимое состояние в том случае, если выбрасывается исключение.Решение
   Необходимо выяснить, какие операции могут выбрасывать исключения, и следует выполнить их первыми, обычно заключая в блокtry/catch.После того как будет выполнен программный код, который может выбрасывать исключение, вы можете изменять состояние объектов. В примере 9.4 показан один из способов обеспечения безопасности функции-члена при исключениях.
   Пример 9.4. Безопасная при исключениях функция-член
   class Message {
   public:
    Message(int bufSize = DEFAULT_BUF_SIZE) :
     bufSize_(bufSize), initBufSize_(bufSize), msgSize_(0), buf_(NULL) {
     buf_ = new char[bufSize];
    }
    ~Message() {
     delete[] buf_;
    }

    // Добавить в конец символьные данные
    void appendData(int len, const char* data) {
     if (msgSize_+len&gt; MAX_SIZE) {
      throw out_of_range("Data size exceeds maximum size.");
     }
     if (msgSize_+len&gt; bufSize_) {
      int newBufSize = bufSize_;
      while ((newBufSize *= 2)&lt; msgSize_+len);
      char* p = new char[newBufSize]; // Выделить память
                                      // для нового буфера
      copy(buf_, buf_+msgSize_, p);     // Скопировать старые данные
      copy(data, data+len, p+msgSize_); // Скопировать новые данные
      msgSize_ += len;
      bufSize_ = newBufSize;
      delete[] buf_; // Освободись старый буфер и установить указатель на
      buf_ = p;      // новый буфер
     } else {
      copy(data, data+len, buf_+msgSize_);
      msgSize_ += len;
     }
    }

    // Скопировать данные в буфер вызывающей программы
    int getData(int maxLen, char* data) {
     if (maxLen&lt; msgSize_) {
      throw out_of_range("This data is too big for your buffer.");
     }
     copy(buf_, buf_+msgSize_, data);
     return(msgSize_);
    }

   private:
    Message(const Message& orig) {}           // Мы рассмотрим эти операторы
    Message& operator=(const Message& rhs) {} //в рецепте 9.5
    int bufSize_;
    int initBufSize_;
    int msgSize_;
    char* buf_;
   };Обсуждение
   Представленный в примере 9.4 классMessageявляется классом, содержащим символьные данные; вы могли бы использовать его в качестве оболочки текстовых или бинарных данных, которые передаются из одной системы в другую. Здесь нас интересует функция-членappendData,которая добавляет данные, переданные вызывающей программой, в конец данных, уже находящихся в буфере, причем увеличивая при необходимости размер буфера. Здесь обеспечивается строгая гарантия безопасности этой функции-члена при исключениях, хотя на первый взгляд может быть не совсем понятно, чем это достигается.
   Рассмотрим следующий фрагментappendData.
   if (msgSize_+len&gt; bufSize_) {
    int newBufSize = bufSize_;
    while ((newBufSize *= 2)&lt; msgSize_+len);
    char* p = new char[newBufSize];
   Этот блок программного кода обеспечивает увеличение размера буфера. Я его увеличиваю путем удвоения его размера до тех пор, пока он не станет достаточно большим. Этот фрагмент программного кода безопасен, потому что исключение может быть выброшено здесь только при выполнении оператораnew,и я не обновляю состояние объекта и не выделяю память ни под какие другие ресурсы до завершения его выполнения. Этот оператор выбросит исключениеbad_alloc,если операционная система не сможет выделить участок памяти необходимого размера.
   После успешного распределения памяти я могу начать обновление состояния объекта, копируя данные и обновляя значения переменных-членов.
   copy(buf_, buf_+msgSize_, p);
   copy(data, data+len, p+msgSize_);
   msgSize_ += len;
   bufSize_ = newBufSize;
   delete[] buf_;
   buf_ = p;
   Ни одна из этих операций не может выбросить исключение, поэтому нам не о чем волноваться. (Это происходит только из-за того, что буфер представляет собой последовательность символов; дополнительные разъяснения вы найдете при обсуждении примера 9.5.)
   Это простое решение и общая стратегия обеспечения строгой безопасности функций- членов при исключениях заключается в следующем: сначала выполняйте все то, что может выбрасывать исключения, затем, когда вся опасная работа окажется выполненной, глубоко вздохните и обновите состояние объекта.appendDataпросто использует временную переменную для хранения нового размера буфера. Это решает проблему, связанную с размером буфера, но обеспечит ли это на самом деле базовую гарантию отсутствия утечки ресурсов? Обеспечит, но с трудом
   сорувызываетoperator=для каждого элемента копируемой последовательности. В примере 9.4 каждый элемент имеет типchar,поэтому безопасность обеспечена, так как оператор присваивания одного символа другому не может выбросить никакого исключения. Но я сказал «обеспечит с трудом», потому что безопасность этого специального случая не должна создавать у вас впечатление о том, что причиной исключений никогда не может быть функцияcopy.
   Предположим на секунду, что вместо «узкого» символьного буфера вам необходимо написать классMessage,который может содержать массив каких-то объектов. Вы могли бы представить его как шаблон класса, подобный представленному в примере 9.5.
   Пример 9.5. Параметризованный класс сообщения
   template&lt;typename T&gt;
   class MessageGeneric {
   public:
    MessageGeneric(int bufSize = DEFAULT_BUF_SIZE) :
     bufSize_(bufSize), initBufSize_(bufSize), msgSize_(0), buf_(new T[bufSize]) {}
    ~MessageGeneric() {
     delete[] buf_;
    }

    void appendData(int len, const data) {
     if (msgSize_+len&gt; MAX_SIZE) {
      throw out of range("Data size exceeds maximum size.");
     }
     if (msgSize_+len&gt; bufSize_) {
      int newBufSize = bufSize_;
      while ((newBufSize *= 2)&lt; msgSize_+len);
      T* p = new T[newBufSize];
      copy(buf_, buf_+msgSize_, p);     // Могут ли эти операторы
      copy(data, data+len, p+msgSize_); // выбросить исключение?
      msgSize_ += len;
      bufSize_ = newBufSize;
      delete[] buf_; // Освободить старый буфер и установить указатель на
      buf_ = p;      // новый буфер
     } else {
      copy(data, data+len, buf_+msgSize_);
      msgSize_ += len;
     }
    }

    // Скопировать данные в буфер вызывающей программы
    int getData(int maxLen, T* data) {
     if (maxLen&lt; msgSize_) {
      throw out of range("This data is too big for your buffer.");
     }
     copy(buf_, buf_+msgSize_, data);
     return(msgSize_);
    }

   private:
    MessageGeneric(const MessageGeneric& orig) {}
    MessageGeneric& operator=(const MessageGeneric& rhs) {}
    int bufSize_;
    int initBufSize_;
    int msgSize_;
    T* buf_;
   };
   Теперь вам необходимо быть более осторожным, так как вы заранее не знаете тип целевого объекта. Например, разве можно быть уверенным, что операторT::operator=не выбросит исключение? Нельзя, поэтому вам необходимо учесть такую возможность. Заключите вызовы функций копирования в блокtry.
   try {
    copy(buf_, buf_+msgSize_, p);
    copy(data, data+len, p+msgSize_);
   } catch(...) {
    // He имеет значения, какое исключение выбрасывается; все, что
    delete[] p; // мне необходимо сделать - это подчистить за собой,
    throw;      // а затем повторно выбросить исключение.
   }
   Поскольку операторcatchс многоточием позволяет перехватывать любой тип исключения, пользователи вашего класса могут быть уверены, что при выбрасывании исключения операторомT::operator=вы его перехватите и сможете освободить динамическую память, которая была только что распределена.
   Строго говоря, функцияcopyв действительности ничего не выбрасывает, но это делает операторT::operator=.Это происходит из-за того, что функцияcopyи остальные алгоритмы стандартной библиотеки в целом являются нейтральными по отношению к исключениям; это значит, что при выбрасывании исключений во время выполнения каких-либо внутренних операторов это исключение будет передано вызывающей программе, а не будет обработано полностью (перехвачено в блокеcatchбез повторного выбрасывания этого исключения). Это сохраняет возможность перехвата исключений в блокеcatch,выполнения некоторой подчистки с последующим их повторным выбрасываний, но в конце концов все исключения, выброшенные в классе или функции стандартной библиотеки, дойдут до вызывающей программы.
   Создание безопасных при исключениях функций-членов — трудоемкая работа. Для этого вам необходимо выявить все места, где могут выбрасываться исключения, и убедиться, что вы правильно их обрабатываете. Когда исключение может выбрасываться? При любом вызове функции. Операторы для встроенных типов данных не могут выбрасывать исключения, а деструкторыникогдане должны выбрасывать исключения, не все остальное, будь это отдельная функция, функция-член, оператор, конструктор и т.д., является потенциальным источником исключения. В приводимых примерах 9.5 и 9.6 в классах и функциях используются исключения с ограниченной областью действия. Классы содержат очень мало переменных-членов, и поведение класса носит дискретный характер. По мере увеличения количества функций-членов и переменных-членов, использования наследования и виртуальных функций задача обеспечения их строгой безопасности при исключениях становится более сложной.
   Наконец, как и для большинства других требований, предъявляемых к программному обеспечению, вам требуется обеспечить только тот уровень безопасности исключений, который вам необходим. Другими словами, если вы создаете диалоговый мастер по генерации веб-страниц, график вашей разработки, вероятно, не позволит провести необходимое исследование и тестирование обеспечения в нем строгой безопасности исключений. Так, для вашего заказчика может быть приемлемой ситуация, когда пользователи встречаются иногда с сообщением о неопределенной ошибке: «Неизвестная ошибка, аварийное завершение программы» («Unknown error, aborting»). С другой стороны, если вы создаете программное обеспечение для управления углом ротора вертолета, ваш заказчик, вероятно, будет настаивать на обеспечении более существенных гарантий безопасности, чем вывод сообщения «Неизвестная ошибка, аварийное завершение программы».
   9.5.Безопасное копирование объектаПроблема
   Требуется иметь безопасные при исключениях конструктор копирования и оператор присваивания базового класса.Решение
   Примените тактику, предложенную в рецепте 9.4, а именно сначала выполните все действия, которые могут выбрасывать исключения, и изменяйте состояние объектов с помощью операций, которые не могут выбрасывать исключения только после того, как будет завершена вся опасная работа. В примере 9.6 вновь представлен классMessage,который на этот раз содержит определения оператора присваивания и конструктора копирования.
   Пример 9.6. Безопасные при исключениях оператор присваивания и конструктор копирования
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   const static int DEFAULT_BUF_SIZE = 3;
   const Static int MAX_SIZE = 4096;

   class Message {
   public:
    Message(int bufSize = DEFAULT_BUF_SIZE) :
     bufSize_(bufSize), initBufSize_(bufSize), msgSize_(0), key_("") {
      buf_ = new char[bufSize]; // Примечание: теперь это делается в теле
                               // конструктора
    }
    ~Message() {
     delete[] buf_;
    }

    // Безопасный при исключениях конструктор копирования
    Message(const Message& orig) :
     bufSize_(orig.bufSize_), initBufSize_(orig.initBufSize_),
     msgSize_(orig.msgSize_), key_(orig.key_) {
     // Эта функция может выбросить исключение
     buf_ = new char[orig.bufSize_]; // ...здесь может произойти то же
                                     // самое
     copy(orig.buf_, orig.buf_+msgSize_, buf_); // Здесь нет
    }

    // Безопасный при исключениях оператор присваивания использующий
    // конструктор копирования
    Message& operator=(const Message& rhs) {
     Message tmp(rhs); // Копировать сообщение во временную переменную,
                       // используя конструктор копирования
     swapInternals(tmp); // Обменять значения переменных-членов и членов
                         // временного объекта
     return(*this); // После выхода переменная tmp уничтожается вместе
                    // с первоначальными данными
    }

    const char* data() {
     return(buf_);
    }

   private:
    void swapInternals(Messages msg) {
     // Поскольку key_ не является встроенным типом данных, он может
     // выбрасывать исключение, поэтому сначала выполняем действия с ним
     swap(key_, msg.key_);
     // Если предыдущий оператор не выбрасывает исключение, то выполняем
     // действия со всеми переменными-членами, которые являются встроенными
     // типами
     swap(bufSize_, msg.bufSize_);
     swap(initBufSize_, msg.initBufSize_);
     swap(msgSize_, msg.msgSize_);
     swap(buf_, msg.buf_);
    }
    int bufSize_;
    int initBufSize_;
    int msgSize_;
    char* buf;
    string key_;
   }Обсуждение
   Вся работа здесь делается конструктором копирования и закрытой функцией-членомswapInternals.Конструктор копирования инициализирует в списке инициализации элементарные члены и один из неэлементарных членов. Затем он распределяет память для нового буфера и копирует туда данные. Довольно просто, но почему используется такая последовательность действий? Вы могли бы возразить, что всю инициализацию можно сделать в списке инициализации, но такой подход может сопровождаться тонкими ошибками.
   Например, вы могли бы следующим образом выделить память под буфер в списке инициализации.
   Message(const Message& orig) :
    bufSize_(orig bufSize_), initBufSize_(orig initBufSize_),
    msgSize_(orig.msgSize_), key_(orig.key_),
    buf_(new char[orig.bufSize_]) {
     copy(orig.buf_, orig.buf_+msgSize_, buf_);
   }
   Вы можете ожидать, что все будет нормально, так как если завершается неудачей выполнение оператораnew,выделяющего память под буфер, все другие полностью сконструированные объекты будут уничтожены. Но это не гарантировано, потому что члены класса инициализируются в той последовательности, в которой они объявляются в заголовке класса, а не в порядке их перечисления в списке инициализации. Переменные-члены объявляются в следующем порядке.
   int bufSize_;
   int initBufSize_;
   int msgSize_;
   char* buf_;
   string key_;
   В результатеbuf_будет инициализироваться передkey_.Если при инициализацииkey_будет выброшено исключение,buf_не будет уничтожен, и у вас образуется участок недоступной памяти. От этого можно защититься путем использования в конструкторе блокаtry/catch (см. рецепт 9.2), но проще разместить оператор инициализацииbuf_в теле конструктора, что гарантирует его выполнение после операторов списка инициализации.
   Выполнение функцииcopyне приведет к выбрасыванию исключения, так как она копирует элементарные значения. Но именно это место является тонким с точки зрения безопасности исключений: этафункция может выбросить исключение, если копируются объекты (например, если речь идет о контейнере, который параметризован типом своих элементов,T);в этом случае вам придется перехватывать исключение и освобождать связанную с ним память.
   Вы можете поступить по-другому и копировать объект при помощи оператора присваивания,operator=.Поскольку этот оператор и конструктор копирования выполняют аналогичные действия (например, приравнивают члены моего класса к членам аргумента), воспользуйтесь тем, что вы уже сделали, и вы облегчите себе жизнь. Единственная особенность заключается в том, что вы можете сделать более привлекательным ваш программный код, используя закрытую функцию-член для обмена значений между данными-членами и временным объектом. Мне бы хотелось быть изобретателем этого приема, но я обязан отдать должное Гербу Саттеру (Herb Sutter) и Стефану Дьюхарсту (Stephen Dewhurst), в работе которых я впервые познакомился с этим подходом.
   Возможно, вам все здесь ясно с первого взгляда, но я дам пояснения на тот случай, если это не так. Рассмотрим первую строку, в которой создается временный объектtmpс помощью конструктора копирования.
   Message tmp(rhs);
   В данном случае мы просто создали двойника объекта-аргумента. Естественно, теперьtmpэквивалентенrhs.После этого мы обмениваем значения его членов со значениями членов объекта*this.
   swapInternals(tmp);
   Вскоре я вернусь к функцииswapInternals.В данный момент нам важно только то, что члены*thisимеют значения, которые имели членыtmpсекунду назад. Однако объектtmpпредставлял собой копию объектаrhs,поэтому теперь*thisэквивалентенrhs.Но подождите: у нас по-прежнему имеется этот временный объект. Нет проблем, когда вы возвратите*this, tmpбудет автоматически уничтожен вместе со старыми значениями переменных-членов при выходе за диапазон его видимости.
   return(*this);
   Все так. Но обеспечивает ли это безопасность при исключениях? Безопасно конструирование объектаtmp,поскольку наш конструктор является безопасным при исключениях. Большая часть работы выполняется функциейswapInternals,поэтому рассмотрим, что в ней делается, и безопасны ли эти действия при исключениях.
   ФункцияswapInternalsвыполняет обмен значениями между каждым данным-членом текущего объекта и переданного ей объекта. Это делается с помощью функцииswap,которая принимает два аргументаaиb,создает временную копиюa,присваивает аргументbаргументуаи затем присваивает временную копию аргументуb.В этом случае такие действия являются безопасными и нейтральными по отношению к исключениям, так как источником исключений здесь могут быть только объекты, над которыми выполняются операции. Здесь не используется динамическая память и поэтому обеспечивается базовая гарантия отсутствия утечки ресурсов.
   Поскольку объектkey_не является элементарным и поэтому операции над ним могут приводить к выбрасыванию исключений, я сначала обмениваю его значения. В этом случае, если выбрасываетсяисключение, никакие другие переменные-члены не будут испорчены. Однако это не значит, что не будет испорчен объектkey_.Когда вы работаете с членами объекта, все зависит от обеспечения ими гарантий безопасности при исключениях. Если такой член не выбрасывает исключение, то это значит, что я добился своего, так как обмен значений переменных встроенных типов не приведет к выбрасыванию исключений. Следовательно, функцияswapInternalsявляется в основном и строгом смысле безопасной при исключениях.
   Однако возникает интересный вопрос. Что, если у вас имеется несколько объектов-членов? Если бы вы имели два строковых члена, начало функцииswapInternalsмогло бы выглядеть следующим образом.
   void swapInternals(Message& msg) {
    swap(key_, msg key_);
    swap(myObj_, msg.myObj_);
    // ...
   Существует одна проблема: если вторая операцияswapвыбрасывает исключение, как можно безопасно отменить первую операциюswap?Другими словами, теперьkey_имеет новое значение, но операцияswapдляmyObj_завершилась неудачей, поэтомуkey_теперь испорчен. Если вызывающая программа перехватывает исключение и попытается продолжить работу, как будто ничего не случилось, она теперь будет обрабатывать нечто отличное от того, что было в начале. Одно из решений — предварительно скопироватьkey_во временную строку, но это не гарантирует безопасность, так как при копировании может быть выброшено исключение.
   Одно из возможных решений состоит в использовании объектов, распределенных в динамической памяти.
   void swapInternals(Message& msg) {
    // key имеет тип string*, a myObj_ - тип MyClass*
    swap(key_, msg.key_);
    swap(myObj_, msg.myObj_);
   Конечно, это означает, что теперь вам придется больше работать с динамической памятью, но обеспечение гарантий безопасности исключений будет часто оказывать влияние на ваш проект, поэтому будет правильно, если вы начнете думать об этом на ранних этапах процесса проектирования.
   Основной лейтмотив этого рецепта не отличается от лейтмотива предыдущих рецептов, связанных с обеспечением безопасности исключений. Сначала выполняйте действия, которые могут создать проблемы, предусмотрите блокtry/catchна тот случай, если что-то пойдет не так, и в последнем случае выполните подчистку за собой. Если все проходит нормально, поздравьте себя и обновите состояние объекта.Смотри также
   Рецепт 9.2 и рецепт 9.3.
   Глава 10
   Потоки и файлы
   10.0.Введение
   Потоки (streams) являются одной из самых мощных (и сложных) компонент стандартной библиотеки С++. Их применение при простом, неформатированном вводе-выводе в целом не представляет трудностей, однако ситуация усложняется, если необходимо изменить формат с помощью стандартных манипуляторов или приходится писать свои собственные манипуляторы. Поэтому первые несколько рецептов описывают различные способы форматирования вывода потока данных. Следующие два рецепта показывают, как можно записывать объекты класса в поток и считывать их оттуда.
   Затем рецепты переходят с темы чтения и записи содержимого файлов на работу с самими файлами (и каталогами). Если в вашей программе используются файлы особенно если такая программа является демоном или процессом на стороне сервера, вам, вероятно, потребуется создавать файлы и каталоги, удалять их, переименовывать и выполнять другие операции над ними. Существует ряд рецептов, которые показывают, как следует решать эти непривлекательные, но необходимые задачи в С++.
   Последняя треть рецептов показывает, как можно манипулировать именами файлов и путями доступа к ним, используя многие стандартные строковые функции-члены. Стандартные строки содержат массу функций, предназначенных для анализа и манипулирования их содержимым, и если вам придется анализировать пути доступа к файлам и имена файлов, эти функции окажутся полезными. Если в этих рецептах нет того, что вам требуется, вернитесь к главе 7: возможно, там описано то, что вы ищете.
   Манипулирование файлами требует прямого взаимодействия с операционной системой (ОС), но между различными ОС часто имеются тонкие отличия (а иногда вопиющие несовместимости). Многие типичные операции над файлами и каталогами выполняются с помощью вызовов системных функций стандартной библиотеки С. которые работают одинаково или аналогично в различных системах. В рецептах я отмечаю отличия версий библиотек различных ОС там, где они имеются.
   Как я отмечал в предыдущих главах, Boost — это проект открытого исходного кода, результатом которого стал ряд высококачественных и переносимых библиотек. Однако поскольку данная книга посвящена C++, а не проекту Boost, во всех возможных случаях я предпочитаю пользоваться стандартными решениями С++. Однако во многих случаях (наиболее примечательный — рецепт 10.12) нельзя получить решения, используя стандартную библиотеку С++, поэтому я пользуюсь библиотекой Boost Filesystem, написанной Биманом Дейвисом(Beman Dawes); она обеспечивает переносимый интерфейс для файловой системы, позволяя получать переносимые решения. Используйте библиотеку Boost Filesystem, если требуется обеспечить переносимость взаимодействия с файловой системой, и это позволит вам сэкономить много времени и многих усилий. Дополнительную информацию по проекту Boost вы найдете на сайтеwww.boost.org.
   10.1.Вывод выровненного текстаПроблема
   Требуется вывести текст, выровненный по вертикали. Например, если ваши данные представлены в табличном виде, вам захочется, чтобы они выглядели следующим образом.
   Jim    Willсох   Mesa         AZ
   Bill   Johnson   San Mateo    CA
   Robert Robertson Fort Collins CO
   Кроме того, вам, вероятно, захочется иметь возможность выравнивать текст вправо или влево.Решение
   Используйте определенные в&lt;ostream&gt;типыostreamилиwostreamдля узких или широких символов и стандартные манипуляторы потоков для установки размера полей и выравнивания текста. Пример 10.1 показывает, как это можно сделать.
   Пример 10.1. Вывод выровненного текста
   #include&lt;iostream&gt;
   #include&lt;iomanip&gt;
   #include&lt;string&gt;

   using namespace std;

   int main() {
    ios_base::fmtflags flags = cout.flags();
    string first, last, citystate;
    int width = 20;
    first = "Richard";
    last = "Stevens";
    citystate = "Tucson, AZ";
    cout&lt;&lt; left             // Каждое поле выравнивается влево.
    &lt;&lt; setw(width)&lt;&lt; first //Затем для каждого поля
    &lt;&lt; setw(width)&lt;&lt; last  // устанавливается его ширина и
                             // записываются некоторые данные
    &lt;&lt; setw(width)&lt;&lt; citystate&lt;&lt; endl;
    cout.flags(flags);
   }
   Вывод выглядит следующим образом.
   Richard            Stevens            Tucson, AZОбсуждение
   Манипулятор — это функция, которая выполняет некоторую операцию над потоком. Применяемые к потоку манипуляторы задаются в оператореoperator&lt;&lt;.Формат потока (ввода и вывода) задается набором флагов и установочных параметров конечного базового класса потока,ios_base.Манипуляторы обеспечивают удобный способ настройки этих флагов и установочных параметров без явного использования для этой цели функцийsetfилиflags,которые громоздки и воспринимаются с трудом. Для форматирования потока вывода лучше всего использовать манипуляторы.
   В примере 10.1 используется два манипулятора для вывода текста в две колонки. Манипуляторsetwзадает размер поля, aleftобеспечивает выравнивание влево находящегося в поле значения (дополнением манипулятораleft,что неудивительно, являетсяright).Когда вы используете слово «поле», вы просто говорите, что хотите дополнить заполнителем выдаваемое в поле значение с одной или с другой стороны, чтобы только вашезначение выводилось в этом поле. Если, как в примере 10.1, вы выравниваете значение влево и затем задаете размер поля, следующее записываемое в поток значение будет начинаться с первой позиции этого поля. Если переданные в поток данные имеют недостаточный размер и не могут заполнить все пространство поля, то правая часть поля будет дополнена символом заполнителя потока, которым по умолчанию является одиночный пробел. Вы можете изменить символ заполнителя с помощью манипулятораsetfill.
   myostr&lt;&lt; setfill('.')&lt;&lt; "foo";
   Если помещаемое в поле значение превышает его размер, будет напечатано все значение и никаких дополнительных символов выводиться не будет.
   Табл. 10.1 содержит краткое описание манипуляторов, работающих с любыми типами значений (текстом, числами с плавающей точкой, целыми числами и т.д.). Имеется ряд манипуляторов, которые применяются только при выводе чисел с плавающей точкой — они описываются в рецепте 10.2.

   Табл. 10.1. Текстовые манипуляторыМанипуляторОписаниеПример выводаleft rightВыровнять значения в текущем поле вправо или влево, заполняя незанятое пространство символом-заполнителемВыравнивание влевоapple      banana     cherry    Выравнивание вправо (ширина поля 10)     apple     banana     cherrysetw(int n)Установить размер поля на n символовСм. предыдущий примерsetfill(intс)Использовать символ с для заполнения незанятого пространства поляcout&lt;&lt; setfill('.')&lt;&lt; setw(10)&lt;&lt; right&lt;&lt; "foo"Выдает:.......fooboolalpha noboolalphaОтобразить булевы значения в текущем локализованном представлении словtrueиfalse,а не 1 и 0cout&lt;&lt; boolalpha&lt;&lt; trueВыдает:trueendlЗаписать в поток символ новой строки (newline) и очистить буфер выводаНетendsЗаписать в поток null-символ ('\0')НетflushОчистить буфер выводаНет
   Некоторые представленные в табл. 10.1 (и в табл. 10.2 в следующем рецепте) манипуляторы переключают бинарные флаги потоков и в действительности реализуются как два манипулятора, которые включают и отключают флаг. Например, возьмем манипуляторboolalpha.Если вы хотите, чтобы булевы значения отображались в соответствии с текущей локализацией (например, «true» и «false»), используйте манипуляторboolalpha.Для отключения этого режима, чтобы вместо слов печатались 0 и 1, используйте манипуляторnoboolalpha (он используется по умолчанию).
   Действие всех манипуляторов сохраняется до тех пор, пока оно не будет явно изменено, исключая манипуляторsetw.Из примера 10.1 видно, что он вызывается перед каждой записью, однакоleftиспользуется только один раз. Это объясняется тем, что ширина поля устанавливается в нуль после записи каждого значения в поток при помощи оператораoperator&lt;&lt;;чтобы обеспечить одинаковую ширину всех полей, мне пришлось каждый раз вызыватьsetw.
   Стандартные манипуляторы позволяют делать многое, но не все. Если у вас возникает потребность в написании собственного манипулятора, см. рецепт 10.2.
   Как и все другие классы стандартной библиотеки, работающие с символами, манипуляторы работают с потоками узких или широких символов. Поэтому вы можете использовать их в шаблонах для написания утилит форматирования, обрабатывающих потоки символов любого вида. В примере 10.2 приводится шаблон классаTableFormatter,который форматирует данные в колонки одинаковой ширины и выдает их в поток.
   Пример 10.2. Параметрический класс для табличного представления данных
   #include&lt;iostream&gt;
   #include&lt;iomanip&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;

   using namespace std;

   // TableFormatterвыдает в поток вывода символы типа T в форматированном
   //виде.
   template&lt;typename T&gt;
   class TableFormatter {
   public:
    TableFormatter(basic_ostream&lt;T&gt;& os) : out_(os) {}
    ~TableFormatter() {out_&lt;&lt; flush;}
    template&lt;typename valT&gt;
    void writeTableRow(const vector&lt;valT&gt;& v, int width);
    //...
   private:
    basic_ostream&lt;T&gt;& out_;
   };

   template&lt;typename T, //ссылается на список параметров шаблона класса
    typename valT&gt;      // ссылается на список параметров функции-члена
   void TableFormatter&lt;T&gt;::writeTableRow(const std::vector&lt;valT&gt;& v,
    int width) {
    ios_base::fmtflags flags = out_.flags();
    out_.flush();
    out_&lt;&lt; setprecision(2)&lt;&lt; fixed; //Задать точность в случае применения
                                      // чисел с плавающей точкой
    for (vector&lt;valT&gt;::const_iterator p = v.begin(); p != v.end(); ++p)
     out_&lt;&lt; setw(width)&lt;&lt; left&lt;&lt; *p; //Установить ширину поля, его
                                        // выравнивание и записать элемент
     out_&lt;&lt; endl; //Очистить буфер
    out setf(flags); // Восстановить стандартное состояние флагов
   }

   int main() {
    TableFormatter&lt;char&gt; fmt(cout);
    vector&lt;string&gt; vs;
    vs.push_back("Sunday");
    vs.push_back("Monday");
    vs.push_back("Tuesday");
    fmt.writeTableRow(vs, 12);
    fmt.writeTableRow(vs, 12);
    fmt.writeTableRow(vs, 12);
    vector&lt;double&gt; vd;
    vd.push_back(4.0);
    vd.push_back(3.0);
    vd.push_back(2.0);
    vd.push_back(1.0);
    fmt.writeTableRow(vd, 5);
   }
   Вывод представленной в примере 10.2 программы выглядит следующим образом.
   Sunday     Monday      Tuesday
   4.00 3.00 2.00 1.00Смотри также
   Таблица 10.1, рецепт 10.2.
   10.2.Форматирование вывода чисел с плавающей точкойПроблема
   Требуется выдать числа с плавающей точкой в удобном формате либо ради обеспечения необходимой точности (применяя нотацию, которая используется в науке, а не в виде числа с фиксированной точкой), либо просто выравнивая значения по десятичной точке для лучшего восприятия.Решение
   Используйте стандартные манипуляторы, определенные в&lt;iomanip&gt;и&lt;ios&gt;,для управления форматом значений чисел с плавающей точкой при их записи в поток. Это можно делать очень многими способами, и в примере 10.3 предлагается несколько способов отображения значения числа «пи».
   Пример 10.3. Форматирование числа «пи»
   #include&lt;iostream&gt;
   #include&lt;iomanip&gt;
   #include&lt;string&gt;

   using namespace std;

   int main() {
    ios_base::fmtflags flags = // Сохранить старые флаги
    cout.flags();
    double pi = 3.14285714;
    cout&lt;&lt; "pi = "&lt;&lt; setprecision(5) //Обычный (стандартный) режим;
    &lt;&lt; pi&lt;&lt; '\n';                    // показать только 5 цифр в сумме
                                       // по обе стороны от точки.
    cout&lt;&lt; "pi = "&lt;&lt; fixed //Режим чисел с фиксированной точкой;
    &lt;&lt; showpos              // выдать "+" для положительных чисел.
    &lt;&lt; setprecision(3)      // показать 3 цифры *справа* от
     &lt;&lt; pi&lt;&lt; '\n';          // десятичной точки.
    cout&lt;&lt; "pi = "&lt;&lt; scientific //Режим научного представления;
    &lt;&lt; noshowpos                 // знак плюс больше не выдается
    &lt;&lt; pi * 1000&lt;&lt; '\n';
    cout.flags(flags); // Восстановить значения флагов
   }
   Это приведет к получению следующего результата.
   pi = 3.1429
   pi = +3.143
   pi = 3.143е+003Обсуждение
   Манипуляторы, работающие с числами с плавающей точкой, делятся на две категории. Одни из них задают формат и в данном рецепте устанавливают общий вид целых значений и значений чисел с плавающей точкой, а другие используются для тонкой настройки каждого формата. Предусмотрены следующие форматы.
   Обычный (стандартный)
   В этом формате фиксировано количество отображаемых цифр (по умолчанию это количество равно шести), а десятичная точка отображается в соответствующем месте. Поэтому число «пи» по умолчанию будет иметь вид3.14286,а умноженное на 100 будет отображаться как314.286.
   Фиксированный
   В этом формате фиксировано количество цифр, отображаемоесправаот десятичной точки, а количество цифр слева не фиксировано. В этом случае при стандартной точности, равной шести, число «пи» будет отображаться в виде3.142857,а умноженное на 100 —314.285714.В обоих случаях количество цифр, отображаемое справа от десятичной точки, равно шести, а общее количество цифр может быть любым.
   Научный
   Значение начинается с цифры, затем идет десятичная точка и несколько цифр, количество которых определяется заданной точностью; затем идет буква «е» и степень 10, в которую надо возвести предыдущее значение. В этом случае число «пи», умноженное на 1000, будет отображаться как3.142857е+003.
   В табл. 10.2 приводятся все манипуляторы, которые воздействуют на вывод чисел с плавающей точкой (а иногда и на вывод любых чисел). См. табл. 10.1, где приводятся манипуляторы общего типа, которые можно использовать совместно с манипуляторами чисел с плавающей точкой.

   Табл. 10.2. Манипуляторы, работающие с любыми числами и числами с плавающей точкойМанипуляторОписаниеПример выводаfixedПоказать значение чисел с плавающей точкой с фиксированным количеством цифр справа от десятичной точкиПри стандартной точности, равной шести цифрам:pi = 3.142857scientificПоказать значение чисел с плавающей точкой, применяя научную нотацию, в которой используется значение с десятичной точкой и экспонентный множительpi * 1000при стандартной точности, равной шести цифрам:pi = 3.142857е+003setprecisionУстановить количество цифр, отображаемых в выводе (см. последующие объяснения)Число «пи» в стандартном формате при точности, равной трем цифрам:pi = 3.14В фиксированном формате:pi = 3.143В научном формате:pi = 3.143е+000showpos noshowposПоказать знак «плюс» перед положительными числами. Это действует для чисел любого типа, с десятичной точкой или целых+3.14showpoint noshowpointПоказать десятичную точку, даже если после нее идут одни нули. Это действует только для чисел с плавающей точкой и не распространяется на целые числаСледующая строка при точности, равной двум цифрам:cout&lt;&lt; showpoint&lt;&lt; 2.0выдаст такой результат:2.00showbase noshowbaseПоказать основание числа, представленного в десятичном виде (основание отсутствует), в восьмеричном виде (ведущий нуль) или в шестнадцатеричном виде (префикс 0x). См. следующую строку таблицыДесятичное представление: 32Восьмеричное: 040Шестнадцатеричное: 0x20dec oct hexУстановить основание для отображения числа в десятичном, восьмеричном или шестнадцатеричном виде. Само основание по умолчанию не отображается; для его отображения используйте showbaseСм предыдущую строку таблицыuppercase nouppercaseОтображать значения, используя верхний регистрУстанавливает регистр вывода чисел, например для префикса0Xшестнадцатеричных чисел или буквыEдля чисел, представленных в научной нотации
   Все манипуляторы, кромеsetprecision,одинаково воздействуют на все три формата. В стандартном режиме «точность» определяет суммарное количество цифр по обе стороны от десятичной точки. Например, для отображения числа «пи» в стандартном формате с точностью, равной 2, выполните следующие действия.
   cout&lt;&lt; "pi = "&lt;&lt; setprecision(2)&lt;&lt; pi&lt;&lt; '\n';
   В результате вы получите
   pi = 3.1
   Для сравнения представим, что вам требуется отобразить число «пи» в формате чисел с плавающей точкой.
   cout&lt;&lt; "pi = "&lt;&lt; fixed&lt;&lt; setprecision(2)&lt;&lt; pi&lt;&lt; '\n';
   Теперь результат будет таким.
   pi = 3.14
   Отличие объясняется тем, что здесь точность определяет количество цифр, расположенныхсправаот десятичной точки. Если мы умножим число «пи» на 1000 и отобразим в том же формате, количество цифр справа от десятичной точки не изменится.
   cout&lt;&lt; "pi = "&lt;&lt; fixed&lt;&lt; setprecision(2)&lt;&lt; pi * 1000&lt;&lt; '\n';
   выдает в результате:
   pi = 3142.86
   Это хорошо, потому что вы можете задать точность, установить ширину своего поля при помощиsetw,выровнять вправо отображаемое значение при помощиright (см. рецепт 10.1), и ваши числа будут выровнены вертикально по десятичной точке.
   Поскольку манипуляторы — это просто удобный способ установки флагов формата для потока, следует помнить, что заданные установки работают до тех пор, пока вы их не уберете или пока поток не будет уничтожен. Сохраните флаги формата (см. пример 10.3) до того, как вы начнете его изменять, и восстановите их в конце.Смотри также
   Рецепт 10.3.
   10.3.Написание своих собственных манипуляторов потокаПроблема
   Требуется иметь манипулятор потока, который делает что-нибудь такое, что не могут делать стандартные манипуляторы. Или вам нужен такой один манипулятор, который устанавливает несколько флагов потока, и вам не приходится вызывать несколько манипуляторов всякий раз, когда необходимо установить конкретный формат вывода.Решение
   Чтобы создать манипулятор, который не имеет аргументов (типаleft),напишите функцию, которая принимает в качестве параметраios_baseи устанавливает для него флаги потока. Если вам нужен манипулятор с аргументом, см. приводимое ниже обсуждение. Пример 10.4 показывает возможный вид манипулятора без аргументов.
   Пример 10.4. Простой манипулятор потока
   #include&lt;iostream&gt;
   #include&lt;iomanip&gt;
   #include&lt;string&gt;

   using namespace std;

   //вывести числа с плавающей точкой в обычном виде
   inline ios_base& floatnormal(ios_base& io) {
    io.setf(0, ios_base::floatfield);
    return(io);
   }

   int main() {
    ios_base::fmtflags flags = // Сохранить старые флаги
     cout.flags();
    double pi = 22.0/7.0;
    cout&lt;&lt; pi = "&lt;&lt; scientific //Научный режим
    &lt;&lt; pi * 1000&lt;&lt; '\n';
    cout&lt;&lt; "pi = "&lt;&lt; floatnormal&lt;&lt; pi&lt;&lt; '\n';
    cout.flags(flags);
   }Обсуждение
   Существует два вида манипуляторов: с аргументами и без аргументов. Манипуляторы без аргументов пишутся просто. Вам требуется только написать функцию, которая принимает в качестве параметра поток, выполнить с ним какие-то действия (установить флаги или изменить установочные параметры) и возвратить его. Сложнее написать манипулятор, который имеет один или несколько аргументов, потому что потребуется создавать дополнительные классы и функции, которые работают «за кулисами». Поскольку манипуляторы без аргументов более простые, начнем с них.
   Прочитав рецепт 10.1, вероятно, вы поняли, что существует три формата вывода чисел с плавающей точкой и только два манипулятора для выбора формата. Для используемогопо умолчанию формата не предусмотрен манипулятор; вам придется соответствующим образом установить флаг для потока, чтобы вернуться к стандартному формату:
   myiostr.setf(0, ios_base::float field);
   Но для удобства вы можете добавить свой собственный манипулятор, делающий то же самое. Именно это сделано в примере 10.4. Манипуляторfloatnormalустанавливает соответствующий флаг потока для вывода чисел с плавающей точкой в стандартном формате.
   Компилятор знает, что делать с вашей новой функцией, потому что в стандартной библиотеке определен следующий оператор дляbasic_ostream (basic_ostream— имя шаблона класса, инстанцируемого в классахostreamиwostream).
   basic_ostream&lt;charT, traits&gt;& operator&lt;&lt;
    (basic_ostream&lt;charT, traits&gt;& (* pf)basic_ostream&lt;charT, traits&gt;&))
   Здесьpf— это указатель функции, которая принимает в аргументе ссылку наbasic_ostreamи возвращает ссылку наbasic_ostream.Этот оператор просто обеспечивает вызов вашей функции, которая принимает в качестве аргумента текущий поток.
   Манипуляторы с аргументами более сложные. Чтобы понять причину этого, рассмотрим работу манипулятора без аргументов. Пусть используется, например, следующий манипулятор
   myostream&lt;&lt; myManip&lt;&lt; "foo";
   Вы задаете его без скобок, поэтому его имя в действительности заменяется адресом функции вашего манипулятора. В действительностиoperator&lt;&lt;вызывает функцию манипулятора и передает ей поток, чтобы манипулятор мог выполнить свою работу.
   Для сравнения представим, что у вас имеется манипулятор, который принимает числовой аргумент, так что в идеале вы могли бы его использовать следующим образом.
   myostream&lt;&lt; myFancyManip(17)&lt;&lt; "apple";
   Как это будет работать? Если вы считаете, чтоmyFancyManipявляется функцией, принимающей целочисленный аргумент, то возникает проблема: как передать поток в функцию без включения его в параметры и явного его использования? Вы могли бы написать так.
   myostream&lt;&lt; myFancyManip(17, myostream)&lt;&lt; "apple";
   Но это выглядит непривлекательно и избыточно. Одним из удобств манипуляторов является то, что их можно просто добавлять в строку с группой операторовoperator&lt;&lt;,и они хорошо воспринимаются и используются.
   Решение состоит в том, чтобы заставить компилятор пойти окольным путем. Вместо того чтобыoperator&lt;&lt;вызывал функцию вашего манипулятора для потока, вам надо просто создать временный объект, который возвращает нечто такое, что может использоватьoperator&lt;&lt;.
   Во-первых, вам необходимо определить временный класс, который делал бы всю работу. Для простоты предположим, что вам требуется написать манипулятор с именемsetWidth,который делает то же самое, что иsetw.Временная структура, которую вам необходимо построить, будет выглядеть примерно так.
   class WidthSetter {
   public:
    WidthSetter(int n) : width_(n) {}
    void operator()(ostream& os) const {os.width(width_);}
   private:
    int width_;
   };
   Этот класс содержит простую функцию. Предусмотрите в ней целочисленный аргумент и, когдаoperator()вызывается с аргументом потока, установите ширину для потока в значение, в какое она была установлена при инициализации этого объекта. В результате мы получимWidthSetter,сконструированный одной функцией и используемый другой. Ваш манипулятор конструирует эту функцию, и это будет выглядеть следующим образом.
   WidthSetter setWidth(int n) {
    return(WidthSetter(n)); // Возвращает инициализированный объект
   }
   Эта функция всего лишь возвращает объектWidthSetter,инициализированный целым значением. Этот манипулятор вы будете использовать в строке операторовoperator&lt;&lt;следующим образом.
   myostream&lt;&lt; setWidth(20)&lt;&lt; "banana";
   Но этого недостаточно, потому чтоsetWidthпросто возвращает объектWidthSetter;operator&lt;&lt;не будет знать, что с ним делать. Вам придется перегрузитьoperator&lt;&lt;,чтобы он знал, как управлять объектомWidthSetter:
   ostream& operator&lt;&lt;(ostream& os, const WidthSetter& ws) {
    ws(os);     // Передать поток объекту ws
    return(os); // для выполнения реальной работы
   }
   Это решает проблему, но не в общем виде. Вам не захочется писать класс типаWidthSetterдля каждого вашего манипулятора, принимающего аргумент (возможно, вы это и делаете, но были бы не против поступить по-другому), поэтому лучше использовать шаблоны иуказатели функций для получения привлекательной, обобщенной инфраструктуры, на базе которой вы можете создавать любое количество манипуляторов. Пример 10.5 содержит классManipInfraи версиюoperator&lt;&lt;,использующую аргументы шаблона для работы с различными типами символов, которые может содержать поток, и с различными типами аргументов, которые могут быть использованы манипулятором потока.
   Пример 10.5. Инфраструктура манипуляторов
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using namespace std;

   // ManipInfra -это небольшой промежуточный класс, который помогает
   //создавать специальные манипуляторы с аргументами. Вызывайте его
   //конструктор с предоставлением указателя функции и значения из основной
   //функции манипулятора
   //Указатель функции должен ссылаться на вспомогательную функцию, которая
   //делает реальную работу. См. примеры ниже
   template&lt;typename T, typename C&gt;
   class ManipInfra {
   public:
    ManipInfra(basic_ostream&lt;C&gt;& (*pFun) (basic_ostream&lt;C&gt;&, T), T val) :
     manipFun_(pFun), val_(val) {}
    void operator()(basic_ostream&lt;C&gt;& os) const {
     manipFun_(os, val_);
    }       // Вызовите функцию, задавая ее указатель и
   private: //передавая ей поток и значение
    T val_;
    basic_ostream&lt;С&gt;& (*manipFun_) (basic_ostream&lt;C&gt;&, T);
   };

   template&lt;typename T, typename C&gt;
   basic_ostream&lt;C&gt;& operator&lt;&lt;(basic_ostream&lt;C&gt;& os,
    const ManipInfra&lt;T, C&gt;& manip) {
    manip(os);
    return(os);
   }

   //Вспомогательная функция, которая вызывается в итоге в классе ManipInfra
   ostream& setTheWidth(ostream& os, int n) {
    os.width(n);
    return(os);
   }

   //Собственно функция манипулятора. Именно она используется в клиентском
   //программном коде
   ManipInfra&lt;int, char&gt; setWidth(int n) {
    return(ManipInfra&lt;int, char&gt;(setTheWidth, n));
   }

   //Ещё одна вспомогательная функция, которая принимает аргумент типа char
   ostream& setTheFillChar(ostream& os, charс) {
    os.fill(c);
    return(os);
   }

   ManipInfra&lt;char, char&gt; setFill(char c) {
    return(ManipInfra&lt;char, char&gt;(setTheFillChar, c));
   }

   int main() {
    cout&lt;&lt; setFill('-')
    &lt;&lt; setWidth(10)&lt;&lt; right&lt;&lt; "Proust\n";
   }
   Если последовательность событий при работе этого класса все же остается неясной, я советую прогнать пример 10.5 через отладчик. Увидев его реальную работу, вы все поймете.
   10.4.Создание класса, записываемого в потокПроблема
   Требуется записать класс в поток для последующего его чтения человеком или с целью его хранения в постоянной памяти, т.е. для его сериализации.Решение
   Перегрузитеoperator&lt;&lt;для записи в поток соответствующих данных-членов. В примере 10.6 показано, как это можно сделать.
   Пример 10.6. Запись объектов в поток
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using namespace std;

   class Employer {
    friend ostream& operator&lt;&lt;             // Он должен быть другом для
     (ostream& out, const Employer& empr); //получения доступа к неоткрытым
   public:                                 // членам
    Employer() {}
    ~Employer() {}
    void setName(const string& name) {name_ = name;}
   private:
    string name_;
   };

   class Employee {
   friend ostream& operator&lt;&lt; (ostream& out, const Employee& obj);
   public:
    Employee() : empr_(NULL) {}
    ~Employee() {if (empr_) delete empr_;}

    void setFirstName(const string& name) {firstName_ = name;}
    void setLasttName(const string& name) {lastName_ = name;}
    void setEmployer(Employer& empr) {empr_ =&empr;}
    const Employer* getEmployer() const {return(empr_);}
   private:
    string firstName_;
    string lastName_;
    Employer* empr_;
   };

   //Обеспечить передачу в поток объектов
   Employer... ostream& operator&lt;&lt;(ostream& out, const Employer& empr) {
    out&lt;&lt; empr.name_&lt;&lt; endl; return(out);
   }

   //Обеспечить передачу в поток объектов Employee...
   ostream& operator&lt;&lt;(ostream& out, const Employee& emp) {
    out&lt;&lt; emp.firstName_&lt;&lt; endl;
    out&lt;&lt; emp.lastName_&lt;&lt; endl;
    if (emp.empr_) out&lt;&lt; *emp.empr_&lt;&lt; endl;
     return(out);
   }

   int main() {
    Employee emp;
    string first = "William";
    string last = "Shatner";
    Employer empr;
    string name = "Enterprise";
    empr.setName(name);
    emp.setFirstName(first);
    emp.setLastName(last);
    emp.setEmployer(empr);
    cout&lt;&lt; emp; //Запись в поток
   }Обсуждение
   Прежде всего, необходимо объявить операторoperator&lt;&lt;другом (friend)класса, который вы хотите записывать в поток. Вы должны использоватьoperator&lt;&lt;,а не функцию-член типаwriteToStream(ostream& os),потому что этот оператор принято использовать в стандартной библиотеке для записи любых объектов в поток. Вам придется объявить его другом, потому что в большинстве случаев потребуется записывать в поток закрытые члены, а не являющиеся друзьями функции не смогут получить доступ к ним.
   После этого определите версиюoperator&lt;&lt;,которая работает сostreamилиwostream (которые определены в&lt;ostream&gt;)и вашим классом, который вы уже объявили с ключевым словомfriend.Здесь вы должны решить, какие данные-члены должны записываться в поток. Обычно потребуется записывать в поток все данные, как это я делал в примере 10.6.
   out&lt;&lt; emp.firstName_&lt;&lt; endl;
   out&lt;&lt; emp.lastName_&lt;&lt; endl;
   В примере 10.6 я записал в поток объект, на который ссылается указательempr_,вызывая для него операторoperator&lt;&lt;.
   if (emp.empr_)
    out&lt;&lt; *emp.empr&lt;&lt; endl;
   Я могу так делать, потому чтоempr_указывает на объект классаEmployer,а для него, как и дляEmployee,я определил операторoperator&lt;&lt;.
   После записи в поток членов вашего класса ваш операторoperator&lt;&lt;должен возвратить переданный ему поток. Это необходимо делать в любой перегрузкеoperator&lt;&lt;,тогда она может успешно использоваться, как в следующем примере.
   cout&lt;&lt; "Here's my object. "&lt;&lt; myObj&lt;&lt; '\n';
   Описанный мною подход достаточно прост, и если вы собираетесь записывать класс с целью его дальнейшего восприятия человеком, он будет хорошо работать, но это только частичное решение проблемы. Если вы записываете объект в поток, это обычно делается по одной из двух причин. Либо этот поток направляется куда-то, где он будет прочитан человеком (cout,окно терминала, файл журнала и т.п.), либо поток записывается на носитель временной или постоянной памяти (stringstream,сетевое соединение, файл и т.д.) и вы планируете восстановить в будущем объект из потока. Если вам требуется воссоздать объект из потока (тема рецепта 10.5), необходимо тщательно продумать взаимосвязи вашего класса.
   Сериализация трудно реализуется для любых классов, не считая тривиальных. Если в вашем классе имеются ссылки или указатели на другие классы, что характерно для большинства нетривиальных классов, вам придется учесть потенциальную возможность наличия циклических ссылок, обработать их должным образом при записи в поток объектов и правильно реконструировать ссылки при считывании объектов. Если вам приходится строить что-то «с чистого листа», необходимо учесть эти особенности проектирования, однако если вы можете использовать внешнюю библиотеку, вам следует воспользоваться библиотекой Boost Serialization, которая обеспечивает переносимый фреймворк сериализации объектов.Смотри также
   Рецепт 10.5.
   10.5.Создание класса, считываемого из потокаПроблема
   В поток записан объект некоторого класса и теперь требуется считать эти данные из потока и использовать их для инициализации объекта того же самого класса.Решение
   Используйтеoperator&gt;&gt;для чтения данных из потока в ваш класс для заполнения значений данных-членов; это просто является обратной задачей по отношению к тому, что сделано в примере 10.6. Реализация приводится в примере 10.7.
   Пример 10.7. Чтение данных из потока в объект
   #include&lt;iostream&gt;
   #include&lt;istream&gt;
   #include&lt;fstream&gt;
   #include&lt;string&gt;

   using namespace std;

   class Employee {
    friend ostream& operator&lt;&lt;            // Они должны быть друзьями,
     (ostream& out, const Employee& emp); //чтобы получить доступ к
    friend istream& operator&gt;&gt;            // неоткрытым членам
     (istream& in, Employee& emp);
   public:
    Employee() {}
    ~Employee() {}

    void setFirstName(const string& name) {firstName_ = name;}
    void setLastName(const string& name) {lastName_ = name;}
   private:
    string firstName_;
    string lastName_;
   };

   //Передать в поток объект Employee...
   ostream& operator&lt;&lt;(ostream& out, const Employee& emp) {
    out&lt;&lt; emp.firstName_&lt;&lt; endl;
    out&lt;&lt; emp.lastName_&lt;&lt; endl;
    return(out);
   }

   //Считать из потока объект Employee
   istream& operator&gt;&gt;(istream& in, Employee& emp) {
    in&gt;&gt; emp.firstName_;
    in&gt;&gt; emp.lastName_;
    return(in);
   }

   int main() {
    Employee emp;
    string first = "William";
    string last = "Shatner";
    emp.setFirstName(first);
    emp.setLastName(last);
    ofstream out("tmp\\emp.txt");
    if (!out) {
     cerr&lt;&lt; "Unable to open output file.\n";
     exit(EXIT_FAILURE);
    }
    out&lt;&lt; emp; //Записать Emp в файл
    out.close();
    ifstream in("tmp\\emp.txt");
    if (!in) {
     cerr&lt;&lt; "Unable to open input file.\n";
     exit(EXIT_FAILURE);
    }
    Employee emp2;
    in&gt;&gt; emp2; //Считать файл в пустой объект
    in.close();
    cout&lt;&lt; emp2;
   }Обсуждение
   При создании класса, считываемого из потока, выполняемые этапы почта совпадают с этапами записи объекта в поток (только они имеют обратный характер) Если вы еще не прочитали рецепт 10.4, это необходимо сделать сейчас, чтобы был понятен пример 10.7.
   Во-первых, вам необходимо объявитьoperator&gt;&gt;как дружественный для вашего целевого класса, однако в данном случае вам нужно, чтобы он использовал потокistream,а неostream.Затем определите операторoperator&gt;&gt; (вместоoperator&lt;&lt;)для прямого чтения значений из потока в каждую переменную-член вашего класса. Завершив чтение данных, возвратите входной поток.Смотри также
   Рецепт 10.4.
   10.6.Получение информации о файлеПроблема
   Требуется получить информацию о файле, например о его размере, номере устройства, времени последнего изменения и т.п.Решение
   Используйте вызов системной C-функцииstat,определенной в&lt;sys/stat.h&gt;.См. Пример 10.8, где показано типичное применение stat для вывода на печать некоторых атрибутов файла.
   Пример 10.8. Получение информации о файле
   #include&lt;iostream&gt;
   #include&lt;ctime&gt;
   #include&lt;sys/types.h&gt;
   #include&lt;sys/stat.h&gt;
   #include&lt;cerrno&gt;
   #include&lt;cstring&gt;

   int main(int argc, char** argv) {
    struct stat fileInfo;
    if (argc&lt; 2) {
     std::cout&lt;&lt; "Usage: fileinfo&lt;file name&gt;\n";
     return(EXIT_FAILURE);
    }
    if (stat(argv[1],&fileInfo) != 0) { //Используйте stat() для получения
                                         // информации
     std::cerr&lt;&lt; "Error: "&lt;&lt; strerror(errno)&lt;&lt; '\n';
     return(EXIT_FAILURE);
    }
    std::cout&lt;&lt; "Type::";
    if ((fileInfo.st_mode& S_IFMT) == S_IFDIR) { //Из sys/types.h
     std::cout&lt;&lt; "Directory\n";
    } else {
     std::cout&lt;&lt; "File\n";
    }
    std::cout&lt;&lt; "Size : "&lt;&lt;
    fileInfo.st_size&lt;&lt; '\n';               // Размер в байтах
    std::cout&lt;&lt; "Device : "&lt;&lt;
     (char)(fileInfo.st_dev + 'A')&gt;&gt; '\n'; //Номер устройства
    std::cout&lt;&lt; "Created : "&lt;&lt;
     std::ctime(&fileInfo.st_ctime);        // Время создания
    std::cout&lt;&lt; "Modified : "&lt;&lt;
     std.:ctime(&fileInfo.st_mtime);        // Время последней модификации
   }Обсуждение
   Стандартная библиотека C++ обеспечивает операции ссодержимымфайловых потоков, но она не имеет встроенных средств по чтению и изменению поддерживаемых ОС метаданных файла, например размера файла, его владельца, прав доступа,различных времен и другой информации. Однако стандартный С содержит несколько стандартных библиотек системных вызовов, которые можно использовать для получения различной информации о файле, что сделано в примере 10.8.
   Существует два средства, обеспечивающие получение информации о файле. Во-первых, это структураstructс именемstat,которая содержит члены с информацией о файле, и, во-вторых, системный вызов (функция) с тем же самым именем, который обеспечивает получение любой запрошенной информации о файле, помещая ее в структуруstat.Системный вызов— это функция, обеспечивающая некоторую системную службу ОС. Ряд системных вызовов является частью стандартного С, и многие из них стандартизованы и входят в состав различных версий Unix. Структураstatимеет следующий вид (из книги Кернигана (Kernigan) и Ричи (Richie) «TheС Programming Language», [издательство «Prentice Hall»]).
   struct stat {
    dev_t  st_dev;   /* устройство */
    ino_t  st_ino;   /* номер inode */
    short  st_mode;  /* вид */
    short  st_nlink  /* число ссылок на файл */
    short  st_uid;   /* пользовательский идентификатор владельца */
    short  st_gid;   /* групповой идентификатор владельца */
    dev_t  st_rdev;  /* для особых файлов */
    off_t  st_size;  /* размер файла в символах */
    time_t st_atime; /* время последнего доступа */
    time_t st_mtime; /* время последней модификации */
    time_t st_ctime; /* время последнего изменения inode */
   };
   Смысл каждого членаstatзависит от ОС. Например,st_uidиst_gidне используются в системах Windows, в то время как в системах Unix они фактически содержат идентификаторы пользователя и группы владельца файла. Воспользуйтесь документацией ОС, чтобы узнать, какие значения поддерживаются и как они интерпретируются.
   В примере 10.8 показано, как можно отображать на экране некоторые переносимые членыstat.st_modeсодержит битовую маску, описывающую тип файла. Она позволяет узнать, является ли файл каталогом или нет.st_ sizeзадает размер файла в байтах. Три члена типаsize_t  определяют время последнего доступа, модификации и создания файлов.
   Остальные члены содержат информацию, зависящую от операционной системы. Рассмотримst_dev:в системах Windows этот член содержит номер устройства (дисковода) в виде смещения от буквы А, представленной в коде ASCII (именно поэтому в примере я добавляю'A',чтобы получить буквенное обозначение дисковода). Но в системе Unix это будет означать нечто другое; значение этого члена передайте в системный вызовustat,и вы получите имя файловой системы.
   Если вам требуется получить дополнительную информацию о файле, лучше всего обратиться к документации вашей ОС. Стандартные системные вызовы C-функций ориентированы на Unix, поэтому они обычно приносят больше пользы в системах Unix (и совместно с ними может использоваться ряд других системных вызовов). Если вы не используете Unix, вполне возможно, что в вашей ОС имеются поставляемые со средой разработки собственные библиотеки, которые позволяют получать более детальную информацию.
   10.7.Копирование файлаПроблема
   Требуется скопировать файл, причем так, чтобы эта операция была переносимой, т.е. без использования зависящего от ОС программного интерфейса.Решение
   Используйте файловые потоки С++, определенные в&lt;fstream&gt;,для копирования одного потока в другой. Пример 10.9 показывает, как можно скопировать поток с помощью буфера
   Пример 10.9. Копирование файла
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;

   const static int BUF_SIZE = 4096;

   using std::ios_base;

   int main(int argc, char** argv) {
    std::ifstream in(argv[1],
     ios_base::in | ios_base::binary);  // Задается двоичный режим, чтобы
    std::ofstream out(argv[2],          // можно было обрабатывать файлы с
     ios_base::out | ios_base::binary), // любым содержимым
    // Убедитесь, что потоки открылись нормально...
    char buf[BUF_SIZE];
    do {
     in.read(&buf[0], BUF_SIZE);      // Считать максимум n байт в буфер,
     out.write(&buf[0], in.gcount()); //затем записать содержимое буфера
    } while (in.gcount()&gt; 0);        // в поток вывода.
    // Проверить наличие проблем в потоках...
    in.close();
    out.close();
   }Обсуждение
   Можно посчитать, что копирование файла — это простая операция чтения из одного потока и записи в другой поток. Однако библиотека потоков C++ достаточно большая, и существует несколько различных способов чтения и записи потоков, поэтому надо обладать некоторыми знаниями об этой библиотеке, чтобы избежать ошибок, снижающих производительность этой операции.
   Пример 10.9 работает быстро, потому что используется буферизация ввода-вывода. Функцииreadиwriteоперируют сразу всем содержимым буфера вместо посимвольного копирования, когда в цикле считывается символ из потока ввода в буфер и затем записывается в поток вывода. При их выполнении не делается никакого форматирования, подобного тому, которое выполняется операторами сдвига влево и вправо, что ускоряет выполнение операции. Кроме того, поскольку потоки работают в двоичном режиме, не надо специально обрабатывать символы EOF. В зависимости от используемого вами оборудования, ОС и т.д. вы получите различный результат при различных размерах буфера. Экспериментально вы можете найти наилучшие параметры для вашей системы
   Однако можно добиться большего. Все потоки C++ уже буферизуют данные при их чтении и записи, поэтому в примере 10.9 фактически выполняетсядвойнаябуферизация. Поток ввода имеет свой собственный внутренний буфер потока, который содержит символы, прочитанные из исходного файла, но еще не обработанные с помощьюread,operator&lt;&lt;,getcили любых других функций-членов, а поток вывода имеет буфер, который содержит вывод, записанный в поток, но не в «пункт назначения» (в случае примененияofstreamэто файл, но могла бы быть строка, сетевое соединение и кто знает, что еще). Поэтому лучше всего обеспечить непосредственный обмен данных буферов. Вы это можете сделать с помощью оператораoperator&lt;&lt;,который работает иначе с буферами потоков. Например, вместо циклаdo/whileприведенного в примере 10.9, используйте следующий оператор.
   out&lt;&lt; in.rdbuf();
   Не следует размещать этот оператор в теле цикла, замените весь цикл одной строкой. Это выглядит немного странно, поскольку обычно операторoperator&lt;&lt;говорит, «возьмите правую часть и передайте ее в поток левой части», однако, поверьте мне, эта запись имеет смысл,rdbufвозвращает буфер потока ввода, а реализацияoperator&lt;&lt;,принимающая буфер потока справа, считывает каждый символ буфера ввода и записывает его в буфер вывода. Когда буфер ввода заканчивается, он «знает», что должен заново заполнить себя данными из реального источника, aoperator&lt;&lt;ведет себя не лучше.
   Пример 10.9 показывает, как можно скопироватьсодержимоефайла, но ваша ОС отвечает за управление файловой системой, которая осуществляет копирование, так почему бы не предоставить право ОС сделать эту работу? В большинстве случаев на это можно ответить, что прямой вызов программного интерфейса ОС, конечно, не является переносимым решением. Библиотека Boost Filesystem скрывает от вас множество зависящих от ОС программных интерфейсов, предоставляя функциюcopy_file,которая выполняет системные вызовы ОС для той платформы, для которой она компилируется. Пример 10.10 содержит короткую программу, которая копирует файл из одного места в другое.
   Пример 10.10. Копирование файла при помощи Boost
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;boost/filesystem/operations.hpp&gt;
   #include&lt;boost/filesystem/fstream.hpp&gt;

   using namespace std;
   using namespace boost::filesystem;

   int main(int argc, char** argv) {
    // Проверка параметров...
    try {
     // Преобразовать аргументы в абсолютные пути, используя «родное»
     // форматирование
     path src = complete(path(argv[1], native));
     path dst = complete(path(argv[2], native));
     copy_file(src, dst);
    } catch (exception& e) {
     cerr&lt;&lt; e.what()&lt;&lt; endl;
    }
    return(EXIT_SUCCESS);
   }
   В этой небольшой программе все же имеется несколько ключевых вопросов, которые необходимо пояснить, поскольку другие рецепты данной главы используют библиотеку Boost Filesystem. Во первых, центральным компонентом библиотеки Boost Filesystem является классpath,описывающий независимым от ОС способом путь к файлу или каталогу. Вы можете создатьpath,используя как переносимый тип строки, так и специфичный для конкретной ОС. В примере 10.10 я создаю путьpathиз аргументов программы (этот путь я затем передаю функцииcomplete,которую мы вскоре рассмотрим).
   path src = complete(path(argv[1], native));
   Первый аргумент — это текстовая строка, представляющая путь, например «tmp\\foo.txt», а второй аргумент — имя функции, которая принимает аргумент типаstringи возвращает значение типаBoolean,которое показывает, удовлетворяет или нет путь определенным правилам. Функцияnativeговорит о том, что проверяется родной формат ОС. Я его использовал в примере 10.10, потому что аргументы берутся из командной строки, где они, вероятно, вводятся человеком, который, по-видимому, использует родной формат ОС при задании имен файлов. Существует несколько функций, предназначенных для проверки имен файлов и каталогов и названия которых не требует пояснений:portable_posix_name,windows_name,portable_name,portable_directory_name,portable_file_nameиno_check.Особенности работы этих функций вы найдете в документации.
   Функцияcompleteформирует абсолютный путь, используя текущий рабочий каталог и переданный ее относительный путь. Так, я могу следующим образом создать абсолютный путь к исходному файлу.
   path src = complete(path("tmp\\foo.txt", native));
   В том случае, если первый аргумент уже имеет абсолютное имя файла, функцияcompleteвыдает заданное значение и не будет пытаться его присоединить к текущему рабочему каталогу. Другими словами, в следующем операторе, выполняемом при текущем каталоге «c:\myprograms», последний будет проигнорирован, потому что уже задан полный путь.
   path src = complete(path("c:\\windows\\garbage.txt", native));
   Многие функции из библиотеки Boost Filesystem будут выбрасывать исключения, если не удовлетворяется некоторое предусловие. Это подробно описано в документации, но хорошим примером является сама функцияcopy_file.Файл должен существовать перед копированием, поэтому если исходного файла нет, операция не будет завершена успешно иcopy_fileвыбросит исключение. Перехватите исключение, как я это сделал в примере 10.10, и вы получите сообщение об ошибке, объясняющее, что произошло.
   10.8.Удаление или переименование файлаПроблема
   Требуется удалить или переименовать файл и сделать эту операцию переносимой, те. без использования специфичного для конкретной ОС программного интерфейса.Решение
   Это сделают стандартные C-функцииremoveиrename,определенные в&lt;cstdio&gt;.Пример 10.11 кратко демонстрирует, как это делается.
   Пример 10.11. Удаление файла
   #include&lt;iostream&gt;
   include&lt;cstdio&gt;
   #include&lt;cerrno&gt;

   using namespace std;

   int main(int argc, char** argv) {
    if (argc != 2) {
     cerr&lt;&lt; "You must supply a file name to remove."&lt;&lt; endl;
     return(EXIT_FAILURE);
    }
    if (remove(argv[1]) == -1) { // remove() возвращает при ошибке -1
     cerr&lt;&lt; "Error: "&lt;&lt; strerror(errno)&lt;&lt; endl;
     return(EXIT_FAILURE);
    } else {
     cout&lt;&lt; "File '"&lt;&lt; argv[1]&lt;&lt; "' removed."&lt;&lt; endl;
    }
   }Обсуждение
   Эти системные вызовы легко использовать: просто вызовите любую из двух функций, передав ей имя файла, который требуется удалить или переименовать. Если что-то не получится, будет возвращено ненулевое значение, иerrnoбудет иметь номер соответствующей ошибки. Вы можете использоватьstrerrorилиperror (обе функции определены в&lt;cstdio&gt;)для вывода на печать сообщения об ошибке, зависящего от реализации.
   Для переименования файла следует поменять в примере 10.11 вызов функцииremoveследующим программным кодом.
   if (rename(argv[1], argv[2])) {
    cerr&lt;&lt; "Error: "&lt;&lt; strerror(errno)&lt;&lt; endl;
    return(EXIT_FAILURE);
   }
   Библиотека Boost Filesystem также предоставляет средства для удаления и переименования файла. В примере 10.12 показана короткая программа по удалению файла (или каталога, однако см. обсуждение, приводимое после этою примера).
   Пример 10.12. Удаления файла средствами Boost
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;boost/filesystem/operations.hpp&gt;
   #include&lt;boost/filesystem/fstream.hpp&gt;

   using namespace std;
   using namespace boost::filesystem;

   int main(int argc, char** argv) {
    // Проверить параметры...
    try {
     path p = complete(path(argv[1], native));
     remove(p);
    } catch (exception& e) {
     cerr&lt;&lt; e.what()&lt;&lt; endl;
    }
    return(EXIT_SUCCESS);
   }
   Важную часть примера 10.12 составляет функцияremove.При ее вызове следует задавать достоверный путь в аргументеpath,который ссылается на файл или пустой каталог, и они будут удалены. Пояснения по классуpathи функцииcomplete (оба они входят в библиотеку Boost Filesystem) приводятся при обсуждении рецепта 10.7. См. рецепт 10.11, где показан пример удаления каталога и всех содержащихся в нем файлов.
   Переименование файла и каталога выполняется аналогично. Замените программный код в блокеtryпримера 10.12 следующим кодом.
   path src = complete(path(argv[1], native));
   path dst = complete(path(argv[2], native));
   rename(src, dst);
   В результатеsrcбудет переименован вdstпри условии, что оба они содержат достоверные пути,srcиdstне обязаны иметь общий каталог, и в этом смысле функция переименования фактически перемещает файл или каталог в новый базовый каталог при условии, что путьdstсуществует.Смотри также
   Рецепт 10.7.
   10.9.Создание временного имени файла и временного файлаПроблема
   Требуется временно сохранить на диске некоторые данные, и вам не хочется писать самому программу, которая генерирует уникальные имена.Решение
   Используйте функциюtmpfileилиtmpnam,которые объявлены в&lt;cstdio&gt;.tmpfileвозвращаетFILE*,который уже открыт на запись, atmpnamгенерирует уникальное имя файла, которое вы можете сами открыть. Пример 10.13 показывает, как можно использовать функциюtmpfile.
   Пример 10.13. Создание временного файла
   #include&lt;iostream&gt;
   #include&lt;cstdio&gt;

   int main() {
    FILE* pf = NULL;
    char buf[256];
    pf = tmpfile(); // Создать и открыть временный файл
    if (pf) {
     fputs("This is a temp file", pf); // Записать в него некоторые данные
    }
    fseek(pf, 5, SEEK_SET); // Восстановить позицию в файле
    fgets(buf, 255, pf);    // Считать оттуда строку
    fclose(pf);
    std:cout&lt;&lt; buf&lt;&lt; '\n';
   }Обсуждение
   Создать временный файл можно двумя способами; в примере 10.13 показан один из них. Функцияtmpfileобъявляется в&lt;cstdio&gt;;она не имеет параметров и возвращаетFILE*при успешном завершении иNULLв противном случае.FILE*— это тот же самый тип, который может использоваться функциями С, обеспечивающими ввод-вывод;fread,fwrite,fgets,putsи т.д.tmpfileоткрывает временный файл в режиме «wb+» — это означает, что вы можете записывать в него или считывать его в двоичном режиме (т.е. при чтении символы никак специально не интерпретируются) После нормального завершения работы программы временный файл, созданный функциейtmpfile,автоматически удаляется.
   Такой подход может как подойти, так и не подойти для вас — все зависит от того, что вы хотите делать. Заметив, чтоtmpfileне предоставляет имени файла, вы спросите, как можно передать его другой программе? В этом случае никак; вам потребуется вместо этой функции использовать аналогичную с именемtmpnam.
   tmpnamна самом деле не создает временный файл, она просто создает уникальное имя файла, которое вы можете использовать при открытии файла,tmpnamпринимает единственный параметр типаchar*и возвращает значение типаchar*.Вы можете передать указатель на буфер символовchar (он должен быть, по крайней мере, не меньше значения макропеременнойL_tmpnam,также определенной в&lt;cstdio&gt;),кудаtmpnamскопирует имя временного файла и возвратит указатель на тот же самый буфер. Если вы передадитеNULL,tmpfileвозвратит указатель на статический буфер, содержащий это имя файла, что означает его перезапись последующими вызовамиtmpnam. (См. пример 10.14.)
   Пример 10.14. Создание имени временного файла
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;cstdio&gt;
   #include&lt;string&gt;

   int main() {
    char* pFileName = NULL;
    pFileName = tmpnam(NULL);
    // Здесь другая программа может получить то же самое имя временного
    // файла.
    if (!pFileName) {
     std::cerr&lt;&lt; "Couldn't create temp file name.\n";
     return(EXIT_FAILURE);
    }
    std::cout&lt;&lt; "The temp file name is: "&lt;&lt; pFileName&lt;&lt; '\n';
    std::ofstream of(pFileName);
    if (of) {
     of&lt;&lt; "Here is some temp data.";
     of.close();
    }
    std::ifstream ifs(pFileName);
    std::string s;
    if (ifs) {
     ifs&gt;&gt; s;
     std::cout&lt;&lt; "Just read in \""&lt;&lt; s&lt;&lt; "\"\n";
     ifs.close();
    }
   }
   Однако одну важную особенность необходимо знать о функцииtmpnam.Может возникнуть условие состязания, когда несколько процессов могут генерировать одинаковое имя файла, если один процесс вызываетtmpname,а другой вызываетtmpnameдо того, как первый процесс откроет этот файл. Это плохо по двум причинам. Во-первых, написанная злоумышленником программа может делать это для перехвата данных временного файла, и, во-вторых, ни о чем не подозревающая программа может получить то же самое имя файла и просто испортить или удалить данные.
   10.10.Создание каталогаПроблема
   Требуется создать каталог, причем эта операция должна быть переносимой, т.е. в ней не должен использоваться специфичный для конкретной ОС программный интерфейс.Решение
   На большинстве платформ вы сможете использовать системный вызовmkdir,который входит в состав большинства компиляторов и содержится в заголовочных файлах C-функций. Он имеет разный вид в различных ОС, но тем не менее вы можете его использовать для создания нового каталога. Стандартными средствами C++ нельзя обеспечить переносимый способ создания каталога. В этом вы можете убедиться на примере 10.15.
   Пример 10.15. Создание каталога
   #include&lt;iostream&gt;
   #include&lt;direct.h&gt;

   int main(int argc, char** argv) {
    if (argc&lt; 2) {
     std::cerr&lt;&lt; "Usage: "&lt;&lt; argv[0]&lt;&lt; " [new dir name]\n";
     return(EXIT_FAILURE);
    }
    if (mkdir(argv[1]) == -1) { // Созвать каталог
     std::cerr&lt;&lt; "Error: "&lt;&lt; strerror(errno);
     return(EXIT_FAILURE);
    }
   }Обсуждение
   Системные вызовы по созданию каталогов слегка отличаются в различных ОС, но пусть это вас не останавливает — их все же следует использовать. В большинстве систем поддерживаются различные варианты вызоваmkdir,поэтому для создания каталога достаточно просто знать, какой включать заголовочный файл и как выглядит сигнатура функции.
   Пример 10.15 работает в системах Windows, но не в Unix. В Windowsmkdirобъявляется в&lt;direct.h&gt;.Эта функция принимает один параметр (имя каталога) и возвращает -1, если возникла ошибка, устанавливая в errno соответствующий номер ошибки. Вы можете получить зависящую от реализации текстовую строку ошибки, вызывая strerror или perror.
   В Unixmkdirобъявляется в&lt;sys/stat.h&gt;,и сигнатура этой функции немного отличается. Семантика ошибки такая же, как в Windows, но существует второй параметр, определяющий права доступа нового каталога. Вы должны указать права доступа, используя традиционный форматchmod (см. дополнительную информацию на man-страницеchmod);например, 0777 означает, что владелец, групповой пользователь и прочие пользователи имеют право на чтение, запись и выполнение. Таким образом, вы могли бы вызвать этуфункцию следующим образом.
   #include&lt;iostream&gt;
   #include&lt;sys/types.h&gt;
   #include&lt;sys/stat.h&gt;

   int main(int argc, char** argv) {
    if (argc&lt; 2) {
     std::cerr&lt;&lt; "Usage: "&lt;&lt; argv[0]&lt;&lt; " [new dir name]\n";
     return(EXIT_FAILURE);
    }
    if (mkdir(argv[1], 0777) == -1) { // Создать каталог
     std::cerr&lt;&lt; "Error:&lt;&lt; strerror(errno);
     return(EXIT_FAILURE);
    }
   }
   Если вам требуется обеспечить переносимость, не следует самому писать операторы#ifdef,лучше воспользоваться библиотекой Boost Filesystem. Вы можете создать каталог, используя функциюсreate_directory,как показано в примере 10.16, который содержит короткую программу, создающую каталог.
   Пример 10.16. Создание каталога средствами Boost
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;cstdlib&gt;
   #include&lt;boost/filesystem/operations.hpp&gt;
   #include&lt;boost/filesystem/fstream.hpp&gt;

   using namespace std;
   using namespace boost::filesystem;

   int main(int argc, char** argv) {
    // Проверка параметров...
    try {
     path p = complete(path(argv[1], native));
     create_directory(p);
    } catch (exception& e) {
     cerr&lt;&lt; e.what()&lt;&lt; endl;
    }
    return(EXIT_SUCCESS);
   }
   Функцияcreate_directoryсоздает каталог, имя которого вы задаете в аргументеpath.Если этот каталог уже существует, выбрасывается исключениеfilesystem_error (которое является производным от стандартного класса исключения). Пояснения по классуpathи функцииcomplete (оба они входят в библиотеку Boost Filesystem) приводятся в обсуждении рецепта 10.7. См. рецепт 10.11, где показан пример удаления каталога и всех содержащихся в нем файлов. С другой стороны, если переносимость вас не волнует, используйте программный интерфейс файловой системы вашей ОС, который, вероятно, обладает большей гибкостью.Смотри также
   Рецепт 10.12.
   10.11.Удаление каталогаПроблема
   Требуется удалить каталог, причем эта операция должна быть переносимой, т.е. в ней не должен использоваться специфичный для конкретной ОС программный интерфейс.Решение
   На большинстве платформ вы сможете воспользоваться системным вызовомrmdir,который входит в состав большинства компиляторов и содержится в заголовочных файлах C-функций. Стандартными средствами C++ нельзя обеспечить переносимый способ удаления каталога. Вызовrmdirимеет разный вид в различных ОС, но тем не менее вы можете его использовать для удаления каталога. См. Пример 10.17, в котором приводится короткая программа по удалению каталога.
   Пример 10.17. Удаление каталога
   #include&lt;iostream&gt;
   #include&lt;direct.h&gt;

   using namespace std;

   int main(int argc, char** argv) {
    if (argc&lt; 2) {
     cerr&lt;&lt; "Usage: "&lt;&lt; argv[0]&lt;&lt; " [dir name]"&lt;&lt; endl;
     return(EXIT_FAILURE);
    }
    if (rmdir(argv[1]) == -1) { // Удалить каталог
     cerr&lt;&lt; "Error: "&lt;&lt; strerror(errno)&lt;&lt; endl;
     return(EXIT_FAILURE);
    }
   }Обсуждение
   Сигнатураrmdirсовпадает в большинстве ОС, однако объявляется эта функция в разных заголовочных файлах. В Windows она объявляется в&lt;direct.h&gt;,а в Unix — в&lt;unistd.h&gt;.Она принимает один параметр (имя каталога) и возвращает -1, если возникла ошибка, устанавливая вerrnoсоответствующий номер ошибки. Вы можете получить зависящую от реализации текстовую строку ошибки, вызываяstrerrorилиperror.
   Если целевой каталог не пустой,rmdirзавершится с ошибкой. Для просмотра списка содержимого каталога, перечисления его элементов для их удаления см. рецепт 10.12.
   Если вам требуется обеспечить переносимость, не следует самому писать операторы#ifdef,заключая в них специфичные для конкретной ОС функции, — лучше воспользоваться библиотекой Boost Filesystem. В библиотеке Boost Filesystem используется концепция пути для ссылкина файл или каталог, а пути можно удалять с помощью одной функции —remove.
   ФункцияremoveRecurseиз примера 10.18 рекурсивно удаляет каталог и все его содержимое. Наиболее важной ее частью является функцияremove (которая на самом деле является функциейboost::filesystem::remove,а не стандартной библиотечной функцией). Она принимает путьpathв качестве аргумента и удаляет его, если это файл или пустой каталог, но она не удаляет каталог, если он содержит файлы.
   Пример 10.18. Удаление каталога средствами Boost
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;cstdlib&gt;
   #include&lt;boost/filesystem/operations.hpp&gt;
   #include&lt;boost/filesystem/fstream.hpp&gt;

   using namespace std;
   using namespace boost::filesystem;

   void removeRecurse(const path& p) {
    // Сначала удалить содержимое каталога
    directory_iterator end;
    for (directory_iterator it(p); it != end; ++it) {
     if (is_directory(*it)) {
      removeRecurse(*it);
     } else {
      remove(*it);
     }
    }
    // Затем удалить сам каталог
    remove(p);
   }

   int main(int argc, char** argv) {
    if (argc != 2) {
     cerr&lt;&lt; "Usage: "&lt;&lt; argv[0]&lt;&lt; " [dir name]\n";
     return(EXIT_FAILURE);
    }
    path thePath = system_complete(path(argv[1], native));
    if (!exists(thePath)) {
     cerr&lt;&lt; "Error: the directory "&lt;&lt; thePath.string()
     &lt;&lt; " does not exist.\n";
     return(EXIT_FAILURE);
    }
    try {
     removeRecurse(thePath);
    } catch (exception& e) {
     cerr&lt;&lt; e.what()&lt;&lt; endl;
     return(EXIT_FAILURE);
    }
    return(EXIT_SUCCESS);
   }
   Программный код, обеспечивающий просмотр содержимого каталога, требует некоторых пояснений, и это является темой рецепта 10.12.
   Библиотека Boost Filesystem достаточно удобна, однако следует помнить, что формально она не является стандартом, и поэтому нет гарантии, что она будет работать в любой среде. Если вы посмотрите на исходный код библиотеки Boost Filesystem, вы увидите, что фактически она компилирует системные вызовы, специфичные для целевой платформы. Если васне волнует переносимость, используйте программный интерфейс файловой системы вашей ОС, который, вполне вероятно, обладает большей гибкостью.Смотри также
   Рецепт 10.12.
   10.12.Чтение содержимого каталогаПроблема
   Требуется прочитать содержимое каталога, вероятно, для того, чтобы сделать что-то с каждым его файлом или подкаталогом.Решение
   Для получения переносимого решения воспользуйтесь классами и функциями библиотеки Boost Filesystem. Она содержит ряд удобных функций по работе с файлами, обеспечивая переносимое представление путей, итераторы каталога и различные функции по переименованию, удалению и копированию файлов и т.п. Пример 10.19 показывает, как можно использовать некоторые из этих средств.
   Пример 10.19. Чтение каталога
   #include&lt;iostream&gt;
   #include&lt;boost/filesystem/operations.hpp&gt;
   #include&lt;boost/filesystem/fstream.hpp&gt;

   using namespace boost::filesystem;

   int main(int argc, char** argv) {
    if (argc&lt; 2) {
     std::cerr&lt;&lt; "Usage: "&lt;&lt; argv[0]&lt;&lt; " [dir name]\n";
     return(EXIT_FAILURE);
    }
    path fullPath = // Создать полный, абсолютный путь
     system_complete(path(argv[1], native));
    if (!exists(fullPath)) {
     std::cerr&lt;&lt; "Error: the directory "&lt;&lt; fullPath.string()
     &lt;&lt; " does not exist.\n";
     return(EXIT_FAILURE);
    }
    if (!is_directory(fullPath)) {
     std::cout&lt;&lt; fullPath.string()&lt;&lt; " is not a directory!\n";
     return(EXIT_SUCCESS);
    }
    directory_iterator end;
    for (directory_iterator it(fullPath);
     it != end; ++it) {        // Просматривать в цикле каждый
                              // элемент каталога почти
     std::cout&lt;&lt; it-&gt;leaf(); //так же, как это делалось бы для
     if (is_directory(*it))   // STL-контейнера
      std::cout&lt;&lt; " (dir)";
     std::cout&lt;&lt; '\n';
    }
    return(EXIT_SUCCESS);
   }Обсуждение
   Как и при создании и удалении каталогов (см. рецепты 10.10 и 10.11), не существует стандартного, переносимого способа чтения содержимого каталога. Чтобы облегчить жизньв C++, библиотека Filesystem проекта Boost содержит ряд переносимых функций по работе с файлами и каталогами. Она также содержит много других функций; дополнительную информацию вы найдете при описании других рецептов этой главы или на веб-странице библиотеки Boost Filesystem сайтаwww.boost.com.
   В примере 10.19 приводится простая программа просмотра каталога (наподобие командыlsв Unix илиdirв MS-DOS). Сначала она следующим образом формирует абсолютный путь на основе аргументов, переданных программе.
   path fullPath = complete(path(argv[1], native));
   Тип данных переменной, содержащей путь, называется, естественно,path (путь). С этим типом данных работает файловая система, и он легко преобразуется в строку путем вызоваpath::string.После формирования пути программа проверяет его существование (с помощью функцииexists),затем с помощью другой функции,is_directory,проверяет, задает ли данный путь каталог. Если ответ положителен, то все хорошо и можно перейти к реальной работе по просмотру содержимого каталога.
   Файловая система имеет класс с именемdirectory_iterator,который использует стандартную семантику итераторов, подобную применяемой для стандартных контейнеров, чтобы можно было использовать итераторы как указатели наэлементы каталога. Однако в отличие от стандартных контейнеров здесь нет функции-членаend,представляющей элемент, следующий за последним элементом (т.е.vector&lt;T&gt;::end).Вместо этого, если вы создаете итератор каталогаdirectory_iteratorпри помощи стандартного конструктора, он предоставляет конечный маркер, который вы можете использовать в операциях сравнения для определения момента завершения просмотра каталога. Поэтому используйте следующий оператор.
   directory_iterator end;
   Затем вы можете создать итератор для вашего пути и следующим образом сравнивать его с маркером конца.
   for (directory_iterator it(fullPath); it != end; ++it) {
    // выполнить любые действия с *it
    std::cout&lt;&lt; it-&gt;leaf();
   }
   Функция-членleafвозвращает строку, представляющую конечный элемент пути, а не весь путь, который вы можете получить, вызывая функцию-членstring.
   Если вам требуется обеспечить переносимость, но по каким-то причинам вы не можете использовать библиотеки Boost, обратите внимание на исходный код Boost. Он содержит операторы#ifdef,которые учитывают (по большей части) отличия среды Windows и ОС, использующих интерфейс Posix, и в частности отличия в представлении путей, например буквы дисководов и имена устройств.Смотри также
   Рецепты 10.10 и 10.11.
   10.13.Извлечение расширения файла из строкиПроблема
   Имеется имя файла или полный путь и требуется получить расширение файла, которое является частью имени файла, расположенной за последней точкой. Например, в именах файловsrc.cpp,Window.classиResume.docрасширениями файла являются соответственно.cpp,.classи.doc.Решение
   Преобразуйте имя файла или путь к нему в строкуstring,используйте функцию-членrfindдля определения позиции последней точки и возвратите то, что находится за ней. Пример 10.20 показывает, как это можно сделать.
   Пример 10.20. Получение расширения файла из его имени
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using std::string;

   string getFileExt(const string& s) {
    size_t i = s.rfind('.', s.length());
    if (i ! = string::npos) {
     return(s.substr(i+1, s.length() - i));
    }
    return("");
   }

   int main(int argc, char** argv) {
    string path = argv[1];
    std::cout&lt;&lt; "The extension is \""&lt;&lt; getFileExt(path)&lt;&lt; "\"\n";
   }Обсуждение
   Для получения расширения из имени файла достаточно лишь найти позицию последней точки «.» и выделить все, что находится справа от нее. Стандартный классstring,определенный в&lt;string&gt;,содержит функции, которые могут выполнить обе эти операции:rfindиsubstr.
   rfindвыполнит поиск (в обратном направлении)того, что вы передаете ей в первом аргументе (символ типаcharв данном случае), начиная с позиции, указанной вторым аргументом, и возвращает позицию, в которой найден указанный объект. Если поиск завершился неудачей,rfindвозвратитstring::npos.Функцияsubstrтакже имеет два аргумента. Первый аргумент содержит позицию первого копируемого элемента, а второй аргумент — количество копируемых символов.
   Стандартный класс строки содержит несколько функций-членов, выполняющих поиск. См. рецепт 4.9, в котором более детально обсуждается поиск строк.Смотри также
   Рецепты 4.9 и 10.12.
   10.14.Извлечение имени файла из полного путиПроблема
   Имеется полный путь к файлу, напримерd:\apps\src\foo.с,и требуется получить имя файлa,foo.с.Решение
   Примените подход, который использовался в предыдущем рецепте, и используйте функцииrfindиsubstrдля поиска и получения из полного пути то, что вам нужно. Пример 10.21 показывает, как это можно сделать.
   Пример 10.21. Извлечение имени файла из полного пути
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using std::string;

   string getFileName(const string& s) {
    char sep = '/';
   #ifdef _WIN32
    sep = '\\';
   #endif
    size_t i = s.rfind(sep.s.length());
    if (i ! = string::npos) {
     return(s.substr(i+1, s.length( ) - i));
    }
    return("");
   }

   int main(int argc, char** argv) {
    string path = argv[1];
    std::cout&lt;&lt; "The file name is \""&lt;&lt; getFileName(path)&lt;&lt; "\"\n";
   }Обсуждение
   См. предыдущий рецепт, в котором приводится детальное описание функцийrfindиsubstr.Стоит отметить только то, что вы уже, по-видимому, заметили в примере 10.21: в Windows в качестве разделителя используется обратный слеш вместо прямого, поэтому я добавил оператор#ifdefдля установки требуемого разделителя элементов пути.
   Классpathиз библиотеки Boost Filesystem позволяет легко получить с помощью функции-членаpath::leafпоследний элемент полного пути, которым может быть имя файла или каталога. В примере 10.22 приводится простая программа, которая использует эту функцию, чтобы показать, к чему относится этот путь: к файлу или к каталогу.
   Пример 10.22. Получение имени файла из пути
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;
   #include&lt;boost/filesystem/operations.hpp&gt;

   using namespace std;
   using namespace boost::filesystem;

   int main(int argc, char** argv) {
    // Проверка параметров
    try {
     path p = complete(path(argv[1], native));
    cout&lt;&lt; p.leaf()&lt;&lt; " is a "
    &lt;&lt; (is_directory(p) ? "directory" : "file")&lt;&lt; endl;
    } catch (exception& e) {
     cerr&lt;&lt; e.what()&lt;&lt; endl;
    }
    return(EXIT_SUCCESS);
   }
   См. обсуждение рецепта 10.7, где более детально рассматривается классpath.Смотри также
   Рецепт 10.15.
   10.15.Извлечение пути из полного имени файлаПроблема
   Имеется полное имя файла (имя файла и путь доступа к нему), напримерd:\apps\src\foo.с,и требуется получить путь к файлу,d:\apps\src.Решение
   Примените подход, который использовался в предыдущих двух рецептах, и используйте функцииrfindиsubstrдля поиска и получения из полного пути то, что вам нужно. В примере 10.23 приводится короткая программа, показывающая, как это можно сделать.
   Пример 10.23. Получение пути из полного имени файла
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using std::string;

   string getPathName(const string& s) {
    char sep = '/';
   #ifdef _WIN32
    sep = '\\';
   #endif
    size_t i = s.rfind(sep, s.length());
    if (i != string::npos) {
     return(s.substr(0, !));
    }
    return("");
   }

   int main(int argc, char** argv) {
    string path = argv[1];
    std::cout&lt;&lt; "The path name is \""&lt;&lt; getPathName(path)&lt;&lt; "\"\n";
   }Обсуждение
   Пример 10.23 тривиален, особенно если вы уже знакомы с двумя предыдущими рецептами, поэтому дополнительные пояснения не требуются. Однако, как и во многих других рецептах, библиотека Boost Filesystem позволяет извлекать с помощью функцииbranch_pathвсе, что угодно, кроме последней части имени файла. Пример 10.24 показывает, как можно использовать эту функцию.
   Пример 10.24. Получение базового пути
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;
   #include&lt;boost/filesystem/operations.hpp&gt;

   using namespace std;
   using namespace boost::filesystem;

   int main(int argc, char** argv) {
    // Проверка параметров...
    try {
     path p = complete(path(argv[1], native));
     cout&lt;&lt; p.branch_path().string()&lt;&lt; endl;
    } catch (exception& e) {
     cerr&lt;&lt; e.what()&lt;&lt; endl;
    }
    return(EXIT_SUCCESS);
   }
   Результат выполнения примера 10.24 может выглядеть следующим образом.
   D:\src\ccb\c10&gt;bin\GetPathBoost.exeс:\windows\system32\1033
   с:/windows/system32Смотри также
   Рецепты 10.13 и 10.14.
   10.16.Замена расширения файлаПроблема
   Имеется имя файла (возможно, с путем доступа к нему) и требуется заменить расширение файла. Например, имя файлаthesis.texтребуется преобразовать вthesis.txt.Решение
   Используйте функции-членыrfindиreplaceклассаstringдля поиска расширения и его замены. Пример 10.25 показывает, как это можно сделать.
   Пример 10.25. Замена расширения файла
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using std::string;

   void replaceExt(string& s, const string& newExt) {
    string::size_type i = s.rfind('.', s.length());
    if (i != string::npos) {
     s.replace(i+1, newExt.length(), newExt);
    }
   }

   int main(int argc, char** argv) {
    string path = argv[1];
    replaceExt(path, "foobar");
    std::cout&lt;&lt; "The new name is \""&lt;&lt; path&lt;&lt; "\"\n";
   }Обсуждение
   Здесь используется подход, аналогичный тому, который применялся в предыдущих рецептах, однако в данном случае я использовал функциюreplaceдля замены части строки новой подстрокой. Функцияreplaceимеет три параметра. Первый параметр задает позицию, в которую вставляется новая подстрока, а второй параметр определяет количество символов, которые необходимо удалить в формируемой строке. Третий параметр — это значение, которое будет использовано для замены удаляемой части строки.Смотри также
   Рецепт 4.9.
   10.17.Объединение двух путей в одинПроблема
   Имеется два пути и требуется их объединить в один путь. Например, вы имеете в качестве первого пути/usr/home/ryanи в качестве второго —utils/compilers;требуется получить/usr/home/ryan/utils/compilers,причем первый путь может как иметь, так и не иметь в конце разделитель элементов пути.Решение
   Рассматривайте пути как строки и используйте оператор добавления в конец строки,operator+=,для составления полного пути из составных частей. См. пример 10.26.
   Пример 10.26. Объединение путей
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using std::string;

   string pathAppend(const string& p1, const string& p2) {
    char sep = '/';
    string tmp = p1;
   #ifdef _WIN32
    sep = '\\';
   #endif
    if (p1[p1.length()] != sep) { // Необходимо добавить
     tmp += sep;                  // разделитель
     return(tmp + p2);
    } else
     return(p1 + p2);
   }

   int main(int argc, char** argv) {
    string path = argv[1];
    std::cout&lt;&lt; "Appending somedir\\anotherdir is \""
    &lt;&lt; pathAppend(path, "somedir\\anotherdir")&lt;&lt; "\"\n";
   }Обсуждение
   В программе примера 10.26 для представления путей используются строки, но здесь не делается дополнительной проверки достоверности путей и переносимость их полностью зависит от содержащихся в них значений. Например, если эти значения получены от пользователя, то вы не можете заранее знать, имеют ли они правильный формат конкретной ОС или содержат недопустимые символы.
   Для многих других рецептов данной главы я включил примеры по использованию библиотеки Boost Filesystem, и при работе с путями такой подход имеет много преимуществ. Как я говорил при обсуждении рецепта 10.7, библиотека Boost Filesystem содержит классpath,обеспечивающий переносимое представление пути к файлу или каталогу. Операции в библиотеке Filesystem в основном оперируют объектамиpath,и поэтому с помощью классаpathможно реализовать объединение относительного пути с абсолютной его базовой частью. (См. пример 10.27.)
   Пример 10.27. Объединение путей средствами Boost
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;cstdlib&gt;
   #include&lt;boost/filesystem/operations.hpp&gt;
   #include&lt;boost/filesystem/fstream.hpp&gt;

   using namespace std;
   using namespace boost::filesystem;

   int main(int argc, char** argv) {
    // Проверка параметров...
    try {
     // Составить путь из значений двух аргументов path
     p1 = complete(path(argv[2], native),
     path(argv[1], native));
     cout&lt;&lt; p1.string()&lt;&lt; endl;
     // Создать путь с базовой частью пути текущего каталога path
     p2 = system_complete(path(argv[2], native));
     cout&lt;&lt; p2.string()&lt;&lt; endl;
    } catch (exception& e) {
     cerr&lt;&lt; e.what()&lt;&lt; endl;
    }
    return(EXIT_SUCCESS);
   }
   Результат выполнения программы примера 10.27 может иметь такой вид.
   D:\src\ccb\c10&gt;bin\MakePathBoost.exe d:\temp some\other\dir
   d:/temp/some/other/dir
   D:/src/ccb/c10/some/other/dir
   Или такой.
   D:\src\ccb\c10&gt;bin\MakePathBoost.exe d:\tempс:\WINDOWS\system32
   c:/WINDOWS/system32
   c:/WINDOWS/system32
   Из этого примера видно, что функцииcompleteиsystem_completeобъединяют пути, когда это возможно, и возвращают абсолютный путь, когда объединение путей не имеет смысла. Например, в первом случае первый переданный программе аргумент является абсолютным путем каталога, а второй — относительным путем. Функцияcompleteобъединяет их и формирует один, абсолютный путь. Первый аргументcompleteявляется относительным путем, а второй — абсолютным путем, и если первый аргумент уже является абсолютным путем, второй аргумент игнорируется. Поэтому во втором случае аргумент «d:\temp» игнорируется, так как переданный мною второй аргумент уже является абсолютным путем.
   system_completeпринимает только один аргумент (в данном случае это относительный путь) и добавляет его в конец текущего рабочего каталога, получая другой абсолютный путь. И в этом случае, если переданный вами путь уже является абсолютным, текущий рабочий каталог игнорируется и просто возвращается переданный вами абсолютный путь.
   Однако эти пути не согласуются с требованиями файловой системы. Вам придется самому проверить объектыpath,чтобы убедиться, что они представляют правильный путь файловой системы. Например, для проверки существования этих путей вы можете использовать функциюexists.
   path p1 = complete(path(argv[2], native),
   path(argv[1], native));
   if (exists(p1)) {
    // ...
   Существует много других функций, позволяющих получать информацию о пути:is_directory,is_empty,file_size,last_write_timeи т.д. Дополнительную информацию вы найдете в документации по библиотеке Boost Filesystem на сайтеwww.boost.org.Смотри также
   Рецепт 10.7.
   Глава 11
   Наука и математика
   11.0.Введение
   Язык программирования C++ хорошо подходит для решения научных и математических задач из-за своей гибкости, выразительности и эффективности. Одно из самых больших преимуществ применения C++ для выполнения численных расчетов связано с тем, что он помогает избегать избыточности.
   Исторически сложилось так, что написанные на многих языках программы, реализующие численные расчеты, обычно снова и снова повторяют алгоритмы для различных числовых типов (например, для коротких чисел, для длинных чисел, для чисел с одинарной точностью, для чисел с двойной точностью, для специальных числовых типов и т.д.). В C++ проблема такой избыточности решается с помощью шаблонов. Шаблоны позволяют писать алгоритмы, которые не зависят от представления данных, — этот подход широко известен под названием «обобщенное программирование».
   Нельзя сказать, что C++ не имеет недостатков, которые проявляются при реализации численных расчетов. Самым большим недостатком С++, отличающим его от специализированных математических и научных языков программирования, являются ограниченные возможности стандартной библиотеки в отношении поддержки алгоритмов и типов данных,характерных для программирования численных расчетов. Возможно, самым большим упущением стандартной библиотеки является отсутствие матричных типов и целых типовпроизвольной точности.
   В данной главе я приведу решения распространенных задач численного программирования и продемонстрирую методы обобщенного программирования при написании эффективного программного кода, реализующего численные расчеты. В подходящих случаях я буду рекомендовать широко используемые библиотеки с открытым исходным кодом, имеющие дружественные коммерческие лицензии и подтвержденный послужной список. В этой главе рассматриваются основные методы обобщенного программирования, причем это делается постепенно, переходя от одного рецепта к другому.
   Многие программисты, использующие С++, все же с недоверием относятся к шаблонам и обобщенному программированию из-за очевидной их сложности. Когда шаблоны впервые были введены в язык, они не были хорошо реализованы, а программисты и разработчики компиляторов не очень хорошо их понимали. В результате многие программисты, включая автора, избегали пользоваться обобщенным программированием на C++ в течение нескольких лет, пока эта технология не достигла зрелости.
   В настоящее время обобщенное программирование рассматривается как мощная и полезная парадигма программирования, которая поддерживается в большинстве популярных языков программирования. Более того, технология разработки компиляторов C++ очень сильно усовершенствовалась, и работа современных компиляторов с шаблонами стала гораздо более эффективной и стандартизованной. В результате современный C++ стал очень мощным языком программирования научных и численных приложении.
   11.1.Подсчет количества элементов в контейнереПроблема
   Требуется найти количество элементов в контейнере.Решение
   Подсчитать количество элементов в контейнере можно при помощи функции-членаsizeили функцииdistance,определенной в заголовочном файле&lt;algorithm&gt;,как это делается в примере 11.1.
   Пример 11.1. Подсчет количества элементов в контейнере
   #include&lt;algorithm&gt;
   #include&lt;iostream&gt;
   #include&lt;vector&gt;

   using namespace std;

   int main() {
    vector&lt;int&gt; v;
    v.push_back(0);
    v.push_back(1);
    v.push_back(2);
    cout&lt;&lt; v.size()&lt;&lt; endl;
    cout&lt;&lt; distance(v.begin(), v.end())&lt;&lt; endl;
   }
   Программа примера 11.1 выдает следующий результат.
   3
   3Обсуждение
   Функция-членsize,которая возвращает количество элементов стандартного контейнера, является наилучшим решением в тех случаях, когда доступен объект контейнера. В примере 11.1 я также продемонстрировал применение функцииdistance,потому что при написании обобщенного программного кода обычно имеешь дело только с парой итераторов. Работая с итераторами, вы часто не знаете тип контейнера и не имеете доступа к его функциям-членам.
   Функцияdistance,как и большинство алгоритмов STL, в действительности является шаблонной функцией. Поскольку тип аргумента шаблона может автоматически выводиться компилятором по аргументам функции, вам не надо его передавать как параметр шаблона. Конечно, при желании можно явно указать тип параметра шаблона, как это сделано ниже.
   cout&lt;&lt; distance&lt;vector&lt;int&gt;::iterator&gt;(v.begin(), v.end())&lt;&lt; endl;
   Производительность функцииdistanceзависит от типа используемого итератора. Время ее выполнения будет постоянным, если итератор ввода является итератором с произвольным доступом; в противном случае время ее работы будет линейным. (Концепция итератора рассматривается в рецепте 7.1.)Смотри также
   Рецепт 15.1.
   11.2.Поиск наибольшего или наименьшего значения в контейнереПроблема
   Требуется найти максимальное или минимальное значение в контейнере.Решение
   Пример 11.2 показывает, как можно находить максимальные и минимальные элементы контейнера с помощью функцийmax_elementиmin_element,определенных в заголовочном файле&lt;algorithm&gt;.Эти функции возвращают итераторы,. которые ссылаются на первый элемент, имеющий самое большое или самое маленькое значение соответственно.
   Пример 11.2. Поиск минимального или максимального элемента контейнера
   #include&lt;algorithm&gt;
   #include&lt;vector&gt;
   #include&lt;iostream&gt;

   using namespace std;

   int getMaxInt(vector&lt;int&gt;& v) {
    return *max_element(v.begin(), v.end());
   }

   int getMinInt(vector&lt;int&gt;& v) {
    return *min_element(v.begin(), v.end());
   }

   int main() {
    vector&lt;int&gt; v;
    for (int i=10; i&lt; 20; ++i) v.push_back(i);
    cout&lt;&lt; "min integer = "&lt;&lt; getMinInt(v)&lt;&lt; endl;
    cout&lt;&lt; "max integer = "&lt;&lt; getMaxInt(v)&lt;&lt; endl;
   }
   Программа примера 11.2 выдает следующий результат.
   min integer = 10
   max integer =19Обсуждение
   Вероятно, вы заметили, что выполняется разыменование значения, возвращаемого функциямиmin_elementиmax_element.Это делается по той причине, что указанные функции возвращают итераторы, а не сами значения, поэтому результат должен быть разыменован. Возможно, вы посчитаете, что такая операция разыменования создает небольшое неудобство, однако это позволяет избежать лишнего копирования возвращаемого значения. Это может быть особенно важно, когда копирование возвращаемого значения обходится дорого (например, если это большая строка).
   Обобщенные алгоритмы стандартной библиотеки, несомненно, достаточно полезны, однако более важно уметь самому писать свои собственные обобщенные функции получения минимального и максимального значения, находящегося в контейнере. Допустим, вам нужно иметь одну функцию, которая возвращает минимальные и максимальные значения, модифицируя переданные ей по ссылке параметры вместо возвращения пары значений или какой-нибудь другой структуры. В примере 11.3 продемонстрировано, как это можносделать.
   Пример 11.3. Обобщенная функция, возвращающая минимальное и максимальное значения
   #include&lt;algorithm&gt;
   #include&lt;vector&gt;
   #include&lt;iostream&gt;

   using namespace std;

   template&lt;class Iter_T, class Value_T&gt;
   void computeMinAndMax(Iter_T first, Iter_T last, Value_T& min, Value_T& max) {
    min = *min_element(first, last);
    max = *max_element(first, last);
   }

   int main() {
    vector&lt;int&gt; v;
    for (int i=10; i&lt; 20; ++i) v.push_back(i);
    int min = -1;
    int max = -1;
    computeMinAndMax(v.begin(), v.end(), min, max);
    cout&lt;&lt; "min integer = "&lt;&lt; min&lt;&lt; endl;
    cout&lt;&lt; "max integer = "&lt;&lt; max&lt;&lt; endl;
   }
   В примере 11.3 я написал шаблон функцииcomputeMinAndMax,которая принимает два параметра шаблона: один — это тип итератора, другой — тип минимальных и максимальных значений. Поскольку оба параметра шаблона являются также параметрами функции, компилятор C++ может догадаться, какие два отдельных типа (Iter_TиValue_T)используются, как это я продемонстрировал в рецепте 11.1. Это позволяет мне не указывать явно тип параметров шаблона, как это сделано ниже.
   compute_min_max&lt;vector&lt;int&gt;::iterator, int&gt;(...)
   При выполнении функцийmin_elementиmax_elementиспользуется операторoperator&lt;для сравнения значений, на которые ссылаются итераторы. Это значит, что, если итератор ссылается на тип, который не поддерживает этот тип сравнения, компилятор выдаст сообщение об ошибке. Однако функцииmin_elementиmax_elementможно также использовать с функтором сравнения, определенным пользователем, т.е. с указателем на функцию или с объектом-функцией.
   Для функцийmin_elementиmax_elementнеобходим специальный функтор, принимающий два значения (они имеют тип объектов, на которые ссылается итератор) и возвращающий значение типаBoolean,показывающее, является ли первое значение меньше, чем второе. Функтор, который возвращает значение типаBoolean,называется предикатом. Рассмотрим, например, поиск самого большого элемента в наборе пользовательских типов (пример 11.4).
   Пример 11.4. Поиск максимального элемента для пользовательских типов
   #include&lt;algorithm&gt;
   #include&lt;vector&gt;
   #include&lt;iostream&gt;

   using namespace std;

   struct Chessplayer {
    ChessPlayer(const char* name, int rating)
     : name_(name), rating_(rating) { }
    const char* name_;
    int rating_;
   };

   struct IsWeakerPlayer {
    bool operator()(const ChessPlayer& x, const ChessPlayer& y) {
    return x.rating_&lt; y.rating_;
   };

   int main() {
    ChessPlayer kasparov("Garry Kasparov", 2805);
    ChessPlayer anand("Viswanathan Anand", 2788);
    ChessPlayer topalov("Veselin Topalov", 2788);
    vector&lt;ChessPlayer&gt; v;
    v.push_back(kasparov);
    v.push_back(anand);
    v.push_hack(topalov);
    cout&lt;&lt; "the best player is ";
    cout&lt;&lt; max_element(v.begin(), v.end(), IsWeakerPlayer())-&gt;name_;
    cout&lt;&lt; endl;
   }
   Программа примера 11.4 выдает следующий результат.
   the best player is Garry Kasparov (лучший игрок - Гарри Каспаров)Функторы
   Многие STL-алгоритмы в качестве параметров используют определенные пользователем объекты-функции и указатели на функции. И те и другие называютсяфункторами (functors).Иногда в литературе термин «объект-функция» используется как синоним термина «функтор», однако я использую термин «объект-функция» для обозначения только экземпляров класса или структур, которые перегружаютoperator().Какой из двух типов функторов лучше использовать? В большинстве случаев объект-функция более эффективен, потому что большинство компиляторов могут легко его реализовать в виде встроенной функции.
   Другая причина применения объекта-функции заключается в том, что он может иметь состояние. Вы можете передавать значения его конструктору, который их сохраняет в соответствующих полях для последующего использования. По выразительным возможностям эти объекты-функции становятся сопоставимы с концепцией замыканий, которая используется в других языках программирования.
   Наконец, объекты-функции могут определяться внутри другой функции или класса. Указатели на функции приходится объявлять в области видимости пространства имен.
   В примере 11.4 я показал, как в функцииmax_elementможно использовать пользовательский предикат. Этот предикат является объектом-функциейIsWeakerPlayer.
   Альтернативой пользовательскому предикату, показанному в примере 11.4, является перегрузка оператораoperator&lt;для структурыChessPlayer.Это хорошо работает в определенных случаях, но предполагает, что самой важной является сортировка игроков по рейтингу. Может оказаться, что более распространенной является сортировка по именам. Поскольку в данном случае выбор метода сортировки может быть произвольным, я предпочитаю не определять операторoperator&lt;.
   11.3.Вычисление суммы и среднего значения элементов контейнераПроблема
   Требуется вычислить сумму и среднее значение чисел, содержащихся в контейнере.Решение
   Для расчета суммы можно использовать функциюaccumulateиз заголовочного файла&lt;numeric&gt;и затем разделить ее на количество элементов, получая среднее значение. Пример 11.5 демонстрирует, как это можно сделать, используя вектор.
   Пример 11.5. Вычисление суммы и среднего значения элементов контейнера
   #include&lt;numeric&gt;
   #include&lt;iostream&gt;
   #include&lt;vector&gt;

   using namespace std;

   int main() {
    vector&lt;int&gt; v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    int sum = accumulate(v.begin(), v.end(), 0);
    double mean = double(sum) / v.size();
    cout&lt;&lt; "sum = "&lt;&lt; sum&lt;&lt; endl;
    cout&lt;&lt; "count = "&lt;&lt; v.size()&lt;&lt; endl;
    cout&lt;&lt; "mean = "&lt;&lt; mean&lt;&lt; endl;
   }
   Программа примера 11.5 выдает следующий результат.
   sum = 10
   count = 4
   mean = 2.5Обсуждение
   Как правило, функцияaccumulateобеспечивает самый эффективный и самый простой способ вычисления суммы всех элементов, содержащихся в контейнере.
   Несмотря на то что данный рецепт имеет относительно простое решение, не так уж просто написать свою собственную обобщенную функцию по расчету среднего значения. Впримере 11.6 показан один из способов написания такой обобщенной функции.
   Пример 11.6. Обобщенная функция по расчету среднего значения
   template&lt;class Iter_T&gt;
   double computeMean(Iter_T first, Iter_T last) {
    return static_cast&lt;double&gt;(accumulate(first, last, 0.0))
     / distance(first, last);
   }
   ФункцияcomputeMeanиз примера 11.6 подойдет в большинстве случаев, но она имеет одно ограничение: не работает она с такими итераторами ввода, какistream_iterator.Итераторы istream_iterator и ostream_iterator
   Шаблоны классовistream_iteratorиostream_iteratorпредставляют собой специализированные итераторы, определенные в заголовочном файле&lt;iterator&gt;которые позволяют рассматривать потоки как однопроходные контейнеры.
   istream_iteratorявляется итератором ввода, который выступает в роли оболочки такого потока ввода, какcinилиifstream,позволяя использовать его в качестве параметра во многих обобщенных функциях.ostream_iteratorявляется итератором вывода, который позволяет использовать потоки вывода, как будто они являются контейнерами. Использование итераторовistream_iteratorиostream_iteratorявляется хорошей привычкой, так как с их помощью легче создавать повторно используемый программный код
   Итераторistream_iteratorпозволяет выполнить только один проход по данным, поэтому вы можете вызвать либоaccumulate,либоdistance,но если вы вызываете обе функции, данные становятся недействительными, и всякая последующая попытка их просмотра, вероятно, приведет к неудаче. Пример 11.7 показывает, как можно написать более обобщенную функцию по расчету среднего значения за один проход последовательности чисел.
   Пример 11.7. Более обобщенная функция по расчету среднего значения
   #include&lt;stdexcept&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;

   using namespace std;

   template&lt;class Value_T, class Iter_T&gt;
   Value_T computeMean(Iter_T first, Iter_T last) {
    if (first == last) throw domain_error("mean is undefined");
    Value_T sum;
    int cnt = 0;
    while (first != last) {
     sum += *first++;
     ++cnt;
    }
    return sum / cnt;
   )

   int main() {
    cout&lt;&lt; "please type in several integers separated by newlines"&lt;&lt; endl;
    cout&lt;&lt; "and terminated by an EOF character (i.e , Ctrl-Z)"&lt;&lt; endl;
    double mean = computeMean&lt;double&gt;(
     istream_iterator&lt;int&gt;(cin), istream_iterator&lt;int&gt;());
    cout&lt;&lt; "the mean is "&lt;&lt; mean&lt;&lt; endl;
   }
   При написании обобщенного программного кода следует, по мере возможности, пытаться пользоваться наиболее общим типом итератора. Это подразумевает, что, когда возможно, вы должны стараться писать обобщенные алгоритмы с единственным проходом по потоку ввода. При таком подходе ваш обобщенный программный код не ограничиваетсятолько контейнерами, а может также использоваться с такими итераторами ввода, какistream_iterator.Кроме того, алгоритмы с единственным проходом часто более эффективны.
   Возможно, вас удивляет то, что я решил тип, возвращаемый функциейcomputeMeanиз примера 11.7, передать в качестве параметра шаблона, а не выводить его из типа итератора. Это сделано по той причине, что обычно статистические расчеты выполняются с более высокой точностью, чем точность значений, содержащихся в контейнере. Так, в программном коде примера 11.7 возвращаемое среднее значение набора чисел целого типа имеет типdouble.
   11.4.Фильтрация значений, выпадающих из заданного диапазонаПроблема
   Требуется проигнорировать содержащиеся в последовательности значения, которые располагаются ниже или выше заданного диапазона.Решение
   Используйте функциюremove_copy_if,определенную в&lt;algorithm&gt;,как показано в примере 11.8.
   Пример 11.8 Удаление из последовательности элементов, значения которых меньше заданного
   #include&lt;algorithm&gt;
   #include&lt;vector&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;

   using namespace std;

   struct OutOfRange {
    OutOfRange(int min, int max) :
     min_(min), max_(max) {}

    bool operator()(int x) {
     return (x&lt; min_) || (x&gt; max_);
    }
    int min_;
    int max_;
   };

   int main() {
    vector&lt;int&gt; v;
    v.push_back(6);
    v.push_back(12);
    v.push_back(10);
    v.push_back(24);
    v.push_back(30);
    remove_copy_if(v.begin(), v.end(),
    ostream_iterator&lt;int&gt;(cout, "\n"), OutOfRange(10, 25));
   }
   Программа примера 11.8 выдает следующий результат.
   12
   18
   24Обсуждение
   Функцияremove_copy_ifкопирует элементы из одного контейнера в другой контейнер (или итератор вывода), игнорируя те элементы, которые удовлетворяют предоставленному вами предикату (вероятно, было бы более правильно назвать функциюcopy_ignore_if).Однако эта функция не изменяет размер целевого контейнера. Если (как часто бывает) количество скопированных функциейremove_copy_ifэлементов меньше, чем размер целевого контейнера, вам придется уменьшить целевой контейнер с помощью функции-членаerase.
   Для функцииremove_copy_ifтребуется унарный предикат (функтор, который принимает один аргумент и возвращает значение типаboolean),который возвращает значение «истина», когда элемент не должен копироваться. В примере 11.8 предикатом является объект-функцияOutOfRange.КонструкторOutOfRangeпринимает нижнюю и верхнюю границу и перегружает операторoperator().Функцияoperator()принимает параметр целого типа и возвращает значение «истина», если переданный аргумент меньше, чем нижняя граница, или больше, чем верхняя граница.
   11.5.Вычисление дисперсии, стандартного отклонения и других статистических функцийПроблема
   Требуется рассчитать значение одной или нескольких обычных статистических функций, например дисперсии (variance), стандартного отклонения (standard deviation), коэффициента асимметрии (skew) и эксцесса (kurtosis) для последовательности чисел.Решение
   Функциюaccumulateиз заголовочного файла&lt;numeric&gt;можно использовать для расчета многих статистических параметров, а не только для суммирования пользовательских объектов-функций. Пример 11.9 показывает, как можно вычислить значения некоторых важных статистические функций при помощиaccumulate.
   Пример 11.9. Статистические функции
   #include&lt;numeric&gt;
   #include&lt;cmath&gt;
   #include&lt;algorithm&gt;
   #include&lt;functional&gt;
   #include&lt;vector&gt;
   #include&lt;iostream&gt;

   using namespace std;

   template&lt;int N, class T&gt;
   T nthPnwer(T x) {
    T ret = x;
    for (int i=1; i&lt; N; ++i) {
     ret *= x;
    }
    return ret;
   }

   template&lt;class T, int N&gt;
   struct SumDiffNthPower {
    SumDiffNthPower(T x) : mean_(x) {};
    T operator()(T sum, T current) {
     return sum + nthPower&lt;N&gt;(current - mean_);
    }
    T mean_;
   };

   template&lt;class T, int N, class Iter_T&gt;
   T nthMoment(Iter_T first, Iter_T last, T mean) {
    size_t cnt = distance(first, last);
    return accumulate(first, last, T(), SumDiffNthPower&lt;T, N&gt;(mean)) / cnt;
   }

   template&lt;class T, class Iter_T&gt;
   T computeVariance(Iter_T first, Iter_T last, T mean) {
    return nthMoment&lt;T, 2&gt;(first, last, mean);
   }

   template&lt;class T, class Iter_T&gt;
   T computeStdDev(Iter_T first, Iter_T last, T mean) {
    return sqrt(computeVariance(first, last, mean));
   }

   template&lt;class T, class Iter_T&gt;
   T computeSkew(Iter_T begin, Iter_T end, T mean) {
    T m3 = nthMoment&lt;T, 3&gt;(begin, end, mean);
    T m2 = nthMoment&lt;T, 2&gt;(begin, end, mean);
    return m3 / (m2 * sqrt(m2));
   }

   template&lt;class T, class Iter_T&gt;
   T computeKurtosisExcess(Iter_T begin, Iter_T end, T mean) {
    T m4 = nthMoment&lt;T, 4&gt;(begin, end, mean);
    T m2 = nthMoment&lt;T, 2&gt;(begin, end, mean);
    return m4 / (m2 * m2) - 3;
   }

   template&lt;class T, class Iter_T&gt;
   void computeStats(Iter_T first, Iter_T last, T& sum, T& mean,
    T& var, T& std_dev, T& skew, T& kurt) {
    size_t cnt = distance(first, last);
    sum = accumulate(first, last, T());
    mean = sum / cnt;
    var = computeVariance(first, last, mean);
    std_dev = sort(var);
    skew = computeSkew(first, last, mean);
    kurt = computeKurtosisExcess(first, last, mean);
   }

   int main() {
    vector&lt;int&gt; v;
    v.push_back(2);
    v.push_back(4);
    v.push_back(8);
    v.push_back(10);
    v.push_back(99);
    v.push_back(1);
    double sum, mean, var, dev, skew, kurt;
    computeStats(v.begin(), v.end(), sum, mean, var, dev, skew, kurt);
    cout&lt;&lt; "count = "&lt;&lt; v.size()&lt;&lt; "\n";
    cout&lt;&lt; "sum = "&lt;&lt; sum&lt;&lt; "\n";
    cout&lt;&lt; "mean = "&lt;&lt; mean&lt;&lt; "\n";
    cout&lt;&lt; "variance = "&lt;&lt; var&lt;&lt; "\n";
    cout&lt;&lt; "standard deviation = "&lt;&lt; dev&lt;&lt; "\n";
    cout&lt;&lt; "skew = "&lt;&lt; skew&lt;&lt; "\n";
    cout&lt;&lt; "kurtosis excess = "&lt;&lt; kurt&lt;&lt; "\n";
    cout&lt;&lt; endl;
   }
   Программа примера 11.9 выдает следующий результат
   count = 6
   sum = 124
   mean = 20.6667
   variance = 1237.22
   standard deviation = 35.1742
   skew = 1.75664
   kurtosis excess = 1.14171Обсуждение
   Некоторые наиболее важные статистические функции (например, дисперсия, стандартное отклонение, коэффициент асимметрии и эксцесс) определяются исходя из нормализованных выборочных моментов. Статистические функции определяются немного по-разному в различных текстах. Здесь мы используем несмещенные определения статистических функций, которые сведены в табл. 11.1.

   Табл. 11.1. Определения статистических функцийСтатистическая функцияФормулаn-й центральный момент (?n)?(xi-mean)nДисперсия?2Стандартное отклонение??2Коэффициент асимметрии?2/?33/2Эксцесс(?4/?2?)-3
    [Картинка: tip_yellow.png] Моментхарактеризует последовательность чисел. Другими словами, он определяет некий способ математического описания последовательности чисел. Моменты являются основой для расчета нескольких важных статистических функций, например дисперсии, стандартного отклонения, коэффициента асимметрии и эксцесса.Центральный момент— это момент, рассчитанный относительно среднего значения, а не нуля.Выборочный момент— это момент, рассчитанный для дискретного набора числовых значений, а не для всех значений функции.Нормализованный момент— это момент, поделенный на некоторую степень стандартного отклонения (стандартное отклонение рассчитывается как квадратный корень второго момента).
   Проще всего программировать статистические функции, определяя их через моменты. Поскольку используется несколько различных моментов, каждый из которых характеризуется целочисленной константой, я передаю эту константу как параметр шаблона. Это в целом позволяет компилятору генерировать более эффективный программный код, потому что это целочисленное значение известно на этапе компиляции.
   Функция момента определяется при помощи математического оператора суммы. Во всех случаях, когда речь идет об этом операторе, следует иметь в виду функциюaccumulate,определенную в заголовочном файле&lt;numeric&gt;.Существует две разновидности функцииaccumulate:одна подсчитывает сумму, используяoperator+,а другая использует функтор суммирования, который вы должны предоставить. Ваш функтор суммирования будет принимать значение накопленной суммы и значение конкретного элемента последовательности.
   Пример 11.10 иллюстрирует работу функцииaccumulate,показывая, как предоставленный пользователем функтор вызывается для каждого элемента последовательности.
   Пример 11.10. Пример реализации функции accumulate
   template&lt;class Iter_T, class Value_T, class BinOp_T&gt;
   Iter_T accumulate(Iter_T begin, Iter_T end, Value_T value, BinOp_T op) {
    while (begin != end) {
     value = op(value, *begin++)
    }
    return value;
   }
   11.6.Генерация случайных чиселПроблема
   Требуется сгенерировать несколько случайных чисел в формате с плавающей точкой в интервале значений[0.0, 1.0)при равномерном их распределении.Решение
   Стандарт C++ предусматривает наличие C-функции библиотеки этапа исполненияrand,определенной в заголовочном файле&lt;cstdlib&gt;,которая возвращает случайное число в диапазоне от 0 доRAND_MAXвключительно. МакропеременнаяRAND_MAXпредставляет собой максимальное значение, которое может быть возвращено функциейrand.Пример 11.11 демонстрирует применение функцииrandдля генерации случайных чисел с плавающей точкой.
   Пример 11.11. Генерация случайных чисел функцией rand
   #include&lt;cstdlib&gt;
   #include&lt;ctime&gt;
   #include&lt;iostream&gt;

   using namespace std;

   double doubleRand() {
    return double(rand()) / (double(RAND_MAX) + 1.0);
   }

   int main() {
    srand(static_cast&lt;unsigned int&gt;(clock()));
    cout&lt;&lt; "expect 5 numbers within the interval [0.0, 1.0)"&lt;&lt; endl;
    for (int i=0; i&lt; 5; i++) {
     cout&lt;&lt; doubleRand()&lt;&lt; "\n";
    }
    cout&lt;&lt; endl;
   }
   Программа примера 11.11 должна выдать результат, подобный следующему.
   expect 5 numbers within the interval [0.0, 1.0)
   0.010437
   0.740997
   0.34906
   0.369293
   0.544373Обсуждение
   Необходимо уточнить, что функции, генерирующие случайные числа (в том числеrand),возвращают псевдослучайные числа, а не реальные случайные числа, поэтому там, где я говорю «случайное число», я на самом деле имею в виду псевдослучайное число.
   Перед применением функцииrandвы должны «посеять» (т.е. инициализировать) генератор случайных чисел с помощью вызова функцииsrand.Это обеспечивает генерацию последующими вызовамиrandразных последовательностей чисел при каждом новом исполнении программы. Проще всего инициализировать генератор случайных чисел путем передачи ему результата вызова функцииclockиз заголовочного файла&lt;ctime&gt;,имеющего типunsigned int.Повторная инициализация генератора случайных чисел приводит к тому, что генерируемые числа становятся менее случайными.
   Функцияrandимеет много ограничений. Прежде всего, она генерирует только целые числа, и эти числа могут иметь только равномерное распределение. Более того, конкретный алгоритм генерации случайных чисел зависит от реализации, и поэтому последовательности случайных чисел нельзя воспроизвести при переходе от одной системы к другой при одинаковой инициализации. Это создает трудности для определенного типа приложений, а также при тестировании и отладке.
   Значительно более изощренную альтернативуrandпредставляет написанная Джензом Маурером (Jens Maurer) библиотека Boost Random; она была инспирирована предложениями по генерации случайных чисел, представленными в TR1.
    [Картинка: tip_yellow.png] TR1означает «Technical Report One» и представляет собой официальный проект по расширению стандартной библиотеки C++98.
   Библиотека Boost Random содержит несколько высококачественных функций по генерации случайных чисел как для целых типов, так и для типов с плавающей точкой, причем с поддержкой многочисленных распределений. Пример 11.12 показывает, как можно сгенерировать случайные числа с плавающей точкой в интервале значений[0,1).
   Пример 11.12. Использование библиотеки Boost Random
   #include&lt;boost/random.hpp&gt;
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;

   using namespace std;
   using namespace boost;

   typedef boost::mt19937 BaseGenerator;
   typedef boost::uniform_real&lt;double&gt; Distribution;
   typedef boost::variate_generator&lt;BaseGenerator, Distribution&gt; Generator;

   double boostDoubleRand() {
    static BaseGenerator base;
    static Distribution dist;
    static Generator rng(base, dist);
    return rng();
   }

   int main() {
    cout&lt;&lt; "expect 5 numbers within the interval [0.1)"&lt;&lt; endl;
    for (int i=0; i&lt; 5; i++) {
     cout&lt;&lt; boostDoubleRand()&lt;&lt; "\n";
    }
    cout&lt;&lt; endl;
   }
   Основное преимущество библиотеки Boost Random в том, что алгоритм генерации псевдослучайных чисел обеспечивает гарантированные и воспроизводимые свойства случайных последовательностей, зависящих от выбранного алгоритма. В примере 11.12 я использую генератор Mersenne Twister (mt19937),потому что он дает хорошее сочетание производительности и качества последовательности случайных чисел.
   11.7.Инициализация контейнера случайными числамиПроблема
   Требуется заполнить произвольный контейнер случайными числами.Решение
   Можно использовать функцииgenerateиgenerate_nиз заголовочного файла&lt;algorithm&gt;совместно с функтором, возвращающим случайные числа. Пример 11.13 показывает, как это можно сделать.
   Пример 11.13. Инициализация контейнеров случайными числами
   #include&lt;algorithm&gt;
   #include&lt;vector&gt;
   #include&lt;iterator&gt;
   #include&lt;iostream&gt;
   #include&lt;cstdlib&gt;

   using namespace std;

   struct RndIntGen {
    RndIntGen(int l, int h) : low(l), high(h) {}
    int operator()() const {
     return low + (rand() % ((high - low) + 1));
    }
   private:
    int low;
    int high;
   };

   int main() {
    srand(static_cast&lt;unsigned int&gt;(clock()));
    vector&lt;mt&gt; v(5);
    generate(v.begin(), v.end(), RndIntGen(1, 6));
    copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, "\n"));
   }
   Программа примера 11.13 должна выдать результат, подобный следующему.
   3
   1
   2
   6
   4Обсуждение
   Стандартная библиотека C++ содержит функцииgenerateиgenerate_n,специально предназначенные для заполнения контейнеров значениями, полученными функцией генератора случайных чисел. Эти функции принимают нуль-арный функтор (указатель на функцию или объект-функцию без аргументов), результат которого присваивается соседним элементам контейнера. Пример реализации функцииgenerateиgenerate_nпоказан в примере 11.14.
   Пример 11.14. Пример реализации функций generate и generate_n
   template&lt;class Iter_T, class Fxn_T&gt;
   void generate(Iter_T first, Iter_T last, Fxn_T f) {
    while (first != last) *first++ = f();
   }

   template&lt;class Iter_T, class Fxn_T&gt;
   void generate_n(Iter_T first, int n, Fxn_T f) {
    for (int i=0; i&lt; n; ++i) *first++ = f();
   }
   11.8.Представление динамического числового вектораПроблема
   Требуется иметь тип для манипулирования динамическими числовыми векторами.Решение
   Вы можете использовать шаблонvalarrayиз заголовочного файла&lt;valarray&gt;.Пример 11.15 показывает, как можно использовать шаблонvalarray.
   Пример 11.15. Применение шаблона valarray
   #include&lt;valarray&gt;
   #include&lt;iostream&gt;

   using namespace std;

   int main() {
    valarray&lt;int&gt; v(3);
    v[0] = 1;
    v[1] = 2;
    v[2] = 3;
    cout&lt;&lt; v[0]&lt;&lt; ", "&lt;&lt; v[1]&lt;&lt; ", "&lt;&lt; v[2]&lt;&lt; endl;
    v = v + v;
    cout&lt;&lt; v[0]&lt;&lt; ", "&lt;&lt; v[1]&lt;&lt; ", "&lt;&lt; v[2]&lt;&lt; endl;
    v /= 2;
    cout&lt;&lt; v[0]&lt;&lt; ", "&lt;&lt; v[1]&lt;&lt; ", "&lt;&lt; v[2]&lt;&lt; endl;
   }
   Программа примера 11.15 выдаст следующий результат.
   1, 2, 3
   2, 4, 6
   1, 2, 3Обсуждение
   Вопреки своему названию типvectorне предназначен для использования в качестве числового вектора, для этой цели используется шаблонvalarray.Этот шаблон написан так, чтобы в конкретных реализациях С++, особенно на высокопроизводительных машинах, можно было применить к нему специальную векторную оптимизацию. Другое большое преимуществоvalarrayсостоит в наличии многочисленных перегруженных операторов, предназначенных для работы с числовыми векторами. Эти операторы обеспечивают выполнение таких операций, как сложение и скалярное умножение векторов.
   Шаблонvalarrayможет также использоваться в стандартных алгоритмах, работающих с массивами, представленными в C-стиле. Пример 11.16 показывает, как можно создавать итераторы, ссылающиеся на начальный элементvalarrayи на элемент, следующий за последним.
   Пример 11.16. Получение итераторов для valarray
   template&lt;class T&gt;
   T* valarray_begin(valarray&lt;T&gt;& x) {
    return&x[0];
   }

   template&lt;class T&gt; T* valarray_end(valarray&lt;T&gt;& x) {
    return valarray_begin(x) + x.size();
   }
   Несмотря на немного академичный вид этого примера, не следует пытаться создавать итератор концаvalarray,используя выражение&x[х.size()].Если это сработает, то только случайно, поскольку индексацияvalarray,выходящая за допустимый индексный диапазон, приводит к непредсказуемому результату.
   Отсутствие вvalarrayфункций-членовbeginиend,несомненно, противоречит стилю STL. Отсутствие этих функций подчеркивает то, что вvalarrayреализуется модель, отличная от концепции контейнера STL. Несмотря на это, вы можете использоватьvalarrayв любом обобщенном алгоритме, где требуется итератор с произвольным доступом.
   11.9.Представление числового вектора фиксированного размераПроблема
   Требуется иметь эффективное представление числовых векторов фиксированного размера.Решение
   В программном обеспечении обычного типа часто более эффектный результат по сравнению сvalarrayдает применение специальной реализации вектора, когда его размер заранее известен на этапе компиляции. Пример 11.17 показывает, как можно реализовать шаблон вектора фиксированного размера, названный здесьkvector.
   Пример 11.17. kvector.hpp
   #include&lt;algorithm&gt;
   #include&lt;cassert&gt;

   template&lt;class Value_T, unsigned int N&gt;
   class kvector {
   public:
    // открытые поля
    Value_T m[N];

    // открытые имена, вводимые typedef
    typedef Value_T value_type;
    typedef Value_T* iterator;
    typedef const Value_T* const_iterator;
    typedef Value_T& reference;
    typedef const Value_T& const_reference;
    typedef size_t size_type;

    // определение более короткого синонима для kvector
    typedef kvector self;

    // функции-члены
    template&lt;typename Iter_T&gt;
    void copy(Iter_T first, Iter_T last) {
     copy(first, last, begin());
    }
    iterator begin() { return m; }
    iterator end() { return m + N; }
    const_iterator begin() const { return m; }
    const_iterator end() const { return m + N; }
    reference operator[](size_type n) { return m[n]; }
    const_reference operator[](size_type n) const { return m[n]; }
    static size_type size() { return N; }

    // векторные операции
    self& operator+=(const self& x) {
     for (int i=0; i&lt;N; ++i) m[i] += x.m[i];
     return *this;
    }
    self& operator-=(const self& x) {
     for (int i=0; i&lt;N; ++i) m[i] -= x.m[i];
     return *this;
    }

    // скалярные операции
    self& operator=(value_type x) {
     std::fill(begin(), end(), x);
     return *this;
    }
    self& operator+=(value_type x) {
     for (int i=0; i&lt;N; ++i) m[i] += x;
     return *this;
    }
    self& operator-=(value_type x) {
     for (int i=0; i&lt;N; ++i) m[i] -= x;
     return *this;
    }
    self& operator*=(value_type x) {
     for (int i=0; i&lt;N; ++i) m[i] *= x;
     return *this;
    }
    self& operator/=(value_type x) {
     for (int i=0; i&lt;N; ++i) m[i] /= x;
     return *this;
    }
    self& operator%=(value_type x) {
     for (int i=0; i&lt;N; ++i) m[i] %= x;
     return *this;
    }
    self operator-() {
     self x;
     for (int i=n; i&lt;N; ++i) x.m[i] = -m[i];
     return x;
    }

    // дружественные операторы
    friend self operator+(self x, const self& y) { return x +=у; }
    friend self operator-(self x, const self& y) { return x -= y; }
    friend self operator+(self x, value_type y) { return x += y; }
    friend self operator-(self x, value_type y) { return x -= y; }
    friend self operator*(self x, value_type y) { return x *= y; }
    friend self operator/(self x, value_type y) { return x /= y; }
    friend self operator%(self x, value type y) { return x %= y; }
   };
   Пример 11.18 показывает, как можно применять шаблон классаkvector.
   Пример 11.18. Применение вектора kvector
   #include "kvector.hpp"
   #include&lt;algorithm&gt;
   #include&lt;numeric&gt;
   #include&lt;iostream&gt;

   using namespace std;

   int main() {
    kvector&lt;int, 4&gt; v = { 1, 2, 3, 4 };
    cout&lt;&lt; "sum = "&lt;&lt; accumulate(v.begin(), v.end(), 0)&lt;&lt; endl;
    v *= 3;
    cout&lt;&lt; "sum = "&lt;&lt; accumulated.begin(), v.end(), 0)&lt;&lt; endl;
    v += 1;
    cout&lt;&lt; "sum = "&lt;&lt; accumulate(v.begin(), v.end(), 0)&lt;&lt; endl;
   }
   Программа примера 11.18 выдаст следующий результат.
   sum = 10
   sum = 30
   sum = 34Обсуждение
   Представленный в примере 11.17 шаблонkvectorявляется гибридомvalarrayи шаблона массива, предложенного в TR1. Как иvalarray,векторkvectorпредставляет собой последовательность значений заданного числового типа, однако подобно массивуTR1::arrayего размер известен на этапе компиляции.
   Характерной особенностью шаблонаkvectorявляется то, что для его инициализации может использоваться синтаксис, применяемый для массивов, и то, что он имеет функции-членыbeginиend.Фактическиkvectorможно рассматривать как псевдоконтейнер, т.е. он удовлетворяет некоторым, но не всем требованиям концепции стандартного контейнера. Следствие этого — более легкое применениеkvectorв стандартных алгоритмах по сравнению сvalarray.
   Другое преимущество шаблонного классаkvectorсостоит в том, что он поддерживает синтаксис, используемый при инициализации массивов.
   int x;
   kvector&lt;int, 3&gt; k = { x = 1, x+2, 5}
   Этот синтаксис возможен только потому, чтоkvectorявляется агрегатом.Агрегат (aggregate) — это массив или класс, который не имеет объявленных пользователем конструкторов, закрытых или защищенных данных-членов, базового класса и виртуальных функций. Следует отметить, что все же можно при объявленииkvectorего заполнить значениями по умолчанию.
   kvector&lt;int, 3&gt; k = {};
   В результате этот вектор будет заполнен нулями.
   Как вы видите, при его реализации мной был найден компромисс между полным удовлетворением требований, предъявляемых к стандартным контейнерам, и возможностью использования синтаксиса, применяемого при инициализации массивов. Аналогичный компромисс был найден при проектировании шаблонаarray,удовлетворяющего требованиям TR1.
   Возможно, самое большое преимуществоkvectorнад реализациями динамического вектора проявляется в его высокой производительности. По двум причинам шаблон kvector значительно эффективнее, чем большинство реализаций динамическихвекторов:компиляторы очень хорошо справляются с оптимизацией циклов фиксированною размера, и здесь нет динамического распределения памяти. Различия в производительностиособенно проявляются при работе с небольшими матрицами (например, 2x2или 3x3),которые часто встречаются во многих приложениях.Что означает имя «self», введенное оператором typedef?
   Введенное с помощью typedef имяselfя использую в примере 11.17 и в последующих примерах; оно представляет собой удобное краткое имя, которое я использую для ссылки на тип текущего класса. Программу значительно легче писать и воспринимать при использовании self вместо имени класса.
   11.10.Вычисление скалярного произведенияПроблема
   Имеется два контейнера, содержащих числа, причем они имеют одинаковую длину, и требуется вычислить их скалярное произведение.Решение
   Пример 11.19 показывает, как можно вычислить скалярное произведение, используя функциюinner_productиз заголовочного файла&lt;numeric&gt;.
   Пример 11.19. Расчет скалярного произведения
   #include&lt;numeric&gt;
   #include&lt;iostream&gt;
   #include&lt;vector&gt;

   using namespace std;

   int main() {
    int v1[] = { 1, 2, 3 };
    int v2[] = { 4, 6, 8 };
    cout&lt;&lt; "the dot product of (1,2,3) and (4,6,8) is ";
    cout&lt;&lt; inner_product(v1, v1 + 3, v2, 0)&lt;&lt; endl;
   }
   Программа примера 11.19 выдает следующий результат.
   the dot product of (1,2,3) and (4,6,8) is 40Обсуждение
   Скалярное произведение (dot product) является одной из форм обобщенного скалярного произведения (inner product), называемой евклидовым скалярным произведением (Euclidean Inner Product). Функцияinner_productобъявляется следующим образом.
   template&lt;class In, class In2, class T&gt;
   T inner_product(In first, In last, In2 first2, T init);
   template&lt;class In, class In2, class T, class BinOp, class BinOp2&gt;
   T inner_product(In first, In last, In2 first2, T init, BinOp op, BinOp2 op2);
   Первый вариант функцииinner_productсуммирует произведения соответствующих элементов двух контейнеров. Второй вариант функцииinner_productпозволяет вам самому предоставить операцию над парой чисел и функцию суммирования. В примере 11.20 продемонстрирована простая реализация функцииinner_product.
   Пример 11.20. Пример реализации функции inner_product()
   template&lt;class In, class In2, class T, class BinOp, class BinOp2&gt;
   T inner_product(In first, In last, In2 first2, T init, BinOp op, Binop2 op2) {
    while (first != last) {
     BinOp(init, BinOp2(*first++, *first2++));
    }
    return init;
   }
   Благодаря гибкости реализации функцииinner_productвы можете ее использовать для многих других целей, а не только для расчета скалярного произведения (например, ее можно использовать для вычисления расстояния между двумя векторами или для вычисления нормы вектора).Смотри также
   Рецепты 11.11 и 11.12.
   11.11.Вычисление нормы вектораПроблема
   Требуется найти норму (т. е. длину) числового вектора.Решение
   Можно использовать функциюinner_productиз заголовочного файла&lt;numeric&gt;для умножения вектора на самого себя, как показано в примере 11.21.
   Пример 11.21. Вычисление нормы вектора
   #include&lt;numeric&gt;
   #include&lt;vector&gt;
   #include&lt;cmath&gt;
   #include&lt;iostream&gt;

   using namespace std;

   template&lt;typename Iter_T&gt;
   long double vectorNorm(Iter_T first, Iter_T last) {
    return sqrt(inner_product(first, last, first, 0.0L));
   }

   int main() {
    int v[] = { 3, 4 };
    cout&lt;&lt; "The length of the vector (3.4) is ";
    cout&lt;&lt; vectorNorm(v, v + 2)&lt;&lt; endl;
   }
   Программа примера 11.21 выдает следующий результат.
   The length of the vector (3,4) is 5Обсуждение
   В примере 11.21 функцияinner_productиз заголовочного файла&lt;numeric&gt;используется для вычисления скалярного произведения числового вектора на самого себя. Квадратный корень полученного значения, как известно, является нормой вектора, или длиной вектора.
   Вместо того чтобы в функцииvectorNormвыводить тип результата по аргументам, я решил для него использовать типlong double,чтобы терять как можно меньше данных. Если вектор представляет собой набор значений целого типа, маловероятно, что в реальных условиях норма вектора может быть адекватно представлена целым типом.
   11.12.Вычисление расстояния между векторамиПроблема
   Требуется найти евклидово расстояние между векторами.Решение
   Евклидово расстояние между векторами определяется как квадратный корень суммы квадратов разностей соответствующих элементов. Рассчитать его можно так, как показано в примере 11.22.
   Пример 11.22. Расчет расстояния между двумя векторами
   #include&lt;cmath&gt;
   #include&lt;iostream&gt;

   using namespace std;

   template&lt;class Iter_T, class Iter2_T&gt;
   double vectorDistance(Iter_T first, Iter_T last, Iter2_T first2) {
    double ret = 0.0;
    while (first != last) {
     double dist = (*first++) - (*first2++);
     ret += dist * dist;
    }
    return ret&gt; 0.0 ? sqrt(ret) : 0.0;
   }

   int main() {
    int v1[] = { 1, 5 };
    int v2[] = { 4, 9 };
    cout&lt;&lt; "distance between vectors (1,5) and (4,9) is ";
    cout&lt;&lt; vectorDistance(v1, v1 + 2, v2)&lt;&lt; endl;
   }
   Программа примера 11.22 выдает следующий результат.
   distance between vectors (1,5) and (4,9) is 5Обсуждение
   Пример 11.22 реализует прямое решение, которое показывает, как следует писать простую обобщенную функцию в стиле STL. Для расчета расстояний между векторами я мог бы использовать функциюinner_product,однако я не стал использовать функтор, потому что это неоправданно усложнило бы решение. Пример 11.23 показывает, как можно рассчитывать расстояние между векторами,применяя функтор и функциюinner_productиз заголовочного файла&lt;numeric&gt;.
   Пример 11.23. Расчет расстояния между векторами с использованием функции inner_product
   #include&lt;numeric&gt;
   #include&lt;cmath&gt;
   #include&lt;iostream&gt;
   #include&lt;functional&gt;

   using namespace std;

   template&lt;class Value_T&gt;
   struct DiffSquared {
    Value_T operator()(Value_T x, Value_T y) const {
     return (x - y) * (x - y);
    }
   };

   template&lt;class Iter_T, class Iter2_T&gt;
   double vectorDistance(Iter_T first, Iter_T last, Iter2_T first2) {
    double ret = inner_product(first, last, first2, 0.0L,
     plus&lt;double&gt;(), DiffSquared&lt;double&gt;());
    return ret&gt; 0.0 ? sqrt(ret) : 0.0;
   }

   int main() {
    int v1[] = { 1, 5 };
    int v2[] = { 4, 9 };
    cout&lt;&lt; "distance between vectors (1,5) and (4,9) is ";
    cout&lt;&lt; vectorDistance(v1, v1 + 2, v2)&lt;&lt; endl;
   }
   Поскольку реализация функцииinner_product()может быть специально оптимизирована для вашей платформы и вашего компилятора, я предпочитаю ее использовать везде, где это возможно.
   11.13.Реализация итератора с шагомПроблема
   Имеются смежные числовые ряды и требуется обеспечить доступ к каждому n-му элементу.Решение
   В примере 11.24 представлен заголовочный файл, реализующий класс итератора с шагом.
   Пример 11.24. stride_iter.hpp
   #ifndef STRIDE_ITER_HPP
   #define STRIDE_ITER_HPP

   #include&lt;iterator&gt;
   #include&lt;cassert&gt;

   template&lt;class Iter_T&gt;
   class stride_iter {
   public:

    // открытые имена, вводимые typedef
    typedef typename std::iterator_traits&lt;Iter_T&gt;::value_type value_type;
    typedef typename std::iterator_traits&lt;Iter_T&gt;::reference reference;
    typedef typename std::iterator_traits&lt;Iter_T&gt;::difference_type
     difference_type;
    typedef typename std::iterator_traits&lt;Iter_T&gt;::pointer pointer;
    typedef std::random_access_iterator_tag iterator_category;
    typedef stride_iter self;

    // конструкторы
    stride_iter() : m(NULL), step(0) {};
    stride_iter(const self& x) : m(x.m), step(x.step) {}
    stride_iter(Iter_T x, difference_type n) : m(x), step(n) {}

    // операторы
    self& operator++() { m += step; return *this; }
    self operator++(int) { self tmp = *this; m += step; return tmp; }
    self& operator+=(difference_type x) { m += x * step; return *this; }
    self& operator--() { m -= step; return *this; }
    self operator--(int) { self tmp = *this; m -= step; return trap; }
    self& operator--(difference type x) { m -= x + step; return *this; }
    reference operator[](difference_type n) { return m[n * step]; }
    reference operator*() { return *m; }

    // дружественные операторы
    friend bool operator==(const self& x, const self& y) {
     assert(x.step == y.step);
     return x.m == y.m;
    }
    friend bool operator!=(const self& x, const self& y) {
     assert(x.step == y.step);
     return x.m != y.m;
    }
    friend bool operator&lt;(const self& x, const self& y) {
     assert(x.step == y.step);
     return x.m&lt; y.m;
    }
    friend difference type operator-(const self& x, const self& y) {
     assert(x.step == y.step);
     return (x.m - y.m) / x.step;
    }
    friend self operator+(const self& x, difference_type y) {
     assert(x.step == y.step);
     return x += y * x.step;
    }
    friend self operator+(difference_type x, const self& y) {
     assert(x.step == y.step);
     return y += x * x.step;
    }
   private:
    Iter_T m;
    difference_type step;
   };

   #endif
   Пример 11.25 показывает, как можно использовать итераторstride_iterиз примера 11.24 для получения доступа к каждому второму элементу последовательности.
   Пример 11.25. Применение итератора stride_iter
   #include "stride_iter.hpp"
   #include&lt;algorithm&gt;
   #include&lt;iterator&gt;
   #include&lt;iostream&gt;

   using namespace std;

   int main() {
    int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
    stride_iter&lt;int*&gt; first(a, 2);
    stride_iter&lt;int*&gt; last(a + 8, 2);
    copy(first, last, ostream_iterator&lt;int&gt;(cout, "\n"));
   }
   Программа примера 11.25 выдает следующий результат.
   0
   2
   4
   6Обсуждение
   Итераторы с шагом часто используются при работе с матрицами. Они обеспечивают простой и эффективный способ реализации матриц в виде набора числовых рядов. Представленная в примере 11.24 реализация итератора с шагом выполнена в виде оболочки другого итератора, который передается как параметр шаблона.
   Я хотел сделать итератор с шагом совместимым с STL, поэтому пришлось выбрать подходящий тип стандартного итератора и удовлетворить его требования. Представленный в примере 11.24 итератор с шагом сделан по образцу итератора с произвольным доступом.
   В примере 11.26 я отдельно привел реализацию итератора с шагом (названнуюkstride_iter),когда размер шага известен на этапе компиляции. Поскольку размер шага передается как параметр шаблона, компилятор может оптимизировать программный код итератораболее эффективно, и размер итератора уменьшается.
   Пример 11.26. kstride_iter.hpp
   #ifndef KSTRIDE_ITER_HPP
   #define KSTRIDE_ITER_HPP

   #include&lt;iterator&gt;

   template&lt;class Iter_T, int Step_N&gt;
   class kstride_iter {
   public:
    // открытые имена, вводимые typedef
    typedef typename std::iterator_traits&lt;Iter_T&gt;::value_type value_type;
    typedef typename std::iterator_traits&lt;Iter_T&gt;::reference reference;
    typedef typename std::iterator_traits&lt;Iter_T&gt;::difference_type
     difference_type;
    typedef typename std::iterator_traits&lt;Iter_T&gt;::pointer pointer;
    typedef std::random_access_iterator_tag iterator_category;
    typedef kstride_iter self;

    // конструкторы
    kstride_iter() : m(NULL) {} kstride_iter(const self& x) : m(x.m) {}
    explicit kstride_iter(Iter_T x) : m(x) {}

    // операторы
    self& operator++() { m += Step_N; return *this; }
    self operator++(int) { self tmp = *this; m += Step_N; return tmp; }
    self& operator+=(difference_type x) { m += x * Step_N; return *this; }
    self& operator--() { m -= Step_N; return *this; }
    self operator--(int) { self tmp = *this; m -= Step_N; return tmp; }
    self& operator--(difference_type x) { m -= x * Step_N; return *this; }
    reference operator[](difference_type n) { return m[n * Step_N]; }
    reference operator*() { return *m; }

    // дружественные операторы
    friend bool operator==(self x, self y) { return x.m == y.m; }
    friend bool operator!=(self x, self y) { return x.m != y.m; }
    friend bool operator&lt;(self x, self y) { return x.m&lt; y.m; }
    friend difference_type operator-(self x, self y) {
     return (x.m - y.m) / Step_N;
    }

    friend self operator+(self x, difference_type y) { return x += y * Step_N; }
    friend self operator+(difference_type x, self y) { return y += x * Step_N; }
   private:
    Iter_T m;
   };

   #endif
   Пример 11.27 показывает, как можно использовать итераторkstride_iter.
   Пример 11.27. Применение итератора kstride_iter
   #include "kstride_iter.hpp"
   #include&lt;algorithm&gt;
   #include&lt;iterator&gt;
   #include&lt;iostream&gt;

   using namespace std;

   int main() {
    int a[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
    kstride_iter&lt;int*, 2&gt; first(a);
    kstride_iter&lt;int*, 2&gt; last(a + 8);
    copy(first, last, ostream_iterator&lt;int&gt;(cout, "\n"));
   }
   11.14.Реализация динамической матрицыПроблема
   Требуется реализовать числовые матрицы, размерности которых (количество строк и столбцов) неизвестны на этапе компиляции.Решение
   В примере 11.28 показана универсальная и эффективная реализация класса динамической матрицы, использующая итератор с шагом из рецепта 11.12 иvalarray.
   Пример 11.28. matrix.hpp
   #ifndef MATRIX_HPP
   #define MATRIX_HPP

   #include "stride_iter.hpp" //см. рецепт 11.12
   #include&lt;valarray&gt;
   #include&lt;numeric&gt;
   #include&lt;algorithm&gt;

   template&lt;class Value_T&gt;
   class matrix {
   public:
    // открытые имена, вводимые typedef
    typedef Value_T value_type;
    typedef matrix self;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;
    typedef Value_T* row_type;
    typedef stride_iter&lt;value_type*&gt; col_type;
    typedef const value_type* const_row_type;
    typedef stride_iter&lt;const value_type*&gt; const_col_type;

    // конструкторы
    matrix() : nrows(0), ncols(0), m() {}
    matrix(int r, int c) : nrows(r), ncols(c), m(r * с) {}
    matrix(const self& x) : m(x.m), nrows(x.nrows), ncols(x.ncols) {}
    template&lt;typename T&gt;
    explicit matrix(const valarray&lt;T&gt;& x)
     : m(x.size() + 1), nrows(x.size()), ncols(1) {
     for (int i=0; i&lt;x.size(); ++i) m[i] = x[i];
    }
    // позволить конструирование из матриц других типов
    template&lt;typename T&gt; explicit matrix(const matrix&lt;T&gt;& x)
     : m(x.size() + 1), nrows(x.nrows), ncols(x.ncols) {
     copy(x.begin(), x.end(), m.begin());
    }

   //открытые функции
    int rows() const { return nrows; }
    int cols() const { return ncols; }
    int size() const { return nrows * ncols; }

    // доступ к элементам
    row_type row begin(int n) { return&m[n * cols()]; }
    row_type row_end(int n) { return row_begin() + cols(); }
    col_type col_begin(int n) { return col_type(&m[n], cols()); }
    col_type col_end(int n) { return col_begin(n) + cols(); }
    const_row_type row_begin(int n) const { return&m[n * cols()]; }
    const_row_type row_end(int n) const { return row_begin() + cols(); }
    const_col_type col_begin(int n) const { return col_type(&m[n], cols()); }
    const_col_type col_end(int n) const { return col_begin() + cols(); }
    iterator begin() { return&m[0]; }
    iterator end() { return begin() + size(); }
    const_iterator begin() const { return&m[0]; }
    const_iterator end() const { return begin() + size(); }

    // операторы
    self& operator=(const self& x) {
     m = x.m;
     nrows = x.nrows;
     ncols = x.ncols;
     return *this;
    }
    self& operator=(value_type x) { m = x; return *this; }
    row_type operator[](int n) { return row_begin(n); }
    const_row_type operator[](int n) const { return row_begin(n); }
    self& operator+=(const self& x) { m += x.m; return *this; }
    self& operator-=(const self& x) { m -= x.m; return *this; }
    self& operator+=(value_type x) { m += x; return *this; }
    self& operator-=(value_type x) { m -= x; return *this; }
    self& operator*=(value_type x) { m *= x; return *this; }
    self& operator/=(value_type x) { m /= x; return *this; }
    self& operator%=(value_type x) { m %= x; return *this; }
    self operator-() { return -m; }
    self operator+() { return +m; }
    self operator!() { return !m; }
    self operator~() { return ~m; }

    // дружественные операторы
    friend self operator+(const self& x, const self& y) { return self(x) += y; }
    friend self operator-(const self& x, const self& y) { return self(x) -= y; }
    friend self operator+(const self& x, value_type y) { return self(x) += y; }
    friend self operator-(const self& x, value_type y) { return self(x) -= y; }
    friend self operator*(const self& x, value type y) { return self(x) *= y; }
    friend self operator/(const self& x, value_type y) { return self(x) /= y; }
    friend self operator%(const self& x, value_type y) { return self(x) %= y; }
   private:
    mutable valarray&lt;Value_T&gt; m;
    int nrows;
    int ncols;
   };
   #endif
   Пример 11.29 показывает, как можно использовать шаблонный классmatrix.
   Пример 11.29. Применение шаблона matrix
   #include "matrix.hpp"
   #include&lt;iostream&gt;

   using namespace std;

   int main() {
    matrix&lt;int&gt; m(2,2);
    m = 0;
    m[0][0] = 1;
    m[1][1] = 1;
    m *= 2;
    cout&lt;&lt; "("&lt;&lt; m[0][0]&lt;&lt; ","&lt;&lt; m[0][1]&lt;&lt; ")"&lt;&lt; endl;
    cout&lt;&lt; "("&lt;&lt; m[1][0]&lt;&lt; ","&lt;&lt; m[1][1]&lt;&lt; ")"&lt;&lt; endl;
   }
   Программа примера 11.29 выдает следующий результат.
   (2,0)
   (0,2)Обсуждение
   Проект шаблона матрицы, представленный в примере 11.28, в значительной степени инспирирован шаблоном матрицы Бьерна Страуструпа (Bjarne Stroustrup) из его книги «The C++ Programming Language», 3-е издание (издательство «Addison Wesley»). Реализация Страуструпа отличается тем, что его итератор использует классsliceи указатель наvalarrayдля индексации. Реализованная в примере 11.27 матрица использует вместо них итератор с шагом из рецепта 11.12, что делает итераторы более компактными и при некоторых реализациях более эффективными.
   Шаблонный классmatrixпозволяет индексировать элементi-й строки иj-го столбца, используя операцию двойной индексации. Например:
   matrix&lt;int&gt; m(100,100);
   cout&lt;&lt; "the element at row 24 and column 42 is "&lt;&lt; m[24][42]&lt;&lt; endl;
   Шаблонный классmatrixтакже имеет функции-членыbeginиend,т.е. его легко можно использовать в различных алгоритмах STL.
   Пример 11.28 содержит строку, которая, возможно, вызывает у вас некоторое удивление. Имеется в виду следующее объявление.
   mutable valarray&lt;Value_T&gt; m;
   Объявление поля-членаmсо спецификаторомmutableвынужденно. В противном случае я не мог бы обеспечить итераторы со спецификаторомconst,потому что нельзя создать итератор дляconst valarray.Смотри также
   Рецепты 11.15 и 11.16.
   11.15.Реализация статической матрицыПроблема
   Требуется эффективно реализовать матрицу, когда ее размерность (т.е. количество строк и столбцов) постоянна и известна на этапе компиляции.Решение
   Когда размерность матрицы известна на этапе компиляции, компилятор может легко оптимизировать реализацию, в которой количество строк и столбцов задается в виде параметров шаблона, как показано в примере 11.30.
   Пример 11.30. kmatrix.hpp
   #ifndef KMATRIX_HPP
   #define KMATRIX_HPP

   #include "kvector.hpp"
   #include "kstride_iter.hpp"

   template&lt;class Value_T, int Rows_N, int Cols_N&gt;
   class kmatrix {
   public:
    // открытые имена, вводимые typedef
    typedef Value_T value_type;
    typedef kmatrix self;
    typedef Value_T* iterator;
    typedef const Value_T* const_iterator;
    typedef kstride_iter&lt;Value_T*, 1&gt; row_type;
    typedef kstride_iter&lt;Value_T*, Cols_N&gt; col_type;
    typedef kstride_iter&lt;const Value_T*, 1&gt; const_row_type;
    typedef kstride_iter&lt;const Value T*, Cols_N&gt; const_col_type;

    // открытые константы
    static const int nRows = Rows_N;
    static const int nCols = Cols_N;

    // конструкторы
    kmatrix() { m = Value_T(); }
    kmatrix(const self& x) { m = x.m; }
    explicit kmatrix(Value_T& x) { m = x.m; }

    // открытые функции
    static int rows() { return Rows_N; }
    static int cols() { return Cols_N; }
    row_type row(int n) { return row_type(begin() * (n * Cols_N)); }
    col_type col(int n) { return col_type(begin() + n); }
    const_row_type row(int n) const {
     return const_row_type(begin() + (n * Cols_N));
    }
    const_col_type col(int n) const {
     return const_col_type(begin() + n);
    }
    iterator begin() { return m.begin(); }
    iterator end() { return m.begin() + size(); }
    const_iterator begin() const { return m; }
    const_iterator end() const { return m + size(); }
    static int size() { return Rows_N * Cols_N; }

    // операторы
    row_type operator[](int n) { return row(n); }
    const_row_type operator[](int n) const { return row(n); }

    // операции присваивания
    self& operator=(const self& x) { m = x.m; return *this; }
    self& operator=(value_type x) { m = x; return *this; }
    self& operator+=(const self& x) { m += x.m; return *this; }
    self& operator-=(const self& x) { m -= x.m; return *this; }
    self& operator+={value_type x) { m += x; return *this; }
    self& operator-=(value_type x) { m -= x; return *this; }
    self& operator*=(value_type x) { m *= x; return *this; }
    self& operator/=(value_type x) { m /= x; return *this; }
    self operator-() { return self(-m); }

    // друзья
    friend self operator+(self x, const self&у) { return x += y; }
    friend self operator-(self x, const self& y) { return x -= y; }
    friend self operator+(self x, value_type y) { return x += y; }
    friend self operator-(self x, value type y) { return x -= y; }
    friend self operator*(self x, value_type y) { return x *= y; }
    friend self operator/(self x, value_type y) { return x /= y; }
    friend bool operator==(const self& x, const self& y) { return x == y; }
    friend bool operator!=(const self& x, const self& y) { return x.m != y.m; }
   private:
    kvector&lt;Value_T, (Rows_N + 1) * Cols_N&gt; m;
   };

   #endif
   В примере 11.31 приведена программа, демонстрирующая применение шаблонного классаkmatrix.
   Пример 11.31. Применение kmatrix
   #include "kmatrix.hpp"
   #include&lt;iostream&gt;

   using namespace std;

   template&lt;class Iter_T&gt;
   void outputRowOrColumn(Iter_T iter, int n) {
    for (int i=0; i&lt; n; ++i) {
     cout&lt;&lt; iter[i]&lt;&lt; " ";
    }
    cout&lt;&lt; endl;
   }

   template&lt;class Matrix_T&gt;
   void initializeMatrix(Matrix_T& m) {
    int k = 0;
    for (int i=0; i&lt; m.rows(); ++i) {
     for (int j=0; j&lt; m.cols(); ++j) {
      m[i][j] = k++;
     }
    }
   }

   template&lt;class Matrix_T&gt;
   void outputMatrix(Matrix_T& m) {
    for (int i=0; i&lt; m.rows(); ++i) {
     cout&lt;&lt; "Row "&lt;&lt; i&lt;&lt; " = ";
      outputRowOrColumn(m.row(i), m.cols());
    }
    for (int i=0; i&lt; m.cols(); ++i) {
     cout&lt;&lt; "Column "&lt;&lt; i&lt;&lt; " = ";
      outputRowOrColumn(m.col(i), m.rows());
    }
   }

   int main() {
    kmatrix&lt;int, 2, 4&gt; m;
    initializeMatrix(m); m *= 2;
    outputMatrix(m);
   }
   Программа примера 11.31 выдает следующий результат.
   Row 0 = 0 2 4 6
   Row 1 = 8 10 12 14
   Column 0 = 0 8
   Column 1 = 2 10
   Column 2 = 4 12
   Column 3 = 6 14Обсуждение
   Представленные в примерах 11.30 и 11.31 определение шаблона классаkmatrixи пример его использования очень напоминают шаблон классаmatrixиз рецепта 11.14. Единственным существенным отличием является то, что при объявлении экземпляраkmatrixприходится передавать размерности матрицы через параметры шаблона, например;
   kmatrix&lt;int 5, 6&gt; m; //объявляет матрицу с пятью строками и шестью
                        // столбцами
   В приложениях многих типов часто требуется, чтобы матрицы имели размерности, известные на этапе компиляции. Передача размера строк и столбцов через параметры шаблона позволяет компилятору легче применять такую оптимизацию, как развертка цикла, встраивание функций и ускорение индексации.
    [Картинка: tip_yellow.png] Как и рассмотренный ранее шаблон статического вектора (kvector),шаблонkmatrixособенно эффективен при небольших размерах матрицы.Смотри также
   Рецепты 11.14 и 11.16.
   11.16.Умножение матрицПроблема
   Требуется эффективно выполнить умножение двух матриц.Решение
   Пример 11.32 показывает, как можно выполнить умножение матриц, причем эта реализация подходит как для динамических, так и для статических матриц. Формально этот алгоритм реализует соотношение A=A+B*C, которое (возможно, неожиданно) вычисляется более эффективно, чем A=B*C.
   Пример 11.32. Умножение матриц
   #include "matrix.hpp" //рецепт 11.13
   #include "kmatrix.hpp" //рецепт 11.14
   #include&lt;iostream&gt;
   #include&lt;cassert&gt;

   using namespace std;

   template&lt;class M1, class M2, class M3&gt;
   void matrixMultiply(const M1& m1, const M2& m2, M3& m3) {
    assert(m1.cols() == m2.rows());
    assert(m1.rows() == m3.rows());
    assert(m2.cols() == m3.cols());
    for (int i=m1.rows()-1; i&gt;= 0; --i) {
     for (int j=m2.cols()-1; j&gt;= 0; --j) {
      for (int k = m1.cols()-1; k&gt;= 0; --k) {
       m3[i][j] += m1[i][k] * m2[k][j];
      }
     }
    }
   }

   int main() {
    matrix&lt;int&gt; m1(2, 1);
    matrix&lt;int&gt; m2(1, 2);
    kmatrix&lt;int, 2, 2&gt; m3;
    m3 = 0;
    m1[0][0] = 1;
    m1[1][0] = 2;
    m2[0][0] = 3;
    m2[0][1] = 4;
    matrixMultlply(m1, m2, m3);
    cout&lt;&lt; "("&lt;&lt; m3[0][0]&lt;&lt; ", "&lt;&lt; m3[0][1]&lt;&lt; ")"&lt;&lt; endl;
    cout&lt;&lt; "("&lt;&lt; m3[1][0]&lt;&lt; ", "&lt;&lt; m3[1][1 ]&lt;&lt; ")"&lt;&lt; endl;
   }
   Программа примера 11.32 выдает следующий результат.
   (3, 4)
   (6, 8)Обсуждение
   При умножении двух матриц число столбцов первой матрицы должно равняться числу строк второй матрицы. Число строк полученной матрицы равно числу строк первой матрицы, а число столбцов равно числу столбцов второй матрицы. Я обеспечиваю эти условия в отладочной версии с помощью макросаassert,определенного в заголовочном файле&lt;cassert&gt;.
   Решающее значение для эффективной реализации умножения имеет отсутствие избыточных операций по созданию и копированию временных объектов. Так, представленная в примере 11.32 функция умножения матриц передает результат по ссылке. Если бы алгоритм умножения я реализовал впрямую путем перегрузки оператораoperator*,это привело бы к лишним операциям распределения, копирования и освобождения памяти, занимаемой временной матрицей. Потенциально такой подход может оказаться очень затратным при работе с большими матрицами.
    [Картинка: tip_yellow.png] В примере 11.32 реализуется равенствоA=A+B*C,а неA=B*C,для того чтобы избежать лишней инициализации значений матрицыA.Смотри также
   Рецепт 11.17.
   11.17.Вычисление быстрого преобразования ФурьеПроблема
   Требуется выполнить эффективный расчет дискретного преобразования Фурье (ДПФ), используя алгоритм быстрого преобразования Фурье (БПФ).Решение
   Программный код примера 11.33 обеспечивает базовую реализацию БПФ.
   Пример 11.33. Реализация БПФ
   #include&lt;iostream&gt;
   #include&lt;complex&gt;
   #include&lt;cmath&gt;
   #include&lt;iterator&gt;

   using namespace std;

   unsigned int bitReverse(unsigned int x, int log2n) {
    int n = 0;
    int mask = 0x1;
    for (int i=0; i&lt; log2n; i++) {
     n&lt;&lt;= 1;
     n |= (x& 1);
     x&gt;&gt;= 1;
    }
    return n;
   }

   const double PI = 3.1415926536;

   template&lt;class Iter_T&gt;
   void fft(Iter_r a, Iter_r b, int log2n) {
    typedef typename iterator_traits&lt;Iter T&gt;::value_type complex;
    const complex J(0, 1);
    int n = 1&lt;&lt; log2n;
    for (unsigned int i=0; i&lt; n; ++i) {
     b[bitReverse(i, log2n)] = a[i];
    }
    for (int s = 1; s&lt;= log2n; ++s) {
     int m = 1&lt;&lt; s;
     int m2 = m&gt;&gt; 1;
     complex w(1, 0);
     complex wm = exp(-J * (PI / m2));
     for (int j=0; j&lt; m2; ++j) {
      for (int k=j; k&lt; n; k += m) {
       complex t = w * b[k + m2];
       complex u = b[k];
       b[k] = u + t;
       b[k + m2] = u - t;
      }
      w *= wm;
     }
    }
   }

   int main() {
    typedef complex&lt;double&gt; cx;
    cx a[] = { cx(0, 0), cx(1, 1), cx(3, 3), cx(4, 4),
     cx(4, 4), cx(3, 3), cx(1, 1), cx(0, 0) };
    cx b[8];
    fft(a, b, 3);
    for (int i=0; i&lt;8; ++i) cout&lt;&lt; b[i]&lt;&lt; "\n";
   }
   Программа примера 11.33 выдает следующий результат.
   (16,16)
   (-4.82843,-11.6569)
   (0,0)
   (-0.343146,0.828427)
   (0.0)
   (0.828427,-0.343146)
   (0,0)
   (-11.6569,-4.82843)Обсуждение
   Преобразование Фурье играет важную роль в спектральном анализе и часто используется в технических и научных приложениях. БПФ — это алгоритм вычисления ДПФ, который имеет сложность порядкаN log2(N)в отличие от ожидаемой сложностиN?для простой реализации ДПФ. Такое впечатляющее ускорение достигается в БПФ благодаря устранению избыточных вычислений.
   Очень не просто найти хорошую реализацию БПФ, написанную на «правильном» C++ (т. е. когда программа на C++ не является механическим переложением алгоритмов, написанных на Фортране или С) и которая не была бы защищена сильно ограничивающей лицензией. Представленный в примере 11.33 программный код основан на открытом коде, который можно найти в сетевой конференции Usenet, посвященной цифровой обработке сигналов (comp.dsp).Большим преимуществом реализации БПФ на правильном C++ по сравнению с более распространенным решением в стиле С является то, что стандартная библиотека содержит шаблонcomplex,который позволяет существенно снизить объем необходимого программного кода. В представленной в примере 11.33 функцииfft()основное внимание уделялось простоте, а не эффективности.
   11.18.Работа с полярными координатамиПроблема
   Требуется обеспечить представление полярных координат и манипулирование ими.Решение
   Шаблонcomplexиз заголовочного файла&lt;complex&gt;содержит функции преобразования в полярные координаты и обратно. Пример 11.34 показывает, как можно использовать класс шаблона complex для представления и манипулирования полярными координатами.
   Пример 11.34. Применение шаблонного класса complex для представления полярных координат
   #include&lt;complex&gt;
   #include&lt;iostream&gt;

   using namespace std;

   int main() {
    double rho = 3.0; // длина
    double theta = 3.141592 / 2; // угол
    complex&lt;double&gt; coord = polar(rho, theta);
    cout&lt;&lt; "rho = "&lt;&lt; abs(coord)&lt;&lt; ", theta = "&lt;&lt; arg(coord)&lt;&lt; endl;
    coord += polar(4.0, 0.0);
    cout&lt;&lt; "rho = "&lt;&lt; abs(coord)&lt;&lt; ", theta = "&lt;&lt; arg(coord)&lt;&lt; endl;
   }
   Программа примера 11.34 выдает следующий результат.
   rho = 3, theta = 1.5708
   rho = 5, theta = 0.643501Обсуждение
   Существует естественная связь между полярными координатами и комплексными числами. Хотя эти понятия в какой-то мере взаимозаменяемы, использование одного и того же типа для представления разных концепций в целом нельзя считать хорошей идеей. Поскольку применение шаблонаcomplexдля представления полярных координат не является элегантным решением, я предусмотрел приведенный в примере 11.25 класс полярных координат, допускающий более естественное применение.
   Пример 11.35. Класс полярных координат
   #include&lt;complex&gt;
   #include&lt;iostream&gt;

   using namespace std;

   template&lt;class T&gt;
   struct BasicPolar {
    public typedef BasicPolar self;

    // конструкторы
    BasicPolar() : m() {} BasicPolar(const self& x) : m(x.m) {}
    BasicPolar(const T& rho, const T& theta) : m(polar(rho, theta)) {}

    // операторы присваивания
    self operator-() { return Polar(-m); }
    self& operator+=(const self& x) { m += x.m; return *this; }
    self& operator-=(const self& x) { m -= x.m; return *this; }
    self& operator*=(const self& x) { m *= x.m; return *this; }
    self& operator/=(const self& x) { m /= x.m; return *this; }
    operator complex&lt;T&gt;() const { return m; }

    // открытые функции-члены
    T rho() const { return abs(m); }
    T theta() const { return arg(m); }

    // бинарные операции
    friend self operator+(self x, const self& y) { return x += y; }
    friend self operator-(self x, const self& y) { return x -= y; }
    friend self operator*(self x, const self& y) { return x *= y; }
    friend self operator/(self x, const self& y) { return x /= y; }

    // операторы сравнения
    friend bool operator==(const self& x, const self& y) { return x.m == y.m; }
    friend bool operator!=(const self& x, const self& y) { return x.m ! = y.m; }
   private:
    complex&lt;T&gt; m;
   };

   typedef BasicPolar&lt;double&gt; Polar;

   int main() {
    double rho = 3.0; // длина
    double theta = 3.141592 / 2; // угол
    Polar coord(rho, theta);
    cout&lt;&lt; "rho = "&lt;&lt; coord.rho()&lt;&lt; ", theta = "&lt;&lt; coord.theta()&lt;&lt; endl;
    coord += Polar(4.0, 0.0);
    cout&lt;&lt; "rho = "&lt;&lt; coord.rho()&lt;&lt; ", theta = "&lt;&lt; coord.theta()&lt;&lt; endl;
    system("pause");
   }
   В примере 11.35 с помощьюtypedefя определил типPolarкак специализацию шаблонаBasicPolar.Так удобно определять используемый по умолчанию тип, однако вы можете при необходимости специализировать шаблонBasicPolarдругим числовым типом. Такой подход используется в стандартной библиотеке в отношении классеstring,который является специализацией шаблонаbasic_string.
   11.19.Выполнение операций с битовыми наборамиПроблема
   Требуется реализовать основные арифметические операции и операции сравнения для набора бит, рассматривая его как двоичное представление целого числа без знака.Решение
   Программный код примера 11.36 содержит функции, которые позволяют выполнять арифметические операции и операции сравнения с шаблоном классаbitsetиз заголовочного файла&lt;bitset&gt;,рассматривая его как целый тип без знака.
   Пример 11.36. bitset_arithmetic.hpp
   #include&lt;stdexcept&gt;
   #include&lt;bitset&gt;

   bool fullAdder(bool b1, bool b2, bool& carry) {
    bool sum = (b1 ^ b2) ^ carry;
    carry = (b1&& b2) || (b1&& carry) || (b2&& carry);
    return sum;
   }

   bool fullSubtractor(bool b1, bool b2, bool& borrow) {
    bool diff;
    if (borrow) {
     diff = !(b1 ^ b2);
     borrow = !b1 || (b1&& b2);
    } else {
     diff = b1 ^ b2;
     borrow = !b1&& b2;
    }
    return diff;
   }

   template&lt;unsigned int N&gt;
   bool bitsetLtEq(const std::bitset&lt;N&gt;& x, const std::bitset&lt;N&gt;& y) {
    for (int i=N-1; i&gt;= 0; i--) {
     if (x[i]&& !y[i]) return false;
     if (!x[i]&& y[i]) return true;
    }
    return true;
   }

   template&lt;unsigned int N&gt;
   bool bitsetLt(const std::bitset&lt;N&gt;& x, const std::bitset&lt;N&gt;& y) {
    for (int i=N-1; i&gt;= 0, i--) {
     if (x[i]&& !y[i]) return false;
     if (!x[i]&& y[i]) return true;
    }
    return false;
   }

   template&lt;unsigned int N&gt;
   bool bitsetGtEq(const std::bitset&lt;N&gt;& x, const std::bitset&lt;N&gt;& y) {
    for (int i=N-1; i&gt;= 0; i--) {
     if (x[i]&& !y[i]) return true;
     if (!x[i]&& y[i]) return false;
    }
    return true;
   }

   template&lt;unsigned int N&gt;
   bool bitsetGt(const std::bitset&lt;N&gt;& x, const std::bitset&lt;N&gt;& y) {
    for (int i=N-1; i&gt;= 0; i--) {
     if (x[i]&& !y[i]) return true;
     if (!x[i]&& y[i]) return false;
    }
    return false;
   }

   template&lt;unsigned int N&gt;
   void bitsetAdd(std::bitset&lt;N&gt;& x, const std::bitset&lt;N&gt;& y) {
    bool carry = false;
    for (int i = 0; i&lt; N; i++) {
     x[i] = fullAdder(x[i], y[x], carry);
    }
   }

   template&lt;unsigned int N&gt;
   void bitsetSubtract(std::bitset&lt;N&gt;& x, const std::bitset&lt;N&gt;& y) {
    bool borrow = false;
    for (int i = 0; i&lt; N; i++) {
     if (borrow) {
      if (x[i]) {
       x[i] = y[i];
       borrow = y[i];
      } else {
       x[i] = !y[i];
       borrow = true;
      }
     } else {
      if (x[i]) {
       x[i] = !y[i];
       borrow = false;
      } else {
       x[i] = y[i];
       borrow = y[i];
      }
     }
    }
   }

   template&lt;unsigned int N&gt;
   void bitsetMultiply(std::bitset&lt;N&gt;& x, const std::bitset&lt;N&gt;& y) {
    std::bitset&lt;N&gt; tmp = x;
    x.reset();
    // мы хотим минимизировать количество операций сдвига и сложения
    if (tmp.count()&lt; y.count()) {
     for (int i=0; i&lt; N; i++) if (tmp[i]) bitsetAdd(x,у&lt;&lt; i);
    } else {
     for (int i=0; i&lt; N; i++) if (y[i]) bitsetAdd(x, tmp&lt;&lt; i);
    }
   }

   template&lt;unsigned int N&gt;
   void bitsetDivide(std::bitset&lt;N&gt; x, std::bitset&lt;N&gt; y,
    std::bitset&lt;N&gt;& q, std::bitset&lt;N&gt;& r) {
    if (y.none()) {
     throw std::domain_error("division by zero undefined");
    }
    q.reset();
    r.reset();
    if (x.none()) {
     return;
    }
    if (x == y) {
     q[0] = 1;
     return;
    }
    r = x;
    if (bitsetLt(x, y)) {
     return;
    }
    // подсчитать количество значащих цифр в делителе и делимом
    unsigned int sig_x;
    for (int i=N-1; i&gt;=0; i--) {
     sig_x = i;
     if (x[i]) break;
    }
    unsigned int sig_y;
    for (int i=N-1; i&gt;=0; i--) {
     sig_y = i;
     if (y[i]) break;
    }
    // выровнять делитель по отношению к делимому
    unsigned int n = (sig_x — sig_y);
    y&lt;&lt;= n;
    // обеспечить правильное число шагов цикла
    n += 1;
    // удлиненный алгоритм деления со сдвигом и вычитанием
    while (n--) {
     // сдвинуть частное влево
     if (bitsetLtEq(y, r)) {
      // добавить новую цифру к частному
      q[n] = true;
      bitset.Subtract(r, y);
     }
     // сдвинуть делитель вправо
     y&gt;&gt;= 1;
    }
   }
   Пример 11.37 показывает, как можно использовать заголовочный файлbitset_arithmetic.hpp.
   Пример 11.37. Применение функций bitset_arithmetic.hpp
   #include "bitset_arithmetic.hpp"
   #include&lt;bitset&gt;
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   using namespace std;

   int main() {
    bitset&lt;10&gt; bits1(string("100010001"));
    bitset&lt;10&gt; bits2(string("000000011"));
    bitsetAdd(bits1, bits2);
    cout&lt;&lt; bits1.to_string&lt;char, char_traits&lt;char&gt;, allocator&lt;char&gt;&gt;()&lt;&lt; endl;
   }
   Программа примера 11.37 выдает следующий результат.
   0100010100Обсуждение
   Шаблон классаbitsetсодержит основные операции по манипулированию битовыми наборами, но не обеспечивает арифметические операции и операции сравнения. Это объясняется тем, что в библиотеке нельзя заранее точно предвидеть, какой числовой тип будет использоваться для представления произвольного битового набора согласно ожиданиям программиста.
   В функциях примера 11.36 считается, чтоbitsetпредставляет собой целый тип без знака, и здесь обеспечиваются операции сложения, вычитания, умножения, деления и сравнения. Эти функции могут составить основу для представления специализированных целочисленных типов, и именно для этого они используются в рецепте 11.20.
   В примере 11.36 я использовал не самые эффективные алгоритмы. Я применил самые простые алгоритмы, потому что их легче понять. В существенно более эффективной реализации использовались бы аналогичные алгоритмы, которые работали бы со словами, а не с отдельными битами.Смотри также
   Рецепт 11.20.
   11.20.Представление больших чисел фиксированного размераПроблема
   Требуется выполнить операции с числами, размер которых превышает размер типаlong int.Решение
   ШаблонBigIntв примере 11.38 используетbitsetиз заголовочного файла&lt;bitset&gt;для того, чтобы можно было представить целые числа без знака в виде набора бит фиксированного размера, причем количество бит определяется параметром шаблона.
   Пример 11.38. big_int.hpp
   #ifndef BIG_INT_HPP
   #define BIG_INT_HPP

   #include&lt;bitset&gt;
   #include "bitset_arithmetic.hpp" //Рецепт 11.20

   template&lt;unsigned int N&gt;
   class BigInt {
    typedef BigInt self;
   public:
    BigInt() : bits() {}
    BigInt(const self& x) : bits(x.bits) {}
    BigInt(unsigned long x) {
     int n = 0;
     while (x) {
      bits[n++] = x& 0x1;
      x&gt;&gt;= 1;
     }
    }
    explicit BigInt(const std::bitset&lt;N&gt;& x) bits(x) {}

    // открытые функции
    bool operator[](int n) const { return bits[n]; }
    unsigned long toUlong() const { return bits.to_ulong(); }

    // операторы
    self& operator&lt;&lt;=(unsigned int n) {
     bits&lt;&lt;= n;
     return *this;
    }
    self& operator&gt;&gt;=(unsigned int n) {
     bits&gt;&gt;= n;
     return *this;
    }
    self operator++(int) {
     self i = *this;
     operator++();
     return i;
    }
    self operator--(int) {
     self i = *this;
     operator--();
     return i;
    }
    self& operator++() {
     bool carry = false;
     bits[0] = fullAdder(bits[0], 1, carry);
     for (int i = 1; i&lt; N; i++) {
      bits[i] = fullAdder(bits[i], 0, carry);
     }
     return *this;
    }
    self& operator--() {
     bool borrow = false;
     bits[0] = fullSubtractor(bits[0], 1, borrow);
     for (int i = 1; i&lt; N; i++) {
      bits[i] = fullSubtractor(bits[i], 0, borrow);
     }
     return *this;
    }
    self& operator+=(const self& x) {
     bitsetAdd(bits, x.bits);
     return *this;
    }
    self& operator-=(const self& x) {
     bitsetSubtract(bits, x.bits);
     return *this;
    }
    self& operator*=(const self& x) {
     bitsetMultiply(bits, x.bits);
     return *this;
    }
    self& operator/=(const self& x) {
     std::bitset&lt;N&gt; tmp;
     bitsetDivide(bits, x.bits, bits, tmp);
     return *this;
    }
    self& operator%=(const self& x) {
     std::bitset&lt;N&gt; tmp;
     bitsetDivide(bits, x.bits, tmp, bits);
     return *this;
    }
    self operator~() const { return ~bits; }
    self& operator&=(self x) { bits x.bits; return *this; }
    self& operator|=(self x) { bits x.bits; return *this; }
    self& operator~=(self x) { bits ~= x.bits; return *this; }

    // дружественные функции
    friend self operator&lt;&lt;(self x, unsigned int n) { return x&lt;&lt;= n; }
    friend self operator&gt;&gt;(self x, unsigned int n) { return x&gt;&gt;= n; }
    friend self operator+(self x, const self& y) { return x += y; }
    friend self operator-(self x, const self& y) { return x -= y; }
    friend self operator*(self x, const self& y) { return x *= y; }
    friend self operator/(self x, const self& y) { return x /= y; }
    friend self operator%(self x, const self& y) { return x %= y; }
    friend self operator^(self x, const self& y) { return x ^= y; }
    friend self operator&(self x, const self& y) { return x&= y; }
    friend self operator|(self x, const self& y) { return x |= y; }

    // операторы сравнения
    friend bool operator==(const self& x, const self& y) {
     return x.bits == y.bits;
    }
    friend bool operator!=(const self& x, const self& y) {
     return x.bits ! = y.bits;
    }
    friend bool operator&gt;(const self& x, const self& y) {
     return bitsetGt(x.bits, y.bits);
    }
    friend bool operator&lt;(const self& x, const self& y) {
     return bitsetLt(x.bits, y.bits);
    }
    friend bool operator&gt;=(const self& x, const self& y) {
     return bitsetGtEq(x.bits, y.bits);
    }
    friend bool operator&lt;=(const self& x, const self& y) {
     return bitsetLtEq(x bits, y.bits);
    }
   private:
    std::bitset&lt;N&gt; bits;
   };

   #endif
   Шаблонный классBigIntможно использовать для вычисления факториалов, как показано в примере 11.39.
   Пример 11.39. Применение класса big_int
   #include "big_int.hpp"
   #include&lt;iostream&gt;
   #include&lt;vector&gt;
   #include&lt;iterator&gt;
   #include&lt;algorithm&gt;

   using namespace std;

   void outputBigInt(BigInt&lt;1024&gt; x) {
    vector&lt;int&gt; v;
    if (x == 0) {
     cout&lt;&lt; 0;
     return;
    }
    while (x&gt; 0) {
     v.push_back((x % 10).to_ulong());
     x /= 10;
    }
    copy(v.rbegin(), v.rend(), ostream_iterator&lt;int&gt;(cout, ""));
    cout&lt;&lt; endl;
   }

   int main() {
    BigInt&lt;1024&gt; n(1); //вычислить факториал числа 32
    for (int 1=1; i&lt;= 32; ++i) {
     n *= i;
    }
    outputBigInt(n);
   }
   Программа примера 11.39 выдает следующий результат.
   263130836933693530167218012160000000Обсуждение
   Большие целые числа часто встречаются во многих приложениях. Например, в криптографии нередки числа, которые представляются 1000 и более битами. Однако современный стандарт C++ позволяет работать как максимум с типомlong int.
    [Картинка: tip_yellow.png] Число бит типаlong intзависит от реализации, но оно не может быть меньше 32. И едва ли это число будет больше 1000. Следует помнить, что один из этих битов используется в качестве знака.
   Ожидается, что новая версия стандарта (C++0x) последует за стандартом C99 и предусмотрит типlong long,размер которого будет, по крайней мере, не меньше размераlong int,а возможно, и больше. Несмотря на это, всегда будут случаи, когда требуется наличие целочисленного типа, размер которого превышает размер самого большого встроенного типа.
   Представленная здесь реализация основана на двоичном представлении чисел при помощи классаbitset,причем это делается за счет некоторого снижения производительности. Однако я потерял в производительности значительно меньше, чем выиграл в простоте. Более эффективная реализация чисел произвольной точности настолько обширна, что могла бы легко заполнить всю книгу.Смотри также
   Рецепт 11.19.
   11.21.Реализация чисел с фиксированной точкойПроблема
   Требуется обеспечить выполнение вычислений с вещественными числами, используя тип с фиксированной, а не с плавающей точкой.Решение
   В примере 11.40 представлена реализация вещественного числа с фиксированной точкой, когда количество двоичных позиций справа от точки задается параметром шаблона. Например, типbasic_fixed_real&lt;10&gt;имеет 10 двоичных цифр справа от двоичной точки, что позволяет представлять числа с точностью до 1/1024.
   Пример 11.40. Представление вещественных чисел, используя формат с фиксированной точкой
   #include&lt;iostream&gt;

   using namespace std;

   template&lt;int E&gt;
   struct BasicFixedReal {
    typedef BasicFixedReal self;
    static const int factor = 1&lt;&lt; (E - 1);
    BasicFixedReal() : m(0) {}
    BasicFixedReal(double d) : m(static_cast&lt;int&gt;(d * factor)) {}
    self& operator+=(const self& x) { m += x.m; return *this; }
    self& operator-=(const self& x) { m -= x.m; return *this; }
    self& operator*=(const self& x) { m *= x.m; m&gt;&gt;=E; return *this; }
    self& operator/=(const self& x) { m /= x.m; m *= factor; return *this; }
    self& operator*=(int x) { m *= x; return *this; }
    self& operator/=(int x) { m /= x; return *this; }
    self operator-() { return self(-m); }
    double toDouble() const { return double(m) / factor; }

    // дружественные функции
    friend self operator+(self x, const self& v) { return x += y; }
    friend self operator-(self x, const self& y) { return x -= y; }
    friend self operator-(self x, const self& y) { return x *= y; }
    friend self operator/(self x, const self& y) { return x /= y; }

    // операторы сравнения
    friend bool operator==(const self& x, const self& y) { return x.m == y.m; }
    friend bool operator!=(const self& x, const self& y) { return x.m != y.m; }
    friend bool operator&gt;(const self& x, const self& y) { return x.m&gt; y.m; }
    friend bool operator&lt;(const self& x, const self& y) { return x.m&lt; y.m; }
    friend bool operator&gt;=(const self& x, const self& y) { return x.m&gt;= y.m; }
    friend bool operator&lt;=(const self& x, const self& y) { return x.m&lt;= y.m; }
   private:
    int m;
   };

   typedef BasicFixedReal&lt;10&gt; FixedReal;

   int main() {
    FixedReal x(0);
    for (int i=0; i&lt; 100; ++i) {
     x += FixedReal(0.0625);
    }
    cout&lt;&lt; x.toDouble()&lt;&lt; endl;
   }
   Программа примера 11.40 выдает следующий результат.
   6.25Обсуждение
   Число с фиксированной точкой, как и число с плавающей точкой, является приблизительным представлением вещественного числа. Число с плавающей точкой имеет мантиссу (m)и экспоненту (е),обеспечивая значение, вычисляемое по формулеm*bе,гдеb— некоторая константа.
   Число с фиксированной точкой имеет почти такой же формат, но здесь экспонента также фиксирована. Эта константа в примере 11.40 передается шаблонуbasic_fixed_realв качестве его параметра.
   Представление экспонентыев виде константы позволяет реализовать числа с фиксированной точкой с помощью целых типов и выполнять арифметические операции с ними, используя целочисленную арифметику. Во многих случаях это может повысить скорость выполнения основных арифметических операций, особенно сложения и вычитания.
   Представление с фиксированной точкой менее гибко, чем представление чисел с плавающей точкой, так как оно обеспечивает только узкий диапазон значений. Приведенный в примере 11.40 типfixed_realпозволяет представлять значения только в диапазоне от -2 097 151 до +2 097 151 с точностью 1/1024.
   Сложение и вычитание чисел с фиксированной точкой реализуется достаточно естественно: я просто складываю или вычитаю их целочисленные представления. Для выполнения деления и умножения требуется дополнительная операция сдвига мантиссы влево или вправо, чтобы двоичная точка заняла правильную позицию.
   Глава 12
   Многопоточная обработка
   12.0.Введение
   В данной главе даются рецепты написания многопоточных программ на C++ с использованием библиотеки Boost Threads, автором которой является Вильям Кемпф (William Kempf). Boost — это набор переносимых, высокопроизводительных библиотек с открытым исходным кодом, неоднократно проверенным программистами, и с широким спектром сложности: от простых структур данных до сложного фреймворка синтаксического анализа. Библиотека Boost Threads обеспечивает фреймворк для многопоточной обработки. Дополнительную информацию по проекту Boost можно найти на сайтеwww.boost.org.
   Стандартом C++ не предусматривается встроенная поддержка многопоточной обработки, поэтому нельзя написать переносимый программный код с многопоточной обработкой, подобно тому как создается переносимый код, использующий такие классы стандартной библиотеки, какstring,vector,listи т.д. Однако в библиотеке Boost Threads пройден значительный путь к созданию стандартной, переносимой библиотеки многопоточной обработки, и использование этой библиотеки позволяет свести к минимуму головную боль, вызываемую многими обычными проблемами, связанными с многопоточной обработкой.
   Все же в отличие от стандартной библиотеки и библиотек независимых разработчиков применение библиотеки многопоточной обработки нельзя свести к распаковке ее архива, включению операторов#includeи написанию программного кода, не требующего особых усилий. Во всех приложениях многопоточной обработки (кроме самых простых) необходимо тщательно подойти к разработке проекта, используя проверенные шаблоны и известные тактические приемы, позволяющие избегать ошибок, неизбежно возникающих в противном случае. В типичном однопоточном приложении обычные ошибки программирования находятся легко: циклы с пропуском одного шага, разыменование нулевого или удаленного указателя, потеря точности при преобразованиях чисел с плавающей точкой и т.д. В программах с многопоточной обработкой ситуация другая. Мало того, что задача отслеживания с помощью отладчика действий нескольких потоков становится очень трудоемкой, многопоточные программы работают недетерминировано, т.е. ошибки могут проявляться только в редких или сложных ситуациях.
   Именно по этой причине нельзя рассматривать данную главу как введение в многопоточное программирование. Если вы уже имели опыт многопоточного программирования, но не на C++ или без использования библиотеки Boost Threads, эта глава будет полезна для вас. Однако описание основных принципов многопоточного программирования выходит за рамки этой книги. Если до сих пор вы никогда не занимались многопоточным программированием, по-видимому, вам следует прочитать вводный материал по этой тематике, но такой материал трудно найти, потому что большинство программистов не используют потоки выполнения (хотя, возможно, их и следовало бы применить).
   Большая часть документации Boost и некоторые приводимые ниже рецепты при обсуждении классов используют понятияконцепцииимодели.Концепция— это абстрактное описание чего-то, обычно класса и его поведения, причем не делается никаких предположений относительно реализации. Как правило, сюда входит описание действий при конструировании и уничтожении, а также описание каждого метода с указанием предусловий, параметров и постусловий. Например, концепция мьютекса (Mutex) описывается как нечто допускающее блокирование и разблокирование только одним потоком в данный момент времени.Модель— это конкретная реализация концепции, например классmutexв библиотеке Boost Threads.Уточнение (refinement)концепции — это некая ее специализация, напримерReadWriteMutex,т.е. мьютекс с некоторыми дополнительными возможностями.
   Наконец, потоки делают что-то одно из трех: работают, находятся в ожидании чего-то или готовы начать работу, но ничего не ожидают и не выполняют никаких действий. Эти состояния носят названия состоянийвыполнения (run),ожидания (wait)иготовности (ready).Эти термины я использую в последующих рецептах.
   12.1.Создание потокаПроблема
   Требуется создать поток (thread) для выполнения некоторой задачи, в то время как главный поток продолжает свою работу.Решение
   Создайте объект классаthreadи передайте ему функтор, который выполняет данную работу. Создание объекта потока приведет к инстанцированию потока операционной системы, который начинает выполнять операторoperator()с вашим функтором (или начинает выполнять функцию, переданную с помощью указателя). Пример 12.1 показывает, как это делается.
   Пример 12.1. Создание потока
   #include&lt;iostream&gt;
   #include&lt;boost/thread/thread.hpp&gt;
   #include&lt;boost/thread/xtime.hpp&gt;

   struct MyThreadFunc {
    void operator()() {
     // Что-нибудь работающее долго...
    }
   } threadFun;

   int main() {
    boost::thread myThread(threadFun); // Создать поток, запускающий
                                       // функцию threadFun
    boost.:thread::yield(); // Уступить порожденному потоку квант времени.
                            // чтобы он мог выполнить какую-то работу.
   //Выполнить какую-нибудь другую работу
   myThread join(); //Текущий поток (т.е поток функции main) прежде.
                    // чем завершиться, будет ждать окончания myThread
   }Обсуждение
   Создается поток обманчиво просто. Вам необходимо лишь создать объектthreadв стеке или в динамической памяти и передать ему функтор, который укажет, с чего начать работу. В данном случае термин «поток» (thread) используется в двух смыслах. Во-первых, это объект классаthread,который является обычным объектом C++. При ссылке на этот объект я буду говорить «объект потока». Кроме того, существует поток выполнения, который является потоком операционной системы, представленным объектомthread.Когда я говорю «поток» (в отличие от названия класса потока, напечатанного моноширинным шрифтом), я имею в виду поток операционной системы.
   Теперь перейдем непосредственно к рассмотрению программного кода в примере. Конструкторthreadпринимает функтор (или указатель функции), имеющий два аргумента и возвращающийvoid.Рассмотрим следующую строку из примера 12.1.
   boost::thread myThread(threadFun);
   Она создает в стеке объектmyThread,являющийся новым потоком операционной системы, который начинает выполнять функциюthreadFun.В этот момент программный код функцииthreadFunи код функцииmain (по крайней мере, теоретически) выполняются параллельно. Конечно, на самом деле они могут выполняться не параллельно, поскольку ваша машина может иметь только один процессор, и в этом случае параллельная работа невозможна (благодаря недавно разработанным архитектурам процессоров это утверждение не совсем точное, но в настоящий момент я не буду принимать в расчет двухъядерные процессоры и т.п.). Если у вас только один процессор, то операционная система предоставит каждому созданному вамипотоку квант времени в состоянии выполнения, перед тем как приостановить его работу. Так как эти кванты времени могут иметь различную величину, никогда нельзя с уверенностью сказать, какой из потоков раньше достигнет определенной точки. Именно в этой особенности многопоточного программирования заключается его сложность:состояние многопоточной программы недетерминировано.При выполнении несколько раз одной и той же многопоточной программы можно получить различные результаты. Темой рецепта 12.2 является координация ресурсов, используемых несколькими потоками.
   После создания потокаmyThreadпотокmainпродолжает свою работу, по крайней мере на мгновение, пока не достигнет следующей строки.
   boost::thread::yield();
   Это переводит текущий поток (в данном случае поток main) в неактивное состояние, что означает переключение операционной системы на другой поток или процесс, используя некоторую политику, которая зависит от операционной системы. С помощью функцииyieldоперационная система уведомляется о том, что текущий поток хочет уступить оставшуюся часть кванта времени. В это время новый поток выполняетthreadFun.После завершенияthreadFunдочерний поток исчезает. Следует отметить, что объектthreadне уничтожается, потому что он является объектом С++, который по-прежнему находится в области видимости. Эта особенность играет важную роль.
   Объект потока — это некий объект, существующий в динамической памяти или в стеке и работающий подобно любому другому объекту С++. Когда программный код выходит из области видимости потока, все находящиеся в стеке объекты потока уничтожаются, или, с другой стороны, когда вызывающая программа выполняет операторdeleteдляthread*,исчезает соответствующий объектthread,который находится в динамической памяти. Но объектыthreadвыступают просто как прокси относительно реальных потоков операционной системы, и когда они уничтожаются, потоки операционной системы не обязательно исчезают. Они просто отсоединяются, что означает невозможность их подключения в будущем. Это не так уж плохо.
   Потоки используют ресурсы, и в любом (хорошо спроектированном) многопоточном приложении управление доступом к таким ресурсам (к объектам, сокетам, файлам, «сырой» памяти и т.д.) осуществляется при помощи мьютексов, которые являются объектами, обеспечивающими последовательный доступ к каким-либо объектам со стороны нескольких потоков (см. рецепт 12.2). Если поток операционной системы оказывается «убитым», он не будет освобождать свои блокировки и свои ресурсы, подобно тому как «убитый» процесс не оставляет шансов на очистку буферов или правильное освобождение ресурсов операционной системы. Простое завершение потока в тот момент, когда вам кажется, что он должен быть завершен, — это все равно что убрать лестницу из-под маляра, когда время его работы закончилось.
   Поэтому предусмотрена функция-членjoin.Как показано в примере 12.1, вы можете вызватьjoin,чтобы дождаться завершения работы дочернего потока,join— это вежливый способ уведомления потока, что вы собираетесь ждать завершения его работы.
   myThread.join();
   Поток, вызвавший функциюjoin,переходит в состояние ожидания, пока не закончит свою работу другой поток, представленный объектомmyThread.Если он никогда не завершится, то никогда не завершится иjoin.Применениеjoin— наилучший способ ожидания завершения работы дочернего потока.
   Возможно, вы заметили, что, если передать что-либо осмысленное функцииthreadFun,но закомментироватьjoin,поток не завершит свою работу. Вы можете убедиться в этом, выполняя вthreadFunцикл или какую-нибудь продолжительную операцию. Это объясняется тем, что операционная система уничтожает процесс вместе со всеми его дочерними процессами независимо от того, закончили или нет они свою работу. Без вызоваjoinфункцияmainне будет ждать окончания работы своих дочерних потоков: она завершается, и поток операционной системы уничтожается.
   Если требуется создать несколько потоков, рассмотрите возможность их группирования в объектthread_group.Объектthread_groupможет управлять объектами двумя способами. Во-первых, вы можете вызватьadd_threadс указателем на объектthread,и этот объект будет добавлен в группу. Ниже приводится пример.
   boost::thread_group grp;
   boost::thread* p = new boost::thread(threadFun);
   grp.add_thread(p);
   //выполнить какие-нибудь действия...
   grp.remove_thread(p);
   При вызове деструктораgrpон удалит операторомdeleteкаждый указатель потока, который был добавлен вadd_thread.По этой причине вы можете добавлять вthread_groupтолько указатели объектов потоков, размещённых в динамической памяти. Удаляйте поток путем вызоваremove_threadс передачей адреса объекта потока (remove_threadнаходит в группе соответствующий объект потока, сравнивая значения указателей, а не сами объекты).remove_threadудалит указатель, ссылающийся на этот поток группы, но вам придется все же удалить сам поток с помощью оператораdelete.
   Кроме того, вы можете добавить поток в группу, не создавая его непосредственно, а используя для этого вызов функцииcreate_thread,которая (подобно объекту потока) принимает функтор в качестве аргумента и начинает его выполнение в новом потоке операционной системы. Например, для порождения двух потоков и добавления их в группу сделайте следующее.
   boost::thread_group grp;
   grp.create_thread(threadFun);
   grp.create_thread(threadFun); //Теперь группа grp содержит два потока
   grp.join_all(); //Подождать завершения всех потоков
   При добавлении потоков в группу при помощиcreate_threadилиadd_threadвы можете вызватьjoin_allдля ожидания завершения работы всех потоков группы. Вызовjoin_allравносилен вызовуjoinдля каждого потока группы:join_allвозвращает управление после завершения работы всех потоков группы.
   Создание объекта потока позволяет начать выполнение отдельного потока. Однако с помощью средств библиотеки Boost Threads это делается обманчиво легко, поэтому необходимо тщательно обдумывать проект. Прочтите остальные рецепты настоящей главы, где даются дополнительные предостережения относительно применения потоков.Смотри также
   Рецепт 12.2.
   12.2.Обеспечение потокозащищенности ресурсовПроблема
   В программе используется несколько потоков и требуется гарантировать невозможность модификации ресурса несколькими потоками одновременно. В целом это называется обеспечениемпотокозащищенности (thread-safe)ресурсов илисериализациейдоступа к ним.Решение
   Используйте классmutex,определенный вboost/thread/mutex.hpp,для синхронизации доступа к потокам. Пример 12.2 показывает, как можно использовать в простых случаях объектmutexдля управления параллельным доступом к очереди.
   Пример 12.2. Создание потокозащищенного класса
   #include&lt;iostream&gt;
   #include&lt;boost/thread/thread.hpp&gt;
   #include&lt;string&gt;

   //Простой класс очереди; в реальной программе вместо него следует
   //использовать std::queue
   template&lt;typename T&gt;
   class Queue {
   public:
    Queue() {}
    ~Queue() {}
    void enqueue(const T& x) {
     // Блокировать мьютекс для этой очереди
     boost::mutex::scoped_lock lock(mutex_);
     list_.push_back(x);
     // scoped_lock автоматически уничтожается (и, следовательно, мьютекс
     // разблокируется) при выходе из области видимости
    }

    T dequeue() {
     boost::mutex::scoped_lock lock(mutex_);
     if (list_.empty())
       throw "empty!";      // Это приводит к выходу из текущей области
     T tmp = list_.front(); // видимости, поэтому блокировка освобождается
     list_.pop_front();
     return(tmp);
    } // Снова при выходе из области видимости мьютекс разблокируется

   private:
    std::list&lt;T&gt; list_;
    boost::mutex mutex_;
   };

   Queue&lt;std::string&gt; queueOfStrings;

   void sendSomething() {
    std::string s;
    for (int i = 0; i&lt; 10; ++i) {
     queueOfStrings.enqueue("Cyrus");
    }
   }

   void recvSomething() {
    std::string s;
    for(int i = 0; i&lt; 10; ++i) {
     try {
      s = queueOfStrings.dequeue();
     } catch(...) {}
    }
   }

   int main() {
    boost::thread thr1(sendSomething);
    boost::thread thr2(recvSomething);
    thr1.join();
    thr2.join();
   }Обсуждение
   Обеспечение потокозащищенности классов, функций, блоков программного кода и других объектов является сущностью многопоточного программирования. Если вы проектируете какой-нибудь компонент программного обеспечения с возможностями многопоточной обработки, то можете постараться обеспечить каждый поток своим набором ресурсов, например объектами в стеке и динамической памяти, ресурсами операционной системы и т.д. Однако рано или поздно вам придется обеспечить совместное использование различными потоками каких-либо ресурсов. Это может быть совместная очередь поступающих запросов (как это происходит на многопоточном веб-сервере) или нечто достаточно простое, как поток вывода (например, в файл журнала или даже вcout).Стандартный способ координации безопасного совместного использования ресурсов подразумевает применениемьютекса (mutex),который обеспечивает монопольный доступ к чему-либо.
   Остальная часть обсуждения в целом посвящена мьютексам, и в частности методам использованияboost::mutexдля сериализации доступа к ресурсам. Я использую терминологию подхода «концепция/модель», о котором я говорил кратко во введении настоящей главы.Концепция— это абстрактное (независимое от языка) описание чего-либо, амодельконцепции — конкретное ее представление в форме класса С++.Уточнениеконцепции — это определенная концепция с некоторыми дополнительными возможностями.
   Все-таки параллельное программирование представляет собой сложную тему, и в одном рецепте нельзя отразить все применяемые в этой технологии методы. Можно использовать много шаблонов проектирования и разных стратегий, подходящих для различных приложений. Если при проектировании программного обеспечения вы предполагаете, что многопоточная обработка составит значительный объем, или проектируете высокопроизводительные приложения, необходимо прочитать хорошую книгу по шаблонам многопоточной обработки. Многие проблемы, связанные с трудностями отладки многопоточных программ, могут быть успешно преодолены за счет тщательного и продолжительного проектирования.Использование мьютексов
   Концепция мьютекса проста: мьютекс это некий объект, представляющий ресурс; только один поток может его блокировать или разблокировать в данный момент времени. Онявляется флагом, который используется для координации доступа к ресурсу со стороны нескольких пользователей. В библиотеке Boost Threads моделью концепции мьютекса является классboost::mutex.В примере 1 2.2 доступ для записи в классе Queue обеспечивается переменной-членомmutex.
   boost::mutex mutex_;
   mutex_должен блокироваться какой-нибудь функцией-членом, которая должна изменять состояние очереди обслуживаемых элементов. Сам объектmutex_ничего не знает о том, что он представляет. Это просто флаг блокировки/разблокировки, используемый всеми пользователями некоторого ресурса.
   В примере 12.2, когда какая-нибудь функция-член классаQueueсобирается изменить состояние объекта, она сначала должна заблокироватьmutex_.Только один поток в конкретный момент времени может его заблокировать, что не позволяет нескольким объектам одновременно модифицировать состояние объектаQueue.Таким образом, мьютексmutexпредставляет собой простой сигнальный механизм, но это нечто большее, чем простоboolилиint,потому что для mutex необходим сериализованный доступ, который может быть обеспечен только ядром операционной системы. Если вы попытаетесь сделать то же самое сbool,это не сработает, потому что ничто не препятствует одновременной модификации состоянияboolнесколькими потоками. (В разных операционных системах это осуществляется по-разному, и именно поэтому не просто реализовать переносимую библиотеку потоков.)
   Объектыmutexблокируются и разблокируются, используя несколько различных стратегий блокировки, самой простой из которых является блокировкаscoped_lock.scoped_lock— это класс, при конструировании объекта которого используется аргумент типаmutex,блокируемый до тех пор, пока не будет уничтожена блокировкаlock.Рассмотрим функцию-членenqueueв примере 12.2, которая показывает, какscoped_lockработает совместно с мьютексомmutex_.
   void enqueue(const T& x) {
    boost::mutex::scoped_lock lock(mutex_);
    list_.push_back(x);
   } //разблокировано!
   Когдаlockуничтожается,mutex_разблокируется. Еслиlockконструируется для объектаmutex,который уже заблокирован другим потоком, текущий поток переходит в состояние ожидания до тех пор, покаlockне окажется доступен.
   Такой подход поначалу может показаться немного странным: а почему бы мьютексуmutexне иметь методыlockиunlock?Применение классаscoped_lock,который обеспечивает блокировку при конструировании и разблокировку при уничтожении, на самом деле более удобно и менее подвержено ошибкам. Когда вы создаете блокировку, используяscoped_lock,мьютекс блокируется на весь период существования объектаscoped_lock,т.е. вам не надо ничего разблокировать в явной форме на каждой ветви вычислений. С другой стороны, если вам приходится явно разблокировать захваченный мьютекс, необходимо гарантировать перехват любых исключений, которые могут быть выброшены в вашей функции (или где-нибудь выше ее в стеке вызовов), и гарантировать разблокировкуmutex.При использованииscoped_lock,если выбрасывается исключение или функция возвращает управление, объектscoped_lockавтоматически уничтожается иmutexразблокируется.
   Использование мьютекса позволяет сделать всю работу, однако хочется немного большего. При таком подходе нет различия между чтением и записью, что существенно, таккак неэффективно заставлять потоки ждать в очереди доступа к ресурсу, когда многие из них выполняют только операции чтения, для которых не требуется монопольный доступ. Для этого в библиотеке Boost Threads предусмотрен классread_write_mutex.Пример 12.3 показывает, как можно реализовать пример 12.2, используяread_write_mutexс функцией-членомfront,которая позволяет вызывающей программе получить копию первого элемента очереди без его выталкивания.
   Пример 12.3. Использование мьютекса чтения/записи
   #include&lt;iostream&gt;
   #include&lt;boost/thread/thread.hpp&gt;
   #include&lt;boost/thread/read_write_mutex.hpp&gt;
   #include&lt;string&gt;

   template&lt;typename T&gt;
   class Queue {
    public:
    Queue() : // Использовать мьютекс чтения/записи и придать ему приоритет
              // записи
    rwMutex_(boost::read_write_scheduling_policy::writer_priority) {}
    ~Queue() {}
    void enqueue(const T& x) {
     // Использовать блокировку чтения/записи, поскольку enqueue
     // обновляет состояние
     boost::read_write_mutex::scoped_write_lock writeLock(rwMutex_);
     list_.push_back(x);
    }

    T dequeue() {
     // Снова использовать блокировку для записи
     boost::read_write_mutex::scoped_write_lock writeLock(rwMutex_);
     if (list_.empty())
      throw "empty!";
     T tmp = list_.front();
     list_.pop_front();
     return(tmp);
    }

    T getFront() {
     // Это операция чтения, поэтому требуется блокировка только для чтения
     boost::read_write_mutex::scoped_read_lock.readLock(rwMutex_);
     if (list_.empty())
      throw "empty!";
     return(list_.front());
    }
   private:
    std::list&lt;T&gt; list_;
    boost::read_write_mutex rwMutex_;
   };

   Queue&lt;std::string&gt; queueOfStrings;

   void sendSomething() {
    std::string s;
    for (int i = 0, i&lt; 10; ++i) {
     queueOfStrings.enqueue("Cyrus");
    }
   }

   void checkTheFront() {
    std::string s;
    for (int i=0; i&lt; 10; ++i) {
     try {
      s = queueOfStrings.getFront();
     } catch(...) {}
    }
   }

   int main() {
    boost::thread thr1(sendSomething);
    boost::thread_group grp;
    grp.сreate_thread(checkTheFront);
    grp.create_thread(checkTheFront);
    grp.сreate_thread(checkTheFront);
    grp_create_thread(checkTheFront);
    thr1.join();
    grp.join_all();
   }
   Здесь необходимо отметить несколько моментов. Обратите внимание, что теперь я используюread_write_mutex.
   boost::read_write_mutex rwMutex_;
   При использовании мьютексов чтения/записи блокировки тоже выполняются иначе. В примере 12.3, когда мне нужно заблокироватьQueueдля записи, я создаю объект классаscoped_write_lock.
   boost::read_write_mutex::scoped_write_lock writeLock(rwMutex_);
   А когда мне просто требуется прочитатьQueue,я используюscoped_read_lock.
   boost::read_write_mutex::scoped_read_lock readLock(rwMutex_);
   Блокировки чтения/записи удобны, но они не предохраняют вас от серьезных ошибок. На этапе компиляции не делается проверка ресурса, представленного мьютексомrwMutex_,гарантирующая отсутствие изменения ресурса при блокировке только для чтения. Вы сами должны позаботиться о том, чтобы поток мог модифицировать состояние объекта только при блокировке для записи, поскольку компилятор это не будет делать.
   Точная последовательность выполнения блокировок определяется политикой их планирования; эту политику вы задаете при конструировании объекта mutex. В библиотеке Boost Threads предусматривается четыре политики.
   reader_priority
   Потоки, ожидающие выполнения блокировки для чтения, ее получат раньше потоков, ожидающих выполнения блокировки для записи.
   writer_priority
   Потоки, ожидающие выполнения блокировки для записи, ее получат раньше потоков, ожидающих выполнения блокировки для чтения.
   alternating_single_read
   Чередуются блокировки для чтения и для записи. Один читающий поток получает возможность блокировки для чтения, когда подходит «очередь» читающих потоков. Эта политика в целом отдает приоритет записывающим потокам. Например, если мьютекс заблокирован для записи и имеется несколько потоков, ожидающих блокировки для чтения, атакже один поток, ожидающий блокировки для записи, сначала будет выполнена одна блокировка для чтения, затем блокировка для записи и после нее — все остальные блокировки для чтения. Подразумевается, что за это время не будет новых запросов на блокировку.
   alternating_many_reads
   Чередуются блокировки для чтения и для записи. Выполняются все блокировки для чтения, когда подходит «очередь» читающих потоков. Другими словами, эта политика приводит к опустошению очереди всех потоков, ожидающих блокировки для чтения, в промежутке между блокировками для записи.
   Каждая из этих политик имеет свои достоинства и недостатки, и их влияние будет сказываться по-разному в различных приложениях. Необходимо тщательно подойти к выбору политики, потому что если просто обеспечить приоритет для чтения или записи, это приведет к зависанию, которое я более подробно описываю ниже.Опасности
   При программировании многопоточной обработки возникает три основные проблемы: взаимная блокировка (deadlock), зависание (starvation) и состояния состязания (race conditions — условия гонок). Существуют различные по сложности методы устранения этих проблем, но их рассмотрение выходит за рамки данного рецепта. Я дам описание каждой их этих проблем, чтобы вы знали, чего следует остерегаться, но если вы планируете разработку многопоточного приложения, вам необходимо сначала выполнить некоторое предварительную работу по шаблонам многопоточной обработки.
   Взаимная блокировка связана с наличием, по крайней мере, двух потоков и двух ресурсов. Пусть имеется два потока, А и В, и два ресурса, X и Y, причем поток А блокирует ресурс X, а В блокирует Y. Взаимная блокировка возникает в том случае, когда А пытается заблокировать Y, а В пытается заблокировать X. Если при работе потоков не предусмотреть какой-либо способ устранения взаимных блокировок, они будут ждать бесконечно.
   Библиотека Boost Threads позволяет избегать взаимных блокировок благодаря уточнению концепций мьютекса и блокировки.Пробныймьютекс (try mutex)— это мьютекс, который используется для определения возможности блокировки путем выполненияпробнойблокировки (try lock);она может быть успешной или нет, но не блокирует ресурс, а ждет момента, когда блокировка станет возможной. Применяя модели этих концепций в форме классовtry_mutexиscoped_try_lock,вы можете в своей программе идти дальше и выполнять какие-то другие действия, если доступ к требуемому ресурсу заблокирован. Существует еще одно уточнение концепции пробной блокировки, называемое временной блокировкой (timed lock). Я не рассматриваю здесь подробно временные блокировки; детальное их описание вы найдете в документации библиотеки Boost Threads.
   Например, в классеQueueиз примера 12.2 требуется использовать мьютекс для пробной блокировки с возвратом функциейdequeueзначения типаbool,показывающего, может или не может быть извлечен из очереди первый элемент. В этом случае при применении функцииdequeueне приходится ждать блокировки очереди. Ниже показано, как можно переписать функциюdequeue.
   bool dequeue(T& x) {
    boost::try_mutex::scoped_try_lock lock(tryMutex_);
    if (!lock.locked())
     return(false);
    else {
     if (list_.empty()) throw "empty!";
     x = list_.front();
     list_.pop_front();
     return(true);
    }
   }
   private:
    boost::try_mutex tryMutex_;
    // ...
   Используемые здесь мьютекс и блокировка отличаются от тех, которые применялись в примере 12.2. Убедитесь, что используемые вами имена классов мьютекса и блокировки правильно квалифицированы, в противном случае вы получите не то, на что рассчитываете.
   При сериализации доступа к чему-либо вы заставляете пользователей этого ресурса выстраиваться друг за другом и дожидаться свой очереди. Если положение пользователей ресурса в очереди остается неизменным, каждый из них имеет шанс получения доступа к ресурсу. Однако если некоторым пользователям разрешается сокращать свою очередь, то до находящихся в конце очередь может никогда не дойти. Возникает зависание.
   При использовании мьютекса mutex пользователи ресурса, которые находятся в состоянии ожидания, образуют группу, а не последовательность. Нельзя сказать, что существует определенный порядок между потоками, ожидающими возможности выполнения блокировки. Для мьютексов чтения/записи в библиотеке Boost Threads используется четыре политики планирования блокировок, которые были описаны ранее. Поэтому при использовании мьютексов чтения/записи необходимо понимать смысл различных политик планирования и действий ваших потоков. Если вы используете политикуwriter_priorityи у вас много потоков, создающих блокировки для записи, ваши читающие потоки будут зависать; то же самое произойдет при применении политикиreader_priority,поскольку эти политики планирования всегда отдают предпочтение одному из двух типов блокировки. Если в ходе тестирования вы понимаете, что один из типов потоков продвигается в очереди недостаточно, рассмотрите возможность перехода на применение политикиalternating_many_readsилиalternating_single_read.Тип политики задается при конструировании мьютекса чтения/записи.
   Наконец, состояние состязания возникает в том случае, когда в программе делается предположение об определенном порядке выполнения блокировок или об их атомарности, что оказывается неверным. Например, рассмотрим пользователя классаQueue,который опрашивает первый элемент очереди и при определенном условии извлекает его из очереди с помощью функцииdequeue.
   if (q.getFront() == "Cyrus") {
    str = q.dequeue();
    // ...
   Этот фрагмент программного кода хорошо работает в однопоточной среде, потому чтоqне может быть модифицирован в промежутке между первой и второй строкой. Однако в условиях многопоточной обработки, когда практически в любой момент другой поток может модифицироватьq,следует исходить из предположения, что совместно используемые объекты модифицируются, когда поток не блокирует доступ к ним. После строки 1 другой поток, работая параллельно, может извлечь следующий элемент изqпри помощи функцииdequeue,что означает получение в строке 2 чего-то неожиданного или совсем ничего. Как функцияgetFront,так и функцияdequeueблокирует один объектmutex,используемый для модификацииq,но между их вызовами мьютекс разблокирован, и, если другой поток находится в ожидании выполнения блокировки, он может это сделать до того, как получит свой шанс строка 2.
   Проблема состояния состязания в этом конкретном случае решается путем гарантирования сохранения блокировки на весь период выполнения операции. Создайте функцию-членdequeueIfEquals,которая извлекает следующий объект из очереди, если он равен аргументу. ФункцияdequeueIfEqualsможет использовать блокировку, как и всякая другая функция.
   T dequeueIfEquals(const T& t) {
    boost::mutex::scoped_lock lock(mutex_);
    if (list_.front() == t)
    // ...
   Существуют состояния состязания другого типа, но этот пример должен дать общее представление о том, чего следует остерегаться. По мере увеличения количества потоков и совместно используемых ресурсов состояния состязания оказываются более изощренными и обнаруживать их сложнее. Поэтому следует быть особенно осторожным на этапе проектирования, чтобы не допускать их.
   В многопоточной обработке самое сложное — гарантировать сериализованный доступ к ресурсам, потому что если это сделано неправильно, отладка становится кошмаром.Поскольку многопоточная программа по своей сути недетерминирована (так как потоки могут выполняться в различной очередности и с различными квантами времени при каждом новом выполнении программы), очень трудно точно обнаружить место и способ ошибочной модификации чего-либо. Здесь еще в большей степени, чем в однопоточном программировании, надежный проект позволяет минимизировать затраты на отладку и переработку.
   12.3.Уведомление одного потока другимПроблема
   Используется шаблон, в котором один поток (или группа потоков) выполняет какие-то действия, и требуется сделать так, чтобы об этом узнал другой поток (или группа потоков). Может использоваться главный поток, который передает работу подчиненным потокам, или может использоваться одна группа потоков для пополнения очереди и другая для удаления данных из очереди и выполнения чего-либо полезного.Решение
   Используйте объектыmutexиcondition,которые объявлены вboost/thread/mutex.hppиboost/thread/condition.hpp.Можно создать условие (condition)для каждой ожидаемой потоками ситуации и при возникновении такой ситуации уведомлять все ее ожидающие потоки. Пример 12.4 показывает, как можно обеспечить передачууведомлений в модели потоков «главный/подчиненные».
   Пример 12.4. Передача уведомлений между потоками
   #include&lt;iostream&gt;
   #include&lt;boost/thread/thread.hpp&gt;
   #include&lt;boost/thread/condition.hpp&gt;
   #include&lt;boost/thread/mutex.hpp&gt;
   #include&lt;list&gt;
   #include&lt;string&gt;

   class Request { /*...*/ };

   //Простой класс очереди заданий; в реальной программе вместо этого класса
   //используйте std::queue
   template&lt;typename T&gt;
   class JobQueue {
   public:
    JobQueue() {}
    ~JobQueue() {}

    void submitJob(const T& x) {
     boost::mutex::scoped_lock lock(mutex_);
     list_.push_back(x);
     workToBeDone_.notify_one();
    }

    T getJob() {
     boost::mutex::scoped_lock lock(mutex_);
     workToBeDone_.wait(lock); // Ждать удовлетворения этого условия, затем
                               // блокировать мьютекс
     T tmp = list_.front();
     list_.pop_front();
     return(tmp);
    }

   private:
    std::list&lt;T&gt; list_;
    boost::mutex mutex_;
    boost::condition workToBeDone_;
   };

   JobQueue&lt;Request&gt; myJobQueue;

   void boss() {
    for (;;) {
     // Получить откуда-то запрос
     Request req;
     myJobQueue.submitJob(req);
    }
   }

   void worker() {
    for (;;) {
     Request r(myJobQueue.getJob());
     // Выполнить какие-то действия с заданием...
    }
   }

   int main() {
    boost::thread thr1(boss);
    boost::thread thr2(worker);
    boost::thread thr3(worker);
    thr1.join();
    thr2.join();
    thr3.join();
   }Обсуждение
   Объект условия использует мьютексmutexи позволяет дождаться ситуации, когда он становится заблокированным. Рассмотрим пример 12.4, в котором представлена модифицированная версии классаQueueиз примера 12.2. Я модифицировал очередьQueue,получая более специализированную очередь, а именноJobQueue,объекты которой являются заданиями, поступающими в очередь со стороны главного потока и обрабатываемыми подчиненными потоками.
   Самое важное изменение классаJobQueueсвязано переменной-членомworkToBeDone_типаcondition.Эта переменная показывает, имеется или нет задание в очереди. Когда потоку требуется получить элемент из очереди, он вызывает функциюgetJob,которая пытается захватить мьютекс и затем дожидаться возникновения новой ситуации, что реализуют следующие строки.
   boost::mutex::scoped_lock lock(mutex_);
   workToBeDone_.wait(lock);
   Первая строка блокирует мьютекс обычным образом. Вторая строкаразблокируетмьютекс и переводит его в состояние ожидания или в неактивное состояние до тех пор, пока не будет удовлетворено условие. Разблокирование мьютекса позволяет другим потокам использовать этот мьютекс; один из них должен установить ожидаемое условие, в противном случае другие потоки не смогут блокировать мьютекс, пока один поток ожидает возникновения необходимого условия.
   В функцииsubmitJobпосле помещения задания во внутренний список я добавил следующую строку.
   workToBeDone_.notify_one();
   В результате «удовлетворяется» условие, в ожидании которого находитсяgetJob.Формально это означает, что если существуют какие-нибудь потоки, вызвавшие функциюwaitдля этого условия, то один из них перейдет в состояние выполнения. Для функцииgetJobэто означает продолжение работы, приостановленной в следующей строке:
   workToBeDone_.wait(lock);
   Но это еще не все. Функцияwaitделает две вещи: она дожидается вызова в каком-нибудь потоке функцииnotify_oneилиnotify_allдля данного условия, затем она пытается блокировать соответствующий мьютекс. Поэтому, когдаsubmitJobвызываетnotify_all,фактически происходит следующее: ожидающий поток переходит в состояние выполнения и на следующем шаге пытается блокировать мьютекс, который все еще блокирует функцияsubmitJob,поэтому он вновь переходит в состояние ожидания, пока не завершит работу функцияsubmitJob.Таким образом,condition::waitтребует, чтобы мьютекс был блокирован при его вызове, когда он оказывается разблокированным и затем вновь заблокированным при удовлетворении условия.
   Для уведомления всех потоков, ожидающих удовлетворения некоторого условия, следует вызывать функциюnotify_all.Она работает так же,как notify_one,за исключением того, что в состояние выполнения переходят все потоки, ожидающие это условие. Однако теперь все они будут пытаться выполнить блокировку, поэтому характер последующих действий зависит от типа мьютекса и типа используемой блокировки.
   Применение условия позволяет управлять ситуацией более тонко, чем при использовании одних только мьютексов и блокировок. Рассмотрим представленный ранее классQueue.Потоки, ожидающие получение элемента из очереди, находятся в состоянии ожидания до тех пор, пока они не смогут установить блокировку для записи и затем извлечь элемент из очереди. Может показаться, что это будет хорошо работать без применения какого-либо механизма сигнализации, но так ли на самом деле? А что произойдет, когда очередь окажется пустой? У вас нет большого выбора при реализации функцииdequeue,если вы ждете удовлетворения некоторого условия: проверка наличия элементов в очереди и, если они отсутствуют, возврат управления; использование другого мьютекса, который блокируется при пустой очереди и разблокируется, когда очередь содержит данные (не подходящее решение) или возврат специального значения, когда очередь оказывается пустой. Все это проблематично или неэффективно. Если вы просто возвращаете управление, когда очередь пустая, выбрасывая исключение или возвращая специальное значение, то вашим клиентам придется постоянно проверять поступающие значения. Это означает бесполезную трату времени.
   Объектconditionпозволяет пользовательским потокам находиться в неактивном состоянии, поэтому процессор может выполнять что-то другое, когда условие не удовлетворяется. Представим веб-сервер, использующий пул рабочих потоков, обрабатывающих поступающие запросы. Значительно лучше иметь дочерние потоки, находящиеся в состоянии ожидания, когда нет никакой активности, чем заставлять их выполнять бесконечный цикл или «засыпать» и «просыпаться» периодически для проверки очереди.
   12.4.Однократная инициализация совместно используемых ресурсовПроблема
   Имеется несколько потоков, использующих один ресурс, который необходимо инициализировать только один раз.Решение
   Либо инициализируйте этот ресурс до запуска потоков, либо, если первое невозможно, используйте функциюcall_once,определенную в&lt;boost/thread/once.hpp&gt;,и типonce_flag.Пример 12.5 показывает, как можно использоватьcall_once.
   Пример 12.5. Однократная инициализация
   #include&lt;iostream&gt;
   #include&lt;boost/thread/thread.hpp&gt;
   #include&lt;boost/thread/once.hpp&gt;

   //Класс, обеспечивающий некоторое соединение, которое должно быть
   //инициализировано только один раз
   struct Conn {
    static void init() {++i_;}
    static boost::once_flag init_;
    static int i_;
    // ...
   };

   int Conn::i_ = 0;
   boost::once_flag Conn::init_ = BOOST_ONCE_INIT;

   void worker() {
    boost::call_once(Conn::init, Conn::init_);
    // Выполнить реальную работу...
   }

   Connс; // Возможно, вы не захотите использовать глобальную переменную,
           // тогда см. следующий рецепт

   int main() {
    boost::thread_group grp;
    for (int i=0; i&lt; 100; ++i) grp.create_thread(worker);
    grp.join_all();
    std::cout&lt;&lt;с.i_&lt;&lt; '\n'; // c.i = i
   }Обсуждение
   Совместно используемый ресурс должен где-то инициализироваться, и, возможно, вы захотите, чтобы это сделал тот поток, который первым стал его использовать. Переменная типаonce_flag (реальный ее тип зависит от платформы) и функцияcall_onceмогут предотвратить повторную инициализацию объекта. Вам придется сделать две вещи.
   Во-первых, проинициализируйте вашу переменнуюonce_flagс помощью макропеременнойBOOST_ONCE_INIT.Значение этой макропеременной зависит от платформы. В примере 12.5 классConnпредставляет собой некоторое соединение (базы данных, сокета, оборудования и т.д.), которое я хочу инициализировать лишь однажды, несмотря на то, что несколько потоков могут пытаться сделать то же самое. Подобная ситуация возникает довольно часто, когда требуется динамически загружать библиотеку, имя которой может быть задано, например, в конфигурационном файле приложения. Флагonce_flag— это переменная статического класса, потому что мне требуется только однократная инициализация независимо от количества существующих экземпляров этого класса.Поэтому я следующим образом устанавливаю этот флаг в начальное значениеBOOST_ONCE_INIT.
   boost::once_flag Conn::initFlag_ = BOOST_ONCE_INIT;
   Затем в моей рабочей функции я вызываюcall_once,которая синхронизирует доступ к моему инициализированному флагу и, следовательно, предотвращает параллельное выполнение другой инициализации. Я передаю вcall_onceдва аргумента:
   boost::call_once(Conn::init, Conn::initFlag_);
   Первым аргументом является адрес функции, которая будет выполнять инициализацию. Второй аргумент — это флаг. В данном случае несколько потоков могут попытаться выполнить инициализацию, но только первый в этом преуспеет.
   12.5.Передача аргумента функции потокаПроблема
   Требуется передать аргумент в вашу функцию потока, однако средствами библиотеки Boost Threads предусматривается передача только функторов без аргументов.Решение
   Создайте адаптер функтора, который принимает ваши параметры и возвращает функтор без параметров. Адаптер функтора можно использовать там, где должен был бы быть функтор потока. Пример 12.6 показывает, как это можно сделать.
   Пример 12.6. Передача аргументов функции потока
   #include&lt;iostream&gt;
   #include&lt;string&gt;
   #include&lt;functional&gt;
   #include&lt;boost/thread/thread.hpp&gt;

   // typedefиспользуется для того, чтобы приводимые ниже объявления лучше
   //читались
   typedef void (*WorkerFunPtr)(const std::string&);

   template&lt;typename FunT, //Тип вызываемой функции
    typename ParamT&gt;       // тип ее параметра
   struct Adapter {
    Adapter(FunT f, ParamT& p) : //Сконструировать данный адаптер и
     f_(f), p_(&p) {}            // установить члены на значение функции и ее
                                 // аргумента
    void operator()() { // Просто вызов функции с ее аргументом
     f_(*p_);
    }
   private:
    FunT f_;
    ParamT* p_; // Использовать адрес параметра. чтобы избежать лишнего
                // копирования
   };

   void worker(const std::string& s) {
    std::cout&lt;&lt; s&lt;&lt; '\n';
   }

   int main() {
    std::string s1 = "This is the first thread!";
    std::string s2 = "This is the second thread!";
    boost::thread thr1(Adapter&lt;WorkerFunPtr, std::string&gt;(worker, s1));
    boost::thread thr2(Adapter&lt;WorkerFunPtr, std::string&gt;(worker, s2));
    thr1.join();
    thr2.join();
   }Обсуждение
   Здесь приходится решать принципиальную проблему, причем характерную не только для потоков или проекта Boost, а общую проблему, возникающую при необходимости передачи функтора с одной сигнатурой туда, где требуется другая сигнатура. Решение состоит в создании адаптера.
   Синтаксис может показаться немного путаным, но фактически в примере 12.6 создается временный функтор, который может вызываться конструктором потока как функция без аргументов (требуется именно такая функция). Но прежде всего используйтеtypedef,чтобы указатель функции лучше воспринимался в тексте.
   typedef void (*WorkerFunPtr)(const std::string&);
   Это создает типWorkerFunPtr,который является указателем на функцию, принимающую по ссылке аргумент типаstringи возвращающую типvoid.После этого я создал шаблон классаAdapter.Он обеспечивает инстанцирование динамического функтора. Обратите внимание на конструктор:
   template&lt;Typename FunT,
    typename ParamT&gt;
   struct Adapter {
    Adapter(FunT f, ParamT& p) : f_(f), p_(&p) {}
    // ...
   Конструктор только инициализирует два члена, которые могут быть любого типа, но нам нужно, чтобы это был указатель на функцию и некоторый параметрpлюбого типа. Ради повышения эффективности я сохраняю адрес параметра, а не его значение.
   Теперь рассмотрим следующую строку главного потока.
   boost::thread thr1(Adapter&lt;WorkerFunPtr, std::string&gt;(worker, s1))
   Аргумент конструктораthr1представляет собой реализацию шаблона классаAdapter,использующую в качестве параметров два типаWorkerFunPtrиstd::string.Это именно те два типа, которые являются членами адаптераf_иp_.Наконец,Adapterперегружаетoperator(),поэтому он может вызываться как функция. Его вызов означает просто выполнение следующей функции.
   f_(*p_);
   Применяя шаблон классаAdapter,можно передавать аргументы функциям потока, причем делается это за счет лишь небольшого усложнения синтаксиса. Если требуется передавать еще один аргумент, просто добавьте дополнительный тип и переменную-член в шаблонAdapter.Этот подход привлекателен тем, что позволяет создавать набор шаблонов классов обобщенного адаптера и использовать их в различных контекстах.
   Глава 13
   Интернационализация
   13.0.Введение
   В данной главе приводятся решения некоторых задач, которые обычно возникают при интернационализации программ С++. Обеспечение возможности работы программы в различных регионах (это обычно называетсялокализацией),как правило, требует решения двух задач: форматирования строк, воспринимаемых пользователем, в соответствии с местными соглашениями (например, даты, времени, денежных сумм и чисел) и обеспечения работы с различными символьными наборами. В настоящей главе рассматривается в основном первая проблема и только кратко вторая, потому что имеется немного возможностей по стандартизации поддержки различных символьных наборов из-за того, что такая поддержка во многом зависит от реализации.
   Большая часть программного обеспечения будет работать в странах, отличных от той, где они были написаны. Для поддержки этой практики стандартная библиотека C++ имеет несколько средств, способствующих написанию программного кода, предназначенного для работы в различных странах. Однако они спроектированы не так. как многие другие средства стандартной библиотеки, например строки, файловый ввод-вывод, контейнеры, алгоритмы и т.п. Например, класс, представляющий локализацию, имеет имяlocaleи содержится в заголовочном файле&lt;lосаlе&gt;.Классlocaleпредоставляет средства для записи и чтения потоков с применением специфичного для данной местности форматирования и получения таких сведений о локализации, как, например, ее символ валюты или формат даты. Однако стандартом предусматривается обеспечение только одной локализации, и этой локализацией является «C»-локализация, или классическая локализация. Классическая локализация использует стандарт ANSI С: принятые в американском варианте английского языка соглашения по форматированию и 7-битовой код ASCII. И от реализации зависит, будут ли обеспечены экземпляры locale для других языков и регионов.
   Заголовочный файл&lt;locale&gt;имеет три основные части. Во-первых, это классlocale (локализация). Он инкапсулирует все поддерживаемые в C++ особенности локализованного поведения и обеспечивает точки входа для получения различной информации о локализации, необходимой для выполнения локализованного форматирования. Во-вторых, самыми маленькими элементами локализации и конкретными классами, с которыми вы будете работать, являются классы, называемыефасетами (facets).Примером фасета является, например, классtime_put,предназначенный для записи даты в поток. В-третьих, каждый фасет принадлежит к некоторой категории, которая объединяет связанные фасеты в одну группу. Например, имеются числовая, временная и денежная категории (только что упомянутый мною фасетtime_putотносится к временной категории). Я кратко описываю категории в данной главе, однако действительную пользу они приносят при осуществлении более изощренных действий, связанных с локализацией.
   Каждая программа на C++ имеет, по крайней мере, одну локализацию, называемую глобальной локализацией (она часто реализуется как глобальный статический объект). По умолчанию это будет классическая локализация «С», пока вы не измените ее на что- нибудь другое. Один из конструкторовlocaleпозволяет инстанцировать локализацию, предпочитаемую пользователем, хотя точное определение «предпочитаемой» пользователем локализации полностью зависит от реализации.
   В большинстве случаев локализации используются при записи и чтении потоков. Это является основной темой настоящей главы.
   13.1.Жесткое кодирование строк в коде UnicodeПроблема
   Требуется в исходном файле жестко закодировать строки в коде Unicode, т.е. используя расширенный набор символов.Решение
   Начинайте строку с префиксаLи затем вводите символы в своем редакторе исходных текстов, как вы это обычно делаете при написании строк, или используйте шестнадцатеричные значения, представляющие нужный вам символ в коде Unicode. Пример 13.1 демонстрирует оба способа кодирования таких строк.
   Пример 13.1. Жесткое кодирование строк в коде Unicode
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;string&gt;

   using namespace std;

   int main() {
    // Создать несколько строк с символами кода Unicode
    wstring ws1 = L"Infinity: \u221E";
    wstring ws2 = L"Euro: €"
    wchar_t w[] = L"Infinity: \u221E";
    wofstream out("tmp\\unicode.txt");
    out&lt;&lt; ws2&lt;&lt; endl;
    wcout&lt;&lt; ws2&lt;&lt; endl;
   }Обсуждение
   Основной вопрос, возникающий при жестком кодировании строк в коде Unicode, связан с выбором способа ввода строки в редакторе исходных текстов. В C++ предусмотрен тип расширенного набора символовwchar_t,который может хранить строки в коде Unicode. Точное представлениеwchar_tзависит от реализации, однако часто используется формат UTF-32. Классwstringопределяется в&lt;string&gt;как последовательность символов типаwchar_t,подобно тому как классstringпредставляет собой последовательность символов типаchar. (Строго говоря, типwstringопределяется, конечно, с помощьюtypedefкакbasic_string&lt;wchar_t&gt;.)
   Самый простой способ ввода символов в коде Unicode — это использование префиксаLперед строковым литералом, как показано в примере 13.1.
   wstring ws1 = L"Infinity, \u2210"; //Использовать сам код
   wstring ws2 = L"Euro:€"; // или просто ввести символ
   Теперь можно записать эти строки с расширенным набором символов в поток с расширенным набором символов.
   wcout&lt;&lt; ws1&lt;&lt; endl; // wcout -версия cout для расширенного набора символов
   Их можно записывать также в файлы:
   wofstream out("tmp\\unicode.txt");
   out&lt;&lt; ws2&lt;&lt; endl;
   При работе с различными кодировками наибольшую ловкость приходится проявлять не для ввода правильных символов в ваши исходные файлы, а при определении типа символьных данных, получаемых из базы данных, по запросу HTTP, из пользовательского ввода и т.д., что выходит за рамки стандарта C++. Стандарт C++ не устанавливает никаких специальных требований, кроме того, что операционная система может использовать для исходных файлов любую кодировку, если она поддерживает, по крайней мере, 96 символов,используемых в языке С++. Для символов, не попадающих в этот набор, называемыйосновным исходным набором символов,стандартом предусматривается возможность их получения с помощью escape-последовательностей\uXXXXили\UXXXXXXXX,гдеX— шестнадцатеричная цифра.
   13.2.Запись и чтение чиселПроблема
   Требуется записать число в поток в форматированном виде в соответствии с местными соглашениями.Решение
   Закрепите (imbue) текущую локализацию за потоком, в который вы собираетесь писать данные, и запишите в него числа, как это сделано в примере 13.2, или можете установить глобальную локализацию и затем создать поток. Последний подход рассматривается в обсуждении.
   Пример 13.2. Запись чисел с использованием локализованного форматирования
   #include&lt;iostream&gt;
   #include&lt;locale&gt;
   #include&lt;string&gt;

   using namespace std;

   //На заднем плане существует глобальная локализация, установленная средой
   //этапа выполнения. По умолчанию это локализация "С". Вы можете ее
   //заменить локализацией locale::global(const locale&).
   int main() {
    locale loc(""); // Создать копию пользовательской локализации
    cout&lt;&lt; "Locale name = "&lt;&lt; loc.name()&lt;&lt; endl;
    cout.imbue(loc); // Уведомить cout о необходимости применения
                     // пользовательской локализации при форматировании
    cout&lt;&lt; "pi in locale "&lt;&lt; cout.getloc().name()&lt;&lt; " is&lt;&lt; 3.14&lt;&lt; endl;
   }Обсуждение
   Пример 13.2 показывает, как можно использовать пользовательскую локализацию для форматирования числа с плавающей точкой. Это делается в два этапа: сначала создается экземпляр классаlocale,который затем закрепляется за потоком с помощью функцииimbue.
   Сначала в примере 13.2 создаетсяloc,который является копией пользовательской локализации. Это необходимо делать, используя конструкторlocale,принимающий пустую строку (а не конструктор по умолчанию).
   locale loc("");
   Отличие небольшое, но важное, и я вскоре вернусь к нему. При создании здесь объектаlocaleсоздается копия «пользовательской локализации», которая зависит от реализации. Это значит, что, если машина сконфигурирована на применение американского варианта английского языка, функцияlocale::name()может возвращать такие строковые имена локализации, как «en_US», «English_United States.1252», «english-american» и т.д. Реальная строка определяется реализацией, а по стандарту C++ достаточно иметь только одну локализацию — «C»-локализацию.
   Для сравнения отметим, что конструктор по умолчанию классаlocaleвозвращает копию текущейглобальнойлокализации. Всякая выполняемая программа, написанная на С++, имеет один глобальный объектlocale (возможно, реализованный как статическая переменная где-то в библиотеке этапа выполнения; детали его реализации зависят от используемой платформы). По умолчанию это будет локализация С, и вы можете заменить ее локализациейlocale::global(locale& loc).Когда потоки создаются, они используют глобальную локализацию, существующую на момент их создания; это означает, чтоcin,cout,cerr,wcin,wcoutиwcerrиспользуют локализацию С, поэтому приходится явным образом ее менять, если требуется, чтобы форматирование подчинялось соглашениям, принятым в определенной местности.
   Имена локализаций не стандартизованы. Однако обычно они имеют следующий формат.
   &lt;язык&gt;_&lt;страна&gt;.&lt;кодовая_страница&gt;
   Язык задается полным названием, например «Spanish», или двухбуквенным кодом, например «sp»; страна задается своим названием, например «Colombia», или двухбуквенным кодом страны, например «СО», а кодовая страница задается своим обозначением, например1252.Обязательно должен быть указан только язык. Поэкспериментируйте, явно задавая локализации в различных системах, чтобы почувствовать характер отличий имен при применении разных компиляторов. Если вы используете неверное имя локализации, будет выброшено исключениеruntime_error.Пример 13.3 показывает, как можно явно задавать имена локализаций.
   Пример 13.3. Явное именование локализаций
   #include&lt;iostream&gt;
   #include&lt;fstream&gt;
   #include&lt;locale&gt;
   #include&lt;string&gt;

   using namespace std;

   int main() {
    try {
     locale loc("");
     cout&lt;&lt; "Locale name = "&lt;&lt; loc.name()&lt;&lt; endl;
     locale locFr("french");
     locale locEn("english-american");
     locale locBr("portuguese-brazilian");
     cout.imbue(locFr); // Уведомить cout о необходимости применения
                        // французского форматирования
     cout&lt;&lt; "3.14 (French) = "&lt;&lt; 3.14&lt;&lt; endl;
     cout&lt;&lt; "Name = "&lt;&lt; locFr.name()&lt;&lt; endl;
     cout.imbue(locEn); // Теперь перейти на английский (американский
                        // вариант)
     cout&lt;&lt; "3.14 (English) = "&lt;&lt; 3.14&lt;&lt; endl;
     cout&lt;&lt; "Name = "&lt;&lt; locEn.name()&lt;&lt; endl;
     cout.imbue(locBr); // Уведомить cout о необходимости применения
                        // бразильского форматирования
     cout&lt;&lt; "3.14 (Brazil) = "&lt;&lt; 3.14&lt;&lt; endl;
     cout&lt;&lt; "Name = "&lt;&lt; locBr.name()&lt;&lt; endl;
    } catch (runtime_error& e) {
     // Если используется неверное имя локализации, выбрасывается исключение
     // runtime_error.
     cerr&lt;&lt; "Error: "&lt;&lt; e.what()&lt;&lt; endl;
    }
   }
   Результат выполнения этой программы в системе Windows при использовании Visual C++ 7.1 выглядит следующим образом.
   Locale name = English_United States.1252
   3.14 (French) = 3,14
   Name = French_France.1252
   3.14 (English) = 3.14
   Name = English_United States.1252
   3.14 (Brazil) = 3,14
   Name = Portuguese_Brazil.1252
   Отсюда видно, что моя машина локализована на американский вариант английского языка с использованием кодовой страницы 1252. Этот пример также показывает, как выводится число «пи» при использовании двух других локализаций. Обратите внимание, что во французском и бразильском вариантах применяется запятая вместо десятичной точки. Разделитель тысяч тоже другой: во французском и португальском вариантах используется пробел вместо запятой, поэтому число 1,000,000.25, представленное в американском формате, имело бы вид 1 000 000,25 в формате французской и португальской локализации.
   В большинстве случаев все же не стоит создавать локализации, явно задавая их имена. Чтобы использовать локализации для печати чисел, дат, денежных и каких-либо других значений, просто достаточно инстанцировать локализацию, используя пустую строку и закрепляя ее за потоком.
   Правила применения локализаций могут показаться немного путанными, поэтому я кратко изложу основные моменты.
   • Используемая по умолчанию глобальная локализация является локализацией «С», потому что стандартом гарантируется существование в любой реализации только этойлокализации.
   • Все стандартные потоки создаются с применением глобальной локализации при запуске программы, и этой локализацией является локализация «С».
   • Копию пользовательской текущей локализации можно создать, передавая пустую строку конструкторуlocale,напримерlocale("").
   • Объектlocaleдля именованной локализации можно создать, передавая строку, идентифицирующую локализацию, напримерlocale("portuguese-brazilian").Однако эти строки не стандартизованы.
   • После получения объектаlocale,представляющего стандартную пользовательскую локализацию или именованную локализацию, можно установить глобальную локализацию с помощью функцииlocale::global.Все создаваемые после этого потоки будут использовать глобальную локализацию.
   • Для потока локализацию можно задать явно при помощи функции-членаimbue.
   При написании программного обеспечения, учитывающего местные особенности, применяйте локализованное форматирование только к данным, которые пользователь видит.То есть если вам требуется отобразить число в формате, привычном для пользователя, инстанцируйте локализацию и закрепите ее за потоком, чтобы число отображалось правильно. Однако, если вы записываете данные в файл или в какую-то другую промежуточную сериализованную память, используйте локализацию С, обеспечивая переносимость. Если ваша программа явным образом изменяет глобальную локализацию, вам необходимо явно закрепить ее за потоками, использующими локализацию С. Вы это можете сделать двумя способами: создавая локализацию с именем «С» или вызывая функциюlocale::classic().
   ofstream out("data.dat");
   out.imbue(locale::classic());
   out&lt;&lt; pi&lt;&lt; endl; //Записать, используя локализацию С
   Считываются числа аналогично. Например, для чтения числа с использованием французской локализации и записи его с использованием локализации С выполните следующее.
   double d;
   cin.imbue(locale("french"));
   cin&gt;&gt; d;
   cout&lt;&lt; "In English: "&lt;&lt; d;
   Если вы выполните эту программу и введете300,00,она распечатает300.
   Чтобы поток подчинялся местным соглашениям по выводу чисел, явно закрепите за потоком объектlocaleцелевой локализации с помощью функцииimbue.Если требуется во всех созданных потоках использовать конкретную локализацию, сделайте ее глобальной. Значения денежных значений обрабатываются немного по-другому; см. рецепт 13.4, где показано, как можно записывать и считывать денежные значения.Смотри также
   Рецепт 13.4.
   13.3.Запись и чтение дат и временПроблема
   Требуется отобразить или прочитать значения дат и времен, используя местные соглашения по форматированию.Решение
   Используйте типtime_tиtm structиз&lt;ctime&gt;,а также фасеты даты и времени, предусмотренные в&lt;locale&gt;,для записи и чтения дат и времен (фасеты вскоре будут рассмотрены при обсуждении примера). См. пример 13.4.
   Пример 13.4. Запись и чтение дат
   #include&lt;iostream&gt;
   #include&lt;ctime&gt;
   #include&lt;locale&gt;
   #include&lt;sstream&gt;
   #include&lt;iterator&gt;

   using namespace std;

   void translateDate(istream& in, ostream& out) {
    // Создать считывающий дату объект
    const time get&lt;char&gt;& dateReader =
     use_facet&lt;time_get&lt;char&gt;&gt;(in.getloc());

    // Создать объект состояния который будет использован фасетом для
    // уведомления нас о возникновении проблемы
    ios_base::iostate state = 0;
    // Маркер конца
    istreambuf_iterator&lt;char&gt; end;
    tm t; // Структура для представления времени (из&lt;ctime&gt;)

    // Теперь, когда все подготовлено, считать дату из входного потока
    // и поместить ее в структуру времени.
    dateReader.get_date(in, end, in, state,&t);

    // В данный момент дата находится в структуре tm. Вывести ее в поток,
    // используя соответствующую локализацию. Убедитесь, что выводятся только
    // достоверные данные из t.
    if (state == 0 || state == ios_base::eofbit) { // Чтение выполнено успешно.
     const Time_put&lt;char&gt;& dateWriter =
      use_facet&lt;time_put&lt;char&gt;&gt;(out.getloc());
     char fmt[] = "%x";
     if (dateWriter.put{out, out, out.fill(),
     &t,&fmt[0],&fmt[2]).failed())
      cerr&lt;&lt; "Unable to write to output stream.\n";
    } else {
     cerr&lt;&lt; "Unable to read cin!\n";
    }
   }

   int main() {
    cin.imbue(locale("english"));
    cout.imbue(locale("german"));
    translateDate(cin, cout);
   }
   Эта программа выдает следующий результат
   3/28/2005
   28.03.2005Обсуждение
   Для правильной записи и чтения значений даты и времени необходимо знать некоторые детали проекта классаlocale.Прочтите введение в эту главу, если вы еще не знакомы с концепциями локализаций и фасетов.
   В C++ нет стандартного класса для представления даты и времени, а наиболее подходящими для этого типами являютсяtime_tи структураtmиз&lt;ctime&gt;.Если требуется записывать и считывать даты с использованием средств стандартной библиотеки, вам придется любое нестандартное представление даты преобразовывать в структуруtm.Это имеет смысл, поскольку используемые вами реализации, вероятно, уже имеют встроенную поддержку форматирования дат с учетом местных особенностей.
   Ранее я говорил, что фасет определяет некоторый аспект локализации, отражающий ее особенности. Более конкретно, фасет — это константная инстанциация шаблона класса символьного типа, поведение которого зависит от класса локализации, используемого при конструировании. В примере 13.4 я следующим образом создаю экземпляр фасетаtime_get.
   const time_get&lt;char*&gt;& dateReader =
    use_facet&lt;time_get&lt;char&gt;&gt;(in.getloc());
   Шаблон функцииuse_facetнаходит заданный фасет для заданной локализации. Все стандартные фасеты являются шаблонами классов, которые принимают параметр символьного типа, и, поскольку мною считываются и записываются символы типаchar,я инстанцирую мой классtime_getдляchar.Стандарт требует, чтобы реализация обеспечивала специализацию шаблона дляcharиwchar_t,поэтому они гарантированно существуют (хотя не гарантируется поддержка заданной локализации, кроме локализации С). Созданный мною объектtime_getимеет спецификаторconst,потому что предусмотренная реализацией функциональность локализации это набор правил форматирования различного вида данных в разных локализациях, и эти правилане могут редактироваться пользователем, поэтому состояние заданного фасета не должно изменяться в программном коде, где он используется.
   Локализация, передаваемая мною в функциюuse_facet,связана с потоком, в который я собираюсь записывать данные. Функцияgetloc()объявляется вios_base;она возвращает локализацию, связанную с потоком ввода или вывода. Наилучший подход — применение локализации, уже связанной с потоком, который вы собираетесь использовать для ввода или вывода данных; передача в качестве параметра или каким-либо другим способом имени локализации легко приводит к ошибкам.
   После создания объекта, который будет выполнять реальное чтение, мне необходимо обеспечить контроль состояния потока.
   ios_base::iostate state = 0;
   Сами фасеты не модифицируют состояние потока (например, устанавливаяstream::failbit = 1);вместо этого они установят соответствующее значение в вашем объекте состояния, показывая, что дату нельзя считывать. Это объясняется тем, что чтение форматированного значения терпит неудачу не обязательно из-за потока; поток ввода символов может быть в полном порядке, однако его чтение с использованием нужного вам формата может оказаться невозможным.
   Реальное значение даты хранится в структуреtm.Вам требуется только создать локальную переменную типа tm и передать ее адрес фасетуtime_getилиtime_put.
   Считав дату, я могу проверить значение переменной, которую я использую для контроля состояния потока. Если это значение равно нулю илиios_base::eofbit,то это говорит о том, что поток находится в нормальном состоянии и что моя дата была считана без проблем. Поскольку в примере 13.4 мне нужно было записать дату в другой поток, пришлось создать объект, используемый именно для этой цели. Я делаю это следующим образом.
   const time_put&lt;char&gt;& dateWriter =
   use_facet&lt;time_put&lt;char&gt;&gt;(out.getloc());
   Это работает так же, как и предыдущая инстанциация классаtime_get,но в другом направлении. После этого я создал строку форматирования (используя синтаксис, подобный применяемому в функцииprintf),которая будет печатать дату. «%x» выводит дату, а «%X» выводит время. Однако следует быть осторожным: в этом примере считывается только дата, поэтому члены структурыtm,относящиеся ко времени, в этот момент имеют неопределенные значения.
   Теперь можно писать данные в поток вывода. Это делается следующим образом.
   if (dateWriter.put(out, //Итератор потока вывода
    out,                   // Лоток вывода
    out.fill(),            // Использовать символ заполнителя
    &t,                    // Адрес структуры tm
    &fmt[0],               // Начало и конец строки форматирования
    &fmt[2]
   ).failed())             // iter_type.failed() показывает, была или
                           // нет ошибка при записи
   Функцияtime_put::putзаписывает дату в переданный ей поток вывода, используя локализацию, с которой был создан объектtime_put.time_put::putвозвращает итераторostreambuf_iterator,который имеет функцию-членfailed,позволяющую зафиксировать ситуацию, когда итератор оказывается испорченным.
   get_dateне единственная функция-член, которую можно использовать для получения компонент даты из потока. Ниже перечислены некоторые из них.
   get_date
   Получает дату из потока, используя местные правила форматирования.
   get_time
   Получает время из потока, используя местные правила форматирования.
   get_weekday
   Получает название дня недели, например Monday, lundi, понедельник.
   get_year
   Получает год, используя местные правила форматирования.
   Может быть полезной также функция-членdate_order.Она возвращает перечисление (time_base::dateorderиз&lt;locale&gt;),которое определяет порядок месяца, дня и года в дате. Эта функция может помочь в тех случаях, когда вам приходится анализировать вывод даты, полученной функциейtime_get::put.Пример 13.5 показывает, как можно проверять порядок элементов, составляющих дату.
   Пример 13.5. Определение последовательности элементов в дате
   #include&lt;iostream&gt;
   #include&lt;locale&gt;
   #include&lt;string&gt;

   using namespace std;

   int main() {
    cin.imbue(locale("german"));
    const time_get&lt;char&gt;& dateReader =
     use_facet&lt;time_get&lt;char&gt;&gt;(cin.getloc());
    time_base::dateorder d = dateReader.date_order();
    string s;
    switch (d) {
    case time_base::no_order:
     s = "No order";
     break;
    case time_base::dmy:
     s = "day/month/year";
     break;
    case time_base::mdy:
     s = "month/day/year";
     break;
    case time_base::ymd:
     s = "year/month/day";
     break;
    case time_base::ydm:
     s = "year/day/month";
     break;
    }
    cout&lt;&lt; "Date order for locale "&lt;&lt; cin.getloc().name()
    &lt;&lt; " is "&lt;&lt; s&lt;&lt; endl;
   }
   Имеется еще одно средство, которое может оказаться полезным при инстанцировании фасетов:has_facet.Шаблон этой функции возвращает значение типаbool,показывающее, определен или нет нужный вам фасет в заданной локализации. Поэтому для надежности используйтеhas_facetво всех случаях, когда вы инстанцируете фасет. Если она возвращает значение «ложь», вы всегда можете перейти к используемой по умолчанию классической локализации С, поскольку ее наличие гарантировано в реализации, отвечающей требованиям стандарта.has_facetприменяется следующим образом.
   if (has_facet&lt;time_put&lt;char&gt;&gt;(loc)) {
    const time_put&lt;char&gt;& dateWriter =
     use_facet&lt;time_put&lt;char&gt;&gt;(loc);
   Разобравшись однажды в синтаксисе классовtime_getиtime_put,вы поймете, что использовать их достаточно просто. Как всегда, можно воспользоватьсяtypedef,чтобы свести к минимуму количество неприятных угловых скобок.
   typedef time_put&lt;char&gt; TimePutNarrow;
   typedef time_get&lt;char&gt; TimeGetNarrow;
   // ...
   const TimeGetNarrow& dateReader = use_facet&lt;TimeGetNarrow&gt;(loc);
   Процедура записи и чтения дат в локализованных форматах немного утомительна, однако, после того как вы один раз разберетесь в требованиях класса локализацииlocale,вы сможете это делать эффективно и быстро. Глава 5 полностью посвящена датам и временам, поэтому более детальные сведения по форматированию вывода дат и времен вы найдете в рецепте 5.2.Смотри также
   Глава 5 и рецепт 5.2.
   13.4.Запись и чтение денежных значенийПроблема
   Требуется записать в поток или прочитать из него денежное значение.Решение
   Используйте фасетыmoney_putиmoney_getдля записи или чтения денежных значений, как показано в примере 13.6.
   Пример 13.6. Запись и чтение денежных значений
   #include&lt;iostream&gt;
   #include&lt;locale&gt;
   #include&lt;string&gt;
   #include&lt;sstream&gt;

   using namespace std;

   long double readMoney(istream& in, bool intl = false) {
    long double val;
    // Создать фасет для чтения
    const money_get&lt;char&gt;& moneyReader =
     use_facet&lt;money_get&lt;char&gt;&gt;(in.getloc());
    // Маркер конца
    istreambuf iterator&lt;char&gt; end;
    // Переменная состояния для обнаружения ошибок
    ios_base::iostate state = 0;
    moneyReader.get(in, end, intl, in, state, val);
    // если что-то не получилось, будет установлен бит неудачного завершения
    if (state != 0&& !(state& ios_base::eofbit))
     throw "Couldn't read money!\n";
    return(val);
   }

   void writeMoney(ostream& out, long double val, bool intl = false) {
    // Создать фасет для записи
    const money_put&lt;char&gt;& moneyWriter =
     use_facet&lt;money_put&lt;char&gt;&gt;(out.getloc());
    // Записать данные в поток. Вызвать failed() (возвращает итератор
    // ostreambuf_iterator), чтобы можно было обнаружить ошибку.
    if (moneyWriter.put(out, intl, out, out.fill(), val).failed())
     throw "Couldn't write money!\n";
   }

   int main() {
    long double val = 0;
    float exchangeRate = 0.775434f; // Курс доллара по отношению к евро
    locale locEn("english");
    locale locFr("french");
    cout&lt;&lt; "Dollars: ";
    cin.imbue(locEn);
    val = readMoney(cin, false);
    cout.imbue(locFr);
    // Установить флаг showbase, чтобы выводить символ валюты
    cout.setf(ios_base::showbase);
    cout&lt;&lt; "Euros: ";
    writeMoney(cout, val = exchangeRate, true);
   }
   Если выполнить программу примера 13.6, можно получить следующий результат.
   Dollars: $100
   Euros: EUR77,54Обсуждение
   Фасетыmoney_putиmoney_getзаписывают форматированные денежные значения в поток и считывают их из потока. Они работают почти так же, как фасеты даты/времени и числовые фасеты, описанные в предыдущих рецептах. Стандарт требует, чтобы были их реализации для стандартных символов и расширенного набора символов, напримерmoney_put&lt;char&gt;иmoney_put&lt;wchar_t&gt;.Как и для других фасетов, функции записи и чтения многословны, но, применив их несколько раз, легко запоминаешь параметры.money_getиmoney_putиспользуют классmoneypunct,содержащий информацию о форматировании.
   Сначала рассмотрим запись денежных значений в поток. Отображение денежной суммы состоит из нескольких частей: знака валюты, знака плюс или минус, разделителя тысяч и десятичной точки. Все они, кроме десятичной точки, могут отсутствовать.
   Вы создаете объектmoney_putс типом символа и локализацией следующим образом.
   const money_put&lt;char&gt;& moneyWriter =
    use_facet&lt;money_put&lt;char&gt;&gt;(out.getloc());
   Стандарт требует наличия версий как дляchar,так и дляwchar_t.Разумно использовать локализацию потока, в который осуществляется запись, чтобы избежать несогласованности, возникающей при попытке синхронизации потока и объектаmoney_put.На следующем шаге вызовите метод put для записи денежного значения в поток вывода.
   if (moneyWriter.put(out, //Итератор вывода
    intl,                   // bool: использовать формат intl?
    out,                    // ostream&
    out.fill(),             // использовать символ заполнителя
    val)                    // денежное значение, тип long double
   .failed()) throw "Couldn't write money!\n";
   Функцияmoney_put::putзаписывает денежное значение в переданный ей поток вывода, используя локализацию, с которой был создан объектmoney_put.money_put::putвозвращает итераторostreambuf_iterator,который ссылается на позицию за последним выведенным символом; этот итератор имеет функцию-членfailed,позволяющую зафиксировать ситуацию, когда итератор оказывается испорченным.
   Все параметрыmoney_put::putне требуют дополнительных пояснений, кроме, возможно, второго (аргументintlв примере). Он имеет типboolи показывает, будет использоваться символ валюты (например, $, €) или трехбуквенное международное обозначение валюты (например, USD, EUR). Для использования символа валюты установите его в значениеfalse,а для использования международного обозначения валюты — в значениеtrue.
   При записи денежных значений в поток вывода можно задавать некоторые параметры потока, которые управляют форматированием. Ниже описывается каждый параметр и объясняется его воздействие на вывод денежного значения.
   ios_base::internal
   Если при форматировании денежного значения задается пробел или пустое значение, будет использован символ заполнителя (а не пробел). Ниже при обсужденииmoneypunctприводятся дополнительные сведения по шаблонам форматирования.
   ios_base::leftиios_base::right
   Выравнивает денежное значение влево или вправо; при этом остальные позиции в пределах заданной ширины заполняются символом заполнителя (см. описание следующего параметра,width).Это удобно, потому что облегчает табуляцию денежного значения.
   ios_base::width
   Значения, выдаваемые функциейmoney_put,подчиняются стандартным правилам управления шириной поля потока. По умолчанию эти значения выравниваются влево. Если поле больше, чем размер значения, используется символ заполнителя, указанный при вызове функцииmoney_put.
   ios_base::showbase
   Если этот флаг имеет значение «истина», символ валюты выводится, в противном случае он не выводится.
   Как я говорил ранее, функцииmoney_getиmoney_putиспользуют классmoneypunct,в котором фактически хранится информация о форматировании. Вам не стоит беспокоиться о классеmoneypunct,если вы не заняты реализацией стандартной библиотеки, но вы можете использовать его для исследования параметров форматирования, применяемых в конкретной локализации,moneypunctсодержит такие сведения, как используемый символ валюты, символ, используемый в качестве десятичной точки, формат положительных и отрицательных значений и т.д. В примере 13.7 представлена короткая программа, печатающая информацию о формате денежных значений, который используется в заданной локализации.
   Пример 13.7. Вывод информации о форматировании денежных значений
   #include&lt;iostream&gt;
   #include&lt;locale&gt;
   #include&lt;string&gt;

   using namespace std;

   string printPattern(moneypunct&lt;char&gt;::pattern& pat) {
    string s(pat.field); // pat.field имеет тип char[4]
    string r;
    for (int i = 0; i&lt; 4; ++i) {
     switch (s[i]) {
     case moneypunct&lt;char&gt;::sign:
      r += "sign ";
      break;
     case moneypunct&lt;char&gt;::none:
      r += "none ";
      break;
     case moneypunct&lt;char&gt;::space:
      r += "space ";
      break;
     case moneypunct&lt;char&gt;::value:
      r += "value ";
      break:
     case moneypunct&lt;char&gt;::symbol:
      r += "symbol ";
      break;
     }
    }
    return(r);
   }

   int main() {
    locale loc("danish");
    const moneypunct&lt;char&gt;& punct =
     use_facet&lt;moneypunct&lt;char&gt;&gt;(loc),
    cout&lt;&lt; "Decimal point: "&lt;&lt; punct.decimal_point()&lt;&lt; '\n'
    &lt;&lt; "Thousands separator. "&lt;&lt; punct.thousands_sep()&lt;&lt; '\n'
    &lt;&lt; "Currency symbol: "&lt;&lt; punct.curr_symbol()&lt;&lt; '\n'
    &lt;&lt; "Positive sign: "&lt;&lt; punct.positive_sign()&lt;&lt; '\n'
    &lt;&lt; "Negative sign: "&lt;&lt; punct.negative_sign()&lt;&lt; '\n'
    &lt;&lt; "Fractional digits: "&lt;&lt; punct.frac_digits()&lt;&lt; '\n'
    &lt;&lt; "Positive format: "
    &lt;&lt; printPattern(punct pos_format())&lt;&lt; '\n'
    &lt;&lt; "Negative format: "
    &lt;&lt; printPattern(punct.neg_format())&lt;&lt; '\n';
    // Группировки описываются символьной строкой, но осмысленными
    // являются числовые значения символов, а не собственно символы
    string s = punct.grouping();
    for (string::iterator p = s.begin(); p != s.end(); ++p)
     cout&lt;&lt; "Groups of: "&lt;&lt; (int)*p&lt;&lt; '\n';
   }
   Назначение большинства этих методов самоочевидно, но некоторые методы требуют дополнительных пояснений. Во-первых, методgroupingвозвращает строку символов, которая интерпретируется как строка целочисленных значений. Каждый символ описывает свою группу цифр в числе, начиная с правой стороны числа. И если в какой-то позиции строки нет значения, то используется значение в предыдущей позиции. Другими словами, для стандартного американского формата в позиции 0 этой строки будет значение 3, что означает три цифры для группы с индексом 0. Поскольку других значений нет, все группы с индексом, большим нуля, должны также состоять из трех цифр.
   pos_formatиneg_formatвозвращают объект типаmoneypunct&lt;T&gt;::pattern,который имеет членfieldтипаT[4],гдеT— символьный тип. Каждый элемент поляfieldсодержит один из элементов перечисленияmoneypunct&lt;T&gt;::part,который имеет пять возможных значений:none,space,symbol,signиvalue.Строковое представление денежного значения состоит из четырех частей (т.е. массив с четырьмя элементами) Обычно части денежного значения образуют последовательностьsymbol space sign value (символ валюты пробел знак значение), что означало бы вывод, например, значения $ -32.00. Часто знак плюс заменяется пустой строкой, поскольку значение без знака обычнорассматривается как положительное значение. Признак отрицательного числа может содержать несколько символов, как, например, «()», и в этом случае первый символ выдается в частиsymbolформата отрицательного числа (neg_format),а другой символ выдается в конце, поэтому отрицательные числа могут иметь, например, такой вид: $(32.00).
   Большую часть времени вам не придется беспокоиться по поводу получения информации о форматировании, содержащейся вmoneypunct.Однако если вам необходимо выполнить большой объем формирования денежных значений в различных локализациях, то имеет смысл поэкспериментировать и познакомитьсяс особенностями форматирования в различных локализациях.Смотри также
   Рецепты 13.2 и 13.3.
   13.5.Сортировка локализованных строкПроблема
   Имеется последовательность строк, содержащая символы не в коде ASCII, и требуется ее отсортировать с учетом местных особенностей.Решение
   В класс локализации встроена поддержка операций сравнения символов в заданной локализации путем перегрузки оператораoperator&lt;.При вызове любой стандартной функции, принимающей функтор сравнения, можно использовать в качестве такого функтора экземпляр класса локализации. (См. пример 13.8.)
   Пример 13.8. Сортировка с учетом местных особенностей
   #include&lt;iostream&gt;
   #include&lt;locale&gt;
   #include&lt;string&gt;
   #include&lt;vector&gt;
   #include&lt;algorithm&gt;

   using namespace std;

   bool localelessThan(const string& s1, const string& s2) {
    const collate&lt;char&gt;& col =
     use_facet&lt;collate&lt;char&gt;&gt;(locale()); //Использовать глобальную
                                          // локализацию
    const char* pb1 = s1.data();
    const char* pb2 = s2.data();
    return (col.compare(pb1, pb1 + s1.size(),
     pb2, pb2 + s2.size())&lt; 0);
   }

   int main() (
    // Создать две строки, одна с немецким символом
    string s1 = "di?t";
    string s2 = "dich";
    vector&lt;string&gt; v;
    v.push_back(s1);
    v.push_back(s2);
    // Сортировать, не используя заданную локализацию, т.е. Применяя
    // правила текущей глобальной локализации
    sort(v.begin(), v.end());
    for (vector&lt;string&gt;::const_iterator p = v.begin();
     p != v.end(); ++p)
     cout&lt;&lt; *p&lt;&lt; endl;
    // Установить в качестве глобальной немецкую локализацию и затем
    // сортировать
    locale::global(locale("german"));
    sort(v.begin(), v.end(), localelessThan);
    for (vector&lt;string&gt;::const_iterator p = v.begin();
     p != v.end(); ++p)
     cout&lt;&lt; *p&lt;&lt; endl;
   }
   Первый вариант обеспечивает сортировку по коду ASCII, и поэтому результат будет выглядеть следующим образом.
   dich
   di?t
   Вторая сортировка использует правильный порядок букв немецкого алфавита, и поэтому результат будет противоположным.
   di?t
   dichОбсуждение
   Сортировка усложняется, когда вы работаете с различными локализациями, но стандартная библиотека решает эту проблему. Фасетcollateобеспечивает функцию-членcompare,которая работает какstrcmp:она возвращает значение -1, если первая строка меньше второй, значение 0, если они равны, и значение 1, если первая строка больше второй. В отличие отstrcmp,функцияcollate::compareиспользует определенную в целевой локализации упорядоченность символов.
   В примере 13.8 приводится функцияlocaleLessThan,которая возвращаетTrue,если согласно глобальной локализации первый аргумент меньше второго. Самым важным здесь моментом является вызов функции сравнения.
   col.compare(pb1,  // Указатель на первый символ
    pb1 + s1.size(), // Указатель на позицию за последним символом
    pb2,
    pb2 + s2.size());
   Выполнение примера 13.8 на вашем компьютере может дать результат как совпадающий, так и не совпадающий с приведенным мною, — это зависит от используемого в вашей реализации набора символов. Однако, если требуется обеспечить сравнение строк с учетом местных особенностей, вам следует использоватьcollate::compare.Конечно, стандарт не требует, чтобы реализация поддерживала какую-либо локализацию, кроме локализации «C», поэтому не забудьте протестировать все используемые вами локализации.
   Глава 14
   XML
   14.0.Введение
   Язык XML играет важную роль во многих областях, в том числе при хранении и поиске информации, в издательском деле и при передаче данных по сетям; в данной главе мы научимся работать с XML в С++. Поскольку эта книга больше посвящена С++, чем XML, я полагаю, вы уже имеете некоторый опыт применения различных технологий, связанных с XML, например SAX, DOM, XML Schema, XPath и XSLT. He стоит беспокоиться из-за того, что вы не являетесь экспертом во всех этих областях; приводимые в данной главе рецепты достаточно независимы друг от друга, поэтому вы можете пропустить некоторые из них и все-таки понять остальные. Во всяком случае, каждый рецепт дает краткое описание концепций XML и используемого ими инструментария.
   Если вы имеете достаточный опыт программирования на другом языке, например на Java, вы можете предположить, что средства обработки документов XML входят в состав стандартной библиотеки С++. К сожалению, XML делал только первые шаги, когда стандарт C++ был уже принят, и хотя добавление средств обработки документов XML в новую версию стандартной библиотеки C++ вызывает большой интерес, в настоящее время вам придется полагаться на несколько доступных в C++ великолепных библиотек XML, поставляемых независимыми разработчиками.
   Возможно, перед началом чтения рецептов вы захотите скачать из Интернета и установить библиотеки, которые будут рассмотрены в настоящей главе. В табл. 14.1 приводятся домашние страницы каждой библиотеки, а в табл. 14.2 указано назначение каждой библиотеки и ссылки на рецепты, в которых они используются. В таблицах не указаны точные версии различных спецификаций и рекомендаций XML, реализованные каждой библиотекой, поскольку эта информация, вероятно, изменится в ближайшем будущем.

   Табл. 14.1. Библиотеки C++ для XMLИмя библиотекиДомашняя страницаTinyXmlwww.grinninglizard.com/tinyxmlXerxesxml.apache.crg/xerces-cXalanxml.apache.org/xalan-cPathan 1software.decisionsoft.com/pathanIntro.htmlBoost.Serializationwww.boost.org/libs/serialization

   Табл. 14.2. Назначение библиотекИмя библиотекиНазначениеРецептыTinyXmlDOM (нестандартная версия)Рецепт 14.1XerxesSAX2, DOM, XML SchemaРецепты 14.2-14.8XalanXSLT, XPathРецепты 14.7-14.8PathanXPathРецепт 14.8Boost.SerializationСериализация XMLРецепт 14.9
   14.1.Синтаксический анализ простого документа XMLПроблема
   Имеется некоторая совокупность данных, хранимых в документе XML. Требуется выполнить синтаксический анализ документа и превратить эти данные в объекты C++. ДокументXML имеет достаточно небольшой размер и может поместиться в оперативной памяти, причем в документе не используется внутреннее определение типа документа (Document Type Definition — DTD) и отсутствуют пространства имен XML.Решение
   Используйте библиотекуTinyXml.Во-первых, определите объект типаTiXmlDocumentи вызовите его методLoadFile(),передавая полное имя файла вашего XML-документа в качестве его аргумента. ЕслиLoadFile()возвращает значение «true», то это означает, что анализ вашего документа завершился успешно. В этом случае вызовите методRootElement()для получения указателя на объект типаTiXmlElement,представляющего корневой элемент документа. Этот объект имеет иерархическую структуру, которая соответствует структуре вашего документа XML; выполняя проход по этой структуре, вы можете извлечь информацию о документе и использовать ее для создания набора объектов С++.
   Например, предположим, что у вас имеется XML-документanimals.xml,описывающий некоторое количество животных цирка, как показано в примере 14.1. Корень документа имеет имяanimalListи содержит несколько дочерних элементовanimal,каждый из которых представляет одно животное, принадлежащее цирку Feldman Family Circus. Предположим также, что у вас имеется класс C++ с именемAnimal,и вам нужно сконструировать векторstd::vector,состоящий из объектовAnimal,представляющих животных, перечисленных в документе.
   Пример 14.1. Документ XML со списком животных цирка
   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;!-Животные цирка Feldman Family Circus --&gt;
   &lt;animalList&gt;
    &lt;animal&gt;
    &lt;name&gt;Herby&lt;/name&gt;
     &lt;species&gt;elephant&lt;/species&gt;
    &lt;dateOfBirth&gt;1992-04-23&lt;/dateOfBirth&gt;
    &lt;veterinarian name="Dr. Hal Brown" phone="(801)595-9627"/&gt;
    &lt;trainer name="Bob Fisk" phone=(801)881-2260"/&gt;
    &lt;/animal&gt;
    &lt;animal&gt;
    &lt;name&gt;Sheldon&lt;/name&gt;
    &lt;species&gt;parrot&lt;/species&gt;
    &lt;dateOfBirth&gt;1998-09-30&lt;/dateOfBirth&gt;
    &lt;veterinarian name="Dr Kevin Wilson" phone="(801)466-6498"/&gt;
    &lt;trainer name="Eli Wendel" phone="(801)929-2506"/&gt;
    &lt;/animal&gt;
    &lt;animal&gt;
     &lt;name&gt;Dippy&lt;/name&gt;
    &lt;species&gt;penguin&lt;/species&gt;
    &lt;dateOfBirth&gt;2001-06-08&lt;/dateOfBirth&gt;
    &lt;veterinarian name= "Dr. Barbara Swayne" phone="(801)459-7746"/&gt;
    &lt;trainer name="Ben Waxman" phone="(801)882-3549"/&gt;
    &lt;/animal&gt;
   &lt;/animalList&gt;
   Пример 14.2 показывает, как может выглядеть определение классаAnimal.Animalимеет пять данных-членов, соответствующих кличке, виду, дате рождения, ветеринару и дрессировщику животного. Кличка и вид животного представляются строками типа std::string, дата его рождения представляется типомboost::gregorian::dateиз Boost.Date_Time, а его ветеринар и дрессировщик представляются экземплярами классаContact,который определен также в примере 14.2. Пример 14.3 показывает, как можно использоватьTinyXmlдля синтаксического анализа документаanimals.xml,просмотра разобранного документа и заполнения вектораstd::vectorобъектовAnimal,используя извлеченные из документа данные.
   Пример 14.2. Заголовочный файл animal.hpp
   #ifndef ANIMALS_HPP_INCLUDED
   #define ANIMALS_HPP_INCLUDED

   #include&lt;ostream&gt;
   #include&lt;string&gt;
   #include&lt;stdexcept&gt; // runtime_error
   #include&lt;boost/date_time/gregorian/gregorian.hpp&gt;
   #include&lt;boost/regex.hpp&gt;

   //Представляет ветеринара или дрессировщика
   class Contact {
   public:
    Contact() {}
    Contact(const std::string& name, const std::string& phone) :
     name_(name) {
     setPhone(phone);
    }
    std::string name() const { return name_; }
    std::string phone() const { return phone_; }
    void setName(const std::string& name) { name_ = name; }
    void setPhone(const std::string& phone) {
     using namespace std;
     using namespace boost;
     // Используйте Boost.Regex, чтобы убедиться, что телефон
     // задач в форме (ddd)ddd-dddd
     static regex pattern("\\([0-9]{3}\\)[0-9]{3}-[0-9]{4}");
     if (!regex_match(phone, pattern)) {
      throw runtime_error(string("bad phone number:") + phone);
     }
     phone_ = phone;
    }
   private:
    std::string name_;
    std::string phone_;
   };

   //Сравнить на равенство два объекта класса Contact; используется в рецепте
   // 14.9 (для полноты следует также определить operator!=)
   bool operator--(const Contact& lhs, const Contact& rhs) {
    return lhs.name() == rhs.name()&& lhs.phone() == rhs.phone();
   }

   //Записывает объект класса Contact в поток ostream
   std::ostream& operator(std::ostream& out, const Contact& contact) {
    out&lt;&lt; contact.name()&lt;&lt; " "&lt;&lt; contact.phone(); return out;
   }

   //Класс Animal представляет животное
   class Animal {
   public:
    // Конструктор по умолчанию класса Animal; этот конструктор будет вами
    // использоваться чаще всего Animal() {}
    // Конструирование объекта Animal с указанием свойств животного;
    // этот конструктор будет использован в рецепте 14.9
    Animal(const std::string& name,
     const std::string& species, const std::string& dob,
     const Contact& vet, const Contact& trainer) :
     name_(name), species_(species), vet_(vet), trainer_(trainer) {
      setDateOfBirth(dob)
     }
    // Функции доступа к свойствам животного
    std::string name() const { return name_; }
    std::string species() const { return species_; }
    boost::gregorian::date dateOfBirth() const { return dob_; )
    Contact veterinarian() const { return vet_; }
    Contact trainer() const { return trainer_; }

    // Функции задания свойств животного
    void setName(const std::string& name) { name_ = name; }
    void setSpecies(const std::string& species) { species_ = species; }
    void setDateOfBirth(const std::string& dob) {
     dob_ = boost::gregorian::from_string(dob);
    }
    void setVeterinarian(const Contact& vet) { vet_ = vet; }
    void setTrainer(const Contact& trainer) { trainer_ = trainer; }
   private:
    std::string name_;
    std::string species_;
    boost::gregorian::date dob_;
    Contact vet_;
    Contact trainer_;
   };

   //Сравнение на равенство двух объектов Animal; используется в рецепте 14.9
   // (для полноты следует также определить operator!=)
   bool operator==(const Animal& lhs, const Animal& rhs) {
    return lhs.name() == rhs.name()&& lhs.species() == rhs.species()&&
     lhs.dateOfBirth() == rhs.dateOfBirth()&&
     lhs.veterinarian() == rhs.veterinarian()&&
     lhs.trainer() == rhs.trainer();
   }

   //Записывает объект Animal в поток ostream
   std::ostream& operator&lt;&lt;(std::ostream& out, const Animal& animal) {
    out&lt;&lt; "Animal {\n"
    &lt;&lt; " name="&lt;&lt; animal.name()&lt;&lt; ";\n"
    &lt;&lt; " species="&lt;&lt; animal.species()&lt;&lt; ";\n"
    &lt;&lt; date-of-birth="&lt;&lt; animal.dateOfBirth()&lt;&lt; ";\n"
    &lt;&lt; " veterinarian="&lt;&lt; animal.veterinarian()&lt;&lt; ";\n"
    &lt;&lt; " trainer="&lt;&lt; animal.trainer()&lt;&lt; ";\n"
    &lt;&lt; "}";
    return out;
   }
   #endif // #ifndef ANIMALS_HPP_INCLUDED
   Пример 14.3. Синтаксический анализ animals.xml с помощью TinyXml
   #include&lt;exception&gt;
   #include&lt;iostream&gt;  // cout
   #include&lt;stdexcept&gt; // runtime_error
   #include&lt;cstdlib&gt;   // EXIT_FAILURE
   #include&lt;cstring&gt;   // strcmp
   #include&lt;vector&gt;
   #include&lt;tinyxml.h&gt;
   #include "animal.hpp"

   using namespace std;

   //Извлекает текстовое содержимое элемента XML
   const char* textValue("TiXmlElement* e) {
    TiXmlNode* first = fi-&gt;FirstChild();
    if (first != 0&& first == e-&gt;LastChild()&&
     first-&gt;Type() == TiXmlNode::TEXT) {
     // элемент «е» имеет один дочерний элемент типа TEXT;
     // возвратить дочерний элемент
     return first-&gt;Value();
    } else {
     throw runtime_error(string("bad ") + e-&gt;Value() + " element");
    }
   }

   //Конструирует объект класса Contact из элементов ветеринара или
   //дрессировщика ("veterinarian" или "trainer")
   Contact nodeToContact(TiXmlElement* contact) {
    using namespace std;
    const char *name, *phone;
    if (contact-&gt;FirstChild() == 0&&
     (name = contact-&gt;Attribute("name"))&&
     (phone = contact-&gt;Attribute("phone"))) {
     // Элемент contact не имеет дочерних элементов и имеет атрибуты имени
     // и телефона ("name" и "phone"); используйте эти значения для
     // конструирования объекта Contact
     return Contact(name, phone);
    } else {
     throw runtime_error(string("bad ") + contact-&gt;Value() + " element");
    }
   }

   //Конструирует объект Animal из элемента животного ("animal")
   Animal nodeToAnimal(TiXmlElement* animal) {
    using namespace std;
    // Убедиться, что animal соответствует элементу "animal"
    if (strcmp(animal-&gt;Value(), "animal") != 0) {
     throw runtime_error(string("bad animal: ") + animal-&gt;Value());
    }
    Animal result; // Возвратить значение
    TiXmlElement* element = animal-&gt;FirstChildElement();
    // Прочитать элемент клички животного
    if (element&& strcmp(element-&gt;Value(), "name") == 0) {
     // Первым дочерним элементом объекта animal является кличка (элемент
     // name"); используйте ее текстовое значение для установки клички
     // в объекте result
     result.setName(textValue(element));
    } else {
     throw runtime_error("no name attribute");
    }
    // Прочитать элемент вида животного
    element = element-&gt;NextSiblingElement();
    if (element&& strcmp(element-&gt;Value(), species") == 0) {
     // Вторым дочерним элементом animal является вид животного
     // (элемент "species"); используйте его текстовое значение для
     // установки вида в объекте result
     result.setSpecies(textValue(element));
    } else {
     throw runtime_error(""no species attribute");
    }
    // Прочитать элемент даты рождения
    element = element-&gt;NextSiblingElement();
    if (element&& strcmp(element-&gt;Value(), "dateOfBirth") == 0) {
     // Третьим дочерним элементом animal является дата рождения
     // (элемент "dateOfBirth"));
     // используйте его текстовое значение для установки даты
     // рождения в объекте result
     result.setDateOfBirth(textValue(element));
    } else {
     throw runtime_error("no dateOfBirth attribute");
    }
    // Прочитать элемент ветеринара
    element = element-&gt;NextSiblingElement();
    if (strcmp(element-&gt;Value(), "veterinarian") == 0) {
     // Четвертым дочерним элементом animal является ветеринар (элемент
     // "veterinarian"); используйте его для конструирования объекта
     // Contact и установки имени ветеринара в объекте result
     result.setVeterinarian(nodeToContact(element));
    } else {
     throw runtime_error("no veterinarian attribute");
    }
    // Прочитать элемент дрессировщика
    element = element-&gt;NextSiblingElement();
    if (strcmp(element-&gt;Value(), "trainer") == 0) {
     // Пятым элементом animal является дрессировщик (элемент "trainer");
     // используйте его для конструирования объекта
     // Contact и установки дрессировщика в объекте result
     result.setTrainer(nodeToContact(element));
    } else {
     throw runtime_error("no trainer attribute");
    }
    // Убедиться в отсутствии других дочерних элементов
    element = element-&gt;NextSiblingElement();
    if (element != 0) {
     throw runtime_error(
      string("unexpected element:") + element-&gt;Value()
     );
    }
    return result;
   }

   int main() {
    using namespace std;
    try {
     vector&lt;Animal&gt; animalList;
     // Обработать "animals.xml"
     TiXmlDocument doc("animals.xml");
     if (!doc.LoadFile())
      throw runtime_error("bad parse");
     // Убедиться, что корневым является список животных
     TiXmlElement* root = doc.RootElement();
     if (strcmp(root-&gt;Value(), "animalList") != 0) {
      throw runtime_error(string("bad root: ") + root-&gt;Value());
     }
     // Просмотреть все дочерние элементы корневого элемента, заполняя
     // список животных
     for (TiXmlElement* animal = root-&gt;FirstChildElement();
      animal; animal = animal-&gt;NextSiblingElement()) {
      animalList.push_back(nodeToAnimal(animal));
     }
     // Напечатать клички животных
     for (vector&lt;Animal&gt;::size_type i = 0, n = animalList.size(); i&lt; n; ++i) {
      cout&lt;&lt; animalList[i]&lt;&lt; "\n";
     }
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }Обсуждение
   TinyXml (буквально «крошечный XML») очень хорошо подходит в тех случаях, когда требуется выполнять несложную обработку документов XML. Дистрибутив исходных текстов этой библиотеки небольшой, ее легко построить и интегрировать в проекты, и она имеет очень простой интерфейс. Она также имеет очень либеральную лицензию. Главными ограничениями TinyXml являются невосприимчивость к пространствам имен XML, невозможность контроля DTD или схемы, а также невозможность анализа документов XML с внутренним DTD. Если вам требуется какая-то из этих функций или какая-нибудь XML-технология, как, например, XPath или XSLT, то необходимо воспользоваться другими библиотеками, рассмотренными в данной главе.
   На выходе парсера TinyXml получается документ XML в виде дерева, узлы которого представляют элементы, текст, комментарии и другие компоненты документа XML. Корень деревапредставляет собственно документ XML. Такое иерархическое представление документа называется объектной моделью документа (Document Object Model - DOM). Модель DOM, полученная парсером TinyXml, аналогична модели, разработанной консорциумом W3C (World Wide Web Consortium), хотя она и не полностью соответствует спецификации W3C. Вследствие приверженности библиотеки TinyXml принципам минимализма модель TinyXml DOM проще W3С DOM, однако она обладает меньшими возможностями.
   Получить доступ к узлам дерева, представляющего документ XML, можно с помощью интерфейсаTiXmlNode,который содержит методы, обеспечивающие доступ к родительскому узлу, последовательный доступ ко всем дочерним узлам, удаление и добавление дочерних узлов. Каждыйузел является экземпляром некоторого производного типа; например, корень дерева является экземпляромTiXmlDocument,узлы элементов являются экземплярамиTiXmlElement,а узлы, представляющие текст, являются экземплярамиTiXmlText.ТипTiXmlNodeможно определить с помощью его методаТуре();зная тип узла, вы можете получить конкретное его представление с помощью таких методов, какtoDocument(),toElement()иtoText().Эти производные типы содержат дополнительные методы, характерные для узлов конкретного типа.
   Теперь несложно разобраться с примером 14.3. Во-первых, функцияtextValue()извлекает текстовое содержимое из элементов, содержащих только текст, напримерname,speciesилиdateOfBirth.В этом случае данная функция сначала убеждается, что имеется только один дочерний элемент и что он является текстовым узлом. Она затем получает текст дочернего элемента, вызывая методValue(),который возвращает текстовое содержимое текстового узла или узла комментария, имя тега узла элемента и имя файла корневого узла.
   На следующем шаге функцияnodeToContact()получает узел, соответствующий элементуveterinarianилиtrainer,и конструирует объектContactиз значений атрибутовnameиphone,получаемых с помощью методаAttribute().
   Аналогично функцияnodeToAnimal()получает узел, соответствующий элементу животного element, и конструирует объектAnimal.Это делается путем прохода по дочерним узлам с помощью методаNextSiblingElement(),извлекая при этом содержащиеся в каждом элементе данные и устанавливая соответствующее свойство объектаAnimal.Данные извлекаются, используя функциюtextValue()для элементовname,speciesиdateOfBirthи функциюnodeToContact()для элементовveterinarianиtrainer.
   В функцииmainя сначала конструирую объектTiXmlDocumentсоответствующий файлуanimals.xml,и выполняю его синтаксический разбор с помощью методаLoadFile().Затем я получаю элементTiXmlElement,соответствующий корню документа, вызывая методRootElement().На следующем шаге я просматриваю все дочерние узлы корневого элемента, конструируя объектAnimalиз каждого элементаanimalс помощью функцииnodeToAnimal().Наконец, я прохожу по всем объектамAnimal,записывая их в стандартный вывод.
   В примере 14.3 не проиллюстрирована одна функция библиотекиTinyXml,а именно методSaveFile()классаTiXmlDocument,который записывает в файл документ, представляемый объектомTiXmlDocument.Это позволяет выполнить синтаксический разбор документа XML, модифицировать его, используя интерфейс DOM, и сохранить модифицированный документ. ДокументTiXmlDocumentможно создать даже с чистого листа и затем сохранить его на диске.
   //Создать документ hello.xml, состоящий
   //из единственного элемента "hello"
   TiXmlDocument doc;
   TiXmlElement root("hello");
   doc.InsertEndChild(root);
   doc.SaveFile("hello.xml");Смотри также
   Рецепты 14.3 и 14.4.
   14.2.Работа со строками XercesПроблема
   Требуется обеспечить надежную и простую работу со строками с расширенным набором символов, используемыми библиотекой Xerces. В частности, необходимо уметь сохранять строки, возвращаемые функциями библиотеки Xerces, а также выполнять преобразования между строками Xerces и строками стандартной библиотеки С++.Решение
   Сохранять строки с расширенным набором символов, возвращаемые функциями библиотеки Xerces, можно с помощью шаблонаstd::basic_string,специализированного типом с расширенным набором символовXMLChбиблиотеки Xerces.
   typedef std::basic_string&lt;XMLCh&gt; XercesString;
   Для выполнения преобразований между строками Xerces и строками, состоящими из стандартных символов, используйте перегруженный статический методtranscode()из классаxercesc::XMLString,который определен в заголовочном файлеxercesc/util/XMLString.hpp.
   В примере 14.4 определяются две перегруженные вспомогательные функции,toNativeиfromNative,которые используютtranscodeдля преобразования строк со стандартными символами в строкиXercesиобратно.Каждая функция имеет две версии: одна принимает строку в C-стиле, а другая принимает строку стандартной библиотеки С++. Для выполнения преобразований между строками Xerces и строками со стандартными символами вполне достаточно иметь эти служебные функции; после того как вы определили эти функции, вам уже никогда не потребуется вызывать непосредственноtranscode.
   Пример 14.4. Заголовочный файл xerces_strings.hpp, используемый для выполнения преобразований между строками Xerces и строками со стандартными символами
   #ifndef XERCES_STRINGS_HPP_INCLUDED
   #define XERCES_STRINGS_HPP_INCLUDED

   #include&lt;string&gt;
   #include&lt;boost/scoped_array.hpp&gt;
   #include&lt;xercesc/util/XMLString.hpp&gt;

   typedef std::basic_string&lt;XMLCh&gt; XercesString;

   //Преобразует строку со стандартными символами
   // в строку с расширенным набором символов
   inline XercesString fromNative(const char* str) {
   boost::scoped_array&lt;XMLCh&gt; ptr(xercesc::XMLString::transcode(str));
    return XercesString(ptr.get());
   }

   //Преобразует строку со стандартными символами
   // в строку с расширенным набором символов.
   inline XercesString fromNative(const std::string& str) {
    return fromNative(str.c_str());
   }

   //Преобразует строку с расширенным набором символов
   // в строку со стандартными символами.
   inline std::string toNative(const XMLCh* str) {
   boost::scoped_array&lt;char&gt; ptr(xercesc::XMLString::transcode(str));
    return std::string(ptr.get());
   }

   //Преобразует строку с расширенным набором символов в строку со стандартными символами.
   inline std::string toNative(const XercesString& str) {
    return toNative(str.c_str());
   }

   #endif // #ifndef XERCES_STRINGS_HPP_INCLUDED
   Для выполнения преобразований между строками Xerces иstd::wstringпросто используйте конструкторstd::basic_string,передавая ему два итератора. Например, можно определить следующие две функции.
   //Преобразует строку Xerces в строку std::wstring
   std::wstring xercesToWstring(const XercesString& str) {
    return std::wstring(str.begin(), str.end());
   }

   //Преобразует строку std::wstring в строку XercesString
   XercesString wstringToXerces(const std::wstring& str) {
    return XercesString(str.begin(), str.end());
   }
   В этих функциях используется тот факт, чтоwchar_tиXMLChявляются интегральными типами, каждый из которых может неявно преобразовываться в другой; это должно работать независимо от размераwchar_t,пока не используются значения, выходящие за диапазонXMLCh.Вы можете определить подобные функции, принимающие в качестве аргументов строки в C-стиле, используя конструкторstd::basic::string,которому передаются в качестве аргументов массив символов и длина.Обсуждение
   Для представления строк в коде Unicode библиотека Xerces использует последовательности символовXMLCh,завершаемые нулем. ТипXMLChвводится с помощьюtypedefкак интегральный тип, зависящий от реализации и содержащий не менее 16 бит, которых достаточно для представления символов почти любого языка. Xerces применяет символьную кодировку UTF-16, что подразумевает теоретическую возможность представления некоторых символов в коде Unicode в виде последовательности из нескольких символовXMLCh;однако практически можно считать, что каждый символXMLChнепосредственно представляет один символ в коде Unicode, т.е. имеет числовое значение символа Unicode.
   Одно время типXMLChопределялся с помощьюtypedefкакwchar_t,что позволяло легко сохранять копию строки Xerces какstd::wstring.Однако в настоящее время Xerces определяетXMLChна всех платформах с помощьюtypedefкакunsigned short.Кроме всего прочего это означает, что на некоторых платформах типыXMLChиwchar_tимеют разный размер. Поскольку Xerces может изменить в будущем определениеXMLCh,нельзя рассчитывать на то, чтоXMLChбудет идентичен какому-то конкретному типу. Поэтому, если требуется сохранить копию строки Xerces, следует использовать типstd::basic_string&lt;XMLCh&gt;.
   При использовании Xerces вам придется часто выполнять преобразования между строками со стандартными символами и строками Xerces; для этой цели в Xerces предусмотрена перегруженная функцияtranscode().transcode()может преобразовать строку Unicode в строку со стандартными символами, использующую «родную» кодировку символов, или строку с «родной» кодировкой со стандартными символами в строку Unicode. Однако смысл родной кодировки точно не определен, поэтому если вы программируете в среде, в которой часто используется несколько кодировок символов, то вам придется все взять в свои руки и выполнять преобразования особым образом, используя либо фасетstd::codecvt,либоподключаемые службы перекодировки (pluggable transcoding services)библиотеки Xerces, описанные в документации Xerces. Однако во многих случаях вполне достаточно использоватьtranscode().
   Память под возвращаемые функциейtranscode()строки, завершающиеся нулем, динамически выделяется при помощи оператораnewв форме массива; вам придется строку удалять самому, используя операторdelete[].Это создает небольшую проблему управления памяти, поскольку обычно требуется копировать строку или записывать ее в поток до ее удаления, а эти операции могут выбросить исключение. Я решаю эту проблему в примере 14.4 с помощью шаблонаboost::scoped_array,который динамически выделяет память под массив и автоматически удаляет его при выходе из области видимости, даже если выбрасывается исключение. Например, рассмотрим реализацию функцииfromNative.
   inline XercesString fromNative(const char* str) {
    boost::scoped_array&lt;XMLCh&gt; ptr(xercesc::XMLString::transcode(str));
    return XercesString(ptr.get());
   }
   Здесьptrстановится обладателем возвращенной функциейtranscode()строки с нулевым завершающим символом и освобождает ее, даже если конструкторXercesStringвыбрасывает исключениеstd::bad_alloc.
   14.3.Синтаксический анализ сложного документа XMLПроблема
   Имеется некоторый набор данных, хранимых в документе XML, внутри которого используется DTD или применяются пространства имен XML. Требуется выполнить синтаксический анализ документа и превратить содержащиеся в нем данные в набор объектов C++.Решение
   Используйте реализацию Xerces в виде программного интерфейса SAX2 (простой программный интерфейс для XML, версия 2.0). Во-первых, создайте класс, производный отxercesc::ContentHandler;этот класс будет получать уведомления с информацией о структуре и содержимом вашего документа XML по мере его анализа. Затем при желании можно создать класс, производный отxercesc::ErrorHandler,для получения предупреждений и сообщений об ошибках. Сконструируйте парсер типаxercesc::SAX2XMLReader,зарегистрируйте экземпляры классов вашего обработчика, используя методы парсераsetContentHandler()иsetErrorHandler().Наконец, вызовите метод парсераparse(),передавая в качестве аргумента полное имя файла, в котором содержится ваш документ.
   Например, пусть требуется выполнить синтаксический анализ документа XMLanimals.xml,приведенного в примере 14.1, и сконструировать векторstd::vectorобъектовAnimal,представляющих животных, перечисленных в этом документе. (Определение классаAnimalдается в примере 14.2.) В примере 14.3 я показываю, как можно это сделать, используя TinyXml. Для усложнения задачи добавим в документ пространства имен, как показано в примере 14.5.
   Пример 14.5. Список цирковых животных, в котором используются пространства имен XML
   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;!-Животные цирка Feldman Family Circus с использованием пространств имен --&gt;
   &lt;ffc:animalList xmlns:ffc="http://www.feldman-family-circus.com"&gt;
    &lt;ffc:animal&gt;
    &lt;ffc:name&gt;Herby&lt;/ffc:name&gt;
    &lt;ffc:species&gt;elephant&lt;/ffc:species&gt;
    &lt;ffc:dateOfBirth&gt;1992-04-23&lt;/ffc:dateOfBirth&gt;
    &lt;ffc:veterinarian name="Dr. Hal Brown" phone="(801)595-9627"/&gt;
    &lt;ffc:trainer name="Bob Fisk" phone="(801)881-2260"/&gt;
    &lt;/ffc:animal&gt;
    &lt;!-и т.д. --&gt;
   &lt;/ffc:animalList&gt;
   Для анализа этого документа с помощью SAX2 определитеContentHandler,как показано в примере 14.6, иErrorHandler,как показано в примере 14.7. Затем сконструируйтеSAX2XMLReader,зарегистрируйте ваши обработчики и запустите парсер. Это проиллюстрировано в примере 14.8.
   Пример 14.6. Применение SAX2 ContentHandler для синтаксического анализа документа animals.xml
   #include&lt;stdexcept&gt; // runtime_error
   #include&lt;vector&gt;
   #include&lt;xercesc/sax2/Attributes.hpp&gt;
   #include&lt;xercesc/sax2/DefaultHandler.hpp&gt; //Содержит реализации без
                                              // операций для различных
                                              // обработчиков, используемых
   #include "xerces_strings.hpp"              // в примере 14.4
   #include "animal.hpp"

   using namespace std;
   using namespace xercesc;

   //Возвращает экземпляр Contact, построенный
   //на основе заданного набора атрибутов
   Contact contactFromAttributes(const Attributes&attrs) {
    // Для повышения эффективности хранить часто используемые строки
    // в статических переменных
    static XercesString name = fromNative("name");
    static XercesString phone = fromNative("phone");
    Contact result;   // Возвращаемый объект Contact.
    const XMLCh* val; // Значение атрибута name или phone.
    // Установить имя объекта Contact.
    if ((val = attrs.getValue(name.c_str())) != 0) {
     result.setName(toNative(val));
    } else {
     throw runtime_error("contact missing name attribute");
    }
    // Установить номер телефона для объекта Contact.
    if ((val = attrs.getValue(phone.c_str())) != 0) {
     result.setPhone(toNative(val));
    } else {
     throw runtime_error("contact missing phone attribute");
    }
    return result;
   }

   //Реализует обратные вызовы, которые получают символьные данные и
   //уведомления о начале и конце элементов
   class CircusContentHandler : public DefaultHandler {
   public:
    CircusContentHandler(vector&lt;Animal&gt;& animalList) :
     animalList_(animalList) {}

    // Если текущий элемент представляет ветеринара или дрессировщика
    // используйте attrs для конструирования объекта Contact для текущего
    // Animal; в противном случае очистите currentText_, подготавливая
    // обратный вызов characters()
    void startElement(
     const XMLCh *const uri,       // URI пространства имен
     const XMLCh *const localname, // имя тега без префикса NS
     const XMLCh *const qname,     // имя тега + префикс NS
     const Attributes&attrs)      // атрибуты элементов
    {
     static XercesString animalList = fromNative("animalList");
     static XercesString animal = fromNative("animal");
     static XercesString vet = fromNative("veterinarian");
     static XercesString trainer = fromNative("trainer");
     static XercesString xmlns =
      fromNative("http://www.feldman-family-circus.com");
     // проверить URI пространства имен
     if (uri != xmlns)
      throw runtime_error(
       string("wrong namespace uri ") + toNative(uri)
      );
     if (localname == animal) {
      // Добавить в список объект Animal; это будет
      // "текущий объект Animal"
      animalList_.push_back(Animal());
     } else if (localname != animalList) {
      Animal& animal = animalList_.back();
      if (localname == vet) {
       // Мы встретили элемент "ветеринар".
       animal.setVeterinarian(contactFromAttributes(attrs));
      } else if (localname == trainer) {
       // Мы встретили элемент "дрессировщик".
       animal.setTrainer(contactFromAttributes(attrs));
      } else {
       // Мы встретили элемент "кличка", "вид животного" или
       // "дата рождения". Их содержимое будет получено
       // при обратном вызове функции characters().
       currentText_.clear();
      }
     }
    }

    // Если текущий элемент представляет кличку, вид животного или дату
    // рождения, используйте хранимый в currentText_ текст для установки
    // соответствующего свойства текущего объекта Animal.
    void endElement(
     const XMLCh *const uri,       // URI пространства имен
     const XMLCh *const localname, // имя тега без префикса NS
     const XMLCh *const qname)     // имя тега + префикс NS
    {
     static XercesString animalList = fromNative("animal-list");
     static XercesString animal = fromNative("animal");
     static XercesString name = fromNative("name");
     static XercesString species = fromNative("species");
     static XercesString dob = fromNative("dateOfBirth");
     if (localname!= animal&& localname!= animalList) {
      // currentText_ содержит текст элемента, который был
      // добавлен. Используйте его для установки свойств текущего
      // объекта Animal.
      Animal& animal = animalList_.back();
      if (localname == name) {
       animal setName(toNative(currentText_));
      } else if (localname == species) {
       animal.setSpecies(toNative(currentText_));
      } else if (localname == dob) {
       animal.setDateOfBirth(toNative(currentText_));
      }
     }
    }

    // Получает уведомления, когда встречаются символьные данные
    void characters(const XMLCh* const chars,
     const unsigned int length) {
     // Добавить символы в конец currentText_ для обработки методом
     // endElement()
     currentText_.append(chars, length);
    }
   private:
    vector&lt;Animal&gt;& animalList_;
    XercesString currentText_;
   };
   Пример 14.7. SAX2 ErrorHandler
   #include&lt;stdexcept&gt; // runtime_error
   #include&lt;xercesc/sax2/DefaultHandler.hpp&gt;

   //Получает уведомления об ошибках.
   class CircusErrorHandler : public DefaultHandler {
   public:
    void warning(const SAXParseException& e) {
     /* нет действий */
    }
    void error(const SAXParseExceptionf& e) {
     throw runtime_error(toNative(e.getMessage()));
    }
    void fatalError(const SAXParseException& e) { error(e); }
   };
   Пример 14.8. Синтаксический анализ документа animals.xml при помощи программного интерфейса SAX2
   #include&lt;exception&gt;
   #include&lt;iostream&gt; // cout
   #include&lt;memory&gt;   // auto_ptr
   #include&lt;vector&gt;
   #include&lt;xercesc/sax2/SAX2XMLReader.hpp&gt;
   #include&lt;xercesc/sax2/XMLReaderFactory.hpp&gt;
   #include&lt;xercesc/util/PlatformUtils.hpp&gt;
   #include "animal.hpp"
   #include "xerces_strings.hpp" //Пример 14.4

   using namespace std;
   using namespace xercesc;

   //Утилита RAII инициализирует парсер и освобождает ресурсы
   //при выходе из области видимости
   class XercesInitializer {
   public:
    XercesInitializer() { XMLPlatformUtils::Initialize(); }
    ~XercesInitializer() { XMLPlatformUtils::Terminate(); }
   private:
    // Запретить копирование и присваивание
    XercesInitializer(const XercesInitializer&);
    XercesInitializer& operator=(const XercesInitializer&);
   };

   int main() {
    try {
     vector&lt;Animal&gt; animalList;
     // Инициализировать Xerces и получить парсер
     XercesInitializer init;
     auto_ptr&lt;SAX2XMLReader&gt;
      parser(XMLReaderFactory::createXMLReader());
     // Зарегистрировать обработчики
     CircusContentHandler content(animalList);
     CircusErrorHandler error;
     parser-&gt;setContentHandler(&content);
     parser-&gt;setErrorHandler(&error);
     // Выполнить синтаксический анализ документа XML
     parser-&gt;parse("animals.xml");
     // Напечатать клички животных
     for (vector&lt;Animal&gt;::size_type i = 0;
      n = animalList.size(); i&lt; n; ++i) {
      cout&lt;&lt; animalList[i]&lt;&lt; "\n";
     }
    } catch (const SAXException& e) {
     cout&lt;&lt; "xml error: "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const XMLException& e) {
     cout&lt;&lt; "xml error: "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }Обсуждение
   Некоторые парсеры XML выполняют синтаксический анализ документа XML и возвращают его пользователю в виде сложного объекта С++. Именно это делает парсер TinyXml и парсер W3C DOM, который будет рассмотрен в следующем рецепте. В отличие от них парсер SAX2 использует ряд функций обратного вызова для передачи пользователю информации о документе XML по ходу его анализа. Функции обратного вызова сгруппированы в несколько интерфейсов обработчиков:ContentHandlerполучает уведомления об элементах, атрибутах и о тексте документа XML,ErrorHandlerполучает предупреждения и сообщения об ошибках, aDTDHandlerполучает уведомления о DTD документа XML.
   Проектирование парсера, использующего функции обратного вызова, имеет несколько важных преимуществ. Например, можно выполнять синтаксический анализ очень больших документов, которые не помещаются в памяти. Кроме того, это может сэкономить процессорное время, потому что не надо выполнять многочисленные операции динамического выделения памяти, необходимые для конструирования узлов внутреннего представления документа XML, и потому что пользователь может создавать свое представление данных документа непосредственно, а не во время прохождения дерева документа, как я это делал в примере 14.3.
   Пример 14.8 достаточно простой: я получаю парсер SAX2, регистрируюContentHandlerиErrorHandler,анализирую документanimals.xmlи печатаю список объектовAnimal,заполненный обработчикомContentHandler.Следует отметить два интересных момента: во-первых, функцияXMLReaderFactory::createXMLReader()возвращает экземплярSAX2XMLReader,память под который выделяется динамически и должна освобождаться пользователем в явной форме; для этой цели я используюstd::auto_ptr,чтобы обеспечить удаление парсера даже в случае возникновения исключения. Во-вторых, среда Xerces должна быть инициализирована, используяxercesc::XMLPlatformUtils::Initialize(),и очищена при помощиxercesc::XMLPlatformUtils::Terminate().Я инкапсулирую эту инициализацию и очистку в классеXercesInitializer,который вызываетXMLPlatformUtils::Initialize()в своем конструкторе иXMLPlatformUtils::Terminate()в своем деструкторе. Это гарантирует вызовTerminate(),даже если выбрасывается исключение. Это пример методазахвата ресурса при инициализации (Resource Acquisition Is Initialization— RAII), который был продемонстрирован в примере 8.3.
   Давайте теперь посмотрим, как классCircusContentHandlerиз примера 14.6 реализует интерфейс SAX2ContentHandler.Парсер SAX 2 вызывает методstartElement()при каждой встрече открывающего тега элемента. Если элементу приписано пространство имен, первый аргумент,uri,будет содержать URI пространства имен элемента, а второй аргумент,localname,будет содержать ту часть имени тега элемента, которая идет за префиксом пространства имен. Если элемент не имеет пространства имен, эти два аргумента будут иметь пустые строки. Третий аргумент содержит имя тега элемента, если с элементом не связывается пространство имен; в противном случае этот аргумент может содержать либо имя тега элемента в том виде, в каком оно встречается в анализируемом документе, либо пустую строку. Четвертым аргументом является экземпляр классаAttributes,представляющего набор атрибутов элемента.
   В приведенной в примере 14.6 реализацииstartElement()я игнорирую элементanimalList.Когда я встречаю элементanimal,я добавляю новый объектAnimalв список животных; назовем еготекущимобъектомAnimalи предоставим право установки свойств этогоAnimalобработчикам других элементов. Когда я встречаю элементveterinarianилиtrainer,я вызываю функциюcontactFromAttributesдля конструирования экземпляраContactиз набора атрибутов элемента и затем использую этот объектContactдля установки свойств ветеринара и дрессировщика в текущем элементеAnimal.Когда я встречаю элемент name,speciesилиdateOfBirth,я очищаю переменную-членcurrentText_,которая будет использоваться для хранения текстового содержимого этого элемента.
   Парсер SAX2 вызывает методcharacters()для передачи символьных данных, содержащихся в элементе. Этот парсер может передавать символы элемента с помощью нескольких вызовов методаcharacters();пока не встретится закрывающий тег, нельзя быть уверенным в передаче всех символьных данных. Поэтому в реализацииcharacters()я просто добавляю полученные символы в конец переменной-членаcurrentText_,которую я использую для установки клички, вида и даты рожденияAnimalсразу после встречи закрывающего тега для элементаname,speciesилиdateOfBirth.
   Парсер SAX2 вызывает методendElement()при выходе из каждого элемента. Его аргументы имеют тот же смысл, который имеют первые три аргумента методаstartElement().В реализацииendElement(),приведенной в примере 14.6, я игнорирую все элементы, отличные отname,speciesиdateOfBirth.Когда происходит обратный вызов, соответствующий одному из этих элементов, сигнализирующий о сделанном только что выходе парсера из элемента, я использую символьные данные, сохраненные вcurrentText_для установки клички, вида и даты рождения текущего объектаAnimal.
   Несколько важных особенностей SAX2 не проиллюстрировано в примерах 14.6, 14.7 и 14.8. Например, классSAX2XMLReaderсодержит перегрузку методаparse(),которая принимает в качестве аргумента экземплярxercesc::InputSourceвместо строки в С-стиле.InputSourceявляется абстрактным классом, инкапсулирующим источник символьных данных; конкретные его подклассы, в том числеxercesc::MemBufInputSourceиxercesc::URLInputSource,позволяют парсеру SAX2 анализировать документ XML, который находится не в локальной файловой системе.
   Более того, интерфейсContentHandlerсодержит много дополнительных методов, напримерstartDocument()иendDocument(),которые сигнализируют о начале и конце документа XML, иsetLocator(),который позволяет задать объектLocator,отслеживающий текущую позицию анализируемого файла. Существуют также другие интерфейсы обработчиков, включаяDTDHandlerиEntityResolver (соответствующие базовой спецификации SAX 2.0), а такжеDeclarationHandlerиLexicalHandler (соответствующие стандартизованным расширениям SAX 2.0).
   Кроме того, можно в одном классе реализовать несколько интерфейсов обработчиков. Это можно легко сделать в классеxercesc::DefaultHandler,потому что он является производным от всех интерфейсов обработчиков и содержит реализации своих виртуальных функций, в которых не выполняется никаких действий. Следовательно, я мог бы добавить методы изCircusErrorHandlerвCircusContentHandlerи следующим образом модифицировать пример 14.8.
   //Зарегистрировать обработчики
   CircusContentHandler handler(animalList);
   parser-&gt;setContentHandler(&handler);
   parser-&gt;setErrorHandler(&handler);
   Пример 14.8 имеет еще одну, последнюю особенность, которую вы должны были заметить: обработчикCircusContentHandlerне проверяет корректность структуры экземпляра анализируемого документа, т.е. не убеждается в том, что корневым является элементanimalListили что все дочерние элементы корня являются элементамиanimal.Это сильно отличается от примера 14.3. Например, функцияmain()из примера 14.3 проверяет то, что элементом верхнего уровня являетсяanimalList,а функцияnodeToAnimal()проверяет то, что ее аргументы представляют элементanimal,содержащий точно пять дочерних элементов типаname,species,dateOfBirth,veterinarianиtrainer.
   Пример 14.6 можно модифицировать, чтобы он выполнял подобного рода проверки. Например, обработчикContentHandlerв примере 14.9 удостоверяется в том, что корневым элементом документа являетсяanimalListи что его дочерние элементы имеют типanimal,а дочерние элементы элементаanimalне содержат других элементов. Это можно сделать с помощью трех флагов типаboolean,parsingAnimalList_,parsingAnimal_иparsingAnimalChild_,которые регистрируют анализируемую в данный момент область документа. МетодыstartElement()иendElement()просто обновляют эти флаги и проверяют их согласованность, делегируя задачу обновления текущего объекта Animal вспомогательным методамstartAnimalChild()иendElementChild(),реализация которых очень напоминает реализацию методовstartElement()иendElement()из примера 14.6.
   Пример 14.9. Обработчик SAX2 ContentHandler документа animals.xml, который проверяет структуру документа
   //Реализует функции обратного вызова, которые получают символьные данные и
   //уведомляют о начале и конце элементов
   class CircusContentHandler : public DefaultHandler {
   public:
    CircusContentHandler(vector&lt;Animal&gt;& animalList)
     : animalList_(animalList), // заполняемый список
     parsingAnimalList_(false), // состояние анализа
     parsingAnimal_(false),     // состояние анализа
     parsingAnimalChild_(false) // состояние анализа
     {}

    // Получает уведомления от парсера при каждой встрече начала
    // какого-нибудь элемента
    void startElement(
     const XMLCh *const uri,       // uri пространства имен
     const XMLCh *const localname, // простое имя тега
     const XMLCh *const qname,     // квалифицированное имя тега
     const Attributes&attrs)      // Набор атрибутов
    {
     static XercesString animalList = fromNative("animalList");
     static XercesString animal = fromNative("animal");
     static XercesString xmlns =
      fromNative("http://www.feldman-family-circus.com");
     // Проверяет uri пространства имен
     if (uri != xmlns)
      throw runtime_error(
       string("wrong namespace uri: ") + toNative(uri)
      );
     // (i)   Обновить флаги parsingAnimalList_, parsingAnimal_
     //       и parsingAnimalChild_, которые показывают, в какой части
     //       документа мы находимся
     // (ii)  Убедиться, что элементы имеют правильную вложенность
     //
     // (iii) Делегировать основную работу методу
     // startAnimalChild()
     if (!parsingAnimalList_) {
      // Мы только что встретили корень документа
      if (localname == animalList) {
       parsingAnimalList_ = true; // Обновить состояние анализа.
      } else {
       // Неправильная вложенность
       throw runtime_error(
        string("expected 'animalList', got ") + toNative(localname)
       );
      }
     } else if (!parsingAnimal_) {
      // Мы только что встретили новое животное
      if (localname == animal) {
       parsingAnimal_ = true; // Обновить состояние
                              // анализа.
       animalList_.push_back(Animal()); // Добавить в список объект
                                        // Animal.
      } else {
       // Неправильная вложенность
       throw runtime error(
        string("expected 'animal', got ") + toNative(localname)
       );
      }
     } else {
      // Вы находимся в середине анализа элемента, описывающего
      // животного.
      if (parsingAnimalChild_) {
       // Неправильная вложенность
       throw runtime_error("bad animal element");
      }
      // Обновить состояние анализа
      parsingAnimalChild_ = true;
      // Пусть startAnimalChild() выполнит реальную работу
      startAnimalChild(uri, localname, qname, attrs);
     }
    }

    void endElement(
     const XMLCh *const uri,       // uri пространства имен
     const XMLCh *const localname, // простое имя тега
     const XMLCh *const qname )    // квалифицированное имя тега
    {
     static XercesString animalList = fromNative("animal-list");
     static XercesString animal = fromNative("animal");
     // Обновить флаги parsingAnimalList, parsingAnimal_
     // и parsingAnimalChild_; делегировать основную работу
     // endAnimalChild()
     if (localname == animal) {
      parsingAnimal_ = false;
     } else if (localname == animalList) {
      parsingAnimalList_ = false;
     } else {
      endAnimalChild(uri, localname, qname);
      parsingAnimalChild_ = false;
     }
    }

    // Получает уведомления о встрече символьных данных
    void characters(const XMLCh* const chars, const unsigned int length) {
     // Добавляет символы в конец currentText_ для обработки методом
     // endAnimalChild()
     currentText.append(chars, length);
    }

   private:
    // Если текущий элемент представляет ветеринара или дрессировщика,
    // используйте attrs для конструирования объекта Contact для
    // текущего Animal; в противном случае очистите currentText_,
    // подготавливая обратный вызов characters()
    void startAnimalChild(
     const XMLCh *const uri,       // uri пространства имен
     const XMLCh *const localname, // простое имя тега
     const XMLCh *const qname,     // квалифицированное имя тега
     const Attributes&attrs )     // Набор атрибутов
    {
     static XercesString vet = fromNative("veterinarian");
     static XercesString trainer = fromNative("trainer");
     Animal& animal = animalList_.back();
     if (localname == vet) {
      // Мы встретили элемент "ветеринар".
      animal.setVeterinarian(contactFromAttributes(attrs));
     } else if (localname == trainer) {
      // Мы встретили элемент "дрессировщик".
      animal.setTrainer(contactFromAttributes(attrs));
     } else {
      // Мы встретили элемент "кличка , "вид" или
      // "дата рождения". Его содержимое будет передано функцией
      // обратного вызова characters().
      currentText_.clear();
     }
    }

    // Если текущий элемент представляет кличку, вид или дату рождения,
    // используйте текст, находящийся в currentText_, для установки
    // соответствующего свойства текущего объекта
    Animal. void endAnimalChild(
     const XMLCh *const uri,       // uri пространства имен
     const XMLCh *const localname, // простое имя тега
     const XMLCh *const qname)     // квалифицированное имя тега
    {
     static XercesString name = fromNative("name");
     static XercesString species = fromNative("species");
     static XercesString dob = fromNative("dateOfBirth");
     // currentText_ содержит текст элемента, который только что
     // закончился. Используйте его для установки свойств текущего
     // объекта Animal.
     Animal& animal = animalList_.back();
     if (localname == name) {
      animal.setName(toNative(currentText_));
     } else if (localname == species) {
      animal.setSpecies(toNative(currentText_));
     } else if (localname == dob) {
      animal.setDateOfBirth(toNative(currentText_));
     }
    }

    vector&lt;Animal&gt;& animalList_; //заполняемый список
    bool parsingAnimalList_;     // состояние анализа
    bool parsingAnimal_;         // состояние анализа
    bool parsingAnimalChild_;    // состояние анализа
    XercesString currentText_;   // символьные данные текущего
                                 // текстового узла
   };
   Из сравнения примера 14.9 с примером 14.6 видно, насколько сложным может быть проверка структуры документа с помощью функций обратного вызова. Более того, в примере 14.6 не делается столько проверок, как в примере 14.3: здесь, например, не проверяется порядок следования дочерних элементов элемента животного. К счастью, существует гораздо более простой способ проверки структуры документа с использованием SАХ2, как вы это увидите в рецептах 14.5 и 14.6.Смотри также
   Рецепты 14.1, 14.4, 14.5 и 14.6.
   14.4.Манипулирование документом XMLПроблема
   Требуется представить документ XML в виде объекта С++, чтобы можно было манипулировать его элементами, атрибутами, текстом, DTD, инструкциями обработки и комментариямиРешение
   Используйте реализованную в Xerces модель W3C DOM. Во-первых, используйте классxercesc::DOMImplementationRegistryдля получения экземпляраxercesc::DOMImplementation,затем используйтеDOMImplementationдля создания экземпляра парсераxercesc::DOMBuilder.На следующем шаге зарегистрируйте экземплярxercesc::DOMErrorHandlerдля получения уведомлений об ошибках, обнаруженных в ходе анализа, и вызовите метод парсераparseURI(),передавая в качестве аргумента URI документа XML или полное имя файла. Если анализ документа завершается успешно, методparseURIвозвратит указатель на объектDOMDocument,представляющий документ XML. Затем вы можете использовать функции, определенные в спецификации W3C DOM для просмотра и манипулирования документом.
   Обработав документ, вы можете сохранить его в файле, получаяDOMWriterизDOMImplementationи вызывая его методwriteNode()с передачей указателя наDOMDocumentв качестве аргумента.
   Пример 14.10 показывает, как можно использовать DOM для синтаксического анализа документаanimals.xml,приведенного в примере 14.1, затем найти и удалить узел, относящийся к слону Herby, и сохранить модифицированный документ.
   Пример 14.10. Применение DOM для загрузки, модификации и затем сохранения документа XML
   #include&lt;exception&gt;
   #include&lt;iostream&gt; // cout
   #include&lt;xercesc/dom/DOM.hpp&gt;
   #include&lt;xercesc/framework/LocalFileFomatTarget.hpp&gt;
   #include&lt;xercesc/sax/SAXException.hpp&gt;
   #include&lt;xercesc/util/PlatformUtils.hpp&gt;
   #include "animal.hpp"
   #include "xerces_strings.hpp"

   using namespace std;
   using namespace xercesc;

   /*
    * Определить XercesInitializer, как это сделано в примере 14.8
    */

   //Утилита RAII, которая освобождает ресурс при выходе из области видимости.
   template&lt;typename T&gt;
   class DOMPtr {
   public:
    DOMPtr(T* t) : t_(t) {}
    ~DOMPtr() { t_-&gt;release(); }
    T* operator-&gt;() const { return t_; }
   private:
    // запретить копирование и присваивание
    DOMPtr(const DOMPtr&);
    DOMPtr& operator=(const DOMPtr&);
    T* t_;
   };

   //Сообщает об ошибках, обнаруженных в ходе синтаксического анализа с
   //использованием DOMBuilder.
   class CircusErrorHandler : public DOMErrorHandler {
   public:
    bool handleFrror(const DOMError& e) {
     std::cout&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return false;
    }
   };

   //Возвращает значение элемента "name", дочернего по отношению к элементу
   // "animal".
   const XMLCh* getAnimalName(const DOMElement* animal) {
    static XercesString name = fromNative("name");
    // Просмотреть дочерние элементы объекта animal
    DOMNodeList* children = animal-&gt;getChildNodes();
    for (size_t i = 0, len = children-&gt;getLength(); i&lt; Len; ++i) {
     DOMNode* child = children-&gt;item(i);
     if (child-&gt;getNodeType() == DOMNode::ELEMENT_NODE&&
      static_cast&lt;DOMElement*&gt;(child)-&gt;getTagName() == name) {
      // Мы нашли элемент "name".
      return child-&gt;getTextContent();
     }
    }
    return 0;
   }

   int main() {
    try {
     // Инициализировать Xerces и получить DOMImplementation;
     // указать, что требуется функция загрузки и сохранения (Load and
     // Save - LS)
     XercesInitializer init;
     DOMImplementation* impl =
      DOMImplementationRegistry::getDOMImplementation(fromNative("LS").c_str()
     );
     if (impl == 0) {
      cout&lt;&lt; "couldn't create DOM implementation\n";
      return EXIT_FAILURE;
     }
     // Сконструировать DOMBuilder для анализа документа animals.xml.
     DOMPtr&lt;DOMBuilder&gt; parser =
      static_cast&lt;DOMImplementationLS*&gt;(impl)-&gt;
       createDOMBuilder(DOMImplementationLS::MODE_SYNCHRONOUS, 0);
     // Подключить пространства имен (они не требуются в этом примере)
     parser-&gt;setFeature(XMLUni::fgDOMNamespaces, true);
     // Зарегистрировать обработчик ошибок
     CircusErrorHandler err;
     parser-&gt;setErrorHandler(&err);
     // Выполнить синтаксический анализ animals.xml; здесь можно
     // использовать URL вместо имени файла
     DOMDocument* doc =
      parser-&gt;parseURI("animals.xml");
     // Найти элемент слона Herby: сначала получить указатель на элемент
     // "animalList".
     DOMElement* animalList = doc-&gt;getDocumentElement();
     if (animalList-&gt;getTagName() != fromNative("animalList")) {
      cout&lt;&lt; "bad document root: "
      &lt;&lt; toNative(animalist-&gt;getTagName())&lt;&lt; "\n";
      return EXIT_FAILURE;
     }
     // Затем просматривать элементы "animal", пытаясь найти элемент слона
     // Herby.
     DOMNodeList* animals =
      animaIList-&gt;getElementsByTagName(fromNative("animal").c_str());
     for (size_t i = 0,
      len = animals-&gt;getLength(); i&lt; len; ++i) {
      DOMElement* animal =
       static_cast&lt;DOMElement"&gt;(animals-&gt;item(i));
      const XMLCh* name = getAnimalName(animal);
      if (name != 0&& name == fromNative("Herby")) {
       // Herby найден - удалить его из документа.
       animalList-&gt;removeChild(animal);
       animal-&gt;release();
       // необязательный оператор.
       break;
      }
     }
     // Сконструировать DOMWriter для сохранения animals.xml.
     DOMPtr&lt;DOMWriter&gt; writer =
      static cast&lt;DOMImplementationLS*&gt;(impl)-&gt;createDOMWriter();
     writer-&gt;setErrorHandler(&err);
     // Сохранить animals.xml.
     LocalFileFormatTarget file("animals.xml");
     writer-&gt;writeNode(&file, *animalList);
    } catch (const SAXException& e) {
     cout&lt;&lt; "xml error: "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const DOMException& e) {
     cout&lt;&lt; "xml error: "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }Обсуждение
   Подобно парсеру TinyXml парсер Xerces DOM на выходе формирует документ XML в виде объекта C++, имеющего структуру дерева, узлы которого представляют компоненты документа. Однако парсер Xerces существенно сложнее: например, в отличие от TinyXml он «понимает» пространства имен XML и может выполнять синтаксический анализ сложных DTD. Этим парсеромтакже формируется гораздо более детальное представление документа XML, включающее инструкции обработки и URI пространств имен, относящиеся к элементам и атрибутам. Очень важно то, что он предоставляет доступ к информации через интерфейс, описанный в спецификации W3C DOM.
   Спецификация W3C, которая все еще дорабатывается, имеет несколько «уровней»; в настоящее время предусматривается три уровня. КлассыDOMImplementation,DOMDocument,DOMElementиDOMNodeList,использованные в примере 14.10, описываются на уровне 1 спецификации DOM. КлассыDOMBuilderиDOMWriteописываются на уровне 3 спецификации DOM как часть рекомендаций по функции загрузки и сохранения (Load и Save).
    [Картинка: tip_yellow.png] Имена классов Xerces не всегда совладают с именами интерфейсов W3C DOM, которые они реализуют; это происходит из-за того, что Xerces реализует несколько спецификаций в одном пространстве имен и использует префиксы в именах классов, чтобы избежать конфликтов имен.
   Понимание примера 14.10 теперь не должно вызывать затруднений. Я начинаю с инициализации Xerces, как это делается в примере 14.8. Затем я получаюDOMImplementationизDOMImplementationRegistry,запрашивая функцию загрузки и сохранения путем передачи строки «LS» статическому методуDOMImplementationRegistry::getDOMImplementation().На следующем шаге я получаюDOMBuilderизDOMImplementation.Мне приходится типDOMImplementationпривести к типуDOMImplementationLS,потому что функция загрузки и сохранения недоступна из интерфейсаDOMImplementationсогласно спецификации W3C DOM уровня 1. Первый аргументcreateDOMBuilder()показывает, что возвращаемый парсер будет работать всинхронном режиме.Другой возможный режим, а именноасинхронный режим,в настоящее время не поддерживается в Xerces.
   ПолучивDOMBuilder,я включаю поддержку пространства имен XML, регистрирую обработчикErrorHandlerи выполняю синтаксический анализ документа. Парсер возвращает документ в видеDOMDocument;используя методgetElementsByTagName()документаDOMDocument,я получаю объектDOMElement,соответствующий элементу этого документаanimalList,и просматриваю его дочерние элементы, используя объект типаDOMNodeList.Когда я нахожу элемент, имеющий дочерний элемент типаnameи содержащий текст «Herby», я удаляю его из документа с помощью вызова метода корневого элементаremoveChild().
    [Картинка: tip_yellow.png] Подобно тому какSAX2XMLReaderимеет методparse(),принимающий экземплярInputSource,DOMBuilderимеет метолparse(),принимающий экземплярxercesc::DOMInputSource (т.е. экземпляр абстрактного класса, который инкапсулирует источник символьных данных). ВDOMInputSourceпредусмотрен конкретный подклассWrapper4DOMInputSource,который может быть использован для преобразования произвольногоInputSourceвxercesc::DOMInputSource.См рецепт 14.3.
   Наконец, я получаю объектDOMWriterизDOMImplementation (причем делаю это во многом точно так же, как при получении объектаDOMBuilder)и сохраняю модифицированный документ XML на диск, вызывая его методwriteNode(),передавая в качестве аргумента корневой элемент документа.
    [Картинка: tip_yellow.png] Вы должны освободить указатели, возвращаемые методами с именами видаDOMImplementation::createXXX(),путем вызова методаrelease().Используйте утилитуDOMPtrиз примера 14.10 для того, чтобы гарантировать освобождение такого указателя, даже если выбрасывается исключение. Необязательно явно удалять указатели, возвращаемые методами, имена которых имеют видDOMDocument::createXXX(),хотя это можно делать, если они больше не нужны. Дополнительные сведения вы найдете в документации Xerces.
   14.5.Проверка документа XML на соответствие определению DTDПроблема
   Требуется проверить документ XML на соответствие DTD.Решение
   Используйте библиотеку Xerces с парсером SAX2 (простой программный XML-интерфейс) или с парсером DOM.
   Для проверки документа XML при использовании SAX2 получитеSAX2XMLReader,как показано в примере 14.8. Затем включите режим проверки DTD, вызывая метод парсераsetFeature()с аргументамиxercesc::XMLUni::fgSAX2CoreValidationиtrue.Наконец, зарегистрируйте обработчикErrorHandlerдля получения уведомлений о нарушении DTD и вызовите метод парсераparse(),указывая в качестве его аргумента имя вашего документа XML.
   Для проверки документа XML при использовании парсера DOM сначала сконструируйте экземплярXercesDOMParser.Затем включите режим проверки DTD, вызывая метод парсераsetValidationScheme()с аргументомxercesc::XercesDOMParser::Val_Always.Наконец, зарегистрируйте обработчикErrorHandlerдля получения уведомлений о нарушении DTD и вызовите метод парсераparse(),указывая в качестве его аргумента имя вашего документа XML.
    [Картинка: tip_yellow.png] Здесь я использую классXercesDOMParser,т.е. XML-парсер, который входил в состав Xerces еще до того, как был разработан интерфейсDOMBuilder—парсера DOM уровня 3. ПрименениеXercesDOMParserпозволяет немного упростить пример, но при желании вы можете вместо него использоватьDOMBuilder.См. обсуждение этого рецепта и рецепт 14.4.
   Для примера предположим, что вы модифицируете документ XMLanimals.xmlиз примера 14.1 для того, чтобы он содержал ссылку на внешнее определение DTD, как показано в примерах 14.11 и 14.12. Программный код, выполняющий проверку документа с использованием программного интерфейса SAX2, приводится в примере 14.13; программный код, выполняющий проверку этого документа с использованием парсера DOM, приводится в примере 14.14.
   Пример 14.11. DTD animals.dtd для файла animals.xml
   &lt;!-- DTDдля животных цирка Feldman Family Circus --&gt;
   &lt;!ELEMENT animalList (animal+)&gt;
   &lt;!ELEMENT animal (name, species, dateOfBirth,
                     veterinarian, trainer)&gt;
   &lt;!ELEMENT name (#PCDATA)&gt;
   &lt;!ELEMENT species (#PCDATA)&gt;
   &lt;!ELEMENT dateOfBirth (#PCDATA)&gt;
   &lt;!ELEMENT veterinarian EMPTY&gt;
   &lt;!ELEMENT trainer EMPTY&gt;
   &lt;!ATTLIST veterinarian
    name  CDATA #REQUIRED
    phone CDATA #REQUIRED
   &gt;
   &lt;!ATTLIST trainer
    name  CDATA #REQUIRED
    phone CDATA #REQUIRED
   &gt;
   Пример 14.12. Модифицированный файл animals.xml, содержащий DTD
   &lt;?xml version="1.0" encodings "UTF-8"?&gt;
   &lt;!--Животные цирка Feldman Family Circus с DTD. --&gt;
   &lt;!DOCTYPE animalList SYSTEM "animals.dtd"&gt;
    &lt;!-так же, как в примере 14.1 --&gt;
   &lt;/animalList&gt;
   Пример 14.13. Проверка документа animals.xml на соответствие DTD с использованием программного интерфейса SAX2
   /*
   *Операторы #include из примера 14.8, кроме включения вектора&lt;vector&gt;который
   здесь не нужен
   */
   #include&lt;stdexcept&gt; // runtime_error
   #include&lt;xercesc/sax2/DefaultHandler.hpp&gt;
   using namespace std;
   using namespace xercesc;

   /*
    * Определить XercesInitializer, как это сделано в примере 14.8, и
    * CircusErrorHandler, как это сделано в примере 14.7
    */
   int main() {
    try {
     // Инициализировать Xerces и получить парсер
     SAX2 XercesInitializer init;
     auto_ptr&lt;SAX2XMLReader&gt;
      parser(XMLReaderFactory::createXMLReader());
     // Включить режим проверки
     parser-&gt;setFeature(XMLUni::fgSAX2CoreValidation, true);
     // Зарегистрировать обработчик ошибок для получения уведомлений о
     // нарушениях DTD
     CircusErrorHandler error;
     parser-&gt;setErrorHandler(&error);
     parser-&gt;parse("animals.xml");
    } catch (const SAXException& e) {
     cout&lt;&lt; "xml error "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const XMLException& e) {
     cout&lt;&lt; "xml error "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }
   Пример 14.14. Проверка документа animals.xml на соответствие DTD animals.dtd с использованием парсера XercesDOMParser
   #include&lt;exception&gt;
   #include&lt;iostream&gt;  // cout
   #include&lt;stdexcept&gt; // runtime_error
   #include&lt;xercesc/dom/DOM.hpp&gt;
   #include&lt;xercesc/parsers/XercesDOMParser.hpp&gt;
   #include&lt;xercesc/sax/HandlerBase.hpp&gt;
   #include&lt;xercesc/util/PlatformUtils.hpp&gt;
   #include "xerces_strings.hpp" //Пример 14.4

   using namespace std;
   using namespace xercesc;

   /*
    * Определить XercesInitializer, как это сделано в примере 14.8
    * и CircusErrorHandler, как это сделано в примере 14.7
    */
   int main() {
    try {
     // Инициализировать Xerces и сконструировать DOM-парсер.
     XercesInitializer init;
     XercesDOMParser parser;
     // Включить режим проверки DTD
     parser.setValidationScheme(XercesDOMParser::Val_Always);
     // Зарегистрировать обработчик ошибок для получения уведомлений о
     // нарушениях схемы
     CircusErrorHandler handler;
     parser.setErrorHandler(&handler);
     // Выполнить синтаксический анализ вместе с проверкой.
     parser.parse("animals.xml");
    } catch (const SAXException& e) {
     cout&lt;&lt; "xml error: "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const XMLException& e) {
     cout&lt;&lt; "xml error: "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }Обсуждение
   Определения DTD обеспечивают простой способ наложения ограничений на документ XML. Например, в DTD можно указать, какие элементы допускаются в документе, какие атрибуты может иметь элемент и может ли конкретный элемент содержать дочерние элементы, текст или и то и другое. Можно также накладывать ограничения на тип, порядок следования и количество дочерних элементов, а также на значения атрибутов.
   DTDпредназначены для определения подмножества правильно сформированных документов XML, которые характерны для определенной прикладной области. Например, в примере 14.1 важно то, что каждый элементanimalимеет дочерние элементыname,species,dateOfBirth,veterinarianиtrainer,а элементыname,speciesиdateOfBirthсодержат только текст в то время, как элементыveterinarianиtrainerимеют атрибутыnameиphone.Более того, элементanimalне должен иметь атрибутphone,а элементveterinarianне должен иметь дочерний элементspecies.
   DTDв примере 14.11 накладывает ограничения различного типа. Например, приведенное нижеобъявление элементаустанавливает необходимость наличия в элементе животного дочерних элементовname,species,dateOfBirth,veterinarianиtrainer,задаваемых именно в этом порядке.
   &lt;!ELEMENT animal (name, species, dateOfBirth,
                     veterinarian, trainer)&gt;
   Аналогично приведенное нижеобъявление атрибутауказывает на то, что элементtrainerдолжен иметь атрибутыnameиphone,а отсутствие в DTD объявлений других атрибутов для элемента дрессировщика говорит о том, что этот элемент может иметь только два атрибута.
   &lt;!ATTLIST trainer
    name  CDATA #REQUIRED
    phone CDATA #REQUIRED
   &gt;
   Документ XML, который содержит DTD и удовлетворяет его требованиям, называютдостоверным (valid). XML-парсер, который обнаруживает не только синтаксические ошибки, но и проверяет достоверность документа XML. называетсяподтверждающим парсером (validating parser).Хотя парсерыSAX2XMLReaderиXercesDOMParserне являются по умолчанию подтверждающими парсерами, в каждом из них предусмотрена функция подтверждения достоверности, которая может подключаться так, как это сделано в примерах 14.13 и 14.14. Аналогично парсерDOMBuilder,описанный в рецепте 14 4, может проверять достоверность документа XML, вызывая свой методsetFeaturе()с аргументамиfgXMLUni::fgDOMValidationиtrue.
    [Картинка: tip_yellow.png] КлассыSAX2XMLReader,DOMBuilder,DOMWriterиXercesDOMParserподдерживают ряд дополнительных функций. ВSAX2XMLReaderиDOMBuilderвы можете включать эти функции, используя методыsetFeature()иsetProperty().Первый метод принимает строку и булево значение: второй метод принимает строку иvoid*.Запросить включенные функции можно с помощью методовgetFeature()иgetProperty().Для удобства в Xerces предусмотрены константы с именами фикций и свойств. КлассDOMWriterподдерживаетsetFeature(),но не поддерживаетsetProperty().КлассXercesDOMParserподдерживает оба метода, в нем предусмотрены отдельные методы по установке и получению каждой функции. В документации Xerces вы найдете полный список поддерживаемыхдополнительных функций.Смотри также
   Рецепт 14.6.
   14.6.Проверка документа XML на соответствие схемеПроблема
   Требуется подтвердить соответствие документа XML схеме, представленной в рекомендациях XML Schema 1.0.Решение
   Используйте библиотеку Xerces совместно с программным интерфейсом SAX2 или с парсером DOM.
   Подтверждение соответствия документа XML схеме с использованием программного интерфейса SAX2 осуществляется точно так же, как подтверждение достоверности документа, содержащего DTD, когда схема содержится внутри целевого документа или когда на нее делается ссылка в этом документе. Если требуется проверить документ XML на соответствие внешней схеме, вы должны вызвать метод парсераsetProperty()для включения режима подтверждения внешней схемы. В качестве первого аргументаsetProperty()необходимо использоватьXMLUni::fgXercesSchemaExternalSchemaLocationилиXMLUni::fgXercesSchemaExternalNoNameSpaceSchemaLocationв зависимости оттого, используется или нет в схеме целевое пространство имен. Второй аргумент должен определять место расположения схемы, представленное значением типаconst XMLCh*.Не забудьте привести тип второго аргумента кvoid*,как это сделано в рецепте 14.5.
   Подтверждение соответствия документа XML схеме на основе использованияXercesDOMParserвыполняется аналогично подтверждению достоверности документа DTD, когда схема содержится внутри целевого документа или когда на нее делается ссылка в этом документе. Единственное отличие заключается в явном подключении средств поддержки схемы и пространства имен, как показано в примере 14.15.
   Пример 14.15. Включение режима подтверждения схемы при использовании XercesDOMParser
   XercesDOMParser parser;
   parser.setValidationScheme(XercesDOMParser::Val_Always);
   parser.setDoSchema(true);
   parser setDoNamespaces(true);
   Если требуется проверить документ XML на соответствие внешней схеме, имеющей целевое пространство имен, вызовите метод парсераsetExternalSchemaLocation(),передавая в качестве аргумента место расположения вашей схемы. Если требуется проверить документ XML на соответствие внешней схеме, не имеющей целевого пространства имен, вызовите метод парсераsetExternalNoNamespaceSchemaLocation().
   Аналогично для проверки документа XML на соответствие схемы с использованиемDOMBuilderвключите функцию подтверждения достоверности следующим образом.
   DOMBuilder* parser = ...;
   parser-&gt;setFeature(XMLUni::fgDOMNamespaces, true);
   parser-&gt;setFeature(XMLUni::fgDOMValidation, true);
   parser-&gt;setFeature(XMLUni::fgXercesSchema, true);
   Для подтверждения соответствия документа внешней схеме с использованиемDOMBuilderустановите свойствоXMLUni::fgXercesSchemaExternalSchemaLocationилиXMLUni::fgXercesSchemaExternalNoNameSpaceSchemaLocationв значение места расположения схемы.
   Например, пусть требуется проверить документanimals.xmlиз примера 14.1, используя схему из примера 14.16. Один из способов заключается в добавлении ссылки на схему в документanimals.xml,как показано в примере 14.17. После этого вы можете проверить документ, используя программный интерфейс SAX2, как показано в примере 14.13, или используя DOM, как показано впримере 14.14 с учетом модификаций, выполненных в примере 14.15.
   Пример 14.16. Схема animals.xsd для файла animals.xml
   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;!-Схема для животных цирка Feldman Family Circus --&gt;
   &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    elementFormDefault="qualified"&gt;
    &lt;xsd:element name="animalList"&gt;
    &lt;xsd:complexType&gt;
     &lt;xsd:sequence&gt;
      &lt;xsd:element name="animal" minOccurs="0" maxOccurs="unbounded"&gt;
       &lt;xsd:complexType&gt;
         &lt;xsd:sequence&gt;
          &lt;xsd:element name="name" type="xsd:string" /&gt;
          &lt;xsd:element name="species" type="xsd:string"/&gt;
          &lt;xsd:element name="dateOfBirth" type="xsd:date"/&gt;
          &lt;xsd:element name="veterinarian" type="contact"/&gt;
          &lt;xsd:element name="trainer" type="contact"/&gt;
         &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
       &lt;/xsd:element&gt;
      &lt;/xsd:sequence&gt;
     &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
    &lt;xsd:complexType name="contact"&gt;
    &lt;xsd:attribute name="name" type="xsd:string"/&gt;
    &lt;xsd:attribute name="phone" type="phone"/&gt;
    &lt;/xsd:complexType&gt;
    &lt;xsd:simpleType name="phone"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
     &lt;xsd:pattern value="\(\d{3}\)\d{3}-\d{4}"/&gt;
    &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
   &lt;/xsd:schema&gt;
   Пример 14.17. Модифицированный файл animals.xml, содержащий ссылку на схему
   &lt;?xml version="1.0" encoding="UTF-8"?&gt;
   &lt;!-Животные цирка Feldman Family Circus со схемой --&gt;
   &lt;animalList xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemalocation="animals.xsd"&gt;
   &lt;!-Так же, как в примере 14.1 --&gt;
   &lt;/animalList&gt;
   Можно поступить по-другому: опустить ссылку на схему и включить режим подтверждения соответствия документа внешней схеме. Пример 14.18 показывает, как это можно сделать при использовании парсера DOM.
   Пример 14.18. Подтверждение соответствия документа XML внешней схеме, используя DOM
   /*
    * Те же самые операторы #include, которые использовались в примере 14.14
    */
   using namespace std;
   using namespace xercesc;

   /*
    * Определить XercesInitializer, как в примере 14.8,
    * и CircusErorHandler, как в примере 14.7
    */
   int main() {
    try {
     // Инициализировать Xerces и сконструировать парсер DOM.
     XercesInitializer init;
     XercesDOMParser parser;
     // Включить проверку
     parser.setValidationScheme(XercesDOMParser::Val_Always);
     parser.setDoSchema(true); parser.setDoNamespaces(true);
     parser.setExternalNoNamespaceSchemaLocation(
      fromNative("animals.xsd").c_str());
     // Зарегистрировать обработчик ошибок для получения уведомлений о
     // нарушениях схемы
     CircusErrorHandler handler;
     parser.setErrorHandler(&handler);
     // Выполнить синтаксический анализ и проверить соответствие документа
     // схеме.
     parser parse("animals.xml");
    } catch (const SAXException& e) {
     cout&lt;&lt; "xml error: "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const XMLException& e) {
     cout&lt;&lt; "xml error: "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }Обсуждение
   Подобно определениям DTD, рассмотренным в предыдущем рецепте, схемы накладывают ограничения на документы XML. Схема предназначена для определения подмножества правильно сформированных документов, характерных для определенной прикладной области. Однако схемы имеют три отличия от определений DTD. Во-первых, концепция DTD и связанное с ней понятиеподтверждения достоверности (validity)определены в самой спецификации XML, в то время как схемы описаны в другой спецификации — в рекомендациях XML Schema. Во-вторых, сами схемы являются правильно сформированными документами XML, в то время как для описания определений DTD используется специальный синтаксис, продемонстрированный в примере 14.11. В-третьих, схемы существенно более выразительны, чем определения DTD. Из-за двух последних отличий считается, что схемы превосходят определения DTD.
   Например, в DTD из примера 14.11 можно было лишь потребовать, чтобы элементыveterinarianимели ровно два атрибута,nameиphone,значения которых состоят из символов. Напротив, схема в примере 14.16 требует, чтобы значение атрибутаphone,кроме того, соответствовало регулярному выражению\(\d{3}\)\d{3}-\d{4},т.е. чтобы оно имело вид(ddd)xxx-dddd,гдеdможет быть любой цифрой. Аналогично обстоит дело с элементомdateOfBirth:если в DTD можно было только потребовать, чтобы этот элемент имел текстовое значение, то схема требует, чтобы текстовое значение имело видyyyy-mm-dd,гдеyyyyзадается в диапазоне от 0001 до 9999,mm— от 01 до 12, add— от 01 до 31.
   Способность накладывать эти дополнительные ограничения создает большое преимущество, поскольку позволяет часть программистской работы переложить на парсер.Смотри также
   Рецепт 14.5.
   14.7.Преобразование документа XML с помощью XSLTПроблема
   Требуется преобразовать документ XML, используя таблицу стилей XSLT.Решение
   Используйте библиотеку Xalan. Во-первых, сконструируйте экземпляр конвертора XSTLxalanc::XalanTransformer.Затем сконструируйте два экземпляраxalanc::XSLTInputSource (один для документа, который будет преобразован, а другой для вашей таблицы стилей) и экземплярхаlanc::XSLTResultTargetдля документа, который будет получен в результате преобразования. Наконец, вызовите метод XSLTtransform(),передавая в качестве аргументов два экземпляраXSLTInputSourceи одинXSLTResultTarget.
   Например, представим, что требуется с помощью веб-браузера просматривать список животных цирка из примера 14.1. Это легко сделать с помощью XSLT В примере 14.19 приводится таблица стилей XSLT, которая на входе принимает документ XML, такой какanimals.xml,и формирует документ HTML, содержащий таблицу, в каждой строке которой описывается одно животное с указанием клички, вида, даты рождения, ветеринара и дрессировщика.Пример 14.20 показывает, как можно использовать библиотеку Xalan, чтобы воспользоваться этой таблицей стилей для документаanimals.xml.В примере 14.21 приводится HTML, сгенерированный программой из примера 14.20; этот HTML переформатирован для лучшего восприятия.
   Пример 14.19. Таблица стилей для animals.xml
   &lt;?xml version="1.0" encoding="utf-8"?&gt;
   &lt;!-Таблица стилей для животных цирка Feldman Family Circus --&gt;
   &lt;xsl:stylesheet versions="1.1"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:output method="html"/&gt;

    &lt;xsl:template match="/"&gt;
    &lt;html&gt;
     &lt;head&gt;
      &lt;title&gt;Feldman Family Circus Animals&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
      &lt;h1&gt;Feldman Family Circus Animals&lt;/h1&gt;
       &lt;table cellpadding="3" border="1"&gt;
        &lt;tr&gt;
         &lt;th&gt;Name&lt;/th&gt;
         &lt;th&gt;Species&lt;/th&gt;
         &lt;th&gt;Date of Birth&lt;/th&gt;
         &lt;th&gt;Veterinarian&lt;/th&gt;
         &lt;th&gt;Trainer&lt;/th&gt;
        &lt;/tr&gt;
        &lt;xsl:apply-templates match="animal"&gt;
        &lt;/xsl:apply-templates&gt;
      &lt;/table&gt;
     &lt;/body&gt;
    &lt;/html&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="animal"&gt;
     &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="name"/&gt;&lt;/td&gt;
     &lt;td&gt;&lt;xsl:value-of select="species"/&gt;&lt;/td&gt;
     &lt;td&gt;&lt;xsl:value-of select="dateOfBirth"/&gt;&lt;/td&gt;
      &lt;xsl:apply-templates select="veterinarian"/&gt;
     &lt;xsl:apply-templates select="trainer"/&gt;
     &lt;/tr&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="veterinarian|trainer"&gt;
    &lt;td&gt;
     &lt;table&gt;
      &lt;tr&gt;
       &lt;th&gt;name:&lt;/th&gt;
       &lt;td&gt;
        &lt;xsl:value-of select="attribute::name"/&gt;
       &lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
       &lt;th&gt;phone:&lt;/th&gt;
       &lt;td&gt;&lt;xsl:value of select="attribute::phone"/&gt;&lt;/td&gt;
      &lt;/tr&gt;
     &lt;/table&gt;
    &lt;/td&gt;
    &lt;/xsl:template&gt;
   &lt;/xsl:stylesheet&gt;
   Пример 14.20. Применение таблицы стилей animals.xsl для файла animals.xml с использованием библиотеки Xalan
   #include&lt;exception&gt;
   #include&lt;iostream&gt; // cout
   #include&lt;xalanc/Include/PlatformDefinitions.hpp&gt;
   #include&lt;xalanc/XalanTransformer/XalanTransformer.hpp&gt;
   #include&lt;xalanc/XSLT/XSLTInputSource.hpp&gt;
   #include&lt;xalanc/XSLT/XSLTResultTarget.hpp&gt;
   #include&lt;xercesc/util/PlatformUtils.hpp&gt;
   #include "xerces_strings.hpp" //Пример 14.4

   using namespace std;
   using namespace xercesc;
   using namespace xalanc;

   //Утилита RAII, которая инициализирует парсер и освобождает ресурсы
   //при выходе из области видимости
   struct XalanInitializer {
    XalanInitializer() {
     XMLPlatformUtils::Initialize();
     XalanTransformer::initialize();
    }
    ~XalanInitializer() {
     XalanTransformer::terminate();
     XMLPlatformUtils::Terminate();
    }
   };

   int main() {
    try {
     XalanInitializer init; // Инициализировать Xalan.
     XalanTransformer xslt; // Конвертор XSLT.
     XSLTInputSource xml("animals.xml"); // Документ XML из
                                         // примера 14.1
     XSLTInputSource xsl("animals.xsl"); // Таблица стилей из
                                         // примера 14.19.
     XSLTResultTarget html("animals.html"); // Результат выполнения xslt.
     // Выполнить преобразование.
     if (xslt.transform(xml, xsl, html) != 0) {
      cout&lt;&lt; "xml error: "&lt;&lt; xslt.getLastError()&lt;&lt; "\n";
     }
    } catch (const XMLException& e) {
     cout&lt;&lt; "xml error "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }
   Пример 14.21. Документ HTML, сгенерированный программой из примера 14.20
   &lt;html&gt;
    &lt;head&gt;
    &lt;МЕТА http-equiv="Content Type" content="text/html; charset=UTF-8"&gt;
    &lt;title&gt;Feldman Family Circus Animals&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;h1&gt;Feldman Family Circus Animals&lt;/h1&gt;
    &lt;table cellpadding="3" border="1"&gt;
     &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Species&lt;/th&gt;
      &lt;th&gt;Date of Birth&lt;/th&gt;
      &lt;th&gt;Veterinarian&lt;/th&gt;
      &lt;th&gt;Trainer&lt;/th&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;Herby&lt;/td&gt;
      &lt;td&gt;elephant&lt;/td&gt;
      &lt;td&gt;1992-04-23&lt;/td&gt;
      &lt;td&gt;
       &lt;table&gt;
        &lt;tr&gt;&lt;th&gt;name:&lt;/th&gt;&lt;td&gt;Dr. Hal Brown&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;th&gt;phone:&lt;/th&gt;&lt;td&gt;(801)595-9627&lt;/td&gt;&lt;/tr&gt;
       &lt;/table&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;table&gt;
        &lt;tr&gt;&lt;th&gt;name:&lt;/th&gt;&lt;td&gt;Bob Fisk&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;th&gt;phone:&lt;/th&gt;&lt;td&gt;(801)881-2260&lt;/td&gt;&lt;/tr&gt;
       &lt;/table&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;Sheldon&lt;/td&gt;
      &lt;td&gt;parrot&lt;/td&gt;
      &lt;td&gt;1998-09-30&lt;/td&gt;
      &lt;td&gt;
       &lt;table&gt;
        &lt;tr&gt;&lt;th&gt;name:&lt;/th&gt;&lt;td&gt;Dr. Kevin Wilson&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;th&gt;phone:&lt;/th&gt;&lt;td&gt;(801)466-6498&lt;/td&gt;&lt;/tr&gt;
       &lt;/table&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;table&gt;
        &lt;tr&gt;&lt;th&gt;name:&lt;/th&gt;&lt;td&gt;Eli Wendel&lt;/td&gt;&lt;/tr&gt;
         &lt;tr&gt;&lt;th&gt;phone:&lt;/th&gt;&lt;td&gt;(801)929-2506&lt;/td&gt;&lt;/tr&gt;
       &lt;/table&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
     &lt;tr&gt;
      &lt;td&gt;Dippy&lt;/td&gt;
      &lt;td&gt;penguin&lt;/td&gt;
      &lt;td&gt;2001-06-08&lt;/td&gt;
      &lt;td&gt;
       &lt;table&gt;
        &lt;tr&gt;&lt;th&gt;name:&lt;/th&gt;&lt;td&gt;Dr. Barbara Swayne&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;th&gt;phone:&lt;/th&gt;&lt;td&gt;(801)459-7746&lt;/td&gt;&lt;/tr&gt;
       &lt;/table&gt;
      &lt;/td&gt;
      &lt;td&gt;
       &lt;table&gt;
        &lt;tr&gt;&lt;th&gt;name:&lt;/th&gt;&lt;td&gt;Ben Waxman&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;&lt;th&gt;phone:&lt;/th&gt;&lt;td&gt;(801)882-3549&lt;/td&gt;&lt;/tr&gt;
       &lt;/table&gt;
      &lt;/td&gt;
     &lt;/tr&gt;
    &lt;/table&gt;
    &lt;/body&gt;
   &lt;/html&gt;Обсуждение
   XSL-преобразование (стандарт XSLT) представляет собой язык преобразования документов XML в другие документы XML. XSLT является одним из элементов семейства спецификаций расширяемых языков описания таблиц стилей (Extensible Stylesheet Language — XSL), который обеспечивает базовые средства для визуального представления документов XML Однако XSLT полезенне только при форматировании; например, он используется веб-серверами при генерации HTML-документов «на лету» и такими системами генерации документов, как DocBook.
   Преобразования XSLT представляются в виде документов XML, называемыхтаблицами стилей (stylesheets).Таблица стилей используется для обработкиисходного документаи формированиявыходного документа (result document).Таблица стилей состоит из набора шаблонов, которым соответствуют узлы исходного документа и которыеприменяютсядля получения фрагментов выходного документа. Шаблоны рекурсивно применяются к исходному документу, генерируя фрагменты выходного документа один за другим, покане будет обнаружено ни одного соответствия. Условия соответствия записываются с помощью языка XPath, предназначенного для извлечения информационных строк, чисел, булевых значений и наборов узлов из документов XML.
   Таблица стилей представленная в примере 14.19, состоит из трех шаблонов. В главном шаблоне атрибутmatchравен/,т.е. он соответствует корню исходною документа, а именно узлу, который является родительским узлом по отношению к корневому элементу документа и любым инструкциямобработки и комментариям верхнего уровня. При применении этого шаблона генерируется фрагмент документа HTML, содержащий заголовок «Животные цирка Feldman Family Circus» и таблицу с одной строкой, состоящей из пяти элементовthс меткамиName,Species,Date of Birth,Veterinarianиtrainer.Этот шаблон содержит элементapply-templates,которому соответствует атрибутanimal.Это приводит к тому, что второй шаблон таблицы стилей с атрибутом соответствияanimal— будет применяться один раз к каждому элементуanimal,дочернему по отношению к корневому документу, формируя строку таблицы для каждого дочернего элемента. Строка, сгенерированная для элементаanimal,состоит из пяти элементовtd.Первые три элементаtdсодержат текстовое значение дочерних элементовanimal (name,speciesиdateOfBirth),извлекаемое с помощью инструкции XSLTvalue-of.Последние два элементаtdсодержат элементы таблицы, полученные путем применения третьего шаблона таблицы стилей с атрибутом соответствияveterinarian|trainer,применяемого к дочерним элементам животногоveterinarianиtrainer.
   Хотя в примере 14.20 мною указаны локальные файлы для таблицы стилей, исходного документа и выходного документа,XSLTInputSourcesиXSLTResultTargetsмогут быть сконструированы из потоков стандартной библиотеки C++, позволяяXalanTransformerпринимать поток ввода и генерировать результат в произвольном месте. Более того, вместо получения на входе экземпляровXSLTInputSourceконверторXalanTransformerможет работать с предварительно скомпилированной таблицей стилей, представляющей экземплярxalanc::XalanCompiledStylesheet,и с исходным документом, прошедшим обработку парсером и представленным экземпляромxalanc::XalanParsedSource.Это проиллюстрировано в примере 14.22. Если требуется применять одну таблицу стилей к нескольким исходным документам, гораздо более эффективный результат получается при использованииXalanCompiledStylesheet,чемXSLTInputSource.
   Пример 14.22. Выполнение преобразования XSLT с применением предварительно откомпилированной таблицы стилей
   /*
    * те же операторы #include, которые использовались в примере 14.20
    */

   using namespace std;
   using namespace xercesc;
   using namespace xalanc;

   /*
    * Определить XalanInitializer так же, как в примере 14.20
    */
   int main() {
    try {
     XalanInitializer init; // Инициализировать Xalan
     XalanTransformer xslt; // Конвертор XSLT.
     XSLTResultTarget html("animals.html"); // Результат работы xslt.
     // Выполнить синтаксический анализ исходного документа
     XSLTInputSource xml("animals.xml");
     XalanParsedSource* parsedXml = 0;
     if (xslt.parseSource(xml, parsedXml) != 0) {
      cout&lt;&lt; "xml error: "&lt;&lt; xslt.getLastError()&lt;&lt; "\n";
     }
     // Компилировать таблицу стилей.
     XSLTInputSource xsl("animals.xsl");
     XalanCompiledStylesheet* compiledXsl = 0;
     if (xslt.compileStylesheet(xsl, compiledXsl) != 0) {
      cout&lt;&lt; "xml error: "&lt;&lt; xslt.getLastError()&lt;&lt; "\n";
     }
     // Выполнить преобразование.
     if (xslt.transform(xml, xsl, html)) {
      cout&lt;&lt; "xml error: "&lt;&lt; xslt.getLastFrror()&lt;&lt; "\n";
     }
    } catch (const XMLException& e) {
     cout&lt;&lt; "xml error: "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }Смотри также
   Рецепт 14.8.
   14.8.Вычисление XPath-выраженияПроблема
   Требуется извлечь информацию из документа XML, обработанного парсером, путем вычисления XPath-выражения.Решение
   Используйте библиотеку Xalan. Во-первых, выполните синтаксический анализ документа XML и получите указатель наxalanc::XalanDocument.Это можно сделать, используя экземплярыXalanSourceTreeInit,XalanSourceTreeDOMSupportиXalanSourceTreeParserLiaison,каждый из которых следующим образом определяется в пространстве именxalanc.
   #include&lt;xercesc/framework/LocalFileInputSource.hpp&gt;
   #include&lt;xalanc/XalanSourceTree/XalarSourceTreeDOMSupport.hpp&gt;
   #include&lt;xalanc/XalanSourceTree/XalanSourceTreeInit.hpp&gt;
   #include&lt;xalanc/XalanSourceTree/XalanSourceTreeParserLiaison.hpp&gt;
   ...

   int main() {
    ...
    // Инициализировать подсистему XalanSourceTree
    XalarSourceTreeInit init;
    XalanSourceTreeDOMSupport support;
    // Интерфейс доступа к парсеру
    XalanSourceTreeParserLiaison liaison(support);
    // Подключить DOMSupport к ParserLiaison
    support.setParserLiaison(&liaison);
    LocalFileInputSource src(место-расположения-документа);
    XalanDocument* doc = liaison.ParseXMLStream(doc);
    ...
   }
   Можно поступить по-другому и использовать парсер Xerces DOM для получения указателя наDOMDocument,как это сделано в примере 14.14, и затем использовать экземплярыXercesDOMSupport,XercesParserLiaisonиXercesDOMWrapperParsedSource,каждый из которых определяется в пространстве именxalancдля получения указателя наXalanDocument,соответствующего документуDOMDocument.
   #include&lt;xercesc/dom/DOM.hpp&gt;
   #include&lt;xalanc/XalanTransformer/XercesDOMWrapperParsedSource.hpp&gt;
   #include&lt;xalanc/XercesParserLiaison/XercesParserLiaison.hpp&gt;
   #include&lt;xalanc/XercesParserLiaison/XercesDOMSupport.hpp&gt;
   ...

   int main() {
    ...
    DOMDocument* doc = ...;
    XercesDOMSupport support;
    XercesParserLiaison liaison(support);
    XercesDOMWrapperParsedSource src(doc, liaison, support);
    XalanDocument* xalanDoc = src.getDocument();
    ...
   }
   На следующем шаге получите указатель на узел, выполняющий роль узла контекста при вычислении выражения XPath. Это можно сделать с помощью интерфейса DOM документаXalanDocument.СконструируйтеXPathEvaluatorдля вычисления выражения XPath иXalanDocumentPrefixResolverдля разрешения префиксов пространств имен в документе XML. Наконец, вызовите методXPathEvaluator::evaluate(),передавая в качестве аргументовDOMSupport,контекстный узел, XPath-выражение иPrefixResolver.Результат вычисления выражения возвращается в виде объекта типаXObjectPtr;тип допустимых операций над этим объектом зависит от типа его данных XPath, который можно узнать при помощи методаgetType().
   Например, пусть требуется извлечь список имен животных из документаanimals.xml,представленного в примере 14.1. Вы можете это сделать, выполняя синтаксический анализ документа и вычисляя XPath-выражениеanimalList/animal/name/child::text()с использованием корня документа в качестве контекстного узла. Это проиллюстрировано в примере 14.23.
   Пример 14.23. Вычисление ХРаth-выражения, используя Xalan
   #include&lt;cstddef&gt; // size_t
   #include&lt;exception&gt;
   #include&lt;iostream&gt; // cout
   #include&lt;xercesc/dom/DOM.hpp&gt;
   #include&lt;xercesc/parsers/XercesDOMParser.hpp&gt;
   #include&lt;xercesc/sax2/DefaultHandler.hpp&gt;
   #include&lt;xercesc/util/PlatformUtils.hpp&gt;
   #include&lt;xalanc/DOMSupport/XalanDocumentPrefixResolver.hpp&gt;
   #include&lt;xalanc/XalanTransformer/XercesDOMWrapperParsedSource.hpp&gt;
   #include&lt;xalanc/XercesParserLiaison/XercesParserLiaison.hpp&gt;
   #include&lt;xalanc/XercesParserLiaison/XercesDOMSupport.hpp&gt;
   #include&lt;xalanc/XPath/XObject.hpp&gt;
   #include&lt;xalanc/XPath/XPathEvaluator.hpp&gt;
   #include "animal.hpp"
   #include "xerces_strings.hpp"

   using namespace std;
   using namespace xercesc;
   using namespace xalanc;

   //Утилита RAII, которая инициализирует парсер и процессор XPath, освобождая
   //ресурсы при выходе из области видимости
   class XPathInitializer {
   public:
    XPathInitializer() {
    XMLPlatformUtils::Initialize();
    XPathEvaluator::initialize();
   }
   ~XPathInitializer() {
    XpathEvaluator::terminate();
    XMLPlatformUtils::Terminate();
   }
   private:
    // Запретить копирование и присваивание
    XPathInitializer(const XPathInitializer&);
    XPathInitializer& operator=(const XPathInitializer&);
   };

   //Получает уведомления об ошибках
   class CircusErrorHandler : public DefaultHandler {
   public:
    void error(const SAXParseException& e) {
     throw runtime_error(toNative(e.getMessage()));
    }
    void fatalError(const SAXParseException& e) { error(e); }
   };

   int main() {
    try {
     // Инициализировать Xerces и XPath и сконструировать парсер DOM.
     XPathInitializer init;
     XercesDOMParser parser;
     // Зарегистрировать обработчик ошибок
     CircusErrorHandler error;
     parser.setErrorHandler(&error);
     // Выполнить синтаксический анализ animals.xml.
     parser.parse(fromNative("animals.xml").c_str());
     DOMDocument* doc = parser.getDocument();
     DOMElement* animalList = doc-&gt;getDocumentElement();
     // Создать XalanDocument на основе doc.
     XercesDOMSupport support;
     XercesParserLiaison liaison(support);
     XercesDOMWrapperParsedSource src(doc, liaison, support);
     XalanDocument* xalanDoc = src.getDocument();
     // Вычислить XPath-выражение для получения списка
     // текстовых узлов, содержащих имена животных
     XPathEvaluator evaluator;
     XalanDocumentPrefixResolver resolver(xalanDoc);
     XercesString xpath =
      fromNative("animalList/animal/name/child::text()");
     XObjectPtr result =
      evaluator.evaluate(
       support,       // поддержка DOM
       xalanDoc,      // контекстный узел
       xpath.c_str(), // XPath-выражение
       resolver);     // функция разрешения пространства имен
     const NodeRefListBase& nodeset = result-&gt;nodeset();
     // Просмотр списка узлов и вывод имен животных
     for (size_t i = 0, len = nodeset.getLength(); i&lt; len; ++i) {
      const XMLCh* name = nodeset.item(i)-&gt;getNodeValue().c_str();
      std::cout&lt;&lt; toNative(name)&lt;&lt; "\n";
     }
    } catch (const DOMException& e) {
     cout&lt;&lt; "xml error: "&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }Обсуждение
   XPath— это язык поиска по образцу (pattern matching language), предназначенный для извлечения информации из документов XML. Основная конструкция XPath —выражение пути (path expression)поддерживает иерархический синтаксис ссылок на элементы, атрибуты и текстовые узлы на основе использования их имен, атрибутов, текстового содержимого, отношений наследования и других свойств. Кроме работы снаборами узловязык XPath может обрабатывать строки, числа и булевы значения. XPath версии 2.0, которая в настоящее время не поддерживается библиотекой Xalan, использует даже более сложную модель данных, основанную на рекомендациях XML Schema. (См. рецепт 14.5.)
   XPath-выражения вычисляются в контексте узла документа XML, называемого контекстным узлом, который используется для интерпретации связанной с ним конструкции, например,parent,childиdescendant.В примере 14.23 я указал корень (root)документа XML в качестве контекстного узла; этот узел является родительским по отношению к корневому элементу документа XML, а также к любой инструкции обработки и комментариям верхнего уровня. При вычислении выражения с использованием корневого узла в качестве контекстного узла выражение путиanimalList/animal/name/child::text()соответствует всем текстовым узлам, дочерним по отношению к элементам name, родительским элементом которых являетсяanimal,и чьим «дедушкой» является элементanimalList.
   Методevaluate()классаXPathEvaluatorвозвращаетXObjectPtr,представляющий результат вычисления выражения XPath. Тип данных, на который ссылаетсяXObjectPtr,можно узнать путем его разыменования с получениемXObjectи вызова методаgetType();затем можно получить доступ к базовым данным при помощи вызоваnum(),boolean(),str()илиnodeset().Поскольку XPath-выражение в примере 14.23 представляет набор узлов, я использовал методnodeset()для получения ссылки наNodeRefListBase,который обеспечивает доступ к узлам в наборе с помощью его методовgetLength()иitem().Методitem()возвращает указатель на узелXalanNode,методgetNodeValue()которого возвращает строку с интерфейсом, похожим на интерфейсstd::basic_string.
   Поскольку XPath обеспечивает простой способ определения местоположения узлов в документе XML, возникает естественный вопрос о возможности применения выражений Xalan XPath для получения экземпляровxercesc::DOMNodeизxercesc::DOMDocument.На самом деле это возможно, но не совсем удобно, а кроме того, по умолчанию узлыxercesc::DOMNodes,полученные таким способом, представляют дерево документа XML с возможностямитолько чтения,что уменьшает пользу от применения XPath в качестве средства манипулирования DOM. Существуют способы, позволяющие обойти это ограничение, однако они достаточно сложны и потенциально опасны.
   К счастью, библиотека Pathan реализует XPath, совместимый с Xerces и позволяющий легко манипулировать Xerces DOM. Пример 14.24 показывает, как можно использовать Pathan для определения места расположения и удаления узла слона Herby из документа XML, приведенного в примере 14.1, с помощью вычисления XPath-выраженияanimalList/animal[child::name='Herby'].Сравнение этого примера с примером 14.10 ясно показывает, насколько мощным является язык XPath.
   Пример 14.24. Определение местоположения узла и удаление его с использованием библиотеки Pathan
   #include&lt;exception&gt;
   #include&lt;iostream&gt; // cout
   #include&lt;xercesc/dom/DOM.hpp&gt;
   #include&lt;xercesc/framework/LocalFileFormatTarget.hpp&gt;
   #include&lt;xercesc/util/PlatformUtils.hpp&gt;
   #include&lt;pathan/XPathNamespace.hpp&gt;
   #include&lt;pathan/XPathResult.hpp&gt;
   &lt;include&lt;pathan/XPathEvaluator.hpp&gt;
   #include&lt;pathan/XPathExpression.hpp&gt;
   #include "xerces_strings.hpp" //Пример 14.4

   using namespace std;
   using namespace xercesc;

   /*
    * Определить XercesInitializer, как это сделано в примере 14.8, а также
    * CircusFrrorHandler и DOMPtr, как это сделано в примере 14.10
    */

   int main() {
    try {
     // Инициализировать Xerces и получить DOMImplementation.
     XercesInitializer init;
     DOMImplementation* impl =
      DOMImplementationRegistry::getDOMImplementation(
       fromNative("LS").c_str()
      );
     if (impl == 0) {
      cout&lt;&lt; "couldn't create DOM implementation\n";
      return EXIT_FAILURE;
     }
     // Сконструировать DOMBuilder для синтаксического анализа
     // документа animals.xml.
     DOMPtr&lt;DOMBuilder&gt; parser =
      static cast&lt;DOMImplementationLS*&gt;(impl)-&gt; createDOMBuilder(
       DOMImplementationLS::MODE_SYNCHRONOUS, 0
      );
     CircusErrorHandler err;
     parser-&gt;setErrorHandler(&err);
     // Выполнить синтаксический анализ
     animals.xml. DOMDocument* doc =
      parser-&gt;parseURI("animals.xml");
     DOMElement* animalList = doc-&gt;getDocumentElement();
     // Создать XPath-выражение.
     auto_ptr&lt;XPathEvaluator&gt;
      evaluator(XPathEvaluator::createEvaluator());
     auto_ptr&lt;XPathNSResolver&gt;
      resolver(evaluator-&gt;createNSResolver(animalList));
     auto_ptr&lt;XPathExpression&gt; xpath(
      evaluator-&gt;createExpression(FromNative(
       "animalList/animal[child::name='Herby']" ).c_str(), resolver.get()
      )
     );
     auto_ptr&lt;XPathEvaluator&gt; evaluator(XPathEvaluator::createEvaluator());
     auto_ptr&lt;XPathNSResolver&gt; resolver(evaluator-&gt;createNSResolver(animalList));
     auto_ptr&lt;XPathExpression&gt; xpath(evaluator-&gt;createExpression(
      fromNative("animalList/animal[child::name='Herby']").c_str(),
      resolver.get()
     ));
     // Вычислить выражение.
     XPathResult* result = xpath-&gt;evaluate(doc,
      XPathResult::ORDERED_NODE_ITERATOR_TYPE, 0
     );
     DOMNode* herby;
     if (herby = result-&gt;iterateNext()) {
      animalList-&gt;removeChild(herby);
      herby-&gt;release(); // optional
     }
     // Сконструировать DOMWriter для сохранения animals.xml
     DOMPtr&lt;DOMWriter&gt; writer =
      static_cast&lt;DOMImplementationLS-&gt;(impl)-&gt;createDOMWriter();
     writer-&gt;setErrorHandler(&err);
     // Сохранить animals.xml.
     LocalFileFormatTarget file("circus.xml");
     writer-&gt;writeNode(&file, *animalList);
    } catch (const DOMException& e) {
     cout&lt;&lt; toNative(e.getMessage())&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const XPathException&e) {
     cout&lt;&lt; e.getString()&lt;&lt; "\n";
     return EXIT_FAILURE;
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }
   Пример 14.24 использует Pathan 1, который реализует рекомендации XPath 1.0; библиотекой Xalan в настоящее время поддерживается именно эта версия. Pathan 2, который в настоящее время доступен в бета-версии, обеспечивает предварительную реализацию рекомендаций XPath 2.0. Pathan 2 представляет собой более точную реализацию стандарта XPath; я рекомендуюиспользовать Pathan 2 вместо Pathan 1, как только станет доступна не бета-версия.Смотри также
   Рецепт 14.7.
   14.9.Применение XML для сохранения и восстановления набора объектовПроблема
   Требуется иметь возможность сохранения набора объектов C++ в документе XML и считывания их потом обратно в память.Решение
   Используйте библиотеку Boost Serialization. Эта библиотека позволяет сохранять и восстанавливать объекты, используя классы, называемыеархивами.Для использования этой библиотеки вы должны сначала сделать каждый из ваших классовсериализуемым (serializable),что просто означает возможность записи экземпляров класса в архив (это называетсясериализацией)и их обратного считывания в память (это называетсядесериализацией).Затем на этапе выполнения вы можете сохранить ваши объекты в архиве XML, используя оператор&lt;&lt;,и восстановить их, используя оператор&gt;&gt;.
   Чтобы сделать класс сериализуемым, добавьте шаблон функции-членаserializeсо следующей сигнатурой.
   template&lt;typename Archive&gt;
   void serialize(Archive& ar, const unsigned int version);
   В реализацииserializeнеобходимо обеспечить запись каждого данного-члена класса в указанный архив в виде пары «имя-значение», используя оператор&.Например, если вы хотите сериализовать и десериализовать экземпляры классаContactиз примера 14.2, добавьте функцию-членserialize,как это сделано в примере 14.25.
   Пример 14.25. Добавление поддержки сериализации в класс Contact из примера 14.2
   #include&lt;boost/serialization/nvp.hpp&gt; //пара "имя-значение"

   class Contact {
    ...
   private:
    friend class boost::serialization::access;
    template&lt;typename Archive&gt;
    void serialize(Archive& ar, const unsigned int version) {
     // Записать (или считать) каждое данное-член в виде пары имя-значение
     using boost::serialization::make_nvp;
     ar& make_nvp("name", name_);
     ar& make_nvp("phone", phone_);
    }
   ...
   };
   Аналогично можно обеспечить сериализацию классаAnimalиз примера 14.2, как это сделано в примере 14.26.
   Пример 14.26. Добавление поддержки сериализации для класса Animal из примера 14.2
   ...
   //Включить поддержку сериализации для boost::gregorian::date
   #include&lt;boost/date_time/gregorian/greg_serialize.hpp&gt;
   ...

   class Contact {
    ...
   private:
    friend class boost::serialization::access;
    template&lt;typename Archive&gt;
    void serialize(Archive& ar, const unsigned int version) {
     // Записать (или считать) каждое данное-член в виде пары имя-значение
     using boost::serialization::make_nvp;
     ar& make_nvp("name", name_);
     ar& make_nvp("species", species_);
     ar& make_nvp("dateOfBirth", dob_);
     ar& make_nvp("veterinarian", vet_);
     ar& make_nvp("trainer", trainer_);
    }
    ...
   };
   Теперь вы можете сериализовать Animal, создавая архив XML типаboost::archive::xml_oarchiveи записывая информацию о животном в архив, используя оператор&lt;&lt;.Конструкторxml_oarchiveв качестве аргумента принимаетstd::ostream;часто этим аргументом будет поток вывода, используемый для записи в файл, однако в общем случае для записи данных может использоваться ресурс любого типа. После сериализации экземпляраAnimalего можно считать обратно в память, конструируя архив XML типа boost::archive::xml_iarchive,подключая его к тому же самому ресурсу, который использовался первым архивом, и применяя оператор&gt;&gt;.
   Пример 14.27 показывает, как можно использовать Boost.Serialization для сохранения вектораstd::vector,состоящего из объектовAnimal,в файлеanimals.xmlи затем для загрузки его обратно в память. В примере 14.28 показано содержимое файлаanimals.xmlпосле выполнения программы из примера 14.27.
   Пример 14.27 Сериализация вектора std::vector, состоящего из объектов Animal
   #include&lt;fstream&gt;
   #include&lt;boost/archive/xml_oarchive.hpp&gt; //Архив для записи XML
   #include&lt;boost/archive/xml_iarchive.hpp&gt; //Архив для чтения XML
   #include&lt;boost/serialization/vector.hpp&gt; //Средства сериализации вектора
   #include "animal.hpp" // std::vector

   int main() {
    using namespace std;
    using namespace boost::archive;       // пространство имен для архивов
    using namespace boost::serialization; // пространство имен для make_nvp
    try {
     // Заполнить список животных
     vector&lt;Animal&gt; animalList;
     animalList.push_back(
      Animal("Herby", "elephant", "1992-04-23",
      Contact("Dr. Hal Brown", "(801)595-9627"),
      Contact("Bob Fisk", "(801)881-2260")));
     animalList.push_back(
      Animal("Sheldon", "parrot", "1998-09-30",
      Contact("Dr. Kevin Wilson", "(801)466-6498"),
      Contact("Eli Wendel", "(801)929-2506")));
     animalList.push_pack(
      Animal("Dippy", "penguin", "2001-06-08",
      Contact("Dr. Barbara Swayne", "(801)459-7746"),
      Contact("Ben Waxman", "(801)882-3549")));
     // Сконструировать выходной архив XML и сериализовать список
     ofstream fout("animals.xml");
     xml_oarchive oa(fout);
     oa&lt;&lt; make_nvp("animalList", animalList);
     fout.close();
     // Сконструировать входной архив XML и десериализовать список
     ifstream fin("animals.xml");
     xml_iarchive ia(fin);
     vector&lt;Animal&gt; animalListCopy;
     ia&gt;&gt; make_nvp("animalList", animalListCopy);
     fin.close();
     if (animalListCopy != animalList) {
      cout&lt;&lt; "XML serialization failed\n";
      return EXIT_FAILURE;
     }
    } catch (const exception& e) {
     cout&lt;&lt; e.what()&lt;&lt; "\n";
     return EXIT_FAILURE;
    }
   }
   Пример 14.28. Файл animals.xml после выполнения программы из примера 14.27
   &lt;?xml version="1.0" encoding="UTF-8" standalone="yes" ?&gt;
   &lt;!DOCTYPE boost_serialization&gt;
   &lt;boost_serialization signature="serialization::archive" version="3"&gt;
   &lt;animalList class_id="0" tracking_level ="0" version="0"&gt;
    &lt;count&gt;3&lt;/count&gt;
    &lt;item class_id="1" tracking_level="0" version="0"&gt;
    &lt;name&gt;Herby&lt;/name&gt;
     &lt;species&gt;elephant&lt;/species&gt;
    &lt;dateOfBirth class_id="2" tracking_level="0" version="0"&gt;
     &lt;date&gt;19920423&lt;/date&gt;
    &lt;/dateOfBirth&gt;
    &lt;veterinarian class_id="3" tracking_level="0" version="0"&gt;
     &lt;name&gt;Dr. Hal Brown&lt;/name&gt;
     &lt;phone&gt;(801)595-9627&lt;/phone&gt;
    &lt;/veterinarian&gt;
    &lt;trainer&gt;
     &lt;name&gt;Bob Fisk&lt;/name&gt;
     &lt;phone&gt;(801)881-2260&lt;/phone&gt;
    &lt;/trainer&gt;
    &lt;/item&gt;
    &lt;item&gt;
    &lt;name&gt;Sheldon&lt;/name&gt;
    &lt;species&gt;parrot&lt;/species&gt;
    &lt;dateOfBirth&gt;
     &lt;date&gt;19980930&lt;/date&gt;
    &lt;/dateOfBirth&gt;
    &lt;veterinarian&gt;
     &lt;name&gt;Dr. Kevin Wilson&lt;/name&gt;
     &lt;phone&gt;(801)466-6498&lt;/phone&gt;
    &lt;/veterinarian&gt;
     &lt;trainer&gt;
     &lt;name&gt;Eli Wendel&lt;/name&gt;
     &lt;phone&gt;(801)929-2506&lt;/phone&gt;
    &lt;/trainer&gt;
    &lt;/item&gt;
    &lt;item&gt;
    &lt;name&gt;Dippy&lt;/name&gt;
    &lt;species&gt;penguin&lt;/species&gt;
    &lt;dateOfBirth&gt;
     &lt;date&gt;20010608&lt;/date&gt;
     &lt;/dateOfBirth&gt;
    &lt;veterinarian&gt;
     &lt;name&gt;Dr. Barbara Swayne&lt;/name&gt;
     &lt;phone&gt;(801)459-7746&lt;/phone&gt;
    &lt;/veterinarian&gt;
     &lt;trainer&gt;
     &lt;name&gt;Ben Waxman&lt;/name&gt;
     &lt;phone&gt;(801)882-3549&lt;/phone&gt;
    &lt;/trainer&gt;
    &lt;/item&gt;
   &lt;/animalList&gt;Обсуждение
   Библиотека Boost Serialization обеспечивает наиболее изощренный и гибкий способ сохранения и восстановления объектов C++. Она представляет собой очень сложный фреймворк. Например, она позволяет сериализовать сложные структуры данных, содержащие циклические ссылки и указатели на полиморфные объекты. Более того, применение этой библиотеки совсем не ограничивается сериализацией XML: кроме архивов XML она предоставляет несколько типов текстовых и бинарных архивов. Архивы XML и текстовые архивы являются переносимыми, т.е. данные можно сериализовать в одной системе и десериализовать в другой; бинарные архивы не переносимы, но компактны.
   Нет никаких спецификаций, которым соответствовали бы документы XML, полученные при помощи Boost.Serialization, и их формат может изменяться в новых версиях Boost. Поэтому вы не можете использовать эти документы совместно с другими фреймворками сериализации С++. Тем не менее XML-сериализация приносит пользу, потому что сериализованный выводлегко воспринимается человеком и может обрабатываться инструментальными средствами, ориентированными на XML.
   Примеры 14.25 и 14.26 демонстрируютинтрузивную сериализацию (intrusive serialization):классыAnimalиContactбыли модифицированы, чтобы обеспечить их сериализацию.Boost.Serializationтакже поддерживаетнеинтрузивную сериализацию (nonintrusive serialization),обеспечивая сериализацию классов без модификации их определений при условии доступности всех состояний объекта через его открытый интерфейс. Вы уже видели пример неинтрузивной сериализации в примере 14.27: шаблонstd::vectorдопускает сериализацию, несмотря на то что его определение не может модифицироваться конечными пользователями. Фактически все контейнеры стандартной библиотекиявляются сериализуемыми; для обеспечения сериализации контейнера, определенного в стандартном заголовочном файлеxxx,просто включите заголовочный файлboost/serialization/xxx.hpp.Дополнительную информацию о неинтрузивной сериализации вы можете найти в документации Boost.Serialization.
   Примеры 14.25 и 14.26 иллюстрируют также двойственную роль оператора&:он действует как оператор&lt;&lt;при сериализации объекта и как оператор&gt;&gt;при десериализации объекта. Это удобно, потому что позволяет реализовать сериализацию и десериализацию одной функцией. Однако в некоторых случаях неудобно использовать одну функцию для сериализации и десериализации; для этого в Boost.Serialization предусмотрен механизм разделения методаserialize()на два отдельных метода,load()иsave().Если вам необходимо воспользоваться преимуществами этой возможности, обратитесь к документации Boost.Serialization.
   В примерах 14.25, 14.26 и 14.27 я использую функциюboost::serialization::make_nvpдля конструирования пар вида «имя-значение». В Boost.Serialization предусмотрен также макросBOOST_SERIALIZATION_NVP,который позволяет выполнять сериализацию переменной, указывая ее имя. Первый компонент пары будет сконструирован автоматически препроцессором, используя оператор «стрингизации» (stringizing)#для преобразования макропараметров в строковые константы.
   //То же самое, что и ar& make_nvp("name_", name_);
   ar& BOOST_SERIALIZATION_NVP(name_);
   В этих примерах я используюmake_nvpвместоBOOST_SERIALIZATION_NVPдля лучшего контроля имен тегов, чтобы содержимое архива XML легче читалось.
   В документации Boost.Serialization рекомендуется объявлять методserialize()как закрытый (private)для уменьшения ошибок пользователя, когда добавляется поддержка сериализации в классы, производные от других сериализуемых классов. Для того чтобы библиотека Boost.Serialization могла вызвать методserialize()вашего класса, вам необходимо объявить дружественным класс boost::serialization::access.
   Наконец второй параметр методаserialize()в примерах 14.25 и 14.26 относится к той части Boost.Serialization, которая поддерживаетуправление версиями классов (class versioning).Когда объект определенного класса первый раз сохраняется в архиве, вместе с ним сохраняется также его версия; когда выполняется десериализация экземпляра класса.Boost.Serialization передает сохраненную версию методуserializeв качестве второго аргумента. Эта информация может использоваться для специализации десериализации; например,serializeмог бы загружать переменную-член только в том случае, если записанная в архив версия класса, по крайней мере, не меньше версии класса, первым объявившим эту переменную. По умолчанию класс имеет версию 0. Для задания версии класса вызовите макросBOOST_CLASS_VERSION,который определен в заголовочном файлеboost/serialization/version.hpp,передавая в качестве аргументов имя и версию класса.
   Глава 15
   Разные функции
   15.0.Введение
   В этой главе рассматриваются некоторые аспекты C++, которые плохо вписываются в тематику любой другой главы: указатели функций и членов, константные переменные и функции- члены, независимые операторы (т.е. не члены класса) и несколько других тем.
   15.1.Применение указателей функций для их обратного вызоваПроблема
   Планируется использование некоторой функцииfunc1,которая на этапе выполнения должна вызывать другую функциюfunc2.Однако по той или иной причине нельзя внутри функцииfunc1жестко закодировать имя функцииfunc2.Возможно, имя функцииfunc2неизвестно на этапе компиляции, илиfunc1относится к программному интерфейсу независимого разработчика, и она не может быть изменена и перекомпилирована В любом случае вам придется воспользоваться функциейобратного вызова (callback function).Решение
   При использовании указанных выше функций объявитеfunc1с указателем на функцию в качестве своего аргумента и передайте ей адресfunc2на этапе выполнения. Используйтеtypedef,чтобы программа легче читалась и отлаживалась. Пример 15.1 показывает, как можно реализовать функцию обратного вызова, используя указатель на функцию.
   Пример 15.1. Функция обратного вызова
   #include&lt;iostream&gt;

   //Пример функции обратного вызова
   bool updateProgress(int pct) {
    std::cout&lt;&lt; pct&lt;&lt; "% complete...\n";
    return(true);
   }

   //Этот typedef делает программный код более понятным
   typedef bool (*FuncPtrBoolInt)(int);

   //Функция, которая выполняется достаточно длительное время
   void longOperation(FuncPtrBoolInt f) {
    for (long l=0; l&lt; 100000000; l++)
    if (l % 10000000 == 0)
    f(l/1000000);
   }

   int main() {
    longOperation(updateProgress); // нормально
   }Обсуждение
   В ситуации, которая показана в примере 15.1, применение указателя на функцию является хорошим решением, еслиUpdateProgressиlongOperationничего не должны знать друг о друге. Например, функцию, которая обновляет индикатор состояния процесса в диалоговом окне пользовательского интерфейса (user interface — UI), в окне консольного режима или где-то еще, не заботит контекст, в котором она вызывается. Аналогично функцияlongOperationможет быть частью некоторого программного интерфейса загрузки данных, которого не заботит место вызова: из графического UI, из окна консольного режима или из фонового процесса.
   Сначала потребуется определить сигнатуру функции, которую вы планируете вызывать, и создать для нееtypedef.Операторtypedef— ваш помощник в тех случаях, когда приходится иметь дело с указателями функций, потому что они имеют не очень привлекательный синтаксис. Рассмотрим, как обычно объявляется такой указатель на примере переменнойf,которая содержит адрес функции, принимающей единственный аргумент целого типа и возвращающей значения типаboolean.Это может выглядеть следующим образом
   bool (*f)(int); // f -имя переменной
   Вы можете справедливо возразить, что здесь нет ничего особенного и я просто излишне драматизирую ситуацию. Но что вы скажете, если требуется определить векторvectorтаких указателей?
   vector&lt;bool (*)(int)&gt; vf;
   Или их массив?
   bool (*af[10])(int);
   Форма представления указателей на функции отличается от обычных переменных С++, которые обычно задаются в виде (квалифицированного) имени типа, за которым идет имяпеременной. Поэтому они вносят путаницу при чтении программного кода.
   Итак, в примере 15.1 я использовал следующийtypedef.
   typedef bool (*FuncPtrBoolInt)(int);
   Сделав это, я могу свободно объявлять указатели функций с сигнатурой, возвращающей значениеboolи принимающей единственный аргумент, как это я бы делал для параметра любого другого типа, например.
   void longOperation(FuncPtrBoolInt f) { // ...
   Теперь все, что надо сделать вlongOperation,— это вызватьf,как если бы это была любая обычная функция.
   f(l/1000000);
   Таким образам, здесьfможет быть любой функцией, которая принимает аргумент целого типа и возвращаетbool.Предположим, что в вызывающей функцииlongOperationне требуется обеспечивать продвижение индикатора состояния процесса. Тогда ей можно передать указатель на функцию без операций.
   bool whoCares(int i) {return(true);}
   //...
   longOperation(whoCares);
   Более важно то, что выбор функции, передаваемойlongOperation,может осуществляться динамически на этапе выполнения.
   15.2.Применение указателей для членов классаПроблема
   Требуется обеспечить адресную ссылку на данное-член или на функцию-член.Решение
   Используйте имя класса и оператор области видимости (::)со звездочкой для правильного квалифицирования имени. Пример 15.2 показывает, как это можно сделать.
   Пример 15.2. Получение указателя на член класса
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   class MyClass {
   public:
    MyClass() : ival_(0), sval_("foo") {}
    ~MyClass() {}
    void incr() {++ival_;}
    void decr() {ival_--;}
   private:
    std::string sval_;
    int ival_;
   };

   int main() {
    MyClass obj;
    int MyClass::* mpi =&MyClass::ival_;         // Указатели на
    std::string MyClass::* mps =&MyClass::sval_; //данные-члены
    void (MyClass::*mpf)(); // Указатель на функцию-член, у которой
                            // нет параметров и которая возвращает void
    void (*pf)(); // Обычный указатель на функцию
    int* pi =&obj.ival_; // int-указатель, ссылающийся на переменную-член
                          // типа int, - все нормально.
    mpf =&MyClass::incr; //Указатель на функцию-член. Вы не можете
                          // записать это значение в поток. Посмотрите в
                          // отладчике, как это значение выглядит.
    pf =&MyClass::incr; //Ошибка:&MyClass::incне является экземпляром
                         // функции
    std::cout&lt;&lt; "mpi = "&lt;&lt; mpi&lt;&lt; '\n';
    std::cout&lt;&lt; "mps = "&lt;&lt; mps&lt;&lt; '\n';
    std::cout&lt;&lt; "pi = "&lt;&lt; pi&lt;&lt; '\n';
    std::cout&lt;&lt; "*pi = "&lt;&lt; *pi&lt;&lt; '\n';
    obj.*mpi = 5;
    obj.*mps = "bar";
    (obj.*mpf)(); // теперь obj.ival_ равно 6
    std::cout&lt;&lt; "obj.ival_ = "&lt;&lt; obj.ival_&lt;&lt; '\n';
    std::cout&lt;&lt; "obj.sval_ = "&lt;&lt; obj.sval_&lt;&lt; '\n';
   }Обсуждение
   Указатели на члены класса выглядят и работают иначе, чем обычные указатели. Прежде всего, они имеют «смешной» синтаксис (не вызывающий смех, но странный). Рассмотрим следующую строку из примера 15.2.
   int MyClass::* mpi =&MyClass::ival_;
   Здесь объявляется указатель и ему присваивается значение целого типа, которым оказывается член классаMyClass.Две вещи отнимают это объявление от обычногоint*.Во-первых, вам приходится вставлять имя класса и оператор области видимости между типом данного и звездочкой. Во-вторых, при выполнении операции присваивания этому указателю на самом деле не назначается какой то определенный адрес памяти. Значение&MyClass::ival_не является каким-то конкретным значением, содержащимся в памяти; оно ссылается на имякласса,а не на имяобъекта,но тогда что же это такое на самом деле? Можно представить это значение как смешение данного-члена относительно начального адреса объекта.
   Переменнаяmpiдолжна использоваться совместно с экземпляром класса, к которому она применяется. Немного ниже в примере 15.2 располагается следующая строка, которая используетmpiдля присваивания целого числа значению, на которое ссылается указательmpi.
   obj.*mpi = 5;
   objявляется экземпляром классаMyClass.Ссылка на член с использованием точки (или-&gt;,если у вас имеется указатель наobj)и разыменованиеmpiпозволяют вам получить ссылку наobj.ival_.
   Указатели на функции-члены действуют фактически так же. В примере 15.2 объявляется указатель на функцию-членMyClass,которая возвращаетvoidи не имеет аргументов.
   void (MyClass::*mpf)();
   Ему можно присвоить значение с помощью оператора адресации.
   mpf =&MyClass::incr;
   Для вызова функции заключите основное выражение в скобки, чтобы компилятор понял ваши намерения, например:
   (obj.*mpf)();
   Однако имеется одно отличие в применении указателей на данные-члены и указателей на функции члены. Если необходимо использовать обычный указатель (не на член класса) на данное-член, просто действуйте обычным образом.
   int* pi =&obj.ival_;
   Конечно, вы используете имя объекта, а не имя класса, потому что получаете адрес конкретного данного-члена конкретного объекта, расположенного где-то в памяти. (Однако обычно стараются адреса данных-членов класса не выдавать за его пределы, чтобы нельзя было их изменить из-за опрометчивых действий в клиентском программном коде.)
   В отличие от данного члена с функцией-членом вы не можете сделать то же самое, потому что это бессмысленно. Рассмотрим указатель на функцию, имеющую такую же сигнатуру, какMyClass::incr (т.е. он возвращаетvoidи не имеет аргументов).
   void (*pf)();
   Теперь попытайтесь присвоить этому указателю адрес функции-члена.
   pf =&MyClass::incr; // Heполучится
   pf =&obj.incr;      // И это не пройдет
   Обе эти строки не будут откомпилированы, и на это имеются веские основания. Применение функции-члена имеет разумный смысл только в контексте объекта, поскольку, вероятнее всего, она должна ссылаться на переменные-члены. Вызов функции-члена без объекта означало бы невозможность в функции-члене использовать какие-либо члены объекта, а эта функция, по-видимому, как раз является функцией-членом, а не автономной функцией, потому что использует члены объекта.См. также
   Рецепт 15.1.
   15.3.Обеспечение невозможности модификации аргумента в функцииПроблема
   Вы пишете функцию и требуется гарантировать, что ее аргументы не будут модифицированы при ее вызове.Решение
   Для предотвращения изменения аргументов вашей функцией объявите ее аргументы с ключевым словомconst.Короткий пример 15.3 показывает, как это можно сделать.
   Пример 15.3. Гарантия невозможности модификации аргументов
   #include&lt;iostream
   #include&lt;string&gt;

   void concat(const std::string& s1, //Аргументы объявлены как константное,
    const std::string& s2,            // поэтому не могут быть изменены
    std::string& out) {
    out = s1 + s2;
   }

   int main() {
    std::string s1 = "Cabo ";
    std::string s2 = "Wabo";
    std::string s3;
    concat(s1, s2, s3);
    std::cout&lt;&lt; "s1 = "&lt;&lt; s1&lt;&lt; '\n';
    std::cout&lt;&lt; "s2 = "&lt;&lt; s2&lt;&lt; '\n';
    std::cout&lt;&lt; "s3 = "&lt;&lt; s3&lt;&lt; '\n';
   }Обсуждение
   В примере 15.3 продемонстрировано прямое использование ключевого словаconst.Существует две причины объявления параметров вашей функции с этим ключевым словом, когда вы не планируете их изменять. Во-первых, этим вы сообщаете о своих намерениях читателям вашего программного кода. Объявляя параметр какconst,вы фактически говорите, что он являетсявходнымпараметром. Это позволяет пользователям вашей функции писать программный код в расчете на то, что эти значения не будут изменены. Во-вторых, это позволяет компилятору запретить любые модифицирующие операции на тот случай, если вы случайно их используете. Рассмотрим небезопасную версиюconcatиз примера 15 3.
   void concatUnsafe(std::string& s1,
    std::string& s2 std::string& out) {
    out = s1 += s2; // Ну вот, записано значение в s1
   }
   Несмотря на мою привычку тщательно подходить к кодированию программ, я сделал глупую ошибку и написал+=вместо+.В результате при вызовеconcatUnsafeбудут модифицированы аргументыoutиs1,что может оказаться сюрпризом для пользователя, который едва ли рассчитывает на модификацию одной из исходных строк.
   Спасти можетconst.Создайте новую функциюconcatSafe,объявите переменные константными, как показано в примере 15.3, и функция не будет откомпилирована.
   void concatSafe(const std::string& s1,
    const std::string& s2, std::string& out) {
    out = s1 += s2; // Теперь вы получите ошибку компиляции
   }
   concatSafегарантирует неизменяемость значений вs1иs2.Эта функция делает еще кое-что: она позволяет пользователю передавать константные аргументы. Например, программный код, выполняющий конкатенацию строк, мог бы выглядеть следующим образом.
   void myFunc(const std::string& s) { //Обратите внимание, что s является
                                       // константной переменной
    std::string dest;
    std::string tmp = "foo";
    concatUnsafe(s, tmp, dest); // Ошибка: s - константная переменная
                                // Выполнить какие-то действия с dest...
   }
   В данном случае функцияmyFuncне будет откомпилирована, потому чтоconcatUnsafeне обеспечиваетconst'антностьmyFunc.myFuncгарантирует внешнему миру, что она не будет модифицировать содержимоеs,т.е. все действия сsвнутри телаmyFuncне должны нарушать это обещание. Конечно, вы можете обойти это ограничение, используя операторconst_castи тем самым освобождаясь от константности, но такой подход ненадежен, и его следует избегать. В этой ситуацииconcatSafeбудет компилироваться и выполняться нормально.
   Указатели вносят темные штрихи в розовую картинуconst.Когда вы объявляете переменную-указатель как параметр, вы имеет дело с двумя объектами: самим адресом и то, на что ссылается этот адрес. C++ позволяет использоватьconstдля ограничения действий по отношению к обоим объектам. Рассмотрим еще одну функцию конкатенации, которая использует указатели.
   void concatUnsafePtr(std::string* ps1,
    std::string* ps2, std::string* pout) {
    *pout = *ps1 + *ps2;
   }
   Здесь такая же проблема, как в примере сconcatUnsafe,описанном ранее. Добавьтеconstдля гарантии невозможности обновления исходных строк.
   void concatSaferPtr(const std::string* ps1,
    const std::string* ps2, std::string* pout) {
    *pout = *ps1 + *ps2;
   }
   Отлично, теперь вы не можете изменить*ps1и*ps2.Но вы по-прежнему можете изменитьps1иps2,или, другими словами, используя их, вы можете сослаться на какую-нибудь другую строку, изменяя значение указателя, но не значение, на которое он ссылается. Ничто не может помешать вам, например, сделать следующее.
   void concatSaferPtr(const std:string* ps1,
    const std::string* ps2, std::string* pout) {
    ps1 = pout; // Ух!
    *pout = *ps1 + *ps2;
   }
   Предотвратить подобные ошибки можно с помощью еще одногоconst.
   void concatSafestPtr(const std::string* const ps1,
    const std::string* const ps2, std::string* pout) {
    *pout = *ps1 + *ps2;
   }
   Применениеconstпо обе стороны звездочки делает вашу функцию максимально надежной. В этом случае вы ясно показываете свои намерения пользователям вашей функции, и ваша репутация не пострадает в случае описки.См. также
   Рецепт 15.4.
   15.4.Обеспечение невозможности модификации своих объектов в функции-членеПроблема
   Требуется вызывать функции -члены для константного объекта, но ваш компилятор жалуется на то, что он не может преобразовать тип используемого вами объекта из константного в неконстантный.Решение
   Поместите ключевое словоconstсправа от имени функции-члена при ее объявлении в классе и при ее определении. Пример 15.4 показывает, как это можно сделать
   Пример 15.4. Объявление функции-члена константной
   #include&lt;iostream&gt;
   #include&lt;string&gt;

   class RecordSet {
   public:
    bool getFieldVal(int i, std::string& s) const;
    // ...
   };

   bool RecordSet::getFieldVal(int i, std::string& s) const {
    // Здесь нельзя модифицировать никакие неизменяемые
    // данные-члены (см. обсуждение)
   }

   void displayRecords(const RecordSet& rs) {
    // Здесь вы можете вызывать только константные функции-члены
    // для rs
   }Обсуждение
   Добавление концевогоconstв объявление члена и в его определение заставляет компилятор более внимательно отнестись к тому, что делается с объектом внутри тела члена. Константным функциям-членам не разрешается выполнять неконстантные операции с данными-членами. Если такие операции присутствуют, компиляция завершится неудачно. Например, если бы вRecordSet::getFieldValя обновил счетчик-член, эта функция не была бы откомпилирована (в предположении, чтоgetFieldCount_является переменной-членом классаRecordSet).
   bool RecordSet::getFieldVal(int i, std::string& s) const {
    ++getFieldCount_; // Ошибка: константная функция-член не может
                      // модифицировать переменную-член
                      // ...
   }
   Это может также помочь обнаружить более тонкие ошибки, подобно тому, что делаетconstв роли квалификатора переменной (см. рецепт 15.3). Рассмотрим следующую глупую ошибку.
   bool RecordSet::getFieldVal(int i, std::string& s) const {
    fieldArray_[i] = s; // Ой, я не это имел в виду
    // ...
   }
   Снова компилятор преждевременно завершит работу и выдаст сообщение об ошибке, потому что вы пытаетесь изменить переменную-член, а это не разрешается делать в константных функциях-членах. Ну, при одном исключении.
   В классеRecordSet (в таком, как (схематичный) класс в примере 15.4) вам, вероятно, потребовалось бы перемещаться туда-сюда по набору записей, используя понятие «текущей» записи. Простой способ заключается в применении переменной-члена целого типа, содержащей номер текущей записи; ваши функции-члены, предназначенные для перемещения текущей записи вперед-назад, должны увеличивать или уменьшать это значение.
   void RecordSet::gotoNextPecord() const {
    if (curIndex_&gt;= 0&& curIndex_&lt; numRecords_-1)
     ++curIndex_;
   }

   void RecordSet::gotoPrevRecord() const {
    if (curIndex_&gt; 0)
     --curIndex_;
   }
   Очевидно, что это не сработает, если эти функции-члены являются константными. Обе обновляют данное-член. Однако без этого пользователи классаRecordSetне смогут перемещаться по объектуconst RecordSet.Это исключение из правил работы с константными функциями-членами является вполне разумным, поэтому C++ имеет механизм его поддержки: ключевое словоmutable.
   Для того чтобыcurIndex_можно было обновлять в константной функции-члене, объявите ее с ключевым словом mutable в объявлении класса.
   mutable int curIndex_;
   Это позволит вам модифицироватьcurIndex_в любом месте. Однако этой возможностью следует пользоваться разумно, поскольку это действует на вашу функцию так, как будто она становится с этого момента неконстантной.
   Применение ключевого словаconstв примере 15.4 позволяет гарантировать невозможность изменения состояния объекта в функции-члене. В целом, такой подход дает хорошие результаты, потому что сообщает пользователям класса о режиме работы функции-члена и потому что сохраняет вам репутацию, заставляя компилятор проконтролировать отсутствие в функции-члене непредусмотренных действий.
   15.5.Написание оператора, не являющегося функцией-членомПроблема
   Необходимо написать бинарный оператор, и вы не можете или не хотите сделать его функцией-членом класса.Решение
   Используйте ключевое словоoperator,временную переменную и конструктор копирования для выполнения основной работы и возвратите временный объект. В примере 15.5 приводится простой оператор конкатенации строк для пользовательского классаString.
   Пример 15.5. Конкатенация с использованием оператора не члена
   #include&lt;iostream&gt;
   #include&lt;cstring&gt;

   class String { //Предположим, что объявление класса String содержит,
                  // по крайней мере, все, что указанно ниже
   public:
    String();
    String(const char* p);
    String(const String& orig);
    ~String() {delete buf_;}
    String& append(const String& s);
    size_t length() const;
    const char* data() const;
    String& operator=(const String& orig);
    // ...
   };

   String operator+(const String& lhs, const String& rhs) {
    String tmp(lhs); // Сконструировать временный объект с помощью
                     // конструктора копирования
    tmp.append(rhs); // Использовать функцию-член для выполнения реальной
                     // работы
    return(tmp); // Возвратить временный объект
   }

   int main() {
    String s1("banana ");
    String s2("rancher");
    String s3, s4, s5, s6;
    s3 = s1 + s2;           // Работает хорошо, но с сюрпризами
    s4 = s1 + "rama";       // Автоматически конструируется "rama", используя
                            // конструктор String(const char*)
    s5 = "ham " + s2;       // Круто, то же самое можно делать даже
    s6 = s1 + "rama " + s2; // с другим операндом
    std::cout&lt;&lt; "s3 = "&lt;&lt; s3.data()&lt;&lt; '\n';
    std::cout&lt;&lt; "s4 = "&lt;&lt; s4.data()&lt;&lt; '\n';
    std::cout&lt;&lt; "s5 = "&lt;&lt; s5.data()&lt;&lt; '\n';
    std::cout&lt;&lt; "s6 = "&lt;&lt; s6.data()&lt;&lt; '\n';
   }Обсуждение
   Независимый оператор объявляется и определяется подобно оператору функции-члена. В примере 15.5 я мог бы реализоватьoperator+как функцию-член, объявляя ее следующим образом.
   String operator+(const String& rhs);
   В большинстве случаев это будет работать одинаково, независимо от того, определяется лиoperator+как функция-член или нет, однако существует, по крайней мере, две причины, по которым желательно реализовать его не как функцию-член. Первая причина концептуальная,имеет ли смысл иметь оператор, который возвращает новый, отличный от других объект?operator+,реализованный как функция-член, не проверяет и не изменяет состояние объекта. Это служебная функция общего назначения, которая в данном случае работает со строками типаStringи, следовательно, не должна являться функцией членом.
   Вторая причина техническая. При использовании оператора-члена вы не сможете выполнить следующую операцию (из приведенного выше примера).
   s5 = "ham " + s2;
   Это не сработает, потому что символьная строка не имеетoperator+,который принимаетStringв качестве параметра. С другой стороны, если вы определили независимыйoperator+,который принимает два параметра типаString,ваш компилятор проверит наличие в классеStringконструктора, принимающегоconst char*в качестве аргумента (или любой другой тип, который вы используете совместно сString),и сконструирует временный объект на этапе выполнения. Поэтому приведенная выше строка эквивалентна следующей.
   s5 = String("ham ") + s2;
   Компилятор позволяет вам немного сэкономить ваши действия и не вводить несколько символов за счет поиска и вызова соответствующего конструктора.
   Перегрузка операторов сдвига потоков влево и вправо (&lt;&lt;и&gt;&gt;)также требует применения операторов не-членов. Например, для записи нового объекта в поток, используя сдвиг влево, вам придется следующим образом объявитьoperator&lt;&lt;:
   ostream& operator&lt;&lt;(ostream& str, const MyClass& obj);
   Конечно, вы можете создать подкласс одного из классов потока стандартной библиотеки и добавить все необходимые вам операторы сдвига влево, но будет ли такое решение действительно удачным? При таком решении только тот программный код, который использует ваш новый класс потока, сможет записывать в него объекты вашего специального класса. Если вы используете независимый оператор, любой программный код в том же самом пространстве имен сможет без проблем записать ваш объект вostream (или считать его изistream).
   15.6.Инициализация последовательности значениями, разделяемыми запятымиПроблема
   Требуется инициализировать последовательность набором значений, разделяемых запятыми, подобно тому как это делается для встроенных массивов.Решение
   При инициализации стандартных последовательностей (таких какvectorиlist)можно использовать синтаксис с запятыми, определяя вспомогательный класс и перегружая оператор запятой, как это продемонстрировано в примере 15.6.
   Пример 15.6. Вспомогательные классы для инициализации стандартных последовательностей с применением синтаксиса с запятыми
   #include&lt;vector&gt;
   #include&lt;iostream&gt;
   #include&lt;iterator&gt;
   #include&lt;algorithm&gt;

   using namespace std;

   template&lt;class Seq_T&gt;
   struct comma helper {
    typedef typename Seq_T::value_type value_type;
    explicit comma_helper(Seq_T& x) : m(x) {}
    comma_helper& operator=(const value_type& x) {
     m.clear();
     return operator+=(x);
    }
    comma_helper& operator+=(const value_type& x) {
     m.push_back(x);
     return *this;
    }
    Seq_T& m;
   };

   template&lt;typename Seq_T&gt;
   comma_helper&lt;Seq_T&gt; initialize(Seq_T& x) {
    return comma_helper&lt;Seq_T&gt;(x);
   }

   template&lt;class Seq_T, class Scalar_T&gt;
   comma_helper&lt;Seq_T&gt;& operator,(comma_helper&lt;Seq_T&gt;& h, Scalar_T x) {
    h += x;
    return h;
   }

   int main() {
    vector v;
    int a = 2;
    int b = 5;
    initialize(v) = 0, 1, 1, a, 3, b, 8, 13;
    cout&lt;&lt; v[3]&lt;&lt; endl; //выдает 2
    system("pause");
    return EXIT_SUCCESS;
   }Обсуждение
   Часто стандартные последовательности инициализируются путем вызова несколько раз функции-членаpush_back.Поскольку это приходится делать не так уж редко, я написал функциюinitialize,которая помогает избавиться от этого скучного занятия, позволяя выполнять инициализацию значениями, разделяемыми запятыми, подобно тому как это делается во встроенных массивах.
   Возможно, вы и не знали, что запятая является оператором, который можно переопределять. Здесь вы не одиноки — этот факт не является общеизвестным. Оператор запятойбыло разрешено перегружать почти только ради решения этой задачи.
   В решении используется вспомогательная функцияinitialize,которая возвращает шаблон вспомогательной функцииcomma_helper.Этот шаблон содержит ссылку на последовательность и перегруженные операторыoperator,,operator=иoperator+=.
   Такое решение требует, чтобы я определил отдельную вспомогательную функцию из-за особенностей восприятия компилятором оператораv = 1, 1, 2, ...;.Компилятор рассматриваетv = 1как недопустимое подвыражение, потому что в стандартных последовательностях не поддерживается оператор присваивания единственного значения. Функцияinitializeконструирует соответствующий объектcomma_helper,который может хранить последовательность, используемую в перегруженном операторе присваивания и запятой.
   Оператор запятой (comma operator), называемый также оператором последовательности (sequencing operator), по умолчанию рассматривает выражения слева направо, и в результате получается значение и тип самого правого значения. Однако при перегрузкеoperatorпринимает новый смысл и теряет первоначальную семантику. Здесь возникает один тонкий момент — оценка параметров слева направо теперь не гарантируется, и результат выполнения программного кода, приведенного в примере 15.7, может оказаться неожиданным.
   Пример 15.7. Применение перегруженного оператора запятой, когда порядок вычисления аргументов не определен
   int prompt_user() {
    cout&lt;&lt; "give me an integer ... ";
    cin&gt;&gt; n;
    return n;
   }

   void f() {
    vector&lt;int&gt; v;
    // Следующий оператор может инициализировать v в неправильной
    // последовательности
    intialize(v) = prompt_user(), prompt_user();
   }
   В правильном варианте функцииfкаждый вызовprompt_userдолжен был бы выполняться в отдельном операторе.
    [Картинка: tip_yellow.png] Библиотека Boost Assign, написанная Торстеном Оттосеном (Thorsten Ottosen), кроме других форм инициализации стандартных коллекций поддерживает также более сложную форму инициализации списком с запятыми. Эта библиотека доступна на сайте http://www.boost.org.
   Об авторах
   Д. Райан Стефенс (D. Ryan Stephens)— студент, живущий в г. Темп, шт. Аризона; он занимается разработкой программного обеспечения и является автором ряда работ по программированию. Ему нравится программировать практически на любом языке, особенно на С++. В его интересы входит поиск информации и ее извлечение из данных, а также все, что связано с алгоритмами и большими наборами данных. Когда он не работает, не пишет статьи и не программирует, он играет со своими детьми, работает по дому и катается на велосипеде.
   Кристофер Диггинс (Christopher Diggins),который начал заниматься программированием в очень раннем возрасте (haut comme trois pommes),является независимым разработчиком программного обеспечения и автором, пишущим в этой области. Кристофер регулярно публикует свои статьи в журнале «C++ Users Journal» и является разработчиком языка программирования Heron.
   Джонатан Турканис (Jonathan Turkanis)— автор библиотеки Boost Iostreams и нескольких других библиотек C++ с открытым исходным кодом, охватывающих такие области, как «умные» указатели, отражение состояния программы на этапе выполнения, программирование обобщенных компонент и программирование, ориентированное на характерные особенности (aspect-oriented programming). Он является аспирантом Калифорнийского университета г. Беркли по специальности «математическая логика».
   Джефф Когсуэлл (Jeff Cogswell)занимается разработкой программного обеспечения и живет недалеко от Цинциннати, шт. Огайо. Он программирует на C++ почти со времени появления этого языка, и им написано много работ по нему, включая две другие книги по C++. Он также любит программировать на других языках, особенно на Python. Когда не работает (что случается редко), он любит читать хороший роман или играть на гитаре.
   Колофон
   Наша точка зрения сложилась в результате анализа комментариев читателей, собственных экспериментов и информации, полученной по каналам распространения. Характерные обложки дополняют наш особый подход к техническим темам, внося индивидуальность и делая более живыми потенциально скучные темы.
   На обложке «C++: рецепты программирования» представлена собака породы колли. Этот тип овчарки появился в гористой местности Шотландии и Британии в 1600-х годах. Одна разновидность овец в гористой Шотландии имела темные метки на морде и ногах, и поэтому таких овец называли «Colley»; это название происходит от старошотландского слова, обозначающего уголь. Современная порода колли светлее и более ширококостная, чем ее шотландские предки; она была выведена в конце 19-го столетия. В настоящее времяколли, в основном, являются домашними любимцами, хотя в Соединенных Штатах они по-прежнему используются в фермерских хозяйствах.
   Существует две разные породы колли: грубошерстные колли, которые использовались для охраны овец, и гладкошерстные - для сопровождения скота на рынок. Обе породы - это гибкие, стройные собаки с четко выраженной мордой и заостренными ушами. По высоте колли достигают 22-26 дюймов и весят 50-75 фунтов. Они обычно имеют белый мех с добавками другого цвета: от желто-белого и рыжего до угольно-черного.
   К знаменитым колли относится, конечно, Лэсси, Бланко Линдона Джонсона и Лэдди из сериала «Симпсоны» (The Simpsons).
   Мэтт Хатчинсон (Matt Hutchinson) был редактором по производству книги «С++: рецепты программирования». Издательство «Octal Publishing, Inc.» предоставляло производственные услуги.Дарен Келли (Darren Kelly), Адам Уитвер (Adam Witwer) и Клер Клутье (Claire Cloutier) обеспечивали контроль качества.
   Карен Монтгомери (Karen Montgomery) разработала обложку этой книги на основе серии проектов Эдди Фридманом (Edie Freedman). Изображение на обложке взято из гравюры 19-го столетия,которая приводится в «Natural History» (Естественная история) издательского дома Cassell. Карен Монтгомери сделала макет обложки, используя InDesign CS компании Adobe и шрифт ITC Garamond той же компании.
   Дэвид Футато (David Futato) разработал внутренний дизайн книги. Эта книга была переведена Кейт Фалгрен (Keith Fahlgren) в формат FrameMaker 5.5.6 с помощью утилиты преобразования форматов, которую создали Эрик Рей (Erik Ray), Джейсон Макинтош (Jason Mcintosh), Нейл Уэллс (Neil Walls) и Майк Сьерра (Mike Sierra); эта утилита использует язык Perl и XML-технологию. Для текста использован шрифт Linotype Birka, шрифт заголовков — Adobe Myriad Condensed, а шрифт программного кода — TheSans Mono Condensed компании «LucasFont». Иллюстрации, которые содержатся внутри книги, были сделаны Робертом Романо (Robert Romano), Джессамин Рид (Jessamyn Read) и Лесли Бораш (Lesley Borash) с помощью Macromedia FreeHand MX и Adobe Photoshop CS. Пиктограммы советов и предупреждений были нарисованы Кристофером Бингом (Christopher Bing). Заключение составил Мэтт Хатчинсон.
   Примечания
   1
   Экспорт символов с помощью__declspec(dllexport)иногда неправильно называютнеявнымэкспортом
   2
   В версиях Visual C++ до Visual C++ 2005 эта опция называласьVisual C++ Projects.
   3
   В версиях Visual C++ до Visual C++ 2005 эта опция называласьVisual C++ Projects.
   4
   В версиях Visual C++ до Visual C++ 2005 эта опция называласьVisual C++ Projects.
   5
   Почемупочти?Потому что даже Comeau и Intel содержат несколько ошибок, а интерпретация некоторых частей стандарта вызывает разночтения

Взято из Флибусты, http://flibusta.net/b/294915
